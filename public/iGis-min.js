!
function(t, e) {
	"object" == typeof exports && "object" == typeof module ? module.exports = e(require("AMap")) : "function" == typeof define && define.amd ? define(["AMap"], e) : "object" == typeof exports ? exports.iGis = e(require("AMap")) : t.iGis = e(t.AMap)
}(window, (function(t) {
	return function(t) {
		var e = {};

		function i(n) {
			if (e[n]) return e[n].exports;
			var r = e[n] = {
				i: n,
				l: !1,
				exports: {}
			};
			return t[n].call(r.exports, r, r.exports, i), r.l = !0, r.exports
		}
		return i.m = t, i.c = e, i.d = function(t, e, n) {
			i.o(t, e) || Object.defineProperty(t, e, {
				enumerable: !0, 
				get: n
			})
		}, i.r = function(t) {
			"undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(t, Symbol.toStringTag, {
				value: "Module"
			}), Object.defineProperty(t, "__esModule", {
				value: !0
			})
		}, i.t = function(t, e) {
			if (1 & e && (t = i(t)), 8 & e) return t;
			if (4 & e && "object" == typeof t && t && t.__esModule) return t;
			var n = Object.create(null);
			if (i.r(n), Object.defineProperty(n, "default", {
				enumerable: !0,
				value: t
			}), 2 & e && "string" != typeof t) for (var r in t) i.d(n, r, function(e) {
				return t[e]
			}.bind(null, r));
			return n
		}, i.n = function(t) {
			var e = t && t.__esModule ?
			function() {
				return t.
			default
			} : function() {
				return t
			};
			return i.d(e, "a", e), e
		}, i.o = function(t, e) {
			return Object.prototype.hasOwnProperty.call(t, e)
		}, i.p = "", i(i.s = 163)
	}([function(t, e, i) {
		"use strict";
		i.r(e);
		var n = {
			ASSUME_TOUCH: !1,
			DEFAULT_MAX_ZOOM: 42,
			DEFAULT_MIN_ZOOM: 0,
			DEFAULT_RASTER_REPROJECTION_ERROR_THRESHOLD: .5,
			DEFAULT_TILE_SIZE: 256,
			DEFAULT_WMS_VERSION: "1.3.0",
			ENABLE_CANVAS: !0,
			ENABLE_PROJ4JS: !0,
			ENABLE_RASTER_REPROJECTION: !0,
			ENABLE_WEBGL: !0,
			DEBUG_WEBGL: !0,
			INITIAL_ATLAS_SIZE: 256,
			MAX_ATLAS_SIZE: -1,
			MOUSEWHEELZOOM_MAXDELTA: 1,
			OVERVIEWMAP_MAX_RATIO: .75,
			OVERVIEWMAP_MIN_RATIO: .1,
			RASTER_REPROJECTION_MAX_SOURCE_TILES: 100,
			RASTER_REPROJECTION_MAX_SUBDIVISION: 10,
			RASTER_REPROJECTION_MAX_TRIANGLE_WIDTH: .25,
			SIMPLIFY_TOLERANCE: .5,
			WEBGL_TEXTURE_CACHE_HIGH_WATER_MARK: 1024,
			VERSION: "v4.6.5"
		};
		n.WEBGL_MAX_TEXTURE_SIZE, n.WEBGL_EXTENSIONS, n.inherits = function(t, e) {
			t.prototype = Object.create(e.prototype), t.prototype.constructor = t
		}, n.nullFunction = function() {}, n.getUid = function(t) {
			return t.ol_uid || (t.ol_uid = ++n.uidCounter_)
		}, n.uidCounter_ = 0, e.
	default = n
	}, function(t, e, i) {
		"use strict";
		i.r(e);
		var n = i(15),
			r = i(114),
			o = i(56),
			s = {
				boundingExtent: function(t) {
					for (var e = s.createEmpty(), i = 0, n = t.length; i < n; ++i) s.extendCoordinate(e, t[i]);
					return e
				},
				boundingExtentXYs_: function(t, e, i) {
					var n = Math.min.apply(null, t),
						r = Math.min.apply(null, e),
						o = Math.max.apply(null, t),
						a = Math.max.apply(null, e);
					return s.createOrUpdate(n, r, o, a, i)
				},
				buffer: function(t, e, i) {
					return i ? (i[0] = t[0] - e, i[1] = t[1] - e, i[2] = t[2] + e, i[3] = t[3] + e, i) : [t[0] - e, t[1] - e, t[2] + e, t[3] + e]
				},
				clone: function(t, e) {
					return e ? (e[0] = t[0], e[1] = t[1], e[2] = t[2], e[3] = t[3], e) : t.slice()
				},
				closestSquaredDistanceXY: function(t, e, i) {
					var n, r;
					return (n = e < t[0] ? t[0] - e : t[2] < e ? e - t[2] : 0) * n + (r = i < t[1] ? t[1] - i : t[3] < i ? i - t[3] : 0) * r
				},
				containsCoordinate: function(t, e) {
					return s.containsXY(t, e[0], e[1])
				},
				containsExtent: function(t, e) {
					return t[0] <= e[0] && e[2] <= t[2] && t[1] <= e[1] && e[3] <= t[3]
				},
				containsXY: function(t, e, i) {
					return t[0] <= e && e <= t[2] && t[1] <= i && i <= t[3]
				},
				coordinateRelationship: function(t, e) {
					var i = t[0],
						n = t[1],
						r = t[2],
						s = t[3],
						a = e[0],
						l = e[1],
						u = o.a.UNKNOWN;
					return a < i ? u |= o.a.LEFT : a > r && (u |= o.a.RIGHT), l < n ? u |= o.a.BELOW : l > s && (u |= o.a.ABOVE), u === o.a.UNKNOWN && (u = o.a.INTERSECTING), u
				},
				createEmpty: function() {
					return [1 / 0, 1 / 0, -1 / 0, -1 / 0]
				},
				createOrUpdate: function(t, e, i, n, r) {
					return r ? (r[0] = t, r[1] = e, r[2] = i, r[3] = n, r) : [t, e, i, n]
				},
				createOrUpdateEmpty: function(t) {
					return s.createOrUpdate(1 / 0, 1 / 0, -1 / 0, -1 / 0, t)
				},
				createOrUpdateFromCoordinate: function(t, e) {
					var i = t[0],
						n = t[1];
					return s.createOrUpdate(i, n, i, n, e)
				},
				createOrUpdateFromCoordinates: function(t, e) {
					var i = s.createOrUpdateEmpty(e);
					return s.extendCoordinates(i, t)
				},
				createOrUpdateFromFlatCoordinates: function(t, e, i, n, r) {
					var o = s.createOrUpdateEmpty(r);
					return s.extendFlatCoordinates(o, t, e, i, n)
				},
				createOrUpdateFromRings: function(t, e) {
					var i = s.createOrUpdateEmpty(e);
					return s.extendRings(i, t)
				},
				equals: function(t, e) {
					return t[0] == e[0] && t[2] == e[2] && t[1] == e[1] && t[3] == e[3]
				},
				extend: function(t, e) {
					return e[0] < t[0] && (t[0] = e[0]), e[2] > t[2] && (t[2] = e[2]), e[1] < t[1] && (t[1] = e[1]), e[3] > t[3] && (t[3] = e[3]), t
				},
				extendCoordinate: function(t, e) {
					e[0] < t[0] && (t[0] = e[0]), e[0] > t[2] && (t[2] = e[0]), e[1] < t[1] && (t[1] = e[1]), e[1] > t[3] && (t[3] = e[1])
				},
				extendCoordinates: function(t, e) {
					var i, n;
					for (i = 0, n = e.length; i < n; ++i) s.extendCoordinate(t, e[i]);
					return t
				},
				extendFlatCoordinates: function(t, e, i, n, r) {
					for (; i < n; i += r) s.extendXY(t, e[i], e[i + 1]);
					return t
				},
				extendRings: function(t, e) {
					var i, n;
					for (i = 0, n = e.length; i < n; ++i) s.extendCoordinates(t, e[i]);
					return t
				},
				extendXY: function(t, e, i) {
					t[0] = Math.min(t[0], e), t[1] = Math.min(t[1], i), t[2] = Math.max(t[2], e), t[3] = Math.max(t[3], i)
				},
				forEachCorner: function(t, e, i) {
					var n;
					return (n = e.call(i, s.getBottomLeft(t))) ? n : (n = e.call(i, s.getBottomRight(t))) ? n : (n = e.call(i, s.getTopRight(t))) ? n : (n = e.call(i, s.getTopLeft(t))) || !1
				},
				getArea: function(t) {
					var e = 0;
					return s.isEmpty(t) || (e = s.getWidth(t) * s.getHeight(t)), e
				},
				getBottomLeft: function(t) {
					return [t[0], t[1]]
				},
				getBottomRight: function(t) {
					return [t[2], t[1]]
				},
				getCenter: function(t) {
					return [(t[0] + t[2]) / 2, (t[1] + t[3]) / 2]
				},
				getCorner: function(t, e) {
					var i;
					return e === r.a.BOTTOM_LEFT ? i = s.getBottomLeft(t) : e === r.a.BOTTOM_RIGHT ? i = s.getBottomRight(t) : e === r.a.TOP_LEFT ? i = s.getTopLeft(t) : e === r.a.TOP_RIGHT ? i = s.getTopRight(t) : n.a.assert(!1, 13), i
				},
				getEnlargedArea: function(t, e) {
					var i = Math.min(t[0], e[0]),
						n = Math.min(t[1], e[1]);
					return (Math.max(t[2], e[2]) - i) * (Math.max(t[3], e[3]) - n)
				},
				getForViewAndSize: function(t, e, i, n, r) {
					var o = e * n[0] / 2,
						a = e * n[1] / 2,
						l = Math.cos(i),
						u = Math.sin(i),
						h = o * l,
						c = o * u,
						d = a * l,
						f = a * u,
						A = t[0],
						p = t[1],
						g = A - h + f,
						m = A - h - f,
						v = A + h - f,
						y = A + h + f,
						_ = p - c - d,
						E = p - c + d,
						x = p + c + d,
						C = p + c - d;
					return s.createOrUpdate(Math.min(g, m, v, y), Math.min(_, E, x, C), Math.max(g, m, v, y), Math.max(_, E, x, C), r)
				},
				getHeight: function(t) {
					return t[3] - t[1]
				},
				getIntersectionArea: function(t, e) {
					var i = s.getIntersection(t, e);
					return s.getArea(i)
				},
				getIntersection: function(t, e, i) {
					var n = i || s.createEmpty();
					return s.intersects(t, e) && (t[0] > e[0] ? n[0] = t[0] : n[0] = e[0], t[1] > e[1] ? n[1] = t[1] : n[1] = e[1], t[2] < e[2] ? n[2] = t[2] : n[2] = e[2], t[3] < e[3] ? n[3] = t[3] : n[3] = e[3]), n
				},
				getMargin: function(t) {
					return s.getWidth(t) + s.getHeight(t)
				},
				getSize: function(t) {
					return [t[2] - t[0], t[3] - t[1]]
				},
				getTopLeft: function(t) {
					return [t[0], t[3]]
				},
				getTopRight: function(t) {
					return [t[2], t[3]]
				},
				getWidth: function(t) {
					return t[2] - t[0]
				},
				intersects: function(t, e) {
					return t[0] <= e[2] && t[2] >= e[0] && t[1] <= e[3] && t[3] >= e[1]
				},
				isEmpty: function(t) {
					return t[2] < t[0] || t[3] < t[1]
				},
				returnOrUpdate: function(t, e) {
					return e ? (e[0] = t[0], e[1] = t[1], e[2] = t[2], e[3] = t[3], e) : t
				},
				scaleFromCenter: function(t, e) {
					var i = (t[2] - t[0]) / 2 * (e - 1),
						n = (t[3] - t[1]) / 2 * (e - 1);
					t[0] -= i, t[2] += i, t[1] -= n, t[3] += n
				},
				intersectsSegment: function(t, e, i) {
					var n = !1,
						r = s.coordinateRelationship(t, e),
						a = s.coordinateRelationship(t, i);
					if (r === o.a.INTERSECTING || a === o.a.INTERSECTING) n = !0;
					else {
						var l, u, h = t[0],
							c = t[1],
							d = t[2],
							f = t[3],
							A = e[0],
							p = e[1],
							g = i[0],
							m = i[1],
							v = (m - p) / (g - A);
						a & o.a.ABOVE && !(r & o.a.ABOVE) && (n = (l = g - (m - f) / v) >= h && l <= d), n || !(a & o.a.RIGHT) || r & o.a.RIGHT || (n = (u = m - (g - d) * v) >= c && u <= f), n || !(a & o.a.BELOW) || r & o.a.BELOW || (n = (l = g - (m - c) / v) >= h && l <= d), n || !(a & o.a.LEFT) || r & o.a.LEFT || (n = (u = m - (g - h) * v) >= c && u <= f)
					}
					return n
				},
				applyTransform: function(t, e, i) {
					var n = [t[0], t[1], t[0], t[3], t[2], t[1], t[2], t[3]];
					e(n, n, 2);
					var r = [n[0], n[2], n[4], n[6]],
						o = [n[1], n[3], n[5], n[7]];
					return s.boundingExtentXYs_(r, o, i)
				}
			};
		e.
	default = s
	}, function(t, e, i) {
		"use strict";
		var n = i(10),
			r = {};
		r.DOCUMENT = document.implementation.createDocument("", "", null), r.createElementNS = function(t, e) {
			return r.DOCUMENT.createElementNS(t, e)
		}, r.getAllTextContent = function(t, e) {
			return r.getAllTextContent_(t, e, []).join("")
		}, r.getAllTextContent_ = function(t, e, i) {
			var n;
			if (t.nodeType == Node.CDATA_SECTION_NODE || t.nodeType == Node.TEXT_NODE) e ? i.push(String(t.nodeValue).replace(/(\r\n|\r|\n)/g, "")) : i.push(t.nodeValue);
			else for (n = t.firstChild; n; n = n.nextSibling) r.getAllTextContent_(n, e, i);
			return i
		}, r.isDocument = function(t) {
			return t instanceof Document
		}, r.isNode = function(t) {
			return t instanceof Node
		}, r.getAttributeNS = function(t, e, i) {
			return t.getAttributeNS(e, i) || ""
		}, r.setAttributeNS = function(t, e, i, n) {
			t.setAttributeNS(e, i, n)
		}, r.parse = function(t) {
			return (new DOMParser).parseFromString(t, "application/xml")
		}, r.makeArrayExtender = function(t, e) {
			return function(i, r) {
				var o = t.call(e, i, r);
				if (void 0 !== o) {
					var s = r[r.length - 1];
					n.a.extend(s, o)
				}
			}
		}, r.makeArrayPusher = function(t, e) {
			return function(i, n) {
				var r = t.call(void 0 !== e ? e : this, i, n);
				void 0 !== r && n[n.length - 1].push(r)
			}
		}, r.makeReplacer = function(t, e) {
			return function(i, n) {
				var r = t.call(void 0 !== e ? e : this, i, n);
				void 0 !== r && (n[n.length - 1] = r)
			}
		}, r.makeObjectPropertyPusher = function(t, e, i) {
			return function(n, r) {
				var o = t.call(void 0 !== i ? i : this, n, r);
				if (void 0 !== o) {
					var s = r[r.length - 1],
						a = void 0 !== e ? e : n.localName;
					(a in s ? s[a] : s[a] = []).push(o)
				}
			}
		}, r.makeObjectPropertySetter = function(t, e, i) {
			return function(n, r) {
				var o = t.call(void 0 !== i ? i : this, n, r);
				void 0 !== o && (r[r.length - 1][void 0 !== e ? e : n.localName] = o)
			}
		}, r.makeChildAppender = function(t, e) {
			return function(i, n, r) {
				t.call(void 0 !== e ? e : this, i, n, r), r[r.length - 1].node.appendChild(i)
			}
		}, r.makeArraySerializer = function(t, e) {
			var i, n;
			return function(e, o, s) {
				if (void 0 === i) {
					i = {};
					var a = {};
					a[e.localName] = t, i[e.namespaceURI] = a, n = r.makeSimpleNodeFactory(e.localName)
				}
				r.serialize(i, n, o, s)
			}
		}, r.makeSimpleNodeFactory = function(t, e) {
			var i = t;
			return (function(t, n, o) {
				var s = n[n.length - 1].node,
					a = i;
				void 0 === a && (a = o);
				var l = e;
				return void 0 === e && (l = s.namespaceURI), r.createElementNS(l, a)
			})
		}, r.OBJECT_PROPERTY_NODE_FACTORY = r.makeSimpleNodeFactory(), r.makeSequence = function(t, e) {
			for (var i = e.length, n = new Array(i), r = 0; r < i; ++r) n[r] = t[e[r]];
			return n
		}, r.makeStructureNS = function(t, e, i) {
			var n, r, o = void 0 !== i ? i : {};
			for (n = 0, r = t.length; n < r; ++n) o[t[n]] = e;
			return o
		}, r.parseNode = function(t, e, i, n) {
			var r;
			for (r = e.firstElementChild; r; r = r.nextElementSibling) {
				var o = t[r.namespaceURI];
				if (void 0 !== o) {
					var s = o[r.localName];
					void 0 !== s && s.call(n, r, i)
				}
			}
		}, r.pushParseAndPop = function(t, e, i, n, o) {
			return n.push(t), r.parseNode(e, i, n, o), n.pop()
		}, r.serialize = function(t, e, i, n, r, o) {
			for (var s, a, l = (void 0 !== r ? r : i).length, u = 0; u < l; ++u) void 0 !== (s = i[u]) && void 0 !== (a = e.call(o, s, n, void 0 !== r ? r[u] : void 0)) && t[a.namespaceURI][a.localName].call(o, a, s, n)
		}, r.pushSerializeAndPop = function(t, e, i, n, o, s, a) {
			return o.push(t), r.serialize(e, i, n, o, s, a), o.pop()
		}, e.a = r
	}, function(t, e, i) {
		"use strict";
		var n = i(8),
			r = {
				bindListener_: function(t) {
					var e = function(e) {
							var i = t.listener,
								n = t.bindTo || t.target;
							return t.callOnce && r.unlistenByKey(t), i.call(n, e)
						};
					return t.boundListener = e, e
				},
				findListener_: function(t, e, i, n) {
					for (var r, o = 0, s = t.length; o < s; ++o) if ((r = t[o]).listener === e && r.bindTo === i) return n && (r.deleteIndex = o), r
				},
				getListeners: function(t, e) {
					var i = t.ol_lm;
					return i ? i[e] : void 0
				},
				getListenerMap_: function(t) {
					var e = t.ol_lm;
					return e || (e = t.ol_lm = {}), e
				},
				removeListeners_: function(t, e) {
					var i = r.getListeners(t, e);
					if (i) {
						for (var o = 0, s = i.length; o < s; ++o) t.removeEventListener(e, i[o].boundListener), n.a.clear(i[o]);
						i.length = 0;
						var a = t.ol_lm;
						a && (delete a[e], 0 === Object.keys(a).length && delete t.ol_lm)
					}
				},
				listen: function(t, e, i, n, o) {
					var s = r.getListenerMap_(t),
						a = s[e];
					a || (a = s[e] = []);
					var l = r.findListener_(a, i, n, !1);
					return l ? o || (l.callOnce = !1) : (l = {
						bindTo: n,
						callOnce: !! o,
						listener: i,
						target: t,
						type: e
					}, t.addEventListener(e, r.bindListener_(l)), a.push(l)), l
				},
				listenOnce: function(t, e, i, n) {
					return r.listen(t, e, i, n, !0)
				},
				unlisten: function(t, e, i, n) {
					var o = r.getListeners(t, e);
					if (o) {
						var s = r.findListener_(o, i, n, !0);
						s && r.unlistenByKey(s)
					}
				},
				unlistenByKey: function(t) {
					if (t && t.target) {
						t.target.removeEventListener(t.type, t.boundListener);
						var e = r.getListeners(t.target, t.type);
						if (e) {
							var i = "deleteIndex" in t ? t.deleteIndex : e.indexOf(t); - 1 !== i && e.splice(i, 1), 0 === e.length && r.removeListeners_(t.target, t.type)
						}
						n.a.clear(t)
					}
				},
				unlistenAll: function(t) {
					var e = r.getListenerMap_(t);
					for (var i in e) r.removeListeners_(t, i)
				}
			};
		e.a = r
	}, function(t, e, i) {
		"use strict";
		e.a = {
			POINT: "Point",
			LINE_STRING: "LineString",
			LINEAR_RING: "LinearRing",
			POLYGON: "Polygon",
			MULTI_POINT: "MultiPoint",
			MULTI_LINE_STRING: "MultiLineString",
			MULTI_POLYGON: "MultiPolygon",
			GEOMETRY_COLLECTION: "GeometryCollection",
			CIRCLE: "Circle"
		}
	}, function(t, e, i) {
		"use strict";
		e.a = {
			CHANGE: "change",
			CLEAR: "clear",
			CLICK: "click",
			DBLCLICK: "dblclick",
			DRAGENTER: "dragenter",
			DRAGOVER: "dragover",
			DROP: "drop",
			ERROR: "error",
			KEYDOWN: "keydown",
			KEYPRESS: "keypress",
			LOAD: "load",
			MOUSEDOWN: "mousedown",
			MOUSEMOVE: "mousemove",
			MOUSEOUT: "mouseout",
			MOUSEUP: "mouseup",
			MOUSEWHEEL: "mousewheel",
			MSPOINTERDOWN: "MSPointerDown",
			RESIZE: "resize",
			TOUCHSTART: "touchstart",
			TOUCHMOVE: "touchmove",
			TOUCHEND: "touchend",
			WHEEL: "wheel"
		}
	}, function(t, e, i) {
		"use strict";
		var n = i(15),
			r = {};
		r.tmp_ = new Array(6), r.create = function() {
			return [1, 0, 0, 1, 0, 0]
		}, r.reset = function(t) {
			return r.set(t, 1, 0, 0, 1, 0, 0)
		}, r.multiply = function(t, e) {
			var i = t[0],
				n = t[1],
				r = t[2],
				o = t[3],
				s = t[4],
				a = t[5],
				l = e[0],
				u = e[1],
				h = e[2],
				c = e[3],
				d = e[4],
				f = e[5];
			return t[0] = i * l + r * u, t[1] = n * l + o * u, t[2] = i * h + r * c, t[3] = n * h + o * c, t[4] = i * d + r * f + s, t[5] = n * d + o * f + a, t
		}, r.set = function(t, e, i, n, r, o, s) {
			return t[0] = e, t[1] = i, t[2] = n, t[3] = r, t[4] = o, t[5] = s, t
		}, r.setFromArray = function(t, e) {
			return t[0] = e[0], t[1] = e[1], t[2] = e[2], t[3] = e[3], t[4] = e[4], t[5] = e[5], t
		}, r.apply = function(t, e) {
			var i = e[0],
				n = e[1];
			return e[0] = t[0] * i + t[2] * n + t[4], e[1] = t[1] * i + t[3] * n + t[5], e
		}, r.rotate = function(t, e) {
			var i = Math.cos(e),
				n = Math.sin(e);
			return r.multiply(t, r.set(r.tmp_, i, n, -n, i, 0, 0))
		}, r.scale = function(t, e, i) {
			return r.multiply(t, r.set(r.tmp_, e, 0, 0, i, 0, 0))
		}, r.translate = function(t, e, i) {
			return r.multiply(t, r.set(r.tmp_, 1, 0, 0, 1, e, i))
		}, r.compose = function(t, e, i, n, r, o, s, a) {
			var l = Math.sin(o),
				u = Math.cos(o);
			return t[0] = n * u, t[1] = r * l, t[2] = -n * l, t[3] = r * u, t[4] = s * n * u - a * n * l + e, t[5] = s * r * l + a * r * u + i, t
		}, r.invert = function(t) {
			var e = r.determinant(t);
			n.a.assert(0 !== e, 32);
			var i = t[0],
				o = t[1],
				s = t[2],
				a = t[3],
				l = t[4],
				u = t[5];
			return t[0] = a / e, t[1] = -o / e, t[2] = -s / e, t[3] = i / e, t[4] = (s * u - a * l) / e, t[5] = -(i * u - o * l) / e, t
		}, r.determinant = function(t) {
			return t[0] * t[3] - t[1] * t[2]
		}, e.a = r
	}, function(t, e, i) {
		"use strict";
		var n = {
			ONE: 1,
			SRC_ALPHA: 770,
			COLOR_ATTACHMENT0: 36064,
			COLOR_BUFFER_BIT: 16384,
			TRIANGLES: 4,
			TRIANGLE_STRIP: 5,
			ONE_MINUS_SRC_ALPHA: 771,
			ARRAY_BUFFER: 34962,
			ELEMENT_ARRAY_BUFFER: 34963,
			STREAM_DRAW: 35040,
			STATIC_DRAW: 35044,
			DYNAMIC_DRAW: 35048,
			CULL_FACE: 2884,
			BLEND: 3042,
			STENCIL_TEST: 2960,
			DEPTH_TEST: 2929,
			SCISSOR_TEST: 3089,
			UNSIGNED_BYTE: 5121,
			UNSIGNED_SHORT: 5123,
			UNSIGNED_INT: 5125,
			FLOAT: 5126,
			RGBA: 6408,
			FRAGMENT_SHADER: 35632,
			VERTEX_SHADER: 35633,
			LINK_STATUS: 35714,
			LINEAR: 9729,
			TEXTURE_MAG_FILTER: 10240,
			TEXTURE_MIN_FILTER: 10241,
			TEXTURE_WRAP_S: 10242,
			TEXTURE_WRAP_T: 10243,
			TEXTURE_2D: 3553,
			TEXTURE0: 33984,
			CLAMP_TO_EDGE: 33071,
			COMPILE_STATUS: 35713,
			FRAMEBUFFER: 36160,
			CONTEXT_IDS_: ["experimental-webgl", "webgl", "webkit-3d", "moz-webgl"],
			getContext: function(t, e) {
				var i, r, o = n.CONTEXT_IDS_.length;
				for (r = 0; r < o; ++r) try {
					if (i = t.getContext(n.CONTEXT_IDS_[r], e)) return i
				} catch (t) {}
				return null
			}
		};
		e.a = n
	}, function(t, e, i) {
		"use strict";
		var n = {};
		n.assign = "function" == typeof Object.assign ? Object.assign : function(t, e) {
			if (null == t) throw new TypeError("Cannot convert undefined or null to object");
			for (var i = Object(t), n = 1, r = arguments.length; n < r; ++n) {
				var o = arguments[n];
				if (null != o) for (var s in o) o.hasOwnProperty(s) && (i[s] = o[s])
			}
			return i
		}, n.clear = function(t) {
			for (var e in t) delete t[e]
		}, n.getValues = function(t) {
			var e = [];
			for (var i in t) e.push(t[i]);
			return e
		}, n.isEmpty = function(t) {
			var e;
			for (e in t) return !1;
			return !e
		}, e.a = n
	}, function(t, e, i) {
		"use strict";
		i.r(e);
		var n = i(0),
			r = i(101),
			o = i(1),
			s = i(11),
			a = i(95),
			l = i(47),
			u = {
				Projection_: function(t) {
					a.a.call(this, {
						code: t,
						units: l.a.METERS,
						extent: u.EXTENT,
						global: !0,
						worldExtent: u.WORLD_EXTENT,
						getPointResolution: function(t, e) {
							return t / s.a.cosh(e[1] / u.RADIUS)
						}
					})
				}
			};
		n.
	default.inherits(u.Projection_, a.a), u.RADIUS = 6378137, u.HALF_SIZE = Math.PI * u.RADIUS, u.EXTENT = [-u.HALF_SIZE, -u.HALF_SIZE, u.HALF_SIZE, u.HALF_SIZE], u.WORLD_EXTENT = [-180, -85, 180, 85], u.PROJECTIONS = [new u.Projection_("EPSG:3857"), new u.Projection_("EPSG:102100"), new u.Projection_("EPSG:102113"), new u.Projection_("EPSG:900913"), new u.Projection_("urn:ogc:def:crs:EPSG:6.18:3:3857"), new u.Projection_("urn:ogc:def:crs:EPSG::3857"), new u.Projection_("http://www.opengis.net/gml/srs/epsg.xml#3857")], u.fromEPSG4326 = function(t, e, i) {
			var n = t.length,
				r = i > 1 ? i : 2,
				o = e;
			void 0 === o && (o = r > 2 ? t.slice() : new Array(n));
			for (var s = u.HALF_SIZE, a = 0; a < n; a += r) {
				o[a] = s * t[a] / 180;
				var l = u.RADIUS * Math.log(Math.tan(Math.PI * (t[a + 1] + 90) / 360));
				l > s ? l = s : l < -s && (l = -s), o[a + 1] = l
			}
			return o
		}, u.toEPSG4326 = function(t, e, i) {
			var n = t.length,
				r = i > 1 ? i : 2,
				o = e;
			void 0 === o && (o = r > 2 ? t.slice() : new Array(n));
			for (var s = 0; s < n; s += r) o[s] = 180 * t[s] / u.HALF_SIZE, o[s + 1] = 360 * Math.atan(Math.exp(t[s + 1] / u.RADIUS)) / Math.PI - 90;
			return o
		};
		var h = u,
			c = i(127),
			d = i(118),
			f = {
				cache_: {},
				clear: function() {
					f.cache_ = {}
				},
				get: function(t) {
					return f.cache_[t] || null
				},
				add: function(t, e) {
					f.cache_[t] = e
				}
			},
			A = f,
			p = i(8),
			g = {
				cache_: {},
				clear: function() {
					g.cache_ = {}
				},
				add: function(t, e, i) {
					var n = t.getCode(),
						r = e.getCode(),
						o = g.cache_;
					n in o || (o[n] = {}), o[n][r] = i
				},
				remove: function(t, e) {
					var i = t.getCode(),
						n = e.getCode(),
						r = g.cache_,
						o = r[i][n];
					return delete r[i][n], p.a.isEmpty(r[i]) && delete r[i], o
				},
				get: function(t, e) {
					var i, n = g.cache_;
					return t in n && e in n[t] && (i = n[t][e]), i
				}
			},
			m = g,
			v = {};
		v.METERS_PER_UNIT = l.a.METERS_PER_UNIT, v.SPHERE_ = new r.
	default (r.
	default.DEFAULT_RADIUS), n.
	default.ENABLE_PROJ4JS && (v.setProj4 = function(t) {
			d.a.set(t)
		}), v.getPointResolution = function(t, e, i, n) {
			var r, o = (t = v.get(t)).getPointResolutionFunc();
			if (o) r = o(e, i);
			else if (t.getUnits() == l.a.DEGREES && !n || n == l.a.DEGREES) r = e;
			else {
				var s = v.getTransformFromProjections(t, v.get("EPSG:4326")),
					a = [i[0] - e / 2, i[1], i[0] + e / 2, i[1], i[0], i[1] - e / 2, i[0], i[1] + e / 2];
				a = s(a, a, 2), r = (v.SPHERE_.haversineDistance(a.slice(0, 2), a.slice(2, 4)) + v.SPHERE_.haversineDistance(a.slice(4, 6), a.slice(6, 8))) / 2;
				var u = n ? l.a.METERS_PER_UNIT[n] : t.getMetersPerUnit();
				void 0 !== u && (r /= u)
			}
			return r
		}, v.addEquivalentProjections = function(t) {
			v.addProjections(t), t.forEach((function(e) {
				t.forEach((function(t) {
					e !== t && m.add(e, t, v.cloneTransform)
				}))
			}))
		}, v.addEquivalentTransforms = function(t, e, i, n) {
			t.forEach((function(t) {
				e.forEach((function(e) {
					m.add(t, e, i), m.add(e, t, n)
				}))
			}))
		}, v.addProjection = function(t) {
			A.add(t.getCode(), t), m.add(t, t, v.cloneTransform)
		}, v.addProjections = function(t) {
			t.forEach(v.addProjection)
		}, v.clearAllProjections = function() {
			A.clear(), m.clear()
		}, v.createProjection = function(t, e) {
			return t ? "string" == typeof t ? v.get(t) : t : v.get(e)
		}, v.addCoordinateTransforms = function(t, e, i, n) {
			var r = v.get(t),
				o = v.get(e);
			m.add(r, o, v.createTransformFromCoordinateTransform(i)), m.add(o, r, v.createTransformFromCoordinateTransform(n))
		}, v.createTransformFromCoordinateTransform = function(t) {
			return function(e, i, n) {
				var r, o, s, a = e.length,
					l = void 0 !== n ? n : 2,
					u = void 0 !== i ? i : new Array(a);
				for (o = 0; o < a; o += l) for (r = t([e[o], e[o + 1]]), u[o] = r[0], u[o + 1] = r[1], s = l - 1; s >= 2; --s) u[o + s] = e[o + s];
				return u
			}
		}, v.fromLonLat = function(t, e) {
			return v.transform(t, "EPSG:4326", void 0 !== e ? e : "EPSG:3857")
		}, v.toLonLat = function(t, e) {
			var i = v.transform(t, void 0 !== e ? e : "EPSG:3857", "EPSG:4326"),
				n = i[0];
			return (n < -180 || n > 180) && (i[0] = s.a.modulo(n + 180, 360) - 180), i
		}, v.get = function(t) {
			var e = null;
			if (t instanceof a.a) e = t;
			else if ("string" == typeof t) {
				var i = t;
				if (e = A.get(i), n.
			default.ENABLE_PROJ4JS && !e) {
					var r = d.a.get();
					"function" == typeof r && void 0 !== r.defs(i) && (e = new a.a({
						code: i
					}), v.addProjection(e))
				}
			}
			return e
		}, v.equivalent = function(t, e) {
			if (t === e) return !0;
			var i = t.getUnits() === e.getUnits();
			return t.getCode() === e.getCode() ? i : v.getTransformFromProjections(t, e) === v.cloneTransform && i
		}, v.getTransform = function(t, e) {
			var i = v.get(t),
				n = v.get(e);
			return v.getTransformFromProjections(i, n)
		}, v.getTransformFromProjections = function(t, e) {
			var i = t.getCode(),
				r = e.getCode(),
				o = m.get(i, r);
			if (n.
		default.ENABLE_PROJ4JS && !o) {
				var s = d.a.get();
				if ("function" == typeof s) {
					var a = s.defs(i),
						l = s.defs(r);
					if (void 0 !== a && void 0 !== l) {
						if (a === l) v.addEquivalentProjections([e, t]);
						else {
							var u = s(r, i);
							v.addCoordinateTransforms(e, t, u.forward, u.inverse)
						}
						o = m.get(i, r)
					}
				}
			}
			return o || (o = v.identityTransform), o
		}, v.identityTransform = function(t, e, i) {
			if (void 0 !== e && t !== e) {
				for (var n = 0, r = t.length; n < r; ++n) e[n] = t[n];
				t = e
			}
			return t
		}, v.cloneTransform = function(t, e, i) {
			var n;
			if (void 0 !== e) {
				for (var r = 0, o = t.length; r < o; ++r) e[r] = t[r];
				n = e
			} else n = t.slice();
			return n
		}, v.transform = function(t, e, i) {
			return v.getTransform(e, i)(t, void 0, t.length)
		}, v.transformExtent = function(t, e, i) {
			var n = v.getTransform(e, i);
			return o.
		default.applyTransform(t, n)
		}, v.transformWithProjections = function(t, e, i) {
			return v.getTransformFromProjections(e, i)(t)
		}, v.addCommon = function() {
			v.addEquivalentProjections(h.PROJECTIONS), v.addEquivalentProjections(c.a.PROJECTIONS), v.addEquivalentTransforms(c.a.PROJECTIONS, h.PROJECTIONS, h.fromEPSG4326, h.toEPSG4326)
		}, v.addCommon();
		e.
	default = v
	}, function(t, e, i) {
		"use strict";
		var n = {
			binarySearch: function(t, e, i) {
				for (var r, o, s = i || n.numberSafeCompareFunction, a = 0, l = t.length, u = !1; a < l;)(o = +s(t[r = a + (l - a >> 1)], e)) < 0 ? a = r + 1 : (l = r, u = !o);
				return u ? a : ~a
			},
			numberSafeCompareFunction: function(t, e) {
				return t > e ? 1 : t < e ? -1 : 0
			},
			includes: function(t, e) {
				return t.indexOf(e) >= 0
			},
			linearFindNearest: function(t, e, i) {
				var n, r = t.length;
				if (t[0] <= e) return 0;
				if (e <= t[r - 1]) return r - 1;
				if (i > 0) {
					for (n = 1; n < r; ++n) if (t[n] < e) return n - 1
				} else if (i < 0) {
					for (n = 1; n < r; ++n) if (t[n] <= e) return n
				} else for (n = 1; n < r; ++n) {
					if (t[n] == e) return n;
					if (t[n] < e) return t[n - 1] - e < e - t[n] ? n - 1 : n
				}
				return r - 1
			},
			reverseSubArray: function(t, e, i) {
				for (; e < i;) {
					var n = t[e];
					t[e] = t[i], t[i] = n, ++e, --i
				}
			},
			extend: function(t, e) {
				var i, n = Array.isArray(e) ? e : [e],
					r = n.length;
				for (i = 0; i < r; i++) t[t.length] = n[i]
			},
			remove: function(t, e) {
				var i = t.indexOf(e),
					n = i > -1;
				return n && t.splice(i, 1), n
			},
			find: function(t, e) {
				for (var i, n = t.length >>> 0, r = 0; r < n; r++) if (e(i = t[r], r, t)) return i;
				return null
			},
			equals: function(t, e) {
				var i = t.length;
				if (i !== e.length) return !1;
				for (var n = 0; n < i; n++) if (t[n] !== e[n]) return !1;
				return !0
			},
			stableSort: function(t, e) {
				var i, n = t.length,
					r = Array(t.length);
				for (i = 0; i < n; i++) r[i] = {
					index: i,
					value: t[i]
				};
				for (r.sort((function(t, i) {
					return e(t.value, i.value) || t.index - i.index
				})), i = 0; i < t.length; i++) t[i] = r[i].value
			},
			findIndex: function(t, e) {
				var i;
				return !t.every((function(n, r) {
					return i = r, !e(n, r, t)
				})) ? i : -1
			},
			isSorted: function(t, e, i) {
				var r = e || n.numberSafeCompareFunction;
				return t.every((function(e, n) {
					if (0 === n) return !0;
					var o = r(t[n - 1], e);
					return !(o > 0 || i && 0 === o)
				}))
			}
		};
		e.a = n
	}, function(t, e, i) {
		"use strict";
		var n = i(15),
			r = {
				clamp: function(t, e, i) {
					return Math.min(Math.max(t, e), i)
				}
			};
		r.cosh = "cosh" in Math ? Math.cosh : function(t) {
			var e = Math.exp(t);
			return (e + 1 / e) / 2
		}, r.roundUpToPowerOfTwo = function(t) {
			return n.a.assert(0 < t, 29), Math.pow(2, Math.ceil(Math.log(t) / Math.LN2))
		}, r.squaredSegmentDistance = function(t, e, i, n, o, s) {
			var a = o - i,
				l = s - n;
			if (0 !== a || 0 !== l) {
				var u = ((t - i) * a + (e - n) * l) / (a * a + l * l);
				u > 1 ? (i = o, n = s) : u > 0 && (i += a * u, n += l * u)
			}
			return r.squaredDistance(t, e, i, n)
		}, r.squaredDistance = function(t, e, i, n) {
			var r = i - t,
				o = n - e;
			return r * r + o * o
		}, r.solveLinearSystem = function(t) {
			for (var e = t.length, i = 0; i < e; i++) {
				for (var n = i, r = Math.abs(t[i][i]), o = i + 1; o < e; o++) {
					var s = Math.abs(t[o][i]);
					s > r && (r = s, n = o)
				}
				if (0 === r) return null;
				var a = t[n];
				t[n] = t[i], t[i] = a;
				for (var l = i + 1; l < e; l++) for (var u = -t[l][i] / t[i][i], h = i; h < e + 1; h++) i == h ? t[l][h] = 0 : t[l][h] += u * t[i][h]
			}
			for (var c = new Array(e), d = e - 1; d >= 0; d--) {
				c[d] = t[d][e] / t[d][d];
				for (var f = d - 1; f >= 0; f--) t[f][e] -= t[f][d] * c[d]
			}
			return c
		}, r.toDegrees = function(t) {
			return 180 * t / Math.PI
		}, r.toRadians = function(t) {
			return t * Math.PI / 180
		}, r.modulo = function(t, e) {
			var i = t % e;
			return i * e < 0 ? i + e : i
		}, r.lerp = function(t, e, i) {
			return t + i * (e - t)
		}, e.a = r
	}, function(t, e, i) {
		"use strict";
		var n, r, o = i(37),
			s = i(16),
			a = i(8),
			l = i(112),
			u = i(6),
			h = {};
		h.defaultFont = "10px sans-serif", h.defaultFillStyle = [0, 0, 0, 1], h.defaultLineCap = "round", h.defaultLineDash = [], h.defaultLineDashOffset = 0, h.defaultLineJoin = "round", h.defaultMiterLimit = 10, h.defaultStrokeStyle = [0, 0, 0, 1], h.defaultTextAlign = "center", h.defaultTextBaseline = "middle", h.defaultPadding = [0, 0, 0, 0], h.defaultLineWidth = 1, h.labelCache = new l.a, h.checkedFonts_ = {}, h.measureContext_ = null, h.textHeights_ = {}, h.checkFont = function() {
			var t, e, i = 60,
				n = h.checkedFonts_,
				r = h.labelCache,
				s = "32px monospace",
				l = "wmytzilWMYTZIL@#/&?$%10";

			function u(t) {
				var i = h.getMeasureContext();
				i.font = s, e = i.measureText(l).width;
				var n = !0;
				"monospace" != t && (i.font = "32px " + t + ",monospace", n = i.measureText(l).width != e);
				return n
			}
			function c() {
				var e = !0;
				for (var o in n) n[o] < i && (u(o) ? (n[o] = i, a.a.clear(h.textHeights_), h.measureContext_ = null, r.clear()) : (++n[o], e = !1));
				e && (window.clearInterval(t), t = void 0)
			}
			return function(e) {
				var r = o.a.getFontFamilies(e);
				if (r) for (var s = 0, a = r.length; s < a; ++s) {
					var l = r[s];
					l in n || (n[l] = i, u(l) || (n[l] = 0, void 0 === t && (t = window.setInterval(c, 32))))
				}
			}
		}(), h.getMeasureContext = function() {
			var t = h.measureContext_;
			return t || (t = h.measureContext_ = s.a.createCanvasContext2D(1, 1)), t
		}, h.measureTextHeight = (r = h.textHeights_, function(t) {
			var e = r[t];
			return null == e && (n || ((n = document.createElement("span")).textContent = "M", n.style.margin = n.style.padding = "0 !important", n.style.position = "absolute !important", n.style.left = "-99999px !important"), n.style.font = t, document.body.appendChild(n), e = r[t] = n.offsetHeight, document.body.removeChild(n)), e
		}), h.measureTextWidth = function(t, e) {
			var i = h.getMeasureContext();
			return t != i.font && (i.font = t), i.measureText(e).width
		}, h.rotateAtOffset = function(t, e, i, n) {
			0 !== e && (t.translate(i, n), t.rotate(e), t.translate(-i, -n))
		}, h.resetTransform_ = u.a.create(), h.drawImage = function(t, e, i, n, r, o, s, a, l, u, c) {
			var d;
			1 != i && (d = t.globalAlpha, t.globalAlpha = d * i), e && t.setTransform.apply(t, e), t.drawImage(n, r, o, s, a, l, u, s * c, a * c), d && (t.globalAlpha = d), e && t.setTransform.apply(t, h.resetTransform_)
		}, e.a = h
	}, function(t, e, i) {
		"use strict";
		e.a = {
			IDLE: 0,
			LOADING: 1,
			LOADED: 2,
			ERROR: 3,
			EMPTY: 4,
			ABORT: 5
		}
	}, function(t, e, i) {
		"use strict";
		var n = i(0),
			r = i(77),
			o = i(81),
			s = i(21),
			a = i(8),
			l = function(t) {
				o.
			default.call(this), n.
			default.getUid(this), this.values_ = {}, void 0 !== t && this.setProperties(t)
			};
		n.
	default.inherits(l, o.
	default), l.changeEventTypeCache_ = {}, l.getChangeEventType = function(t) {
			return l.changeEventTypeCache_.hasOwnProperty(t) ? l.changeEventTypeCache_[t] : l.changeEventTypeCache_[t] = "change:" + t
		}, l.prototype.get = function(t) {
			var e;
			return this.values_.hasOwnProperty(t) && (e = this.values_[t]), e
		}, l.prototype.getKeys = function() {
			return Object.keys(this.values_)
		}, l.prototype.getProperties = function() {
			return a.a.assign({}, this.values_)
		}, l.prototype.notify = function(t, e) {
			var i;
			i = l.getChangeEventType(t), this.dispatchEvent(new l.Event(i, t, e)), i = r.a.PROPERTYCHANGE, this.dispatchEvent(new l.Event(i, t, e))
		}, l.prototype.set = function(t, e, i) {
			if (i) this.values_[t] = e;
			else {
				var n = this.values_[t];
				this.values_[t] = e, n !== e && this.notify(t, n)
			}
		}, l.prototype.setProperties = function(t, e) {
			var i;
			for (i in t) this.set(i, t[i], e)
		}, l.prototype.unset = function(t, e) {
			if (t in this.values_) {
				var i = this.values_[t];
				delete this.values_[t], e || this.notify(t, i)
			}
		}, l.Event = function(t, e, i) {
			s.a.call(this, t), this.key = e, this.oldValue = i
		}, n.
	default.inherits(l.Event, s.a), e.a = l
	}, function(t, e, i) {
		"use strict";
		var n = i(132),
			r = {
				assert: function(t, e) {
					if (!t) throw new n.a(e)
				}
			};
		e.a = r
	}, function(t, e, i) {
		"use strict";
		var n = {
			createCanvasContext2D: function(t, e) {
				var i = document.createElement("CANVAS");
				return t && (i.width = t), e && (i.height = e), i.getContext("2d")
			},
			outerWidth: function(t) {
				var e = t.offsetWidth,
					i = getComputedStyle(t);
				return e += parseInt(i.marginLeft, 10) + parseInt(i.marginRight, 10)
			},
			outerHeight: function(t) {
				var e = t.offsetHeight,
					i = getComputedStyle(t);
				return e += parseInt(i.marginTop, 10) + parseInt(i.marginBottom, 10)
			},
			replaceNode: function(t, e) {
				var i = e.parentNode;
				i && i.replaceChild(t, e)
			},
			removeNode: function(t) {
				return t && t.parentNode ? t.parentNode.removeChild(t) : null
			},
			removeChildren: function(t) {
				for (; t.lastChild;) t.removeChild(t.lastChild)
			}
		};
		e.a = n
	}, function(t, e, i) {
		"use strict";
		e.a = {
			IDLE: 0,
			LOADING: 1,
			LOADED: 2,
			ERROR: 3
		}
	}, function(t, e, i) {
		"use strict";
		e.a = {
			XY: "XY",
			XYZ: "XYZ",
			XYM: "XYM",
			XYZM: "XYZM"
		}
	}, function(t, e, i) {
		"use strict";
		i.r(e);
		var n = i(11),
			r = i(85),
			o = {
				add: function(t, e) {
					return t[0] += e[0], t[1] += e[1], t
				},
				closestOnCircle: function(t, e) {
					var i = e.getRadius(),
						n = e.getCenter(),
						r = n[0],
						o = n[1],
						s = t[0] - r,
						a = t[1] - o;
					0 === s && 0 === a && (s = 1);
					var l = Math.sqrt(s * s + a * a);
					return [r + i * s / l, o + i * a / l]
				},
				closestOnSegment: function(t, e) {
					var i, n, r = t[0],
						o = t[1],
						s = e[0],
						a = e[1],
						l = s[0],
						u = s[1],
						h = a[0],
						c = a[1],
						d = h - l,
						f = c - u,
						A = 0 === d && 0 === f ? 0 : (d * (r - l) + f * (o - u)) / (d * d + f * f || 0);
					return A <= 0 ? (i = l, n = u) : A >= 1 ? (i = h, n = c) : (i = l + A * d, n = u + A * f), [i, n]
				},
				createStringXY: function(t) {
					return function(e) {
						return o.toStringXY(e, t)
					}
				},
				degreesToStringHDMS: function(t, e, i) {
					var o = n.a.modulo(e + 180, 360) - 180,
						s = Math.abs(3600 * o),
						a = i || 0,
						l = Math.pow(10, a),
						u = Math.floor(s / 3600),
						h = Math.floor((s - 3600 * u) / 60),
						c = s - 3600 * u - 60 * h;
					return (c = Math.ceil(c * l) / l) >= 60 && (c = 0, h += 1), h >= 60 && (h = 0, u += 1), u + "° " + r.a.padNumber(h, 2) + "′ " + r.a.padNumber(c, 2, a) + "″" + (0 == o ? "" : " " + t.charAt(o < 0 ? 1 : 0))
				},
				format: function(t, e, i) {
					return t ? e.replace("{x}", t[0].toFixed(i)).replace("{y}", t[1].toFixed(i)) : ""
				},
				equals: function(t, e) {
					for (var i = !0, n = t.length - 1; n >= 0; --n) if (t[n] != e[n]) {
						i = !1;
						break
					}
					return i
				},
				rotate: function(t, e) {
					var i = Math.cos(e),
						n = Math.sin(e),
						r = t[0] * i - t[1] * n,
						o = t[1] * i + t[0] * n;
					return t[0] = r, t[1] = o, t
				},
				scale: function(t, e) {
					return t[0] *= e, t[1] *= e, t
				},
				sub: function(t, e) {
					return t[0] -= e[0], t[1] -= e[1], t
				},
				squaredDistance: function(t, e) {
					var i = t[0] - e[0],
						n = t[1] - e[1];
					return i * i + n * n
				},
				distance: function(t, e) {
					return Math.sqrt(o.squaredDistance(t, e))
				},
				squaredDistanceToSegment: function(t, e) {
					return o.squaredDistance(t, o.closestOnSegment(t, e))
				},
				toStringHDMS: function(t, e) {
					return t ? o.degreesToStringHDMS("NS", t[1], e) + " " + o.degreesToStringHDMS("EW", t[0], e) : ""
				},
				toStringXY: function(t, e) {
					return o.format(t, "{x}, {y}", e)
				}
			};
		e.
	default = o
	}, function(t, e, i) {
		"use strict";
		var n = {
			TRUE: function() {
				return !0
			},
			FALSE: function() {
				return !1
			}
		};
		e.a = n
	}, function(t, e, i) {
		"use strict";
		var n = function(t) {
				this.propagationStopped, this.type = t, this.target = null
			};
		n.prototype.preventDefault = n.prototype.stopPropagation = function() {
			this.propagationStopped = !0
		}, n.stopPropagation = function(t) {
			t.stopPropagation()
		}, n.preventDefault = function(t) {
			t.preventDefault()
		}, e.a = n
	}, function(t, e, i) {
		"use strict";
		e.a = {
			ANIMATING: 0,
			INTERACTING: 1
		}
	}, function(t, e, i) {
		"use strict";
		var n = i(0),
			r = i(20),
			o = i(24),
			s = i(78),
			a = i(29),
			l = i(8),
			u = function(t) {
				var e = t || {},
					i = e.handleEvent ? e.handleEvent : u.handleEvent;
				a.a.call(this, {
					handleEvent: i
				}), this.handleDownEvent_ = e.handleDownEvent ? e.handleDownEvent : u.handleDownEvent, this.handleDragEvent_ = e.handleDragEvent ? e.handleDragEvent : u.handleDragEvent, this.handleMoveEvent_ = e.handleMoveEvent ? e.handleMoveEvent : u.handleMoveEvent, this.handleUpEvent_ = e.handleUpEvent ? e.handleUpEvent : u.handleUpEvent, this.handlingDownUpSequence = !1, this.trackedPointers_ = {}, this.targetPointers = []
			};
		n.
	default.inherits(u, a.a), u.centroid = function(t) {
			for (var e = t.length, i = 0, n = 0, r = 0; r < e; r++) i += t[r].clientX, n += t[r].clientY;
			return [i / e, n / e]
		}, u.prototype.isPointerDraggingEvent_ = function(t) {
			var e = t.type;
			return e === o.a.POINTERDOWN || e === o.a.POINTERDRAG || e === o.a.POINTERUP
		}, u.prototype.updateTrackedPointers_ = function(t) {
			if (this.isPointerDraggingEvent_(t)) {
				var e = t.pointerEvent,
					i = e.pointerId.toString();
				t.type == o.a.POINTERUP ? delete this.trackedPointers_[i] : t.type == o.a.POINTERDOWN ? this.trackedPointers_[i] = e : i in this.trackedPointers_ && (this.trackedPointers_[i] = e), this.targetPointers = l.a.getValues(this.trackedPointers_)
			}
		}, u.handleDragEvent = n.
	default.nullFunction, u.handleUpEvent = r.a.FALSE, u.handleDownEvent = r.a.FALSE, u.handleMoveEvent = n.
	default.nullFunction, u.handleEvent = function(t) {
			if (!(t instanceof s.a)) return !0;
			var e = !1;
			if (this.updateTrackedPointers_(t), this.handlingDownUpSequence) {
				if (t.type == o.a.POINTERDRAG) this.handleDragEvent_(t);
				else if (t.type == o.a.POINTERUP) {
					var i = this.handleUpEvent_(t);
					this.handlingDownUpSequence = i && this.targetPointers.length > 0
				}
			} else if (t.type == o.a.POINTERDOWN) {
				var n = this.handleDownEvent_(t);
				this.handlingDownUpSequence = n, e = this.shouldStopEvent(n)
			} else t.type == o.a.POINTERMOVE && this.handleMoveEvent_(t);
			return !e
		}, u.prototype.shouldStopEvent = function(t) {
			return t
		}, e.a = u
	}, function(t, e, i) {
		"use strict";
		var n = i(5),
			r = {
				SINGLECLICK: "singleclick",
				CLICK: n.a.CLICK,
				DBLCLICK: n.a.DBLCLICK,
				POINTERDRAG: "pointerdrag",
				POINTERMOVE: "pointermove",
				POINTERDOWN: "pointerdown",
				POINTERUP: "pointerup",
				POINTEROVER: "pointerover",
				POINTEROUT: "pointerout",
				POINTERENTER: "pointerenter",
				POINTERLEAVE: "pointerleave",
				POINTERCANCEL: "pointercancel"
			};
		e.a = r
	}, function(t, e, i) {
		"use strict";
		i.r(e);
		var n = i(0),
			r = i(1),
			o = i(18),
			s = i(4),
			a = i(40),
			l = i(64),
			u = i(11),
			h = function(t, e) {
				a.a.call(this), this.setCoordinates(t, e)
			};
		n.
	default.inherits(h, a.a), h.prototype.clone = function() {
			var t = new h(null);
			return t.setFlatCoordinates(this.layout, this.flatCoordinates.slice()), t
		}, h.prototype.closestPointXY = function(t, e, i, n) {
			var r = this.flatCoordinates,
				o = u.a.squaredDistance(t, e, r[0], r[1]);
			if (o < n) {
				var s, a = this.stride;
				for (s = 0; s < a; ++s) i[s] = r[s];
				return i.length = a, o
			}
			return n
		}, h.prototype.getCoordinates = function() {
			return this.flatCoordinates ? this.flatCoordinates.slice() : []
		}, h.prototype.computeExtent = function(t) {
			return r.
		default.createOrUpdateFromCoordinate(this.flatCoordinates, t)
		}, h.prototype.getType = function() {
			return s.a.POINT
		}, h.prototype.intersectsExtent = function(t) {
			return r.
		default.containsXY(t, this.flatCoordinates[0], this.flatCoordinates[1])
		}, h.prototype.setCoordinates = function(t, e) {
			t ? (this.setLayout(e, t, 0), this.flatCoordinates || (this.flatCoordinates = []), this.flatCoordinates.length = l.a.coordinate(this.flatCoordinates, 0, t, this.stride), this.changed()) : this.setFlatCoordinates(o.a.XY, null)
		}, h.prototype.setFlatCoordinates = function(t, e) {
			this.setFlatCoordinatesInternal(t, e), this.changed()
		}, e.
	default = h
	}, function(t, e, i) {
		"use strict";
		i.r(e);
		var n = i(15),
			r = i(3),
			o = i(5),
			s = i(0),
			a = i(14),
			l = i(60),
			u = i(34),
			h = function(t) {
				if (a.a.call(this), this.id_ = void 0, this.geometryName_ = "geometry", this.style_ = null, this.styleFunction_ = void 0, this.geometryChangeKey_ = null, r.a.listen(this, a.a.getChangeEventType(this.geometryName_), this.handleGeometryChanged_, this), void 0 !== t) if (t instanceof l.a || !t) {
					var e = t;
					this.setGeometry(e)
				} else {
					var i = t;
					this.setProperties(i)
				}
			};
		s.
	default.inherits(h, a.a), h.prototype.clone = function() {
			var t = new h(this.getProperties());
			t.setGeometryName(this.getGeometryName());
			var e = this.getGeometry();
			e && t.setGeometry(e.clone());
			var i = this.getStyle();
			return i && t.setStyle(i), t
		}, h.prototype.getGeometry = function() {
			return this.get(this.geometryName_)
		}, h.prototype.getId = function() {
			return this.id_
		}, h.prototype.getGeometryName = function() {
			return this.geometryName_
		}, h.prototype.getStyle = function() {
			return this.style_
		}, h.prototype.getStyleFunction = function() {
			return this.styleFunction_
		}, h.prototype.handleGeometryChange_ = function() {
			this.changed()
		}, h.prototype.handleGeometryChanged_ = function() {
			this.geometryChangeKey_ && (r.a.unlistenByKey(this.geometryChangeKey_), this.geometryChangeKey_ = null);
			var t = this.getGeometry();
			t && (this.geometryChangeKey_ = r.a.listen(t, o.a.CHANGE, this.handleGeometryChange_, this)), this.changed()
		}, h.prototype.setGeometry = function(t) {
			this.set(this.geometryName_, t)
		}, h.prototype.setStyle = function(t) {
			this.style_ = t, this.styleFunction_ = t ? h.createStyleFunction(t) : void 0, this.changed()
		}, h.prototype.setId = function(t) {
			this.id_ = t, this.changed()
		}, h.prototype.setGeometryName = function(t) {
			r.a.unlisten(this, a.a.getChangeEventType(this.geometryName_), this.handleGeometryChanged_, this), this.geometryName_ = t, r.a.listen(this, a.a.getChangeEventType(this.geometryName_), this.handleGeometryChanged_, this), this.handleGeometryChanged_()
		}, h.createStyleFunction = function(t) {
			var e, i;
			"function" == typeof t ? e = 2 == t.length ?
			function(e) {
				return t(this, e)
			} : t : (Array.isArray(t) ? i = t : (n.a.assert(t instanceof u.
		default, 41), i = [t]), e = function() {
				return i
			});
			return e
		}, e.
	default = h
	}, function(t, e, i) {
		"use strict";
		i.r(e);
		var n = i(0),
			r = i(132),
			o = i(42),
			s = i(14),
			a = i(21),
			l = function(t, e) {
				s.a.call(this);
				var i = e || {};
				if (this.unique_ = !! i.unique, this.array_ = t || [], this.unique_) for (var n = 0, r = this.array_.length; n < r; ++n) this.assertUnique_(this.array_[n], n);
				this.updateLength_()
			};
		n.
	default.inherits(l, s.a), l.prototype.clear = function() {
			for (; this.getLength() > 0;) this.pop()
		}, l.prototype.extend = function(t) {
			var e, i;
			for (e = 0, i = t.length; e < i; ++e) this.push(t[e]);
			return this
		}, l.prototype.forEach = function(t, e) {
			for (var i = e ? t.bind(e) : t, n = this.array_, r = 0, o = n.length; r < o; ++r) i(n[r], r, n)
		}, l.prototype.getArray = function() {
			return this.array_
		}, l.prototype.item = function(t) {
			return this.array_[t]
		}, l.prototype.getLength = function() {
			return this.get(l.Property_.LENGTH)
		}, l.prototype.insertAt = function(t, e) {
			this.unique_ && this.assertUnique_(e), this.array_.splice(t, 0, e), this.updateLength_(), this.dispatchEvent(new l.Event(o.a.ADD, e))
		}, l.prototype.pop = function() {
			return this.removeAt(this.getLength() - 1)
		}, l.prototype.push = function(t) {
			this.unique_ && this.assertUnique_(t);
			var e = this.getLength();
			return this.insertAt(e, t), this.getLength()
		}, l.prototype.remove = function(t) {
			var e, i, n = this.array_;
			for (e = 0, i = n.length; e < i; ++e) if (n[e] === t) return this.removeAt(e)
		}, l.prototype.removeAt = function(t) {
			var e = this.array_[t];
			return this.array_.splice(t, 1), this.updateLength_(), this.dispatchEvent(new l.Event(o.a.REMOVE, e)), e
		}, l.prototype.setAt = function(t, e) {
			var i = this.getLength();
			if (t < i) {
				this.unique_ && this.assertUnique_(e, t);
				var n = this.array_[t];
				this.array_[t] = e, this.dispatchEvent(new l.Event(o.a.REMOVE, n)), this.dispatchEvent(new l.Event(o.a.ADD, e))
			} else {
				var r;
				for (r = i; r < t; ++r) this.insertAt(r, void 0);
				this.insertAt(t, e)
			}
		}, l.prototype.updateLength_ = function() {
			this.set(l.Property_.LENGTH, this.array_.length)
		}, l.prototype.assertUnique_ = function(t, e) {
			for (var i = 0, n = this.array_.length; i < n; ++i) if (this.array_[i] === t && i !== e) throw new r.a(58)
		}, l.Property_ = {
			LENGTH: "length"
		}, l.Event = function(t, e) {
			a.a.call(this, t), this.element = e
		}, n.
	default.inherits(l.Event, a.a), e.
	default = l
	}, function(t, e, i) {
		"use strict";
		i.r(e);
		var n = i(24),
			r = i(15),
			o = i(20),
			s = i(35),
			a = {
				altKeyOnly: function(t) {
					var e = t.originalEvent;
					return e.altKey && !(e.metaKey || e.ctrlKey) && !e.shiftKey
				},
				altShiftKeysOnly: function(t) {
					var e = t.originalEvent;
					return e.altKey && !(e.metaKey || e.ctrlKey) && e.shiftKey
				}
			};
		a.always = o.a.TRUE, a.click = function(t) {
			return t.type == n.a.CLICK
		}, a.mouseActionButton = function(t) {
			var e = t.originalEvent;
			return 0 == e.button && !(s.a.WEBKIT && s.a.MAC && e.ctrlKey)
		}, a.never = o.a.FALSE, a.pointerMove = function(t) {
			return "pointermove" == t.type
		}, a.singleClick = function(t) {
			return t.type == n.a.SINGLECLICK
		}, a.doubleClick = function(t) {
			return t.type == n.a.DBLCLICK
		}, a.noModifierKeys = function(t) {
			var e = t.originalEvent;
			return !e.altKey && !(e.metaKey || e.ctrlKey) && !e.shiftKey
		}, a.platformModifierKeyOnly = function(t) {
			var e = t.originalEvent;
			return !e.altKey && (s.a.MAC ? e.metaKey : e.ctrlKey) && !e.shiftKey
		}, a.shiftKeyOnly = function(t) {
			var e = t.originalEvent;
			return !e.altKey && !(e.metaKey || e.ctrlKey) && e.shiftKey
		}, a.targetNotEditable = function(t) {
			var e = t.originalEvent.target.tagName;
			return "INPUT" !== e && "SELECT" !== e && "TEXTAREA" !== e
		}, a.mouseOnly = function(t) {
			return r.a.assert(t.pointerEvent, 56), "mouse" == t.pointerEvent.pointerType
		}, a.primaryAction = function(t) {
			var e = t.pointerEvent;
			return e.isPrimary && 0 === e.button
		}, e.
	default = a
	}, function(t, e, i) {
		"use strict";
		var n = i(0),
			r = i(14),
			o = i(39),
			s = i(111),
			a = i(11),
			l = function(t) {
				r.a.call(this), this.map_ = null, this.setActive(!0), this.handleEvent = t.handleEvent
			};
		n.
	default.inherits(l, r.a), l.prototype.getActive = function() {
			return this.get(s.a.ACTIVE)
		}, l.prototype.getMap = function() {
			return this.map_
		}, l.prototype.setActive = function(t) {
			this.set(s.a.ACTIVE, t)
		}, l.prototype.setMap = function(t) {
			this.map_ = t
		}, l.pan = function(t, e, i) {
			var n = t.getCenter();
			if (n) {
				var r = t.constrainCenter([n[0] + e[0], n[1] + e[1]]);
				i ? t.animate({
					duration: i,
					easing: o.
				default.linear,
					center:
					r
				}) : t.setCenter(r)
			}
		}, l.rotate = function(t, e, i, n) {
			e = t.constrainRotation(e, 0), l.rotateWithoutConstraints(t, e, i, n)
		}, l.rotateWithoutConstraints = function(t, e, i, n) {
			if (void 0 !== e) {
				var r = t.getRotation(),
					s = t.getCenter();
				void 0 !== r && s && n > 0 ? t.animate({
					rotation: e,
					anchor: i,
					duration: n,
					easing: o.
				default.easeOut
				}) : t.rotate(e, i)
			}
		}, l.zoom = function(t, e, i, n, r) {
			e = t.constrainResolution(e, 0, r), l.zoomWithoutConstraints(t, e, i, n)
		}, l.zoomByDelta = function(t, e, i, n) {
			var r = t.getResolution(),
				o = t.constrainResolution(r, e, 0);
			if (void 0 !== o) {
				var s = t.getResolutions();
				o = a.a.clamp(o, t.getMinResolution() || s[s.length - 1], t.getMaxResolution() || s[0])
			}
			if (i && void 0 !== o && o !== r) {
				var u = t.getCenter(),
					h = t.calculateCenterZoom(o, i);
				h = t.constrainCenter(h), i = [(o * u[0] - r * h[0]) / (o - r), (o * u[1] - r * h[1]) / (o - r)]
			}
			l.zoomWithoutConstraints(t, o, i, n)
		}, l.zoomWithoutConstraints = function(t, e, i, n) {
			if (e) {
				var r = t.getResolution(),
					s = t.getCenter();
				if (void 0 !== r && s && e !== r && n) t.animate({
					resolution: e,
					anchor: i,
					duration: n,
					easing: o.
				default.easeOut
				});
				else {
					if (i) {
						var a = t.calculateCenterZoom(e, i);
						t.setCenter(a)
					}
					t.setResolution(e)
				}
			}
		}, e.a = l
	}, function(t, e, i) {
		"use strict";
		i.r(e);
		var n = i(0),
			r = i(27),
			o = i(42),
			s = i(77),
			a = i(10),
			l = i(15),
			u = i(3),
			h = i(21),
			c = i(5),
			d = i(1),
			f = i(93),
			A = i(2),
			p = {
				loadFeaturesXhr: function(t, e, i, n) {
					return function(r, o, s) {
						var a = new XMLHttpRequest;
						a.open("GET", "function" == typeof t ? t(r, o, s) : t, !0), e.getType() == f.a.ARRAY_BUFFER && (a.responseType = "arraybuffer"), a.onload = function(t) {
							if (!a.status || a.status >= 200 && a.status < 300) {
								var r, o = e.getType();
								o == f.a.JSON || o == f.a.TEXT ? r = a.responseText : o == f.a.XML ? (r = a.responseXML) || (r = A.a.parse(a.responseText)) : o == f.a.ARRAY_BUFFER && (r = a.response), r ? i.call(this, e.readFeatures(r, {
									featureProjection: s
								}), e.readProjection(r), e.getLastExtent()) : n.call(this)
							} else n.call(this)
						}.bind(this), a.onerror = function() {
							n.call(this)
						}.bind(this), a.send()
					}
				},
				xhr: function(t, e) {
					return p.loadFeaturesXhr(t, e, (function(t, e) {
						this.addFeatures(t)
					}), n.
				default.nullFunction)
				}
			},
			g = p,
			m = i(20),
			v = i(148),
			y = i(8),
			_ = i(97),
			E = i(59),
			x = i(74),
			C = i(84),
			I = function(t) {
				var e = t || {};
				_.a.call(this, {
					attributions: e.attributions,
					logo: e.logo,
					projection: void 0,
					state: E.a.READY,
					wrapX: void 0 === e.wrapX || e.wrapX
				}), this.loader_ = n.
			default.nullFunction, this.format_ = e.format, this.overlaps_ = null == e.overlaps || e.overlaps, this.url_ = e.url, void 0 !== e.loader ? this.loader_ = e.loader:
				void 0 !== this.url_ && (l.a.assert(this.format_, 7), this.loader_ = g.xhr(this.url_, this.format_)), this.strategy_ = void 0 !== e.strategy ? e.strategy : v.
			default.all;
				var i, o, s = void 0 === e.useSpatialIndex || e.useSpatialIndex;
				this.featuresRtree_ = s ? new C.a:
				null, this.loadedExtentsRtree_ = new C.a, this.nullGeometryFeatures_ = {}, this.idIndex_ = {}, this.undefIdIndex_ = {}, this.featureChangeKeys_ = {}, this.featuresCollection_ = null, e.features instanceof r.
			default ?o = (i = e.features).getArray():
				Array.isArray(e.features) && (o = e.features), s || void 0 !== i || (i = new r.
			default (o)), void 0 !== o && this.addFeaturesInternal(o), void 0 !== i && this.bindFeaturesCollection_(i)
			};
		n.
	default.inherits(I, _.a), I.prototype.addFeature = function(t) {
			this.addFeatureInternal(t), this.changed()
		}, I.prototype.addFeatureInternal = function(t) {
			var e = n.
		default.getUid(t).toString();
			if (this.addToIndex_(e, t)) {
				this.setupChangeEvents_(e, t);
				var i = t.getGeometry();
				if (i) {
					var r = i.getExtent();
					this.featuresRtree_ && this.featuresRtree_.insert(r, t)
				} else this.nullGeometryFeatures_[e] = t;
				this.dispatchEvent(new I.Event(x.a.ADDFEATURE, t))
			}
		}, I.prototype.setupChangeEvents_ = function(t, e) {
			this.featureChangeKeys_[t] = [u.a.listen(e, c.a.CHANGE, this.handleFeatureChange_, this), u.a.listen(e, s.a.PROPERTYCHANGE, this.handleFeatureChange_, this)]
		}, I.prototype.addToIndex_ = function(t, e) {
			var i = !0,
				n = e.getId();
			return void 0 !== n ? n.toString() in this.idIndex_ ? i = !1 : this.idIndex_[n.toString()] = e : (l.a.assert(!(t in this.undefIdIndex_), 30), this.undefIdIndex_[t] = e), i
		}, I.prototype.addFeatures = function(t) {
			this.addFeaturesInternal(t), this.changed()
		}, I.prototype.addFeaturesInternal = function(t) {
			var e, i, r, o, s = [],
				a = [],
				l = [];
			for (i = 0, r = t.length; i < r; i++) o = t[i], e = n.
		default.getUid(o).toString(), this.addToIndex_(e, o) && a.push(o);
			for (i = 0, r = a.length; i < r; i++) {
				o = a[i], e = n.
			default.getUid(o).toString(), this.setupChangeEvents_(e, o);
				var u = o.getGeometry();
				if (u) {
					var h = u.getExtent();
					s.push(h), l.push(o)
				} else this.nullGeometryFeatures_[e] = o
			}
			for (this.featuresRtree_ && this.featuresRtree_.load(s, l), i = 0, r = a.length; i < r; i++) this.dispatchEvent(new I.Event(x.a.ADDFEATURE, a[i]))
		}, I.prototype.bindFeaturesCollection_ = function(t) {
			var e = !1;
			u.a.listen(this, x.a.ADDFEATURE, (function(i) {
				e || (e = !0, t.push(i.feature), e = !1)
			})), u.a.listen(this, x.a.REMOVEFEATURE, (function(i) {
				e || (e = !0, t.remove(i.feature), e = !1)
			})), u.a.listen(t, o.a.ADD, (function(t) {
				e || (e = !0, this.addFeature(t.element), e = !1)
			}), this), u.a.listen(t, o.a.REMOVE, (function(t) {
				e || (e = !0, this.removeFeature(t.element), e = !1)
			}), this), this.featuresCollection_ = t
		}, I.prototype.clear = function(t) {
			if (t) {
				for (var e in this.featureChangeKeys_) {
					this.featureChangeKeys_[e].forEach(u.a.unlistenByKey)
				}
				this.featuresCollection_ || (this.featureChangeKeys_ = {}, this.idIndex_ = {}, this.undefIdIndex_ = {})
			} else if (this.featuresRtree_) for (var i in this.featuresRtree_.forEach(this.removeFeatureInternal, this), this.nullGeometryFeatures_) this.removeFeatureInternal(this.nullGeometryFeatures_[i]);
			this.featuresCollection_ && this.featuresCollection_.clear(), this.featuresRtree_ && this.featuresRtree_.clear(), this.loadedExtentsRtree_.clear(), this.nullGeometryFeatures_ = {};
			var n = new I.Event(x.a.CLEAR);
			this.dispatchEvent(n), this.changed()
		}, I.prototype.forEachFeature = function(t, e) {
			return this.featuresRtree_ ? this.featuresRtree_.forEach(t, e) : this.featuresCollection_ ? this.featuresCollection_.forEach(t, e) : void 0
		}, I.prototype.forEachFeatureAtCoordinateDirect = function(t, e, i) {
			var n = [t[0], t[1], t[0], t[1]];
			return this.forEachFeatureInExtent(n, (function(n) {
				return n.getGeometry().intersectsCoordinate(t) ? e.call(i, n) : void 0
			}))
		}, I.prototype.forEachFeatureInExtent = function(t, e, i) {
			return this.featuresRtree_ ? this.featuresRtree_.forEachInExtent(t, e, i) : this.featuresCollection_ ? this.featuresCollection_.forEach(e, i) : void 0
		}, I.prototype.forEachFeatureIntersectingExtent = function(t, e, i) {
			return this.forEachFeatureInExtent(t, (function(n) {
				if (n.getGeometry().intersectsExtent(t)) {
					var r = e.call(i, n);
					if (r) return r
				}
			}))
		}, I.prototype.getFeaturesCollection = function() {
			return this.featuresCollection_
		}, I.prototype.getFeatures = function() {
			var t;
			return this.featuresCollection_ ? t = this.featuresCollection_.getArray() : this.featuresRtree_ && (t = this.featuresRtree_.getAll(), y.a.isEmpty(this.nullGeometryFeatures_) || a.a.extend(t, y.a.getValues(this.nullGeometryFeatures_))), t
		}, I.prototype.getFeaturesAtCoordinate = function(t) {
			var e = [];
			return this.forEachFeatureAtCoordinateDirect(t, (function(t) {
				e.push(t)
			})), e
		}, I.prototype.getFeaturesInExtent = function(t) {
			return this.featuresRtree_.getInExtent(t)
		}, I.prototype.getClosestFeatureToCoordinate = function(t, e) {
			var i = t[0],
				n = t[1],
				r = null,
				o = [NaN, NaN],
				s = 1 / 0,
				a = [-1 / 0, -1 / 0, 1 / 0, 1 / 0],
				l = e || m.a.TRUE;
			return this.featuresRtree_.forEachInExtent(a, (function(t) {
				if (l(t)) {
					var e = t.getGeometry(),
						u = s;
					if ((s = e.closestPointXY(i, n, o, s)) < u) {
						r = t;
						var h = Math.sqrt(s);
						a[0] = i - h, a[1] = n - h, a[2] = i + h, a[3] = n + h
					}
				}
			})), r
		}, I.prototype.getExtent = function(t) {
			return this.featuresRtree_.getExtent(t)
		}, I.prototype.getFeatureById = function(t) {
			var e = this.idIndex_[t.toString()];
			return void 0 !== e ? e : null
		}, I.prototype.getFormat = function() {
			return this.format_
		}, I.prototype.getOverlaps = function() {
			return this.overlaps_
		}, I.prototype.getResolutions = function() {}, I.prototype.getUrl = function() {
			return this.url_
		}, I.prototype.handleFeatureChange_ = function(t) {
			var e = t.target,
				i = n.
			default.getUid(e).toString(),
				r = e.getGeometry();
			if (r) {
				var o = r.getExtent();
				i in this.nullGeometryFeatures_ ? (delete this.nullGeometryFeatures_[i], this.featuresRtree_ && this.featuresRtree_.insert(o, e)) : this.featuresRtree_ && this.featuresRtree_.update(o, e)
			} else i in this.nullGeometryFeatures_ || (this.featuresRtree_ && this.featuresRtree_.remove(e), this.nullGeometryFeatures_[i] = e);
			var s = e.getId();
			if (void 0 !== s) {
				var a = s.toString();
				i in this.undefIdIndex_ ? (delete this.undefIdIndex_[i], this.idIndex_[a] = e) : this.idIndex_[a] !== e && (this.removeFromIdIndex_(e), this.idIndex_[a] = e)
			} else i in this.undefIdIndex_ || (this.removeFromIdIndex_(e), this.undefIdIndex_[i] = e);
			this.changed(), this.dispatchEvent(new I.Event(x.a.CHANGEFEATURE, e))
		}, I.prototype.isEmpty = function() {
			return this.featuresRtree_.isEmpty() && y.a.isEmpty(this.nullGeometryFeatures_)
		}, I.prototype.loadFeatures = function(t, e, i) {
			var n, r, o = this.loadedExtentsRtree_,
				s = this.strategy_(t, e);
			for (n = 0, r = s.length; n < r; ++n) {
				var a = s[n];
				o.forEachInExtent(a, (function(t) {
					return d.
				default.containsExtent(t.extent, a)
				})) || (this.loader_.call(this, a, e, i), o.insert(a, {
					extent: a.slice()
				}))
			}
		}, I.prototype.removeLoadedExtent = function(t) {
			var e, i = this.loadedExtentsRtree_;
			i.forEachInExtent(t, (function(i) {
				if (d.
			default.equals(i.extent, t)) return e = i, !0
			})), e && i.remove(e)
		}, I.prototype.removeFeature = function(t) {
			var e = n.
		default.getUid(t).toString();
			e in this.nullGeometryFeatures_ ? delete this.nullGeometryFeatures_[e]:
			this.featuresRtree_ && this.featuresRtree_.remove(t), this.removeFeatureInternal(t), this.changed()
		}, I.prototype.removeFeatureInternal = function(t) {
			var e = n.
		default.getUid(t).toString();
			this.featureChangeKeys_[e].forEach(u.a.unlistenByKey), delete this.featureChangeKeys_[e];
			var i = t.getId();
			void 0 !== i ? delete this.idIndex_[i.toString()]:
			delete this.undefIdIndex_[e], this.dispatchEvent(new I.Event(x.a.REMOVEFEATURE, t))
		}, I.prototype.removeFromIdIndex_ = function(t) {
			var e = !1;
			for (var i in this.idIndex_) if (this.idIndex_[i] === t) {
				delete this.idIndex_[i], e = !0;
				break
			}
			return e
		}, I.prototype.setLoader = function(t) {
			this.loader_ = t
		}, I.Event = function(t, e) {
			h.a.call(this, t), this.feature = e
		}, n.
	default.inherits(I.Event, h.a);
		e.
	default = I
	}, function(t, e, i) {
		"use strict";
		i.r(e);
		var n = i(0),
			r = i(10),
			o = i(1),
			s = i(18),
			a = i(4),
			l = i(126),
			u = i(25),
			h = i(40),
			c = i(102),
			d = i(70),
			f = i(72),
			A = i(64),
			p = i(65),
			g = i(133),
			m = i(103),
			v = i(73),
			y = i(76),
			_ = i(11),
			E = function(t, e) {
				h.a.call(this), this.ends_ = [], this.flatInteriorPointRevision_ = -1, this.flatInteriorPoint_ = null, this.maxDelta_ = -1, this.maxDeltaRevision_ = -1, this.orientedRevision_ = -1, this.orientedFlatCoordinates_ = null, this.setCoordinates(t, e)
			};
		n.
	default.inherits(E, h.a), E.prototype.appendLinearRing = function(t) {
			this.flatCoordinates ? r.a.extend(this.flatCoordinates, t.getFlatCoordinates()) : this.flatCoordinates = t.getFlatCoordinates().slice(), this.ends_.push(this.flatCoordinates.length), this.changed()
		}, E.prototype.clone = function() {
			var t = new E(null);
			return t.setFlatCoordinates(this.layout, this.flatCoordinates.slice(), this.ends_.slice()), t
		}, E.prototype.closestPointXY = function(t, e, i, n) {
			return n < o.
		default.closestSquaredDistanceXY(this.getExtent(), t, e) ? n:
			(this.maxDeltaRevision_ != this.getRevision() && (this.maxDelta_ = Math.sqrt(d.a.getsMaxSquaredDelta(this.flatCoordinates, 0, this.ends_, this.stride, 0)), this.maxDeltaRevision_ = this.getRevision()), d.a.getsClosestPoint(this.flatCoordinates, 0, this.ends_, this.stride, this.maxDelta_, !0, t, e, i, n))
		}, E.prototype.containsXY = function(t, e) {
			return f.a.linearRingsContainsXY(this.getOrientedFlatCoordinates(), 0, this.ends_, this.stride, t, e)
		}, E.prototype.getArea = function() {
			return c.a.linearRings(this.getOrientedFlatCoordinates(), 0, this.ends_, this.stride)
		}, E.prototype.getCoordinates = function(t) {
			var e;
			return void 0 !== t ? (e = this.getOrientedFlatCoordinates().slice(), v.a.orientLinearRings(e, 0, this.ends_, this.stride, t)) : e = this.flatCoordinates, p.a.coordinatess(e, 0, this.ends_, this.stride)
		}, E.prototype.getEnds = function() {
			return this.ends_
		}, E.prototype.getFlatInteriorPoint = function() {
			if (this.flatInteriorPointRevision_ != this.getRevision()) {
				var t = o.
			default.getCenter(this.getExtent());
				this.flatInteriorPoint_ = g.a.linearRings(this.getOrientedFlatCoordinates(), 0, this.ends_, this.stride, t, 0), this.flatInteriorPointRevision_ = this.getRevision()
			}
			return this.flatInteriorPoint_
		}, E.prototype.getInteriorPoint = function() {
			return new u.
		default (this.getFlatInteriorPoint(), s.a.XYM)
		}, E.prototype.getLinearRingCount = function() {
			return this.ends_.length
		}, E.prototype.getLinearRing = function(t) {
			if (t < 0 || this.ends_.length <= t) return null;
			var e = new l.a(null);
			return e.setFlatCoordinates(this.layout, this.flatCoordinates.slice(0 === t ? 0 : this.ends_[t - 1], this.ends_[t])), e
		}, E.prototype.getLinearRings = function() {
			var t, e, i = this.layout,
				n = this.flatCoordinates,
				r = this.ends_,
				o = [],
				s = 0;
			for (t = 0, e = r.length; t < e; ++t) {
				var a = r[t],
					u = new l.a(null);
				u.setFlatCoordinates(i, n.slice(s, a)), o.push(u), s = a
			}
			return o
		}, E.prototype.getOrientedFlatCoordinates = function() {
			if (this.orientedRevision_ != this.getRevision()) {
				var t = this.flatCoordinates;
				v.a.linearRingsAreOriented(t, 0, this.ends_, this.stride) ? this.orientedFlatCoordinates_ = t : (this.orientedFlatCoordinates_ = t.slice(), this.orientedFlatCoordinates_.length = v.a.orientLinearRings(this.orientedFlatCoordinates_, 0, this.ends_, this.stride)), this.orientedRevision_ = this.getRevision()
			}
			return this.orientedFlatCoordinates_
		}, E.prototype.getSimplifiedGeometryInternal = function(t) {
			var e = [],
				i = [];
			e.length = y.a.quantizes(this.flatCoordinates, 0, this.ends_, this.stride, Math.sqrt(t), e, 0, i);
			var n = new E(null);
			return n.setFlatCoordinates(s.a.XY, e, i), n
		}, E.prototype.getType = function() {
			return a.a.POLYGON
		}, E.prototype.intersectsExtent = function(t) {
			return m.a.linearRings(this.getOrientedFlatCoordinates(), 0, this.ends_, this.stride, t)
		}, E.prototype.setCoordinates = function(t, e) {
			if (t) {
				this.setLayout(e, t, 2), this.flatCoordinates || (this.flatCoordinates = []);
				var i = A.a.coordinatess(this.flatCoordinates, 0, t, this.stride, this.ends_);
				this.flatCoordinates.length = 0 === i.length ? 0 : i[i.length - 1], this.changed()
			} else this.setFlatCoordinates(s.a.XY, null, this.ends_)
		}, E.prototype.setFlatCoordinates = function(t, e, i) {
			this.setFlatCoordinatesInternal(t, e), this.ends_ = i, this.changed()
		}, E.circular = function(t, e, i, n) {
			var o, a = n || 32,
				l = [];
			for (o = 0; o < a; ++o) r.a.extend(l, t.offset(e, i, 2 * Math.PI * o / a));
			l.push(l[0], l[1]);
			var u = new E(null);
			return u.setFlatCoordinates(s.a.XY, l, [l.length]), u
		}, E.fromExtent = function(t) {
			var e = t[0],
				i = t[1],
				n = t[2],
				r = t[3],
				o = [e, i, e, r, n, r, n, i, e, i],
				a = new E(null);
			return a.setFlatCoordinates(s.a.XY, o, [o.length]), a
		}, E.fromCircle = function(t, e, i) {
			for (var n = e || 32, r = t.getStride(), o = t.getLayout(), s = new E(null, o), a = r * (n + 1), l = new Array(a), u = 0; u < a; u++) l[u] = 0;
			var h = [l.length];
			return s.setFlatCoordinates(o, l, h), E.makeRegular(s, t.getCenter(), t.getRadius(), i), s
		}, E.makeRegular = function(t, e, i, n) {
			for (var r, o, s = t.getFlatCoordinates(), a = t.getLayout(), l = t.getStride(), u = t.getEnds(), h = s.length / l - 1, c = n || 0, d = 0; d <= h; ++d) o = d * l, r = c + 2 * _.a.modulo(d, h) * Math.PI / h, s[o] = e[0] + i * Math.cos(r), s[o + 1] = e[1] + i * Math.sin(r);
			t.setFlatCoordinates(a, s, u)
		}, e.
	default = E
	}, function(t, e, i) {
		"use strict";
		var n = i(0),
			r = i(10),
			o = i(26),
			s = i(69),
			a = i(123),
			l = i(18),
			u = i(58),
			h = i(126),
			c = i(94),
			d = i(104),
			f = i(106),
			A = i(25),
			p = i(31),
			g = i(8),
			m = i(9),
			v = i(2),
			y = function(t) {
				var e = t || {};
				this.featureType = e.featureType, this.featureNS = e.featureNS, this.srsName = e.srsName, this.schemaLocation = "", this.FEATURE_COLLECTION_PARSERS = {}, this.FEATURE_COLLECTION_PARSERS[y.GMLNS] = {
					featureMember: v.a.makeReplacer(y.prototype.readFeaturesInternal),
					featureMembers: v.a.makeReplacer(y.prototype.readFeaturesInternal)
				}, a.a.call(this)
			};
		n.
	default.inherits(y, a.a), y.GMLNS = "http://www.opengis.net/gml", y.ONLY_WHITESPACE_RE_ = /^[\s\xa0]*$/, y.prototype.readFeaturesInternal = function(t, e) {
			var i = t.localName,
				n = null;
			if ("FeatureCollection" == i) n = "http://www.opengis.net/wfs" === t.namespaceURI ? v.a.pushParseAndPop([], this.FEATURE_COLLECTION_PARSERS, t, e, this) : v.a.pushParseAndPop(null, this.FEATURE_COLLECTION_PARSERS, t, e, this);
			else if ("featureMembers" == i || "featureMember" == i) {
				var r, o, s = e[0],
					a = s.featureType,
					l = s.featureNS;
				if (!a && t.childNodes) {
					for (a = [], l = {}, r = 0, o = t.childNodes.length; r < o; ++r) {
						var u = t.childNodes[r];
						if (1 === u.nodeType) {
							var h = u.nodeName.split(":").pop();
							if (-1 === a.indexOf(h)) {
								var c = "",
									d = 0,
									f = u.namespaceURI;
								for (var A in l) {
									if (l[A] === f) {
										c = A;
										break
									}++d
								}
								c || (l[c = "p" + d] = f), a.push(c + ":" + h)
							}
						}
					}
					"featureMember" != i && (s.featureType = a, s.featureNS = l)
				}
				if ("string" == typeof l) {
					var p = l;
					(l = {}).p0 = p
				}
				var g = {},
					m = Array.isArray(a) ? a : [a];
				for (var y in l) {
					var _ = {};
					for (r = 0, o = m.length; r < o; ++r) {
						(-1 === m[r].indexOf(":") ? "p0" : m[r].split(":")[0]) === y && (_[m[r].split(":").pop()] = "featureMembers" == i ? v.a.makeArrayPusher(this.readFeatureElement, this) : v.a.makeReplacer(this.readFeatureElement, this))
					}
					g[l[y]] = _
				}
				n = "featureMember" == i ? v.a.pushParseAndPop(void 0, g, t, e) : v.a.pushParseAndPop([], g, t, e)
			}
			return null === n && (n = []), n
		}, y.prototype.readGeometryElement = function(t, e) {
			var i = e[0];
			i.srsName = t.firstElementChild.getAttribute("srsName"), i.srsDimension = t.firstElementChild.getAttribute("srsDimension");
			var n = v.a.pushParseAndPop(null, this.GEOMETRY_PARSERS_, t, e, this);
			return n ? s.a.transformWithOptions(n, !1, i) : void 0
		}, y.prototype.readFeatureElement = function(t, e) {
			var i, n, r = t.getAttribute("fid") || v.a.getAttributeNS(t, y.GMLNS, "id"),
				s = {};
			for (i = t.firstElementChild; i; i = i.nextElementSibling) {
				var a = i.localName;
				if (0 === i.childNodes.length || 1 === i.childNodes.length && (3 === i.firstChild.nodeType || 4 === i.firstChild.nodeType)) {
					var l = v.a.getAllTextContent(i, !1);
					y.ONLY_WHITESPACE_RE_.test(l) && (l = void 0), s[a] = l
				} else "boundedBy" !== a && (n = a), s[a] = this.readGeometryElement(i, e)
			}
			var u = new o.
		default (s);
			return n && u.setGeometryName(n), r && u.setId(r), u
		}, y.prototype.readPoint = function(t, e) {
			var i = this.readFlatCoordinatesFromNode_(t, e);
			if (i) {
				var n = new A.
			default (null);
				return n.setFlatCoordinates(l.a.XYZ, i), n
			}
		}, y.prototype.readMultiPoint = function(t, e) {
			var i = v.a.pushParseAndPop([], this.MULTIPOINT_PARSERS_, t, e, this);
			return i ? new d.a(i) : void 0
		}, y.prototype.readMultiLineString = function(t, e) {
			var i = v.a.pushParseAndPop([], this.MULTILINESTRING_PARSERS_, t, e, this);
			if (i) {
				var n = new c.
			default (null);
				return n.setLineStrings(i), n
			}
		}, y.prototype.readMultiPolygon = function(t, e) {
			var i = v.a.pushParseAndPop([], this.MULTIPOLYGON_PARSERS_, t, e, this);
			if (i) {
				var n = new f.a(null);
				return n.setPolygons(i), n
			}
		}, y.prototype.pointMemberParser_ = function(t, e) {
			v.a.parseNode(this.POINTMEMBER_PARSERS_, t, e, this)
		}, y.prototype.lineStringMemberParser_ = function(t, e) {
			v.a.parseNode(this.LINESTRINGMEMBER_PARSERS_, t, e, this)
		}, y.prototype.polygonMemberParser_ = function(t, e) {
			v.a.parseNode(this.POLYGONMEMBER_PARSERS_, t, e, this)
		}, y.prototype.readLineString = function(t, e) {
			var i = this.readFlatCoordinatesFromNode_(t, e);
			if (i) {
				var n = new u.
			default (null);
				return n.setFlatCoordinates(l.a.XYZ, i), n
			}
		}, y.prototype.readFlatLinearRing_ = function(t, e) {
			var i = v.a.pushParseAndPop(null, this.GEOMETRY_FLAT_COORDINATES_PARSERS_, t, e, this);
			return i || void 0
		}, y.prototype.readLinearRing = function(t, e) {
			var i = this.readFlatCoordinatesFromNode_(t, e);
			if (i) {
				var n = new h.a(null);
				return n.setFlatCoordinates(l.a.XYZ, i), n
			}
		}, y.prototype.readPolygon = function(t, e) {
			var i = v.a.pushParseAndPop([null], this.FLAT_LINEAR_RINGS_PARSERS_, t, e, this);
			if (i && i[0]) {
				var n, o, s = new p.
			default (null),
					a = i[0],
					u = [a.length];
				for (n = 1, o = i.length; n < o; ++n) r.a.extend(a, i[n]), u.push(a.length);
				return s.setFlatCoordinates(l.a.XYZ, a, u), s
			}
		}, y.prototype.readFlatCoordinatesFromNode_ = function(t, e) {
			return v.a.pushParseAndPop(null, this.GEOMETRY_FLAT_COORDINATES_PARSERS_, t, e, this)
		}, y.prototype.MULTIPOINT_PARSERS_ = {
			"http://www.opengis.net/gml": {
				pointMember: v.a.makeArrayPusher(y.prototype.pointMemberParser_),
				pointMembers: v.a.makeArrayPusher(y.prototype.pointMemberParser_)
			}
		}, y.prototype.MULTILINESTRING_PARSERS_ = {
			"http://www.opengis.net/gml": {
				lineStringMember: v.a.makeArrayPusher(y.prototype.lineStringMemberParser_),
				lineStringMembers: v.a.makeArrayPusher(y.prototype.lineStringMemberParser_)
			}
		}, y.prototype.MULTIPOLYGON_PARSERS_ = {
			"http://www.opengis.net/gml": {
				polygonMember: v.a.makeArrayPusher(y.prototype.polygonMemberParser_),
				polygonMembers: v.a.makeArrayPusher(y.prototype.polygonMemberParser_)
			}
		}, y.prototype.POINTMEMBER_PARSERS_ = {
			"http://www.opengis.net/gml": {
				Point: v.a.makeArrayPusher(y.prototype.readFlatCoordinatesFromNode_)
			}
		}, y.prototype.LINESTRINGMEMBER_PARSERS_ = {
			"http://www.opengis.net/gml": {
				LineString: v.a.makeArrayPusher(y.prototype.readLineString)
			}
		}, y.prototype.POLYGONMEMBER_PARSERS_ = {
			"http://www.opengis.net/gml": {
				Polygon: v.a.makeArrayPusher(y.prototype.readPolygon)
			}
		}, y.prototype.RING_PARSERS = {
			"http://www.opengis.net/gml": {
				LinearRing: v.a.makeReplacer(y.prototype.readFlatLinearRing_)
			}
		}, y.prototype.readGeometryFromNode = function(t, e) {
			var i = this.readGeometryElement(t, [this.getReadOptions(t, e || {})]);
			return i || null
		}, y.prototype.readFeatures, y.prototype.readFeaturesFromNode = function(t, e) {
			var i = {
				featureType: this.featureType,
				featureNS: this.featureNS
			};
			return e && g.a.assign(i, this.getReadOptions(t, e)), this.readFeaturesInternal(t, [i]) || []
		}, y.prototype.readProjectionFromNode = function(t) {
			return m.
		default.get(this.srsName ? this.srsName : t.firstElementChild.getAttribute("srsName"))
		}, e.a = y
	}, function(t, e, i) {
		"use strict";
		i.r(e);
		var n = i(0),
			r = i(51),
			o = i(53),
			s = i(135),
			a = i(8),
			l = i(34),
			u = function(t) {
				var e = t || {},
					i = a.a.assign({}, e);
				delete i.style, delete i.renderBuffer, delete i.updateWhileAnimating, delete i.updateWhileInteracting, o.a.call(this, i), this.declutter_ = void 0 !== e.declutter && e.declutter, this.renderBuffer_ = void 0 !== e.renderBuffer ? e.renderBuffer : 100, this.style_ = null, this.styleFunction_ = void 0, this.setStyle(e.style), this.updateWhileAnimating_ = void 0 !== e.updateWhileAnimating && e.updateWhileAnimating, this.updateWhileInteracting_ = void 0 !== e.updateWhileInteracting && e.updateWhileInteracting, this.renderMode_ = e.renderMode || s.a.VECTOR, this.type = r.a.VECTOR
			};
		n.
	default.inherits(u, o.a), u.prototype.getDeclutter = function() {
			return this.declutter_
		}, u.prototype.setDeclutter = function(t) {
			this.declutter_ = t
		}, u.prototype.getRenderBuffer = function() {
			return this.renderBuffer_
		}, u.prototype.getRenderOrder = function() {
			return this.get(u.Property_.RENDER_ORDER)
		}, u.prototype.getSource, u.prototype.getStyle = function() {
			return this.style_
		}, u.prototype.getStyleFunction = function() {
			return this.styleFunction_
		}, u.prototype.getUpdateWhileAnimating = function() {
			return this.updateWhileAnimating_
		}, u.prototype.getUpdateWhileInteracting = function() {
			return this.updateWhileInteracting_
		}, u.prototype.setRenderOrder = function(t) {
			this.set(u.Property_.RENDER_ORDER, t)
		}, u.prototype.setStyle = function(t) {
			this.style_ = void 0 !== t ? t : l.
		default.defaultFunction, this.styleFunction_ = null === t ? void 0:
			l.
		default.createFunction(this.style_), this.changed()
		}, u.prototype.getRenderMode = function() {
			return this.renderMode_
		}, u.Property_ = {
			RENDER_ORDER: "renderOrder"
		}, e.
	default = u
	}, function(t, e, i) {
		"use strict";
		i.r(e);
		var n = i(15),
			r = i(4),
			o = i(68),
			s = i(38),
			a = i(36),
			l = function(t) {
				var e = t || {};
				this.geometry_ = null, this.geometryFunction_ = l.defaultGeometryFunction, void 0 !== e.geometry && this.setGeometry(e.geometry), this.fill_ = void 0 !== e.fill ? e.fill : null, this.image_ = void 0 !== e.image ? e.image : null, this.renderer_ = void 0 !== e.renderer ? e.renderer : null, this.stroke_ = void 0 !== e.stroke ? e.stroke : null, this.text_ = void 0 !== e.text ? e.text : null, this.zIndex_ = e.zIndex
			};
		l.prototype.clone = function() {
			var t = this.getGeometry();
			return t && t.clone && (t = t.clone()), new l({
				geometry: t,
				fill: this.getFill() ? this.getFill().clone() : void 0,
				image: this.getImage() ? this.getImage().clone() : void 0,
				stroke: this.getStroke() ? this.getStroke().clone() : void 0,
				text: this.getText() ? this.getText().clone() : void 0,
				zIndex: this.getZIndex()
			})
		}, l.prototype.getRenderer = function() {
			return this.renderer_
		}, l.prototype.setRenderer = function(t) {
			this.renderer_ = t
		}, l.prototype.getGeometry = function() {
			return this.geometry_
		}, l.prototype.getGeometryFunction = function() {
			return this.geometryFunction_
		}, l.prototype.getFill = function() {
			return this.fill_
		}, l.prototype.setFill = function(t) {
			this.fill_ = t
		}, l.prototype.getImage = function() {
			return this.image_
		}, l.prototype.setImage = function(t) {
			this.image_ = t
		}, l.prototype.getStroke = function() {
			return this.stroke_
		}, l.prototype.setStroke = function(t) {
			this.stroke_ = t
		}, l.prototype.getText = function() {
			return this.text_
		}, l.prototype.setText = function(t) {
			this.text_ = t
		}, l.prototype.getZIndex = function() {
			return this.zIndex_
		}, l.prototype.setGeometry = function(t) {
			"function" == typeof t ? this.geometryFunction_ = t : "string" == typeof t ? this.geometryFunction_ = function(e) {
				return e.get(t)
			} : t ? void 0 !== t && (this.geometryFunction_ = function() {
				return t
			}) : this.geometryFunction_ = l.defaultGeometryFunction, this.geometry_ = t
		}, l.prototype.setZIndex = function(t) {
			this.zIndex_ = t
		}, l.createFunction = function(t) {
			var e, i;
			"function" == typeof t ? e = t : (Array.isArray(t) ? i = t : (n.a.assert(t instanceof l, 41), i = [t]), e = function() {
				return i
			});
			return e
		}, l.default_ = null, l.defaultFunction = function(t, e) {
			if (!l.default_) {
				var i = new s.
			default ({
					color: "rgba(255,255,255,0.4)"
				}),
					n = new a.
				default ({
						color: "#3399CC",
						width: 1.25
					});
				l.default_ = [new l({
					image: new o.
				default ({
						fill: i,
						stroke: n,
						radius: 5
					}),
					fill:
					i,
					stroke: n
				})]
			}
			return l.default_
		}, l.createDefaultEditing = function() {
			var t = {},
				e = [255, 255, 255, 1],
				i = [0, 153, 255, 1];
			return t[r.a.POLYGON] = [new l({
				fill: new s.
			default ({
					color: [255, 255, 255, .5]
				})
			})], t[r.a.MULTI_POLYGON] = t[r.a.POLYGON], t[r.a.LINE_STRING] = [new l({
				stroke: new a.
			default ({
					color: e,
					width: 5
				})
			}), new l({
				stroke: new a.
			default ({
					color: i,
					width: 3
				})
			})], t[r.a.MULTI_LINE_STRING] = t[r.a.LINE_STRING], t[r.a.CIRCLE] = t[r.a.POLYGON].concat(t[r.a.LINE_STRING]), t[r.a.POINT] = [new l({
				image: new o.
			default ({
					radius: 6,
					fill: new s.
				default ({
						color: i
					}),
					stroke:
					new a.
				default ({
						color: e,
						width: 1.5
					})
				}),
				zIndex:
				1 / 0
			})], t[r.a.MULTI_POINT] = t[r.a.POINT], t[r.a.GEOMETRY_COLLECTION] = t[r.a.POLYGON].concat(t[r.a.LINE_STRING], t[r.a.POINT]), t
		}, l.defaultGeometryFunction = function(t) {
			return t.getGeometry()
		}, e.
	default = l
	}, function(t, e, i) {
		"use strict";
		var n = i(0),
			r = i(7),
			o = {},
			s = "undefined" != typeof navigator ? navigator.userAgent.toLowerCase() : "";
		o.FIREFOX = -1 !== s.indexOf("firefox"), o.SAFARI = -1 !== s.indexOf("safari") && -1 == s.indexOf("chrom"), o.WEBKIT = -1 !== s.indexOf("webkit") && -1 == s.indexOf("edge"), o.MAC = -1 !== s.indexOf("macintosh"), o.DEVICE_PIXEL_RATIO = window.devicePixelRatio || 1, o.CANVAS_LINE_DASH = !1, o.CANVAS = n.
	default.ENABLE_CANVAS &&
		function() {
			if (!("HTMLCanvasElement" in window)) return !1;
			try {
				var t = document.createElement("CANVAS").getContext("2d");
				return !!t && (void 0 !== t.setLineDash && (o.CANVAS_LINE_DASH = !0), !0)
			} catch (t) {
				return !1
			}
		}(), o.DEVICE_ORIENTATION = "DeviceOrientationEvent" in window, o.GEOLOCATION = "geolocation" in navigator, o.TOUCH = n.
	default.ASSUME_TOUCH || "ontouchstart" in window, o.POINTER = "PointerEvent" in window, o.MSPOINTER = !! navigator.msPointerEnabled, o.WEBGL, function() {
			if (n.
		default.ENABLE_WEBGL) {
				var t, e = !1,
					i = [];
				if ("WebGLRenderingContext" in window) try {
					var s = document.createElement("CANVAS"),
						a = r.a.getContext(s, {
							failIfMajorPerformanceCaveat: !0
						});
					a && (e = !0, t = a.getParameter(a.MAX_TEXTURE_SIZE), i = a.getSupportedExtensions())
				} catch (t) {}
				o.WEBGL = e, n.
			default.WEBGL_EXTENSIONS = i, n.
			default.WEBGL_MAX_TEXTURE_SIZE = t
			}
		}(), e.a = o
	}, function(t, e, i) {
		"use strict";
		i.r(e);
		var n = i(0),
			r = function(t) {
				var e = t || {};
				this.color_ = void 0 !== e.color ? e.color : null, this.lineCap_ = e.lineCap, this.lineDash_ = void 0 !== e.lineDash ? e.lineDash : null, this.lineDashOffset_ = e.lineDashOffset, this.lineJoin_ = e.lineJoin, this.miterLimit_ = e.miterLimit, this.width_ = e.width, this.checksum_ = void 0
			};
		r.prototype.clone = function() {
			var t = this.getColor();
			return new r({
				color: t && t.slice ? t.slice() : t || void 0,
				lineCap: this.getLineCap(),
				lineDash: this.getLineDash() ? this.getLineDash().slice() : void 0,
				lineDashOffset: this.getLineDashOffset(),
				lineJoin: this.getLineJoin(),
				miterLimit: this.getMiterLimit(),
				width: this.getWidth()
			})
		}, r.prototype.getColor = function() {
			return this.color_
		}, r.prototype.getLineCap = function() {
			return this.lineCap_
		}, r.prototype.getLineDash = function() {
			return this.lineDash_
		}, r.prototype.getLineDashOffset = function() {
			return this.lineDashOffset_
		}, r.prototype.getLineJoin = function() {
			return this.lineJoin_
		}, r.prototype.getMiterLimit = function() {
			return this.miterLimit_
		}, r.prototype.getWidth = function() {
			return this.width_
		}, r.prototype.setColor = function(t) {
			this.color_ = t, this.checksum_ = void 0
		}, r.prototype.setLineCap = function(t) {
			this.lineCap_ = t, this.checksum_ = void 0
		}, r.prototype.setLineDash = function(t) {
			this.lineDash_ = t, this.checksum_ = void 0
		}, r.prototype.setLineDashOffset = function(t) {
			this.lineDashOffset_ = t, this.checksum_ = void 0
		}, r.prototype.setLineJoin = function(t) {
			this.lineJoin_ = t, this.checksum_ = void 0
		}, r.prototype.setMiterLimit = function(t) {
			this.miterLimit_ = t, this.checksum_ = void 0
		}, r.prototype.setWidth = function(t) {
			this.width_ = t, this.checksum_ = void 0
		}, r.prototype.getChecksum = function() {
			return void 0 === this.checksum_ && (this.checksum_ = "s", this.color_ ? "string" == typeof this.color_ ? this.checksum_ += this.color_ : this.checksum_ += n.
		default.getUid(this.color_).toString():
			this.checksum_ += "-", this.checksum_ += "," + (void 0 !== this.lineCap_ ? this.lineCap_.toString() : "-") + "," + (this.lineDash_ ? this.lineDash_.toString() : "-") + "," + (void 0 !== this.lineDashOffset_ ? this.lineDashOffset_ : "-") + "," + (void 0 !== this.lineJoin_ ? this.lineJoin_ : "-") + "," + (void 0 !== this.miterLimit_ ? this.miterLimit_.toString() : "-") + "," + (void 0 !== this.width_ ? this.width_.toString() : "-")), this.checksum_
		}, e.
	default = r
	}, function(t, e, i) {
		"use strict";
		var n, r, o = {};
		o.CLASS_HIDDEN = "ol-hidden", o.CLASS_SELECTABLE = "ol-selectable", o.CLASS_UNSELECTABLE = "ol-unselectable", o.CLASS_UNSUPPORTED = "ol-unsupported", o.CLASS_CONTROL = "ol-control", o.getFontFamilies = (r = {}, function(t) {
			if (n || (n = document.createElement("div").style), !(t in r)) {
				n.font = t;
				var e = n.fontFamily;
				if (n.font = "", !e) return null;
				r[t] = e.split(/,\s?/)
			}
			return r[t]
		}), e.a = o
	}, function(t, e, i) {
		"use strict";
		i.r(e);
		var n = i(0),
			r = i(44),
			o = function(t) {
				var e = t || {};
				this.color_ = void 0 !== e.color ? e.color : null, this.checksum_ = void 0
			};
		o.prototype.clone = function() {
			var t = this.getColor();
			return new o({
				color: t && t.slice ? t.slice() : t || void 0
			})
		}, o.prototype.getColor = function() {
			return this.color_
		}, o.prototype.setColor = function(t) {
			this.color_ = t, this.checksum_ = void 0
		}, o.prototype.getChecksum = function() {
			return void 0 === this.checksum_ && (this.color_ instanceof CanvasPattern || this.color_ instanceof CanvasGradient ? this.checksum_ = n.
		default.getUid(this.color_).toString():
			this.checksum_ = "f" + (this.color_ ? r.a.asString(this.color_) : "-")), this.checksum_
		}, e.
	default = o
	}, function(t, e, i) {
		"use strict";
		i.r(e);
		var n = {
			easeIn: function(t) {
				return Math.pow(t, 3)
			},
			easeOut: function(t) {
				return 1 - n.easeIn(1 - t)
			},
			inAndOut: function(t) {
				return 3 * t * t - 2 * t * t * t
			},
			linear: function(t) {
				return t
			},
			upAndDown: function(t) {
				return t < .5 ? n.inAndOut(2 * t) : 1 - n.inAndOut(2 * (t - .5))
			}
		};
		e.
	default = n
	}, function(t, e, i) {
		"use strict";
		var n = i(0),
			r = i(20),
			o = i(1),
			s = i(60),
			a = i(18),
			l = i(45),
			u = i(8),
			h = function() {
				s.a.call(this), this.layout = a.a.XY, this.stride = 2, this.flatCoordinates = null
			};
		n.
	default.inherits(h, s.a), h.getLayoutForStride_ = function(t) {
			var e;
			return 2 == t ? e = a.a.XY : 3 == t ? e = a.a.XYZ : 4 == t && (e = a.a.XYZM), e
		}, h.getStrideForLayout = function(t) {
			var e;
			return t == a.a.XY ? e = 2 : t == a.a.XYZ || t == a.a.XYM ? e = 3 : t == a.a.XYZM && (e = 4), e
		}, h.prototype.containsXY = r.a.FALSE, h.prototype.computeExtent = function(t) {
			return o.
		default.createOrUpdateFromFlatCoordinates(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, t)
		}, h.prototype.getCoordinates = function() {}, h.prototype.getFirstCoordinate = function() {
			return this.flatCoordinates.slice(0, this.stride)
		}, h.prototype.getFlatCoordinates = function() {
			return this.flatCoordinates
		}, h.prototype.getLastCoordinate = function() {
			return this.flatCoordinates.slice(this.flatCoordinates.length - this.stride)
		}, h.prototype.getLayout = function() {
			return this.layout
		}, h.prototype.getSimplifiedGeometry = function(t) {
			if (this.simplifiedGeometryRevision != this.getRevision() && (u.a.clear(this.simplifiedGeometryCache), this.simplifiedGeometryMaxMinSquaredTolerance = 0, this.simplifiedGeometryRevision = this.getRevision()), t < 0 || 0 !== this.simplifiedGeometryMaxMinSquaredTolerance && t <= this.simplifiedGeometryMaxMinSquaredTolerance) return this;
			var e = t.toString();
			if (this.simplifiedGeometryCache.hasOwnProperty(e)) return this.simplifiedGeometryCache[e];
			var i = this.getSimplifiedGeometryInternal(t);
			return i.getFlatCoordinates().length < this.flatCoordinates.length ? (this.simplifiedGeometryCache[e] = i, i) : (this.simplifiedGeometryMaxMinSquaredTolerance = t, this)
		}, h.prototype.getSimplifiedGeometryInternal = function(t) {
			return this
		}, h.prototype.getStride = function() {
			return this.stride
		}, h.prototype.setFlatCoordinatesInternal = function(t, e) {
			this.stride = h.getStrideForLayout(t), this.layout = t, this.flatCoordinates = e
		}, h.prototype.setCoordinates = function(t, e) {}, h.prototype.setLayout = function(t, e, i) {
			var n;
			if (t) n = h.getStrideForLayout(t);
			else {
				var r;
				for (r = 0; r < i; ++r) {
					if (0 === e.length) return this.layout = a.a.XY, void(this.stride = 2);
					e = e[0]
				}
				n = e.length, t = h.getLayoutForStride_(n)
			}
			this.layout = t, this.stride = n
		}, h.prototype.applyTransform = function(t) {
			this.flatCoordinates && (t(this.flatCoordinates, this.flatCoordinates, this.stride), this.changed())
		}, h.prototype.rotate = function(t, e) {
			var i = this.getFlatCoordinates();
			if (i) {
				var n = this.getStride();
				l.a.rotate(i, 0, i.length, n, t, e, i), this.changed()
			}
		}, h.prototype.scale = function(t, e, i) {
			var n = e;
			void 0 === n && (n = t);
			var r = i;
			r || (r = o.
		default.getCenter(this.getExtent()));
			var s = this.getFlatCoordinates();
			if (s) {
				var a = this.getStride();
				l.a.scale(s, 0, s.length, a, t, n, r, s), this.changed()
			}
		}, h.prototype.translate = function(t, e) {
			var i = this.getFlatCoordinates();
			if (i) {
				var n = this.getStride();
				l.a.translate(i, 0, i.length, n, t, e, i), this.changed()
			}
		}, h.transform2D = function(t, e, i) {
			var n = t.getFlatCoordinates();
			if (n) {
				var r = t.getStride();
				return l.a.transform2D(n, 0, n.length, r, e, i)
			}
			return null
		}, e.a = h
	}, function(t, e, i) {
		"use strict";
		var n = i(2),
			r = i(85),
			o = {
				NAMESPACE_URI: "http://www.w3.org/2001/XMLSchema",
				readBoolean: function(t) {
					var e = n.a.getAllTextContent(t, !1);
					return o.readBooleanString(e)
				},
				readBooleanString: function(t) {
					var e = /^\s*(true|1)|(false|0)\s*$/.exec(t);
					return e ? void 0 !== e[1] || !1 : void 0
				},
				readDateTime: function(t) {
					var e = n.a.getAllTextContent(t, !1),
						i = Date.parse(e);
					return isNaN(i) ? void 0 : i / 1e3
				},
				readDecimal: function(t) {
					var e = n.a.getAllTextContent(t, !1);
					return o.readDecimalString(e)
				},
				readDecimalString: function(t) {
					var e = /^\s*([+\-]?\d*\.?\d+(?:e[+\-]?\d+)?)\s*$/i.exec(t);
					return e ? parseFloat(e[1]) : void 0
				},
				readNonNegativeInteger: function(t) {
					var e = n.a.getAllTextContent(t, !1);
					return o.readNonNegativeIntegerString(e)
				},
				readNonNegativeIntegerString: function(t) {
					var e = /^\s*(\d+)\s*$/.exec(t);
					return e ? parseInt(e[1], 10) : void 0
				},
				readString: function(t) {
					return n.a.getAllTextContent(t, !1).trim()
				},
				writeBooleanTextNode: function(t, e) {
					o.writeStringTextNode(t, e ? "1" : "0")
				},
				writeCDATASection: function(t, e) {
					t.appendChild(n.a.DOCUMENT.createCDATASection(e))
				},
				writeDateTimeTextNode: function(t, e) {
					var i = new Date(1e3 * e),
						o = i.getUTCFullYear() + "-" + r.a.padNumber(i.getUTCMonth() + 1, 2) + "-" + r.a.padNumber(i.getUTCDate(), 2) + "T" + r.a.padNumber(i.getUTCHours(), 2) + ":" + r.a.padNumber(i.getUTCMinutes(), 2) + ":" + r.a.padNumber(i.getUTCSeconds(), 2) + "Z";
					t.appendChild(n.a.DOCUMENT.createTextNode(o))
				},
				writeDecimalTextNode: function(t, e) {
					var i = e.toPrecision();
					t.appendChild(n.a.DOCUMENT.createTextNode(i))
				},
				writeNonNegativeIntegerTextNode: function(t, e) {
					var i = e.toString();
					t.appendChild(n.a.DOCUMENT.createTextNode(i))
				},
				writeStringTextNode: function(t, e) {
					t.appendChild(n.a.DOCUMENT.createTextNode(e))
				}
			};
		e.a = o
	}, function(t, e, i) {
		"use strict";
		e.a = {
			ADD: "add",
			REMOVE: "remove"
		}
	}, function(t, e, i) {
		"use strict";
		i.r(e);
		var n = i(0),
			r = i(89),
			o = i(14),
			s = i(16),
			a = i(3),
			l = function(t) {
				o.a.call(this), this.element = t.element ? t.element : null, this.target_ = null, this.map_ = null, this.listenerKeys = [], this.render = t.render ? t.render : n.
			default.nullFunction, t.target && this.setTarget(t.target)
			};
		n.
	default.inherits(l, o.a), l.prototype.disposeInternal = function() {
			s.a.removeNode(this.element), o.a.prototype.disposeInternal.call(this)
		}, l.prototype.getMap = function() {
			return this.map_
		}, l.prototype.setMap = function(t) {
			this.map_ && s.a.removeNode(this.element);
			for (var e = 0, i = this.listenerKeys.length; e < i; ++e) a.a.unlistenByKey(this.listenerKeys[e]);
			(this.listenerKeys.length = 0, this.map_ = t, this.map_) && ((this.target_ ? this.target_ : t.getOverlayContainerStopEvent()).appendChild(this.element), this.render !== n.
		default.nullFunction && this.listenerKeys.push(a.a.listen(t, r.a.POSTRENDER, this.render, this)), t.render())
		}, l.prototype.setTarget = function(t) {
			this.target_ = "string" == typeof t ? document.getElementById(t) : t
		}, e.
	default = l
	}, function(t, e, i) {
		"use strict";
		var n, r, o = i(15),
			s = i(11),
			a = {};
		a.HEX_COLOR_RE_ = /^#(?:[0-9a-f]{3,4}){1,2}$/i, a.NAMED_COLOR_RE_ = /^([a-z]*)$/i, a.asArray = function(t) {
			return Array.isArray(t) ? t : a.fromString(t)
		}, a.asString = function(t) {
			return "string" == typeof t ? t : a.toString(t)
		}, a.fromNamed = function(t) {
			var e = document.createElement("div");
			e.style.color = t, document.body.appendChild(e);
			var i = getComputedStyle(e).color;
			return document.body.removeChild(e), i
		}, a.fromString = (n = {}, r = 0, function(t) {
			var e;
			if (n.hasOwnProperty(t)) e = n[t];
			else {
				if (r >= 1024) {
					var i, o = 0;
					for (i in n) 0 == (3 & o++) && (delete n[i], --r)
				}
				e = a.fromStringInternal_(t), n[t] = e, ++r
			}
			return e
		}), a.fromStringInternal_ = function(t) {
			var e, i, n, r, s, l;
			if (a.NAMED_COLOR_RE_.exec(t) && (t = a.fromNamed(t)), a.HEX_COLOR_RE_.exec(t)) {
				var u, h = t.length - 1;
				u = h <= 4 ? 1 : 2;
				var c = 4 === h || 8 === h;
				e = parseInt(t.substr(1 + 0 * u, u), 16), i = parseInt(t.substr(1 + 1 * u, u), 16), n = parseInt(t.substr(1 + 2 * u, u), 16), r = c ? parseInt(t.substr(1 + 3 * u, u), 16) : 255, 1 == u && (e = (e << 4) + e, i = (i << 4) + i, n = (n << 4) + n, c && (r = (r << 4) + r)), s = [e, i, n, r / 255]
			} else 0 == t.indexOf("rgba(") ? (l = t.slice(5, -1).split(",").map(Number), s = a.normalize(l)) : 0 == t.indexOf("rgb(") ? ((l = t.slice(4, -1).split(",").map(Number)).push(1), s = a.normalize(l)) : o.a.assert(!1, 14);
			return (s)
		}, a.normalize = function(t, e) {
			var i = e || [];
			return i[0] = s.a.clamp(t[0] + .5 | 0, 0, 255), i[1] = s.a.clamp(t[1] + .5 | 0, 0, 255), i[2] = s.a.clamp(t[2] + .5 | 0, 0, 255), i[3] = s.a.clamp(t[3], 0, 1), i
		}, a.toString = function(t) {
			var e = t[0];
			e != (0 | e) && (e = e + .5 | 0);
			var i = t[1];
			i != (0 | i) && (i = i + .5 | 0);
			var n = t[2];
			return n != (0 | n) && (n = n + .5 | 0), "rgba(" + e + "," + i + "," + n + "," + (void 0 === t[3] ? 1 : t[3]) + ")"
		}, e.a = a
	}, function(t, e, i) {
		"use strict";
		var n = {
			transform2D: function(t, e, i, n, r, o) {
				var s, a = o || [],
					l = 0;
				for (s = e; s < i; s += n) {
					var u = t[s],
						h = t[s + 1];
					a[l++] = r[0] * u + r[2] * h + r[4], a[l++] = r[1] * u + r[3] * h + r[5]
				}
				return o && a.length != l && (a.length = l), a
			},
			rotate: function(t, e, i, n, r, o, s) {
				for (var a = s || [], l = Math.cos(r), u = Math.sin(r), h = o[0], c = o[1], d = 0, f = e; f < i; f += n) {
					var A = t[f] - h,
						p = t[f + 1] - c;
					a[d++] = h + A * l - p * u, a[d++] = c + A * u + p * l;
					for (var g = f + 2; g < f + n; ++g) a[d++] = t[g]
				}
				return s && a.length != d && (a.length = d), a
			},
			scale: function(t, e, i, n, r, o, s, a) {
				for (var l = a || [], u = s[0], h = s[1], c = 0, d = e; d < i; d += n) {
					var f = t[d] - u,
						A = t[d + 1] - h;
					l[c++] = u + r * f, l[c++] = h + o * A;
					for (var p = d + 2; p < d + n; ++p) l[c++] = t[p]
				}
				return a && l.length != c && (l.length = c), l
			},
			translate: function(t, e, i, n, r, o, s) {
				var a, l, u = s || [],
					h = 0;
				for (a = e; a < i; a += n) for (u[h++] = t[a] + r, u[h++] = t[a + 1] + o, l = a + 2; l < a + n; ++l) u[h++] = t[l];
				return s && u.length != h && (u.length = h), u
			}
		};
		e.a = n
	}, function(t, e, i) {
		"use strict";
		e.a = {
			CANVAS: "canvas",
			WEBGL: "webgl"
		}
	}, function(t, e, i) {
		"use strict";
		var n = {
			DEGREES: "degrees",
			FEET: "ft",
			METERS: "m",
			PIXELS: "pixels",
			TILE_PIXELS: "tile-pixels",
			USFEET: "us-ft",
			METERS_PER_UNIT: {}
		};
		n.METERS_PER_UNIT[n.DEGREES] = 2 * Math.PI * 6370997 / 360, n.METERS_PER_UNIT[n.FEET] = .3048, n.METERS_PER_UNIT[n.METERS] = 1, n.METERS_PER_UNIT[n.USFEET] = 1200 / 3937, e.a = n
	}, function(t, e, i) {
		"use strict";
		var n = {
			buffer: function(t, e, i) {
				return void 0 === i && (i = [0, 0]), i[0] = t[0] + 2 * e, i[1] = t[1] + 2 * e, i
			},
			hasArea: function(t) {
				return t[0] > 0 && t[1] > 0
			},
			scale: function(t, e, i) {
				return void 0 === i && (i = [0, 0]), i[0] = t[0] * e + .5 | 0, i[1] = t[1] * e + .5 | 0, i
			},
			toSize: function(t, e) {
				return Array.isArray(t) ? t : (void 0 === e ? e = [t, t] : e[0] = e[1] = t, e)
			}
		};
		e.a = n
	}, function(t, e, i) {
		"use strict";
		var n = {
			createOrUpdate: function(t, e, i, n) {
				return void 0 !== n ? (n[0] = t, n[1] = e, n[2] = i, n) : [t, e, i]
			},
			getKeyZXY: function(t, e, i) {
				return t + "/" + e + "/" + i
			},
			getKey: function(t) {
				return n.getKeyZXY(t[0], t[1], t[2])
			},
			fromKey: function(t) {
				return t.split("/").map(Number)
			},
			hash: function(t) {
				return (t[1] << t[0]) + t[2]
			},
			quadKey: function(t) {
				var e, i, n = t[0],
					r = new Array(n),
					o = 1 << n - 1;
				for (e = 0; e < n; ++e) i = 48, t[1] & o && (i += 1), t[2] & o && (i += 2), r[e] = String.fromCharCode(i), o >>= 1;
				return r.join("")
			},
			withinExtentAndZ: function(t, e) {
				var i = t[0],
					n = t[1],
					r = t[2];
				if (e.getMinZoom() > i || i > e.getMaxZoom()) return !1;
				var o, s = e.getExtent();
				return !(o = s ? e.getTileRangeForExtentAndZ(s, i) : e.getFullTileRange(i)) || o.containsXY(n, r)
			}
		};
		e.a = n
	}, function(t, e, i) {
		"use strict";
		var n = i(0),
			r = i(88),
			o = i(3),
			s = i(21),
			a = function() {
				r.a.call(this), this.pendingRemovals_ = {}, this.dispatching_ = {}, this.listeners_ = {}
			};
		n.
	default.inherits(a, r.a), a.prototype.addEventListener = function(t, e) {
			var i = this.listeners_[t];
			i || (i = this.listeners_[t] = []), -1 === i.indexOf(e) && i.push(e)
		}, a.prototype.dispatchEvent = function(t) {
			var e = "string" == typeof t ? new s.a(t) : t,
				i = e.type;
			e.target = this;
			var r, o = this.listeners_[i];
			if (o) {
				i in this.dispatching_ || (this.dispatching_[i] = 0, this.pendingRemovals_[i] = 0), ++this.dispatching_[i];
				for (var a = 0, l = o.length; a < l; ++a) if (!1 === o[a].call(this, e) || e.propagationStopped) {
					r = !1;
					break
				}
				if (--this.dispatching_[i], 0 === this.dispatching_[i]) {
					var u = this.pendingRemovals_[i];
					for (delete this.pendingRemovals_[i]; u--;) this.removeEventListener(i, n.
				default.nullFunction);
					delete this.dispatching_[i]
				}
				return r
			}
		}, a.prototype.disposeInternal = function() {
			o.a.unlistenAll(this)
		}, a.prototype.getListeners = function(t) {
			return this.listeners_[t]
		}, a.prototype.hasListener = function(t) {
			return t ? t in this.listeners_ : Object.keys(this.listeners_).length > 0
		}, a.prototype.removeEventListener = function(t, e) {
			var i = this.listeners_[t];
			if (i) {
				var r = i.indexOf(e);
				t in this.pendingRemovals_ ? (i[r] = n.
			default.nullFunction, ++this.pendingRemovals_[t]) : (i.splice(r, 1), 0 === i.length && delete this.listeners_[t])
			}
		}, e.a = a
	}, function(t, e, i) {
		"use strict";
		e.a = {
			IMAGE: "IMAGE",
			TILE: "TILE",
			VECTOR_TILE: "VECTOR_TILE",
			VECTOR: "VECTOR"
		}
	}, function(t, e, i) {
		"use strict";
		e.a = {
			OPACITY: "opacity",
			VISIBLE: "visible",
			EXTENT: "extent",
			Z_INDEX: "zIndex",
			MAX_RESOLUTION: "maxResolution",
			MIN_RESOLUTION: "minResolution",
			SOURCE: "source"
		}
	}, function(t, e, i) {
		"use strict";
		var n = i(3),
			r = i(5),
			o = i(0),
			s = i(14),
			a = i(121),
			l = i(52),
			u = i(8),
			h = i(57),
			c = i(59),
			d = function(t) {
				var e = u.a.assign({}, t);
				delete e.source, a.a.call(this, e), this.mapPrecomposeKey_ = null, this.mapRenderKey_ = null, this.sourceChangeKey_ = null, t.map && this.setMap(t.map), n.a.listen(this, s.a.getChangeEventType(l.a.SOURCE), this.handleSourcePropertyChange_, this);
				var i = t.source ? t.source : null;
				this.setSource(i)
			};
		o.
	default.inherits(d, a.a), d.visibleAtResolution = function(t, e) {
			return t.visible && e >= t.minResolution && e <= t.maxResolution
		}, d.prototype.getLayersArray = function(t) {
			var e = t || [];
			return e.push(this), e
		}, d.prototype.getLayerStatesArray = function(t) {
			var e = t || [];
			return e.push(this.getLayerState()), e
		}, d.prototype.getSource = function() {
			return this.get(l.a.SOURCE) || null
		}, d.prototype.getSourceState = function() {
			var t = this.getSource();
			return t ? t.getState() : c.a.UNDEFINED
		}, d.prototype.handleSourceChange_ = function() {
			this.changed()
		}, d.prototype.handleSourcePropertyChange_ = function() {
			this.sourceChangeKey_ && (n.a.unlistenByKey(this.sourceChangeKey_), this.sourceChangeKey_ = null);
			var t = this.getSource();
			t && (this.sourceChangeKey_ = n.a.listen(t, r.a.CHANGE, this.handleSourceChange_, this)), this.changed()
		}, d.prototype.setMap = function(t) {
			this.mapPrecomposeKey_ && (n.a.unlistenByKey(this.mapPrecomposeKey_), this.mapPrecomposeKey_ = null), t || this.changed(), this.mapRenderKey_ && (n.a.unlistenByKey(this.mapRenderKey_), this.mapRenderKey_ = null), t && (this.mapPrecomposeKey_ = n.a.listen(t, h.a.PRECOMPOSE, (function(t) {
				var e = this.getLayerState();
				e.managed = !1, e.zIndex = 1 / 0, t.frameState.layerStatesArray.push(e), t.frameState.layerStates[o.
			default.getUid(this)] = e
			}), this), this.mapRenderKey_ = n.a.listen(this, r.a.CHANGE, t.render, t), this.changed())
		}, d.prototype.setSource = function(t) {
			this.set(l.a.SOURCE, t)
		}, e.a = d
	}, function(t, e, i) {
		"use strict";
		e.a = {
			CENTER: "center",
			RESOLUTION: "resolution",
			ROTATION: "rotation"
		}
	}, function(t, e, i) {
		"use strict";
		Object.defineProperty(e, "__esModule", {
			value: !0
		});
		var n = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ?
		function(t) {
			return typeof t
		} : function(t) {
			return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t
		};
		e.mixin = function(t, e) {
			for (var i in e) t[i] = e[i]
		}, e.mixinByCondition = function(t, e, i) {
			for (var n in e) i.indexOf(n) >= 0 && (t[n] = e[n])
		}, e.isFunction = function(t) {
			return "function" == typeof t
		}, e.isObject = function(t) {
			var e = void 0 === t ? "undefined" : n(t);
			return "object" == e && null != t || "function" == e
		}, e.isNull = function(t) {
			return null === t
		}, e.isDef = function(t) {
			return void 0 !== t
		}, e.isDefAndNotNull = function(t) {
			return null != t
		}, e.isArray = function(t) {
			return "[object Array]" === Object.prototype.toString.call(t)
		}, e.domAppendChild = function(t, e) {
			t.appendChild(e)
		}
	}, function(t, e, i) {
		"use strict";
		e.a = {
			UNKNOWN: 0,
			INTERSECTING: 1,
			ABOVE: 2,
			RIGHT: 4,
			BELOW: 8,
			LEFT: 16
		}
	}, function(t, e, i) {
		"use strict";
		e.a = {
			POSTCOMPOSE: "postcompose",
			PRECOMPOSE: "precompose",
			RENDER: "render"
		}
	}, function(t, e, i) {
		"use strict";
		i.r(e);
		var n = i(0),
			r = i(10),
			o = i(1),
			s = i(18),
			a = i(4),
			l = i(40),
			u = i(70),
			h = i(64),
			c = i(65),
			d = i(122),
			f = i(103),
			A = i(136),
			p = i(134),
			g = i(76),
			m = function(t, e) {
				l.a.call(this), this.flatMidpoint_ = null, this.flatMidpointRevision_ = -1, this.maxDelta_ = -1, this.maxDeltaRevision_ = -1, this.setCoordinates(t, e)
			};
		n.
	default.inherits(m, l.a), m.prototype.appendCoordinate = function(t) {
			this.flatCoordinates ? r.a.extend(this.flatCoordinates, t) : this.flatCoordinates = t.slice(), this.changed()
		}, m.prototype.clone = function() {
			var t = new m(null);
			return t.setFlatCoordinates(this.layout, this.flatCoordinates.slice()), t
		}, m.prototype.closestPointXY = function(t, e, i, n) {
			return n < o.
		default.closestSquaredDistanceXY(this.getExtent(), t, e) ? n:
			(this.maxDeltaRevision_ != this.getRevision() && (this.maxDelta_ = Math.sqrt(u.a.getMaxSquaredDelta(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, 0)), this.maxDeltaRevision_ = this.getRevision()), u.a.getClosestPoint(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, this.maxDelta_, !1, t, e, i, n))
		}, m.prototype.forEachSegment = function(t, e) {
			return p.a.forEach(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, t, e)
		}, m.prototype.getCoordinateAtM = function(t, e) {
			if (this.layout != s.a.XYM && this.layout != s.a.XYZM) return null;
			var i = void 0 !== e && e;
			return d.a.lineStringCoordinateAtM(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, t, i)
		}, m.prototype.getCoordinates = function() {
			return c.a.coordinates(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride)
		}, m.prototype.getCoordinateAt = function(t, e) {
			return d.a.lineString(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, t, e)
		}, m.prototype.getLength = function() {
			return A.a.lineString(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride)
		}, m.prototype.getFlatMidpoint = function() {
			return this.flatMidpointRevision_ != this.getRevision() && (this.flatMidpoint_ = this.getCoordinateAt(.5, this.flatMidpoint_), this.flatMidpointRevision_ = this.getRevision()), this.flatMidpoint_
		}, m.prototype.getSimplifiedGeometryInternal = function(t) {
			var e = [];
			e.length = g.a.douglasPeucker(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, t, e, 0);
			var i = new m(null);
			return i.setFlatCoordinates(s.a.XY, e), i
		}, m.prototype.getType = function() {
			return a.a.LINE_STRING
		}, m.prototype.intersectsExtent = function(t) {
			return f.a.lineString(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, t)
		}, m.prototype.setCoordinates = function(t, e) {
			t ? (this.setLayout(e, t, 1), this.flatCoordinates || (this.flatCoordinates = []), this.flatCoordinates.length = h.a.coordinates(this.flatCoordinates, 0, t, this.stride), this.changed()) : this.setFlatCoordinates(s.a.XY, null)
		}, m.prototype.setFlatCoordinates = function(t, e) {
			this.setFlatCoordinatesInternal(t, e), this.changed()
		}, e.
	default = m
	}, function(t, e, i) {
		"use strict";
		e.a = {
			UNDEFINED: "undefined",
			LOADING: "loading",
			READY: "ready",
			ERROR: "error"
		}
	}, function(t, e, i) {
		"use strict";
		var n = i(0),
			r = i(14),
			o = i(1),
			s = i(20),
			a = i(45),
			l = i(9),
			u = i(47),
			h = i(6),
			c = function() {
				r.a.call(this), this.extent_ = o.
			default.createEmpty(), this.extentRevision_ = -1, this.simplifiedGeometryCache = {}, this.simplifiedGeometryMaxMinSquaredTolerance = 0, this.simplifiedGeometryRevision = 0, this.tmpTransform_ = h.a.create()
			};
		n.
	default.inherits(c, r.a), c.prototype.clone = function() {}, c.prototype.closestPointXY = function(t, e, i, n) {}, c.prototype.getClosestPoint = function(t, e) {
			var i = e || [NaN, NaN];
			return this.closestPointXY(t[0], t[1], i, 1 / 0), i
		}, c.prototype.intersectsCoordinate = function(t) {
			return this.containsXY(t[0], t[1])
		}, c.prototype.computeExtent = function(t) {}, c.prototype.containsXY = s.a.FALSE, c.prototype.getExtent = function(t) {
			return this.extentRevision_ != this.getRevision() && (this.extent_ = this.computeExtent(this.extent_), this.extentRevision_ = this.getRevision()), o.
		default.returnOrUpdate(this.extent_, t)
		}, c.prototype.rotate = function(t, e) {}, c.prototype.scale = function(t, e, i) {}, c.prototype.simplify = function(t) {
			return this.getSimplifiedGeometry(t * t)
		}, c.prototype.getSimplifiedGeometry = function(t) {}, c.prototype.getType = function() {}, c.prototype.applyTransform = function(t) {}, c.prototype.intersectsExtent = function(t) {}, c.prototype.translate = function(t, e) {}, c.prototype.transform = function(t, e) {
			var i = this.tmpTransform_,
				n = (t = l.
			default.get(t)).getUnits() == u.a.TILE_PIXELS ?
			function(n, r, s) {
				var u = t.getExtent(),
					c = t.getWorldExtent(),
					d = o.
				default.getHeight(c) / o.
				default.getHeight(u);
				return h.a.compose(i, c[0], c[3], d, -d, 0, 0, 0), a.a.transform2D(n, 0, n.length, s, i, r), l.
			default.getTransform(t, e)(n, r, s)
			} : l.
		default.getTransform(t, e);
			return this.applyTransform(n), this
		}, e.a = c
	}, function(t, e, i) {
		"use strict";
		e.a = {
			LAYERGROUP: "layergroup",
			SIZE: "size",
			TARGET: "target",
			VIEW: "view"
		}
	}, function(t, e, i) {
		"use strict";
		var n = i(44),
			r = {
				asColorLike: function(t) {
					return r.isColorLike(t) ? t : n.a.asString(t)
				},
				isColorLike: function(t) {
					return "string" == typeof t || t instanceof CanvasPattern || t instanceof CanvasGradient
				}
			};
		e.a = r
	}, function(t, e, i) {
		"use strict";
		Object.defineProperty(e, "__esModule", {
			value: !0
		});
		e.MapConstant = {
			mapRadius: 6378137,
			defaultProjection: "EPSG:4326",
			defaultUnits: "metric",
			defaultMinZoom: 1,
			defaultMaxZoom: 18
		}, e.MapType = {
			BLANK_MAP: "BLANK_MAP",
			OPENSTREET_MAP: "OPENSTREET_MAP",
			XYZ_MAP: "XYZ_MAP",
			WMS_MAP: "WMS_MAP",
			WMTS_MAP: "WMTS_MAP",
			ARCGIS_MAP: "ARCGIS_MAP",
			BING_MAP: "BING_MAP"
		}, e.OutMapType = {
			GAODE_ROADNET_MAP: "GAODE_ROADNET_MAP",
			GAODE_SATELLITE_MAP: "GAODE_SATELLITE_MAP"
		}
	}, function(t, e, i) {
		"use strict";
		var n = {
			coordinate: function(t, e, i, n) {
				var r, o;
				for (r = 0, o = i.length; r < o; ++r) t[e++] = i[r];
				return e
			},
			coordinates: function(t, e, i, n) {
				var r, o;
				for (r = 0, o = i.length; r < o; ++r) {
					var s, a = i[r];
					for (s = 0; s < n; ++s) t[e++] = a[s]
				}
				return e
			},
			coordinatess: function(t, e, i, r, o) {
				var s, a, l = o || [],
					u = 0;
				for (s = 0, a = i.length; s < a; ++s) {
					var h = n.coordinates(t, e, i[s], r);
					l[u++] = h, e = h
				}
				return l.length = u, l
			},
			coordinatesss: function(t, e, i, r, o) {
				var s, a, l = o || [],
					u = 0;
				for (s = 0, a = i.length; s < a; ++s) {
					var h = n.coordinatess(t, e, i[s], r, l[u]);
					l[u++] = h, e = h[h.length - 1]
				}
				return l.length = u, l
			}
		};
		e.a = n
	}, function(t, e, i) {
		"use strict";
		var n = {
			coordinates: function(t, e, i, n, r) {
				var o, s = void 0 !== r ? r : [],
					a = 0;
				for (o = e; o < i; o += n) s[a++] = t.slice(o, o + n);
				return s.length = a, s
			},
			coordinatess: function(t, e, i, r, o) {
				var s, a, l = void 0 !== o ? o : [],
					u = 0;
				for (s = 0, a = i.length; s < a; ++s) {
					var h = i[s];
					l[u++] = n.coordinates(t, e, h, r, l[u]), e = h
				}
				return l.length = u, l
			},
			coordinatesss: function(t, e, i, r, o) {
				var s, a, l = void 0 !== o ? o : [],
					u = 0;
				for (s = 0, a = i.length; s < a; ++s) {
					var h = i[s];
					l[u++] = n.coordinatess(t, e, h, r, l[u]), e = h[h.length - 1]
				}
				return l.length = u, l
			}
		};
		e.a = n
	}, function(t, e, i) {
		"use strict";
		e.a = {
			POINTERMOVE: "pointermove",
			POINTERDOWN: "pointerdown",
			POINTERUP: "pointerup",
			POINTEROVER: "pointerover",
			POINTEROUT: "pointerout",
			POINTERENTER: "pointerenter",
			POINTERLEAVE: "pointerleave",
			POINTERCANCEL: "pointercancel"
		}
	}, function(t, e, i) {
		"use strict";
		e.a = {
			BOTTOM_LEFT: "bottom-left",
			BOTTOM_CENTER: "bottom-center",
			BOTTOM_RIGHT: "bottom-right",
			CENTER_LEFT: "center-left",
			CENTER_CENTER: "center-center",
			CENTER_RIGHT: "center-right",
			TOP_LEFT: "top-left",
			TOP_CENTER: "top-center",
			TOP_RIGHT: "top-right"
		}
	}, function(t, e, i) {
		"use strict";
		i.r(e);
		var n = i(0),
			r = i(92),
			o = function(t) {
				var e = t || {};
				r.a.call(this, {
					points: 1 / 0,
					fill: e.fill,
					radius: e.radius,
					snapToPixel: e.snapToPixel,
					stroke: e.stroke,
					atlasManager: e.atlasManager
				})
			};
		n.
	default.inherits(o, r.a), o.prototype.clone = function() {
			var t = new o({
				fill: this.getFill() ? this.getFill().clone() : void 0,
				stroke: this.getStroke() ? this.getStroke().clone() : void 0,
				radius: this.getRadius(),
				snapToPixel: this.getSnapToPixel(),
				atlasManager: this.atlasManager_
			});
			return t.setOpacity(this.getOpacity()), t.setScale(this.getScale()), t
		}, o.prototype.setRadius = function(t) {
			this.radius_ = t, this.render_(this.atlasManager_)
		}, e.
	default = o
	}, function(t, e, i) {
		"use strict";
		var n = i(60),
			r = i(8),
			o = i(9),
			s = function() {
				this.defaultDataProjection = null, this.defaultFeatureProjection = null
			};
		s.prototype.getReadOptions = function(t, e) {
			var i;
			return e && (i = {
				dataProjection: e.dataProjection ? e.dataProjection : this.readProjection(t),
				featureProjection: e.featureProjection
			}), this.adaptOptions(i)
		}, s.prototype.adaptOptions = function(t) {
			return r.a.assign({
				dataProjection: this.defaultDataProjection,
				featureProjection: this.defaultFeatureProjection
			}, t)
		}, s.prototype.getLastExtent = function() {
			return null
		}, s.prototype.getType = function() {}, s.prototype.readFeature = function(t, e) {}, s.prototype.readFeatures = function(t, e) {}, s.prototype.readGeometry = function(t, e) {}, s.prototype.readProjection = function(t) {}, s.prototype.writeFeature = function(t, e) {}, s.prototype.writeFeatures = function(t, e) {}, s.prototype.writeGeometry = function(t, e) {}, s.transformWithOptions = function(t, e, i) {
			var r, s = i ? o.
		default.get(i.featureProjection):
			null,
				a = i ? o.
			default.get(i.dataProjection):
				null;
			if (r = s && a && !o.
		default.equivalent(s, a) ? t instanceof n.a ? (e ? t.clone() : t).transform(e ? s : a, e ? a : s):
			o.
		default.transformExtent(t, a, s):
			t, e && i && void 0 !== i.decimals) {
				var l = Math.pow(10, i.decimals);
				r === t && (r = r.clone()), r.applyTransform((function(t) {
					for (var e = 0, i = t.length; e < i; ++e) t[e] = Math.round(t[e] * l) / l;
					return t
				}))
			}
			return r
		}, e.a = s
	}, function(t, e, i) {
		"use strict";
		var n = i(11),
			r = {
				point: function(t, e, i, r, o, s, a) {
					var l, u, h = t[e],
						c = t[e + 1],
						d = t[i] - h,
						f = t[i + 1] - c;
					if (0 === d && 0 === f) u = e;
					else {
						var A = ((o - h) * d + (s - c) * f) / (d * d + f * f);
						if (A > 1) u = i;
						else {
							if (A > 0) {
								for (l = 0; l < r; ++l) a[l] = n.a.lerp(t[e + l], t[i + l], A);
								return void(a.length = r)
							}
							u = e
						}
					}
					for (l = 0; l < r; ++l) a[l] = t[u + l];
					a.length = r
				},
				getMaxSquaredDelta: function(t, e, i, r, o) {
					var s = t[e],
						a = t[e + 1];
					for (e += r; e < i; e += r) {
						var l = t[e],
							u = t[e + 1],
							h = n.a.squaredDistance(s, a, l, u);
						h > o && (o = h), s = l, a = u
					}
					return o
				},
				getsMaxSquaredDelta: function(t, e, i, n, o) {
					var s, a;
					for (s = 0, a = i.length; s < a; ++s) {
						var l = i[s];
						o = r.getMaxSquaredDelta(t, e, l, n, o), e = l
					}
					return o
				},
				getssMaxSquaredDelta: function(t, e, i, n, o) {
					var s, a;
					for (s = 0, a = i.length; s < a; ++s) {
						var l = i[s];
						o = r.getsMaxSquaredDelta(t, e, l, n, o), e = l[l.length - 1]
					}
					return o
				},
				getClosestPoint: function(t, e, i, o, s, a, l, u, h, c, d) {
					if (e == i) return c;
					var f, A;
					if (0 === s) {
						if ((A = n.a.squaredDistance(l, u, t[e], t[e + 1])) < c) {
							for (f = 0; f < o; ++f) h[f] = t[e + f];
							return h.length = o, A
						}
						return c
					}
					for (var p = d || [NaN, NaN], g = e + o; g < i;) if (r.point(t, g - o, g, o, l, u, p), (A = n.a.squaredDistance(l, u, p[0], p[1])) < c) {
						for (c = A, f = 0; f < o; ++f) h[f] = p[f];
						h.length = o, g += o
					} else g += o * Math.max((Math.sqrt(A) - Math.sqrt(c)) / s | 0, 1);
					if (a && (r.point(t, i - o, e, o, l, u, p), (A = n.a.squaredDistance(l, u, p[0], p[1])) < c)) {
						for (c = A, f = 0; f < o; ++f) h[f] = p[f];
						h.length = o
					}
					return c
				},
				getsClosestPoint: function(t, e, i, n, o, s, a, l, u, h, c) {
					var d, f, A = c || [NaN, NaN];
					for (d = 0, f = i.length; d < f; ++d) {
						var p = i[d];
						h = r.getClosestPoint(t, e, p, n, o, s, a, l, u, h, A), e = p
					}
					return h
				},
				getssClosestPoint: function(t, e, i, n, o, s, a, l, u, h, c) {
					var d, f, A = c || [NaN, NaN];
					for (d = 0, f = i.length; d < f; ++d) {
						var p = i[d];
						h = r.getsClosestPoint(t, e, p, n, o, s, a, l, u, h, A), e = p[p.length - 1]
					}
					return h
				}
			};
		e.a = r
	}, function(t, e, i) {
		"use strict";
		var n = i(0),
			r = i(13),
			o = i(39),
			s = i(50),
			a = i(5),
			l = function(t, e, i) {
				s.a.call(this);
				var n = i || {};
				this.tileCoord = t, this.state = e, this.interimTile = null, this.key = "", this.transition_ = void 0 === n.transition ? 250 : n.transition, this.transitionStarts_ = {}
			};
		n.
	default.inherits(l, s.a), l.prototype.changed = function() {
			this.dispatchEvent(a.a.CHANGE)
		}, l.prototype.getKey = function() {
			return this.key + "/" + this.tileCoord
		}, l.prototype.getInterimTile = function() {
			if (!this.interimTile) return this;
			var t = this.interimTile;
			do {
				if (t.getState() == r.a.LOADED) return t;
				t = t.interimTile
			} while (t);
			return this
		}, l.prototype.refreshInterimChain = function() {
			if (this.interimTile) {
				var t = this.interimTile,
					e = this;
				do {
					if (t.getState() == r.a.LOADED) {
						t.interimTile = null;
						break
					}
					t.getState() == r.a.LOADING ? e = t : t.getState() == r.a.IDLE ? e.interimTile = t.interimTile : e = t, t = e.interimTile
				} while (t)
			}
		}, l.prototype.getTileCoord = function() {
			return this.tileCoord
		}, l.prototype.getState = function() {
			return this.state
		}, l.prototype.setState = function(t) {
			this.state = t, this.changed()
		}, l.prototype.load = function() {}, l.prototype.getAlpha = function(t, e) {
			if (!this.transition_) return 1;
			var i = this.transitionStarts_[t];
			if (i) {
				if (-1 === i) return 1
			} else i = e, this.transitionStarts_[t] = i;
			var n = e - i + 1e3 / 60;
			return n >= this.transition_ ? 1 : o.
		default.easeIn(n / this.transition_)
		}, l.prototype.inTransition = function(t) {
			return !!this.transition_ && -1 !== this.transitionStarts_[t]
		}, l.prototype.endTransition = function(t) {
			this.transition_ && (this.transitionStarts_[t] = -1)
		};
		var u = l,
			h = i(16),
			c = i(3),
			d = function(t, e, i, n, r, o) {
				u.call(this, t, e, o), this.crossOrigin_ = n, this.src_ = i, this.image_ = new Image, null !== n && (this.image_.crossOrigin = n), this.imageListenerKeys_ = null, this.tileLoadFunction_ = r
			};
		n.
	default.inherits(d, u), d.prototype.disposeInternal = function() {
			this.state == r.a.LOADING && (this.unlistenImage_(), this.image_ = d.getBlankImage()), this.interimTile && this.interimTile.dispose(), this.state = r.a.ABORT, this.changed(), u.prototype.disposeInternal.call(this)
		}, d.prototype.getImage = function() {
			return this.image_
		}, d.prototype.getKey = function() {
			return this.src_
		}, d.prototype.handleImageError_ = function() {
			this.state = r.a.ERROR, this.unlistenImage_(), this.image_ = d.getBlankImage(), this.changed()
		}, d.prototype.handleImageLoad_ = function() {
			this.image_.naturalWidth && this.image_.naturalHeight ? this.state = r.a.LOADED : this.state = r.a.EMPTY, this.unlistenImage_(), this.changed()
		}, d.prototype.load = function() {
			this.state == r.a.ERROR && (this.state = r.a.IDLE, this.image_ = new Image, null !== this.crossOrigin_ && (this.image_.crossOrigin = this.crossOrigin_)), this.state == r.a.IDLE && (this.state = r.a.LOADING, this.changed(), this.imageListenerKeys_ = [c.a.listenOnce(this.image_, a.a.ERROR, this.handleImageError_, this), c.a.listenOnce(this.image_, a.a.LOAD, this.handleImageLoad_, this)], this.tileLoadFunction_(this, this.src_))
		}, d.prototype.unlistenImage_ = function() {
			this.imageListenerKeys_.forEach(c.a.unlistenByKey), this.imageListenerKeys_ = null
		}, d.getBlankImage = function() {
			var t = h.a.createCanvasContext2D(1, 1);
			return t.fillStyle = "rgba(0,0,0,0)", t.fillRect(0, 0, 1, 1), t.canvas
		};
		var f = d,
			A = i(112),
			p = i(49),
			g = function(t) {
				A.a.call(this, t)
			};
		n.
	default.inherits(g, A.a), g.prototype.expireCache = function(t) {
			for (var e, i; this.canExpireCache() && !((i = (e = this.peekLast()).tileCoord[0].toString()) in t && t[i].contains(e.tileCoord));) this.pop().dispose()
		}, g.prototype.pruneExceptNewestZ = function() {
			if (0 !== this.getCount()) {
				var t = this.peekFirstKey(),
					e = p.a.fromKey(t)[0];
				this.forEach((function(t) {
					t.tileCoord[0] !== e && (this.remove(p.a.getKey(t.tileCoord)), t.dispose())
				}), this)
			}
		};
		var m = g,
			v = i(9),
			y = i(1),
			_ = i(11),
			E = i(107),
			x = i(139),
			C = function(t, e, i, o, s, a, l, h, c, d, f) {
				u.call(this, s, r.a.IDLE), this.renderEdges_ = void 0 !== f && f, this.pixelRatio_ = l, this.gutter_ = h, this.canvas_ = null, this.sourceTileGrid_ = e, this.targetTileGrid_ = o, this.wrappedTileCoord_ = a || s, this.sourceTiles_ = [], this.sourcesListenerKeys_ = null, this.sourceZ_ = 0;
				var A = o.getTileCoordExtent(this.wrappedTileCoord_),
					p = this.targetTileGrid_.getExtent(),
					g = this.sourceTileGrid_.getExtent(),
					m = p ? y.
				default.getIntersection(A, p):
					A;
				if (0 !== y.
			default.getArea(m)) {
					var v = t.getExtent();
					v && (g = g ? y.
				default.getIntersection(g, v):
					v);
					var C = o.getResolution(this.wrappedTileCoord_[0]),
						I = y.
					default.getCenter(m),
						S = E.a.calculateSourceResolution(t, i, I, C);
					if (!isFinite(S) || S <= 0) this.state = r.a.EMPTY;
					else {
						var T = void 0 !== d ? d : n.
					default.DEFAULT_RASTER_REPROJECTION_ERROR_THRESHOLD;
						if (this.triangulation_ = new x.a(t, i, m, g, S * T), 0 !== this.triangulation_.getTriangles().length) {
							this.sourceZ_ = e.getZForResolution(S);
							var R = this.triangulation_.calculateSourceExtent();
							if (g && (t.canWrapX() ? (R[1] = _.a.clamp(R[1], g[1], g[3]), R[3] = _.a.clamp(R[3], g[1], g[3])) : R = y.
						default.getIntersection(R, g)), y.
						default.getArea(R)) {
								for (var w = e.getTileRangeForExtentAndZ(R, this.sourceZ_), L = w.minX; L <= w.maxX; L++) for (var N = w.minY; N <= w.maxY; N++) {
									var P = c(this.sourceZ_, L, N, l);
									P && this.sourceTiles_.push(P)
								}
								0 === this.sourceTiles_.length && (this.state = r.a.EMPTY)
							} else this.state = r.a.EMPTY
						} else this.state = r.a.EMPTY
					}
				} else this.state = r.a.EMPTY
			};
		n.
	default.inherits(C, u), C.prototype.disposeInternal = function() {
			this.state == r.a.LOADING && this.unlistenSources_(), u.prototype.disposeInternal.call(this)
		}, C.prototype.getImage = function() {
			return this.canvas_
		}, C.prototype.reproject_ = function() {
			var t = [];
			if (this.sourceTiles_.forEach((function(e, i, n) {
				e && e.getState() == r.a.LOADED && t.push({
					extent: this.sourceTileGrid_.getTileCoordExtent(e.tileCoord),
					image: e.getImage()
				})
			}), this), this.sourceTiles_.length = 0, 0 === t.length) this.state = r.a.ERROR;
			else {
				var e = this.wrappedTileCoord_[0],
					i = this.targetTileGrid_.getTileSize(e),
					n = "number" == typeof i ? i : i[0],
					o = "number" == typeof i ? i : i[1],
					s = this.targetTileGrid_.getResolution(e),
					a = this.sourceTileGrid_.getResolution(this.sourceZ_),
					l = this.targetTileGrid_.getTileCoordExtent(this.wrappedTileCoord_);
				this.canvas_ = E.a.render(n, o, this.pixelRatio_, a, this.sourceTileGrid_.getExtent(), s, l, this.triangulation_, t, this.gutter_, this.renderEdges_), this.state = r.a.LOADED
			}
			this.changed()
		}, C.prototype.load = function() {
			if (this.state == r.a.IDLE) {
				this.state = r.a.LOADING, this.changed();
				var t = 0;
				this.sourcesListenerKeys_ = [], this.sourceTiles_.forEach((function(e, i, n) {
					var o, s = e.getState();
					s != r.a.IDLE && s != r.a.LOADING || (t++, o = c.a.listen(e, a.a.CHANGE, (function(i) {
						var n = e.getState();
						n != r.a.LOADED && n != r.a.ERROR && n != r.a.EMPTY || (c.a.unlistenByKey(o), 0 === --t && (this.unlistenSources_(), this.reproject_()))
					}), this), this.sourcesListenerKeys_.push(o))
				}), this), this.sourceTiles_.forEach((function(t, e, i) {
					t.getState() == r.a.IDLE && t.load()
				})), 0 === t && setTimeout(this.reproject_.bind(this), 0)
			}
		}, C.prototype.unlistenSources_ = function() {
			this.sourcesListenerKeys_.forEach(c.a.unlistenByKey), this.sourcesListenerKeys_ = null
		};
		var I = C,
			S = i(79),
			T = i(21),
			R = i(48),
			w = i(97),
			L = i(75),
			N = function(t) {
				w.a.call(this, {
					attributions: t.attributions,
					extent: t.extent,
					logo: t.logo,
					projection: t.projection,
					state: t.state,
					wrapX: t.wrapX
				}), this.opaque_ = void 0 !== t.opaque && t.opaque, this.tilePixelRatio_ = void 0 !== t.tilePixelRatio ? t.tilePixelRatio : 1, this.tileGrid = void 0 !== t.tileGrid ? t.tileGrid : null, this.tileCache = new m(t.cacheSize), this.tmpSize = [0, 0], this.key_ = "", this.tileOptions = {
					transition: t.transition
				}
			};
		n.
	default.inherits(N, w.a), N.prototype.canExpireCache = function() {
			return this.tileCache.canExpireCache()
		}, N.prototype.expireCache = function(t, e) {
			var i = this.getTileCacheForProjection(t);
			i && i.expireCache(e)
		}, N.prototype.forEachLoadedTile = function(t, e, i, n) {
			var o = this.getTileCacheForProjection(t);
			if (!o) return !1;
			for (var s, a, l, u = !0, h = i.minX; h <= i.maxX; ++h) for (var c = i.minY; c <= i.maxY; ++c) a = p.a.getKeyZXY(e, h, c), l = !1, o.containsKey(a) && (l = (s = o.get(a)).getState() === r.a.LOADED) && (l = !1 !== n(s)), l || (u = !1);
			return u
		}, N.prototype.getGutter = function(t) {
			return 0
		}, N.prototype.getKey = function() {
			return this.key_
		}, N.prototype.setKey = function(t) {
			this.key_ !== t && (this.key_ = t, this.changed())
		}, N.prototype.getOpaque = function(t) {
			return this.opaque_
		}, N.prototype.getResolutions = function() {
			return this.tileGrid.getResolutions()
		}, N.prototype.getTile = function(t, e, i, n, r) {}, N.prototype.getTileGrid = function() {
			return this.tileGrid
		}, N.prototype.getTileGridForProjection = function(t) {
			return this.tileGrid ? this.tileGrid : L.a.getForProjection(t)
		}, N.prototype.getTileCacheForProjection = function(t) {
			var e = this.getProjection();
			return e && !v.
		default.equivalent(e, t) ? null:
			this.tileCache
		}, N.prototype.getTilePixelRatio = function(t) {
			return this.tilePixelRatio_
		}, N.prototype.getTilePixelSize = function(t, e, i) {
			var n = this.getTileGridForProjection(i),
				r = this.getTilePixelRatio(e),
				o = R.a.toSize(n.getTileSize(t), this.tmpSize);
			return 1 == r ? o : R.a.scale(o, r, this.tmpSize)
		}, N.prototype.getTileCoordForTileUrlFunction = function(t, e) {
			var i = void 0 !== e ? e : this.getProjection(),
				n = this.getTileGridForProjection(i);
			return this.getWrapX() && i.isGlobal() && (t = L.a.wrapX(n, t, i)), p.a.withinExtentAndZ(t, n) ? t : null
		}, N.prototype.refresh = function() {
			this.tileCache.clear(), this.changed()
		}, N.prototype.useTile = n.
	default.nullFunction, N.Event = function(t, e) {
			T.a.call(this, t), this.tile = e
		}, n.
	default.inherits(N.Event, T.a);
		var P = N,
			O = {
				TILELOADSTART: "tileloadstart",
				TILELOADEND: "tileloadend",
				TILELOADERROR: "tileloaderror"
			},
			M = function(t) {
				P.call(this, {
					attributions: t.attributions,
					cacheSize: t.cacheSize,
					extent: t.extent,
					logo: t.logo,
					opaque: t.opaque,
					projection: t.projection,
					state: t.state,
					tileGrid: t.tileGrid,
					tilePixelRatio: t.tilePixelRatio,
					wrapX: t.wrapX,
					transition: t.transition
				}), this.tileLoadFunction = t.tileLoadFunction, this.tileUrlFunction = this.fixedTileUrlFunction ? this.fixedTileUrlFunction.bind(this) : S.a.nullTileUrlFunction, this.urls = null, t.urls ? this.setUrls(t.urls) : t.url && this.setUrl(t.url), t.tileUrlFunction && this.setTileUrlFunction(t.tileUrlFunction), this.tileLoadingKeys_ = {}
			};
		n.
	default.inherits(M, P), M.prototype.fixedTileUrlFunction, M.prototype.getTileLoadFunction = function() {
			return this.tileLoadFunction
		}, M.prototype.getTileUrlFunction = function() {
			return this.tileUrlFunction
		}, M.prototype.getUrls = function() {
			return this.urls
		}, M.prototype.handleTileChange = function(t) {
			var e, i = t.target,
				o = n.
			default.getUid(i),
				s = i.getState();
			s == r.a.LOADING ? (this.tileLoadingKeys_[o] = !0, e = O.TILELOADSTART):
			o in this.tileLoadingKeys_ && (delete this.tileLoadingKeys_[o], e = s == r.a.ERROR ? O.TILELOADERROR : s == r.a.LOADED || s == r.a.ABORT ? O.TILELOADEND : void 0), null != e && this.dispatchEvent(new P.Event(e, i))
		}, M.prototype.setTileLoadFunction = function(t) {
			this.tileCache.clear(), this.tileLoadFunction = t, this.changed()
		}, M.prototype.setTileUrlFunction = function(t, e) {
			this.tileUrlFunction = t, this.tileCache.pruneExceptNewestZ(), void 0 !== e ? this.setKey(e) : this.changed()
		}, M.prototype.setUrl = function(t) {
			var e = this.urls = S.a.expandUrl(t);
			this.setTileUrlFunction(this.fixedTileUrlFunction ? this.fixedTileUrlFunction.bind(this) : S.a.createFromTemplates(e, this.tileGrid), t)
		}, M.prototype.setUrls = function(t) {
			this.urls = t;
			var e = t.join("\n");
			this.setTileUrlFunction(this.fixedTileUrlFunction ? this.fixedTileUrlFunction.bind(this) : S.a.createFromTemplates(t, this.tileGrid), e)
		}, M.prototype.useTile = function(t, e, i) {
			var n = p.a.getKeyZXY(t, e, i);
			this.tileCache.containsKey(n) && this.tileCache.get(n)
		};
		var b = M,
			F = function(t) {
				b.call(this, {
					attributions: t.attributions,
					cacheSize: t.cacheSize,
					extent: t.extent,
					logo: t.logo,
					opaque: t.opaque,
					projection: t.projection,
					state: t.state,
					tileGrid: t.tileGrid,
					tileLoadFunction: t.tileLoadFunction ? t.tileLoadFunction : F.defaultTileLoadFunction,
					tilePixelRatio: t.tilePixelRatio,
					tileUrlFunction: t.tileUrlFunction,
					url: t.url,
					urls: t.urls,
					wrapX: t.wrapX,
					transition: t.transition
				}), this.crossOrigin = void 0 !== t.crossOrigin ? t.crossOrigin : null, this.tileClass = void 0 !== t.tileClass ? t.tileClass : f, this.tileCacheForProjection = {}, this.tileGridForProjection = {}, this.reprojectionErrorThreshold_ = t.reprojectionErrorThreshold, this.renderReprojectionEdges_ = !1
			};
		n.
	default.inherits(F, b), F.prototype.canExpireCache = function() {
			if (!n.
		default.ENABLE_RASTER_REPROJECTION) return b.prototype.canExpireCache.call(this);
			if (this.tileCache.canExpireCache()) return !0;
			for (var t in this.tileCacheForProjection) if (this.tileCacheForProjection[t].canExpireCache()) return !0;
			return !1
		}, F.prototype.expireCache = function(t, e) {
			if (n.
		default.ENABLE_RASTER_REPROJECTION) {
				var i = this.getTileCacheForProjection(t);
				for (var r in this.tileCache.expireCache(this.tileCache == i ? e : {}), this.tileCacheForProjection) {
					var o = this.tileCacheForProjection[r];
					o.expireCache(o == i ? e : {})
				}
			} else b.prototype.expireCache.call(this, t, e)
		}, F.prototype.getGutter = function(t) {
			return n.
		default.ENABLE_RASTER_REPROJECTION && this.getProjection() && t && !v.
		default.equivalent(this.getProjection(), t) ? 0:
			this.getGutterInternal()
		}, F.prototype.getGutterInternal = function() {
			return 0
		}, F.prototype.getOpaque = function(t) {
			return !(n.
		default.ENABLE_RASTER_REPROJECTION && this.getProjection() && t && !v.
		default.equivalent(this.getProjection(), t)) && b.prototype.getOpaque.call(this, t)
		}, F.prototype.getTileGridForProjection = function(t) {
			if (!n.
		default.ENABLE_RASTER_REPROJECTION) return b.prototype.getTileGridForProjection.call(this, t);
			var e = this.getProjection();
			if (!this.tileGrid || e && !v.
		default.equivalent(e, t)) {
				var i = n.
			default.getUid(t).toString();
				return i in this.tileGridForProjection || (this.tileGridForProjection[i] = L.a.getForProjection(t)), this.tileGridForProjection[i]
			}
			return this.tileGrid
		}, F.prototype.getTileCacheForProjection = function(t) {
			if (!n.
		default.ENABLE_RASTER_REPROJECTION) return b.prototype.getTileCacheForProjection.call(this, t);
			var e = this.getProjection();
			if (!e || v.
		default.equivalent(e, t)) return this.tileCache;
			var i = n.
		default.getUid(t).toString();
			return i in this.tileCacheForProjection || (this.tileCacheForProjection[i] = new m(this.tileCache.highWaterMark)), this.tileCacheForProjection[i]
		}, F.prototype.createTile_ = function(t, e, i, n, o, s) {
			var l = [t, e, i],
				u = this.getTileCoordForTileUrlFunction(l, o),
				h = u ? this.tileUrlFunction(u, n, o) : void 0,
				d = new this.tileClass(l, void 0 !== h ? r.a.IDLE : r.a.EMPTY, void 0 !== h ? h : "", this.crossOrigin, this.tileLoadFunction, this.tileOptions);
			return d.key = s, c.a.listen(d, a.a.CHANGE, this.handleTileChange, this), d
		}, F.prototype.getTile = function(t, e, i, r, o) {
			var s = this.getProjection();
			if (n.
		default.ENABLE_RASTER_REPROJECTION && s && o && !v.
		default.equivalent(s, o)) {
				var a, l = this.getTileCacheForProjection(o),
					u = [t, e, i],
					h = p.a.getKey(u);
				l.containsKey(h) && (a = l.get(h));
				var c = this.getKey();
				if (a && a.key == c) return a;
				var d = this.getTileGridForProjection(s),
					f = this.getTileGridForProjection(o),
					A = this.getTileCoordForTileUrlFunction(u, o),
					g = new I(s, d, o, f, u, A, this.getTilePixelRatio(r), this.getGutterInternal(), function(t, e, i, n) {
						return this.getTileInternal(t, e, i, n, s)
					}.bind(this), this.reprojectionErrorThreshold_, this.renderReprojectionEdges_);
				return g.key = c, a ? (g.interimTile = a, g.refreshInterimChain(), l.replace(h, g)) : l.set(h, g), g
			}
			return this.getTileInternal(t, e, i, r, s || o)
		}, F.prototype.getTileInternal = function(t, e, i, n, o) {
			var s = null,
				a = p.a.getKeyZXY(t, e, i),
				l = this.getKey();
			if (this.tileCache.containsKey(a)) {
				if ((s = this.tileCache.get(a)).key != l) {
					var u = s;
					s = this.createTile_(t, e, i, n, o, l), u.getState() == r.a.IDLE ? s.interimTile = u.interimTile : s.interimTile = u, s.refreshInterimChain(), this.tileCache.replace(a, s)
				}
			} else s = this.createTile_(t, e, i, n, o, l), this.tileCache.set(a, s);
			return s
		}, F.prototype.setRenderReprojectionEdges = function(t) {
			if (n.
		default.ENABLE_RASTER_REPROJECTION && this.renderReprojectionEdges_ != t) {
				for (var e in this.renderReprojectionEdges_ = t, this.tileCacheForProjection) this.tileCacheForProjection[e].clear();
				this.changed()
			}
		}, F.prototype.setTileGridForProjection = function(t, e) {
			if (n.
		default.ENABLE_RASTER_REPROJECTION) {
				var i = v.
			default.get(t);
				if (i) {
					var r = n.
				default.getUid(i).toString();
					r in this.tileGridForProjection || (this.tileGridForProjection[r] = e)
				}
			}
		}, F.defaultTileLoadFunction = function(t, e) {
			t.getImage().src = e
		};
		e.a = F
	}, function(t, e, i) {
		"use strict";
		var n = i(1),
			r = {
				linearRingContainsExtent: function(t, e, i, o, s) {
					return !n.
				default.forEachCorner(s, (function(n) {
						return !r.linearRingContainsXY(t, e, i, o, n[0], n[1])
					}))
				},
				linearRingContainsXY: function(t, e, i, n, r, o) {
					for (var s = 0, a = t[i - n], l = t[i - n + 1]; e < i; e += n) {
						var u = t[e],
							h = t[e + 1];
						l <= o ? h > o && (u - a) * (o - l) - (r - a) * (h - l) > 0 && s++ : h <= o && (u - a) * (o - l) - (r - a) * (h - l) < 0 && s--, a = u, l = h
					}
					return 0 !== s
				},
				linearRingsContainsXY: function(t, e, i, n, o, s) {
					if (0 === i.length) return !1;
					if (!r.linearRingContainsXY(t, e, i[0], n, o, s)) return !1;
					var a, l;
					for (a = 1, l = i.length; a < l; ++a) if (r.linearRingContainsXY(t, i[a - 1], i[a], n, o, s)) return !1;
					return !0
				},
				linearRingssContainsXY: function(t, e, i, n, o, s) {
					if (0 === i.length) return !1;
					var a, l;
					for (a = 0, l = i.length; a < l; ++a) {
						var u = i[a];
						if (r.linearRingsContainsXY(t, e, u, n, o, s)) return !0;
						e = u[u.length - 1]
					}
					return !1
				}
			};
		e.a = r
	}, function(t, e, i) {
		"use strict";
		var n = {
			coordinates: function(t, e, i, n) {
				for (; e < i - n;) {
					var r;
					for (r = 0; r < n; ++r) {
						var o = t[e + r];
						t[e + r] = t[i - n + r], t[i - n + r] = o
					}
					e += n, i -= n
				}
			}
		},
			r = n,
			o = {
				linearRingIsClockwise: function(t, e, i, n) {
					for (var r = 0, o = t[i - n], s = t[i - n + 1]; e < i; e += n) {
						var a = t[e],
							l = t[e + 1];
						r += (a - o) * (l + s), o = a, s = l
					}
					return r > 0
				},
				linearRingsAreOriented: function(t, e, i, n, r) {
					var s, a, l = void 0 !== r && r;
					for (s = 0, a = i.length; s < a; ++s) {
						var u = i[s],
							h = o.linearRingIsClockwise(t, e, u, n);
						if (0 === s) {
							if (l && h || !l && !h) return !1
						} else if (l && !h || !l && h) return !1;
						e = u
					}
					return !0
				},
				linearRingssAreOriented: function(t, e, i, n, r) {
					var s, a;
					for (s = 0, a = i.length; s < a; ++s) if (!o.linearRingsAreOriented(t, e, i[s], n, r)) return !1;
					return !0
				},
				orientLinearRings: function(t, e, i, n, s) {
					var a, l, u = void 0 !== s && s;
					for (a = 0, l = i.length; a < l; ++a) {
						var h = i[a],
							c = o.linearRingIsClockwise(t, e, h, n);
						(0 === a ? u && c || !u && !c : u && !c || !u && c) && r.coordinates(t, e, h, n), e = h
					}
					return e
				},
				orientLinearRingss: function(t, e, i, n, r) {
					var s, a;
					for (s = 0, a = i.length; s < a; ++s) e = o.orientLinearRings(t, e, i[s], n, r);
					return e
				}
			};
		e.a = o
	}, function(t, e, i) {
		"use strict";
		e.a = {
			ADDFEATURE: "addfeature",
			CHANGEFEATURE: "changefeature",
			CLEAR: "clear",
			REMOVEFEATURE: "removefeature"
		}
	}, function(t, e, i) {
		"use strict";
		var n = i(0),
			r = i(48),
			o = i(1),
			s = i(114),
			a = i(8),
			l = i(9),
			u = i(47),
			h = i(120),
			c = {
				getForProjection: function(t) {
					var e = t.getDefaultTileGrid();
					return e || (e = c.createForProjection(t), t.setDefaultTileGrid(e)), e
				},
				wrapX: function(t, e, i) {
					var n = e[0],
						r = t.getTileCoordCenter(e),
						s = c.extentFromProjection(i);
					if (o.
				default.containsCoordinate(s, r)) return e;
					var a = o.
				default.getWidth(s),
						l = Math.ceil((s[0] - r[0]) / a);
					return r[0] += a * l, t.getTileCoordForCoordAndZ(r, n)
				},
				createForExtent: function(t, e, i, n) {
					var r = void 0 !== n ? n : s.a.TOP_LEFT,
						a = c.resolutionsFromExtent(t, e, i);
					return new h.a({
						extent: t,
						origin: o.
					default.getCorner(t, r),
						resolutions:
						a,
						tileSize: i
					})
				},
				createXYZ: function(t) {
					var e = {};
					return a.a.assign(e, void 0 !== t ? t : {}), void 0 === e.extent && (e.extent = l.
				default.get("EPSG:3857").getExtent()), e.resolutions = c.resolutionsFromExtent(e.extent, e.maxZoom, e.tileSize), delete e.maxZoom, new h.a(e)
				},
				resolutionsFromExtent: function(t, e, i) {
					for (var s = void 0 !== e ? e : n.
				default.DEFAULT_MAX_ZOOM, a = o.
				default.getHeight(t), l = o.
				default.getWidth(t), u = r.a.toSize(void 0 !== i ? i : n.
				default.DEFAULT_TILE_SIZE), h = Math.max(l / u[0], a / u[1]), c = s + 1, d = new Array(c), f = 0; f < c; ++f) d[f] = h / Math.pow(2, f);
					return d
				},
				createForProjection: function(t, e, i, n) {
					var r = c.extentFromProjection(t);
					return c.createForExtent(r, e, i, n)
				},
				extentFromProjection: function(t) {
					var e = (t = l.
				default.get(t)).getExtent();
					if (!e) {
						var i = 180 * l.
					default.METERS_PER_UNIT[u.a.DEGREES] / t.getMetersPerUnit();
						e = o.
					default.createOrUpdate(-i, -i, i, i)
					}
					return e
				}
			};
		e.a = c
	}, function(t, e, i) {
		"use strict";
		var n = i(11),
			r = {
				lineString: function(t, e, i, n, o, s, a) {
					var l = void 0 !== a ? a : [];
					return s || (i = r.radialDistance(t, e, i, n, o, l, 0), t = l, e = 0, n = 2), l.length = r.douglasPeucker(t, e, i, n, o, l, 0), l
				},
				douglasPeucker: function(t, e, i, r, o, s, a) {
					var l = (i - e) / r;
					if (l < 3) {
						for (; e < i; e += r) s[a++] = t[e], s[a++] = t[e + 1];
						return a
					}
					var u = new Array(l);
					u[0] = 1, u[l - 1] = 1;
					for (var h, c = [e, i - r], d = 0; c.length > 0;) {
						var f = c.pop(),
							A = c.pop(),
							p = 0,
							g = t[A],
							m = t[A + 1],
							v = t[f],
							y = t[f + 1];
						for (h = A + r; h < f; h += r) {
							var _ = t[h],
								E = t[h + 1],
								x = n.a.squaredSegmentDistance(_, E, g, m, v, y);
							x > p && (d = h, p = x)
						}
						p > o && (u[(d - e) / r] = 1, A + r < d && c.push(A, d), d + r < f && c.push(d, f))
					}
					for (h = 0; h < l; ++h) u[h] && (s[a++] = t[e + h * r], s[a++] = t[e + h * r + 1]);
					return a
				},
				douglasPeuckers: function(t, e, i, n, o, s, a, l) {
					var u, h;
					for (u = 0, h = i.length; u < h; ++u) {
						var c = i[u];
						a = r.douglasPeucker(t, e, c, n, o, s, a), l.push(a), e = c
					}
					return a
				},
				douglasPeuckerss: function(t, e, i, n, o, s, a, l) {
					var u, h;
					for (u = 0, h = i.length; u < h; ++u) {
						var c = i[u],
							d = [];
						a = r.douglasPeuckers(t, e, c, n, o, s, a, d), l.push(d), e = c[c.length - 1]
					}
					return a
				},
				radialDistance: function(t, e, i, r, o, s, a) {
					if (i <= e + r) {
						for (; e < i; e += r) s[a++] = t[e], s[a++] = t[e + 1];
						return a
					}
					var l = t[e],
						u = t[e + 1];
					s[a++] = l, s[a++] = u;
					var h = l,
						c = u;
					for (e += r; e < i; e += r) h = t[e], c = t[e + 1], n.a.squaredDistance(l, u, h, c) > o && (s[a++] = h, s[a++] = c, l = h, u = c);
					return h == l && c == u || (s[a++] = h, s[a++] = c), a
				},
				snap: function(t, e) {
					return e * Math.round(t / e)
				},
				quantize: function(t, e, i, n, o, s, a) {
					if (e == i) return a;
					var l, u, h = r.snap(t[e], o),
						c = r.snap(t[e + 1], o);
					e += n, s[a++] = h, s[a++] = c;
					do {
						if (l = r.snap(t[e], o), u = r.snap(t[e + 1], o), (e += n) == i) return s[a++] = l, s[a++] = u, a
					} while (l == h && u == c);
					for (; e < i;) {
						var d, f;
						if (d = r.snap(t[e], o), f = r.snap(t[e + 1], o), e += n, d != l || f != u) {
							var A = l - h,
								p = u - c,
								g = d - h,
								m = f - c;
							A * m == p * g && (A < 0 && g < A || A == g || A > 0 && g > A) && (p < 0 && m < p || p == m || p > 0 && m > p) ? (l = d, u = f) : (s[a++] = l, s[a++] = u, h = l, c = u, l = d, u = f)
						}
					}
					return s[a++] = l, s[a++] = u, a
				},
				quantizes: function(t, e, i, n, o, s, a, l) {
					var u, h;
					for (u = 0, h = i.length; u < h; ++u) {
						var c = i[u];
						a = r.quantize(t, e, c, n, o, s, a), l.push(a), e = c
					}
					return a
				},
				quantizess: function(t, e, i, n, o, s, a, l) {
					var u, h;
					for (u = 0, h = i.length; u < h; ++u) {
						var c = i[u],
							d = [];
						a = r.quantizes(t, e, c, n, o, s, a, d), l.push(d), e = c[c.length - 1]
					}
					return a
				}
			};
		e.a = r
	}, function(t, e, i) {
		"use strict";
		e.a = {
			PROPERTYCHANGE: "propertychange"
		}
	}, function(t, e, i) {
		"use strict";
		var n = i(0),
			r = i(125),
			o = function(t, e, i, n, o) {
				r.a.call(this, t, e, i.originalEvent, n, o), this.pointerEvent = i
			};
		n.
	default.inherits(o, r.a), e.a = o
	}, function(t, e, i) {
		"use strict";
		var n = i(15),
			r = i(11),
			o = i(49),
			s = {
				createFromTemplate: function(t, e) {
					var i = /\{z\}/g,
						r = /\{x\}/g,
						o = /\{y\}/g,
						s = /\{-y\}/g;
					return function(a, l, u) {
						return a ? t.replace(i, a[0].toString()).replace(r, a[1].toString()).replace(o, (function() {
							return (-a[2] - 1).toString()
						})).replace(s, (function() {
							var t = a[0],
								i = e.getFullTileRange(t);
							return n.a.assert(i, 55), (i.getHeight() + a[2]).toString()
						})) : void 0
					}
				},
				createFromTemplates: function(t, e) {
					for (var i = t.length, n = new Array(i), r = 0; r < i; ++r) n[r] = s.createFromTemplate(t[r], e);
					return s.createFromTileUrlFunctions(n)
				},
				createFromTileUrlFunctions: function(t) {
					return 1 === t.length ? t[0] : function(e, i, n) {
						if (e) {
							var s = o.a.hash(e),
								a = r.a.modulo(s, t.length);
							return t[a](e, i, n)
						}
					}
				},
				nullTileUrlFunction: function(t, e, i) {},
				expandUrl: function(t) {
					var e = [],
						i = /\{([a-z])-([a-z])\}/.exec(t);
					if (i) {
						var n, r = i[1].charCodeAt(0),
							o = i[2].charCodeAt(0);
						for (n = r; n <= o; ++n) e.push(t.replace(i[0], String.fromCharCode(n)));
						return e
					}
					if (i = i = /\{(\d+)-(\d+)\}/.exec(t)) {
						for (var s = parseInt(i[2], 10), a = parseInt(i[1], 10); a <= s; a++) e.push(t.replace(i[0], a.toString()));
						return e
					}
					return e.push(t), e
				}
			};
		e.a = s
	}, function(t, e, i) {
		"use strict";
		Object.defineProperty(e, "__esModule", {
			value: !0
		});
		var n = {
			PI: 3.141592653589793,
			x_pi: 52.35987755982988,
			delta: function(t, e) {
				var i = 6378245,
					n = .006693421622965943,
					r = this.transformLat(e - 105, t - 35),
					o = this.transformLon(e - 105, t - 35),
					s = t / 180 * this.PI,
					a = Math.sin(s);
				a = 1 - n * a * a;
				var l = Math.sqrt(a);
				return {
					lat: r = 180 * r / (i * (1 - n) / (a * l) * this.PI),
					lon: o = 180 * o / (i / l * Math.cos(s) * this.PI)
				}
			},
			gcj_encryptArr: function(t) {
				var e = this.gcj_encrypt(t[1], t[0]);
				return [e.lon, e.lat]
			},
			gcj_encrypt: function(t, e) {
				if (this.outOfChina(t, e)) return {
					lat: t,
					lon: e
				};
				var i = this.delta(t, e);
				return {
					lat: t + i.lat,
					lon: e + i.lon
				}
			},
			gcj_decryptArr: function(t) {
				var e = this.gcj_decrypt(t[1], t[0]);
				return [e.lon, e.lat]
			},
			gcj_decrypt: function(t, e) {
				if (this.outOfChina(t, e)) return {
					lat: t,
					lon: e
				};
				var i = this.delta(t, e);
				return {
					lat: t - i.lat,
					lon: e - i.lon
				}
			},
			gcj_decrypt_exactArr: function(t) {
				var e = this.gcj_decrypt_exact(t[1], t[0]);
				return [e.lon, e.lat]
			},
			gcj_decrypt_exact: function(t, e) {
				for (var i, n, r = .01, o = .01, s = t - r, a = e - o, l = t + r, u = e + o, h = 0;;) {
					i = (s + l) / 2, n = (a + u) / 2;
					var c = this.gcj_encrypt(i, n);
					if (r = c.lat - t, o = c.lon - e, Math.abs(r) < 1e-9 && Math.abs(o) < 1e-9) break;
					if (r > 0 ? l = i : s = i, o > 0 ? u = n : a = n, ++h > 1e4) break
				}
				return {
					lat: i,
					lon: n
				}
			},
			gcj_decrypt_exactArrWithAzimuth: function(t) {
				var e = this.gcj_decrypt_exactWithAzimuth(t[1], t[0], t[2]);
				return [e.lon, e.lat, e.azimuth]
			},
			gcj_decrypt_exactWithAzimuth: function(t, e, i) {
				for (var n, r, o = .01, s = .01, a = t - o, l = e - s, u = t + o, h = e + s, c = 0;;) {
					n = (a + u) / 2, r = (l + h) / 2;
					var d = this.gcj_encrypt(n, r);
					if (o = d.lat - t, s = d.lon - e, Math.abs(o) < 1e-9 && Math.abs(s) < 1e-9) break;
					if (o > 0 ? u = n : a = n, s > 0 ? h = r : l = r, ++c > 1e4) break
				}
				return {
					lat: n,
					lon: r,
					azimuth: i
				}
			},
			bd_encrypt: function(t, e) {
				var i = e,
					n = t,
					r = Math.sqrt(i * i + n * n) + 2e-5 * Math.sin(n * this.x_pi),
					o = Math.atan2(n, i) + 3e-6 * Math.cos(i * this.x_pi),
					s = r * Math.cos(o) + .0065;
				return {
					lat: r * Math.sin(o) + .006,
					lon: s
				}
			},
			bd_decrypt: function(t, e) {
				var i = e - .0065,
					n = t - .006,
					r = Math.sqrt(i * i + n * n) - 2e-5 * Math.sin(n * this.x_pi),
					o = Math.atan2(n, i) - 3e-6 * Math.cos(i * this.x_pi),
					s = r * Math.cos(o);
				return {
					lat: r * Math.sin(o),
					lon: s
				}
			},
			mercator_encrypt: function(t, e) {
				var i = 20037508.34 * e / 180,
					n = Math.log(Math.tan((90 + t) * this.PI / 360)) / (this.PI / 180);
				return {
					lat: n = 20037508.34 * n / 180,
					lon: i
				}
			},
			mercator_decrypt: function(t, e) {
				var i = e / 20037508.34 * 180,
					n = t / 20037508.34 * 180;
				return {
					lat: n = 180 / this.PI * (2 * Math.atan(Math.exp(n * this.PI / 180)) - this.PI / 2),
					lon: i
				}
			},
			distance: function(t, e, i, n) {
				var r = Math.cos(t * this.PI / 180) * Math.cos(i * this.PI / 180) * Math.cos((e - n) * this.PI / 180) + Math.sin(t * this.PI / 180) * Math.sin(i * this.PI / 180);
				r > 1 && (r = 1), r < -1 && (r = -1);
				var o = 6371e3 * Math.acos(r);
				return o
			},
			outOfChina: function(t, e) {
				return e < 72.004 || e > 137.8347 || (t < .8293 || t > 55.8271)
			},
			transformLat: function(t, e) {
				var i = 2 * t - 100 + 3 * e + .2 * e * e + .1 * t * e + .2 * Math.sqrt(Math.abs(t));
				return i += 2 * (20 * Math.sin(6 * t * this.PI) + 20 * Math.sin(2 * t * this.PI)) / 3, i += 2 * (20 * Math.sin(e * this.PI) + 40 * Math.sin(e / 3 * this.PI)) / 3, i += 2 * (160 * Math.sin(e / 12 * this.PI) + 320 * Math.sin(e * this.PI / 30)) / 3
			},
			transformLon: function(t, e) {
				var i = 300 + t + 2 * e + .1 * t * t + .1 * t * e + .1 * Math.sqrt(Math.abs(t));
				return i += 2 * (20 * Math.sin(6 * t * this.PI) + 20 * Math.sin(2 * t * this.PI)) / 3, i += 2 * (20 * Math.sin(t * this.PI) + 40 * Math.sin(t / 3 * this.PI)) / 3, i += 2 * (150 * Math.sin(t / 12 * this.PI) + 300 * Math.sin(t / 30 * this.PI)) / 3
			}
		};
		e.GPSTrans = n
	}, function(t, e, i) {
		"use strict";
		i.r(e);
		var n = i(0),
			r = i(3),
			o = i(50),
			s = i(5),
			a = function() {
				o.a.call(this), this.revision_ = 0
			};
		n.
	default.inherits(a, o.a), a.unByKey = function(t) {
			if (Array.isArray(t)) for (var e = 0, i = t.length; e < i; ++e) r.a.unlistenByKey(t[e]);
			else r.a.unlistenByKey(t)
		}, a.prototype.changed = function() {
			++this.revision_, this.dispatchEvent(s.a.CHANGE)
		}, a.prototype.dispatchEvent, a.prototype.getRevision = function() {
			return this.revision_
		}, a.prototype.on = function(t, e, i) {
			if (Array.isArray(t)) {
				for (var n = t.length, o = new Array(n), s = 0; s < n; ++s) o[s] = r.a.listen(this, t[s], e, i);
				return o
			}
			return r.a.listen(this, t, e, i)
		}, a.prototype.once = function(t, e, i) {
			if (Array.isArray(t)) {
				for (var n = t.length, o = new Array(n), s = 0; s < n; ++s) o[s] = r.a.listenOnce(this, t[s], e, i);
				return o
			}
			return r.a.listenOnce(this, t, e, i)
		}, a.prototype.un = function(t, e, i) {
			if (Array.isArray(t)) for (var n = 0, o = t.length; n < o; ++n) r.a.unlisten(this, t[n], e, i);
			else r.a.unlisten(this, t, e, i)
		}, e.
	default = a
	}, function(t, e, i) {
		"use strict";
		var n = function(t, e, i, n) {
				this.minX = t, this.maxX = e, this.minY = i, this.maxY = n
			};
		n.createOrUpdate = function(t, e, i, r, o) {
			return void 0 !== o ? (o.minX = t, o.maxX = e, o.minY = i, o.maxY = r, o) : new n(t, e, i, r)
		}, n.prototype.contains = function(t) {
			return this.containsXY(t[1], t[2])
		}, n.prototype.containsTileRange = function(t) {
			return this.minX <= t.minX && t.maxX <= this.maxX && this.minY <= t.minY && t.maxY <= this.maxY
		}, n.prototype.containsXY = function(t, e) {
			return this.minX <= t && t <= this.maxX && this.minY <= e && e <= this.maxY
		}, n.prototype.equals = function(t) {
			return this.minX == t.minX && this.minY == t.minY && this.maxX == t.maxX && this.maxY == t.maxY
		}, n.prototype.extend = function(t) {
			t.minX < this.minX && (this.minX = t.minX), t.maxX > this.maxX && (this.maxX = t.maxX), t.minY < this.minY && (this.minY = t.minY), t.maxY > this.maxY && (this.maxY = t.maxY)
		}, n.prototype.getHeight = function() {
			return this.maxY - this.minY + 1
		}, n.prototype.getSize = function() {
			return [this.getWidth(), this.getHeight()]
		}, n.prototype.getWidth = function() {
			return this.maxX - this.minX + 1
		}, n.prototype.intersects = function(t) {
			return this.minX <= t.maxX && this.maxX >= t.minX && this.minY <= t.maxY && this.maxY >= t.minY
		}, e.a = n
	}, function(t, e, i) {
		"use strict";
		var n = i(109),
			r = {
				mapRendererPlugins_: [],
				getMapRendererPlugins: function() {
					return r.mapRendererPlugins_
				},
				layerRendererPlugins_: [],
				getLayerRendererPlugins: function() {
					return r.layerRendererPlugins_
				},
				register: function(t, e) {
					switch (t) {
					case n.a.MAP_RENDERER:
						r.mapRendererPlugins_.push(e);
						break;
					case n.a.LAYER_RENDERER:
						r.layerRendererPlugins_.push(e);
						break;
					default:
						throw new Error("Unsupported plugin type: " + t)
					}
				},
				registerMultiple: function(t, e) {
					for (var i = 0, n = e.length; i < n; ++i) r.register(t, e[i])
				}
			};
		e.a = r
	}, function(t, e, i) {
		"use strict";
		var n = i(0),
			r = i(116),
			o = i.n(r),
			s = i(1),
			a = i(8),
			l = function(t) {
				this.rbush_ = o()(t), this.items_ = {}
			};
		l.prototype.insert = function(t, e) {
			var i = {
				minX: t[0],
				minY: t[1],
				maxX: t[2],
				maxY: t[3],
				value: e
			};
			this.rbush_.insert(i), this.items_[n.
		default.getUid(e)] = i
		}, l.prototype.load = function(t, e) {
			for (var i = new Array(e.length), r = 0, o = e.length; r < o; r++) {
				var s = t[r],
					a = e[r],
					l = {
						minX: s[0],
						minY: s[1],
						maxX: s[2],
						maxY: s[3],
						value: a
					};
				i[r] = l, this.items_[n.
			default.getUid(a)] = l
			}
			this.rbush_.load(i)
		}, l.prototype.remove = function(t) {
			var e = n.
		default.getUid(t),
				i = this.items_[e];
			return delete this.items_[e], null !== this.rbush_.remove(i)
		}, l.prototype.update = function(t, e) {
			var i = this.items_[n.
		default.getUid(e)],
				r = [i.minX, i.minY, i.maxX, i.maxY];
			s.
		default.equals(r, t) || (this.remove(e), this.insert(t, e))
		}, l.prototype.getAll = function() {
			return this.rbush_.all().map((function(t) {
				return t.value
			}))
		}, l.prototype.getInExtent = function(t) {
			var e = {
				minX: t[0],
				minY: t[1],
				maxX: t[2],
				maxY: t[3]
			};
			return this.rbush_.search(e).map((function(t) {
				return t.value
			}))
		}, l.prototype.forEach = function(t, e) {
			return this.forEach_(this.getAll(), t, e)
		}, l.prototype.forEachInExtent = function(t, e, i) {
			return this.forEach_(this.getInExtent(t), e, i)
		}, l.prototype.forEach_ = function(t, e, i) {
			for (var n, r = 0, o = t.length; r < o; r++) if (n = e.call(i, t[r])) return n;
			return n
		}, l.prototype.isEmpty = function() {
			return a.a.isEmpty(this.items_)
		}, l.prototype.clear = function() {
			this.rbush_.clear(), this.items_ = {}
		}, l.prototype.getExtent = function(t) {
			var e = this.rbush_.data;
			return s.
		default.createOrUpdate(e.minX, e.minY, e.maxX, e.maxY, t)
		}, l.prototype.concat = function(t) {
			for (var e in this.rbush_.load(t.rbush_.all()), t.items_) this.items_[0 | e] = t.items_[0 | e]
		}, e.a = l
	}, function(t, e, i) {
		"use strict";
		var n = {
			padNumber: function(t, e, i) {
				var n = void 0 !== i ? t.toFixed(i) : "" + t,
					r = n.indexOf(".");
				return (r = -1 === r ? n.length : r) > e ? n : new Array(1 + e - r).join("0") + n
			},
			compareVersions: function(t, e) {
				for (var i = ("" + t).split("."), n = ("" + e).split("."), r = 0; r < Math.max(i.length, n.length); r++) {
					var o = parseInt(i[r] || "0", 10),
						s = parseInt(n[r] || "0", 10);
					if (o > s) return 1;
					if (s > o) return -1
				}
				return 0
			}
		};
		e.a = n
	}, function(t, e, i) {
		"use strict";
		i.r(e);
		var n = i(38),
			r = i(137),
			o = function(t) {
				var e = t || {};
				this.font_ = e.font, this.rotation_ = e.rotation, this.rotateWithView_ = e.rotateWithView, this.scale_ = e.scale, this.text_ = e.text, this.textAlign_ = e.textAlign, this.textBaseline_ = e.textBaseline, this.fill_ = void 0 !== e.fill ? e.fill : new n.
			default ({
					color: o.DEFAULT_FILL_COLOR_
				}), this.maxAngle_ = void 0 !== e.maxAngle ? e.maxAngle:
				Math.PI / 4, this.placement_ = void 0 !== e.placement ? e.placement : r.a.POINT;
				var i = void 0 === e.overflow ? e.exceedLength : e.overflow;
				this.overflow_ = void 0 !== i && i, this.stroke_ = void 0 !== e.stroke ? e.stroke : null, this.offsetX_ = void 0 !== e.offsetX ? e.offsetX : 0, this.offsetY_ = void 0 !== e.offsetY ? e.offsetY : 0, this.backgroundFill_ = e.backgroundFill ? e.backgroundFill : null, this.backgroundStroke_ = e.backgroundStroke ? e.backgroundStroke : null, this.padding_ = void 0 === e.padding ? null : e.padding
			};
		o.DEFAULT_FILL_COLOR_ = "#333", o.prototype.clone = function() {
			return new o({
				font: this.getFont(),
				placement: this.getPlacement(),
				maxAngle: this.getMaxAngle(),
				overflow: this.getOverflow(),
				rotation: this.getRotation(),
				rotateWithView: this.getRotateWithView(),
				scale: this.getScale(),
				text: this.getText(),
				textAlign: this.getTextAlign(),
				textBaseline: this.getTextBaseline(),
				fill: this.getFill() ? this.getFill().clone() : void 0,
				stroke: this.getStroke() ? this.getStroke().clone() : void 0,
				offsetX: this.getOffsetX(),
				offsetY: this.getOffsetY()
			})
		}, o.prototype.getOverflow = function() {
			return this.overflow_
		}, o.prototype.getFont = function() {
			return this.font_
		}, o.prototype.getMaxAngle = function() {
			return this.maxAngle_
		}, o.prototype.getPlacement = function() {
			return this.placement_
		}, o.prototype.getOffsetX = function() {
			return this.offsetX_
		}, o.prototype.getOffsetY = function() {
			return this.offsetY_
		}, o.prototype.getFill = function() {
			return this.fill_
		}, o.prototype.getRotateWithView = function() {
			return this.rotateWithView_
		}, o.prototype.getRotation = function() {
			return this.rotation_
		}, o.prototype.getScale = function() {
			return this.scale_
		}, o.prototype.getStroke = function() {
			return this.stroke_
		}, o.prototype.getText = function() {
			return this.text_
		}, o.prototype.getTextAlign = function() {
			return this.textAlign_
		}, o.prototype.getTextBaseline = function() {
			return this.textBaseline_
		}, o.prototype.getBackgroundFill = function() {
			return this.backgroundFill_
		}, o.prototype.getBackgroundStroke = function() {
			return this.backgroundStroke_
		}, o.prototype.getPadding = function() {
			return this.padding_
		}, o.prototype.setOverflow = function(t) {
			this.overflow_ = t
		}, o.prototype.setFont = function(t) {
			this.font_ = t
		}, o.prototype.setMaxAngle = function(t) {
			this.maxAngle_ = t
		}, o.prototype.setOffsetX = function(t) {
			this.offsetX_ = t
		}, o.prototype.setOffsetY = function(t) {
			this.offsetY_ = t
		}, o.prototype.setPlacement = function(t) {
			this.placement_ = t
		}, o.prototype.setFill = function(t) {
			this.fill_ = t
		}, o.prototype.setRotation = function(t) {
			this.rotation_ = t
		}, o.prototype.setScale = function(t) {
			this.scale_ = t
		}, o.prototype.setStroke = function(t) {
			this.stroke_ = t
		}, o.prototype.setText = function(t) {
			this.text_ = t
		}, o.prototype.setTextAlign = function(t) {
			this.textAlign_ = t
		}, o.prototype.setTextBaseline = function(t) {
			this.textBaseline_ = t
		}, o.prototype.setBackgroundFill = function(t) {
			this.backgroundFill_ = t
		}, o.prototype.setBackgroundStroke = function(t) {
			this.backgroundStroke_ = t
		}, o.prototype.setPadding = function(t) {
			this.padding_ = t
		}, e.
	default = o
	}, function(t, e, i) {
		"use strict";
		Object.defineProperty(e, "__esModule", {
			value: !0
		}), e.BaseLayer = e.DefaultStyle = e.LayerType = void 0;
		var n, r = i(173),
			o = (n = r) && n.__esModule ? n : {
			default:
				n
			},
			s = l(i(55)),
			a = l(i(142));

		function l(t) {
			if (t && t.__esModule) return t;
			var e = {};
			if (null != t) for (var i in t) Object.prototype.hasOwnProperty.call(t, i) && (e[i] = t[i]);
			return e.
		default = t, e
		}
		var u = {
			selFillColor: "rgba(255,255,255,0.4)",
			selStrokeColor: "#3399CC",
			selStrokeWidth: 1
		},
			h = function(t) {
				this.gisMapObj = t.gisMapObj, this.callBackFun = t.callBackFun ||
				function() {}, this.layerVector = null, this.sequence = new o.
			default, this.layerOptions = {
					minShowZoom: 3,
					maxShowZoom: this.gisMapObj.getMapMaxZoom(),
					fillColor: "#F0B267",
					strokeColor: "#3E82F7",
					strokeWidth: 1,
					selFillColor: "#ED7C24",
					selStrokeColor: "#0099FF",
					selStrokeWidth: 1,
					label: "",
					labFillColor: "#000000",
					labStrokeColor: "#FFFFFF",
					labStrokeWidth: 1,
					lalFontSize: "11px",
					labFontFamily: "微软雅黑",
					selLabFillColor: "#000000",
					selLabStrokeColor: "#FFFFFF",
					selLabStrokeWidth: 1,
					labOffsetX: 0,
					labOffsetY: 0,
					labTextAlign: "center",
					labTextBaseline: "middle",
					labRotation: 0,
					IconRotation: 0
				}, s.mixin(this.layerOptions, t.layerOptions), s.mixinByCondition(u, t.layerOptions, ["selFillColor", "selStrokeColor", "selStrokeWidth"]), this.data = [], this.isRef = !s.isDef(t.isRef) || t.isRef, this.isHover = !! s.isDef(t.isHover) && t.isHover, this.setIntervalArr = []
			};
		h.prototype.setData = function(t, e) {
			this.sequence.match(e) && (null != t[0] && t[0].hasOwnProperty("heatValue") ? this.data = function(t) {
				for (var e = [], i = 0; i < t.length; i++) for (var n = 0; n < t[i].heatValue; n++) {
					var r = {
						id: n > 0 ? t[i].id + n : t[i].id,
						coord: t[i].coord,
						layerOptions: t[i].layerOptions ? t[i].layerOptions : null
					};
					e.push(r)
				}
				return e
			}(t) : this.data = function(t) {
				for (var e = null, i = 0; i < t.length; i++) for (var n = 0; n < t[i].coord.length; n++) Array.isArray(t[i].coord[0]) ? (e == t[i].coord[n][0] && (t[i].coord[n][0] = t[i].coord[n][0] + 1e-8), e = t[i].coord[n][0]) : (e == t[i].coord[0] && (t[i].coord[0] = t[i].coord[0] + 1e-8), e = t[i].coord[0]);
				return t
			}(t), this.refreshLayer())
		}, h.prototype.refreshLayer = function() {}, h.prototype.refreshLayerByData = function() {
			if (s.isFunction(this.callBackFun)) {
				var t = this.sequence.getNextVal();
				if (0 != t) {
					var e = {
						extent: this.gisMapObj.getDataExtent(),
						seq: t,
						rate: this.gisMapObj.getCurrMap().getView().getResolution() / this.gisMapObj.getCurrMap().getView().getMaxResolution(),
						currObj: this
					};
					this.callBackFun(e)
				}
			}
		}, h.prototype.updateFeature = function(t, e) {
			var i = this.sourceObj.getFeatureById(t);
			if (i) {
				s.mixin(i.get("property"), e);
				for (var n = 0; n < this.data.length; n++) if (this.data[n].id == t) {
					s.mixin(this.data[n], i.get("property"));
					break
				}
				this.refreshLayer()
			}
		}, h.prototype.removeFeatureById = function(t) {
			var e = this.sourceObj.getFeatureById(t);
			if (e) {
				this.sourceObj.removeFeature(e);
				for (var i = 0; i < this.data.length; i++) if (this.data[i].id == t) {
					this.data.splice(i, 1);
					break
				}
			}
		}, h.prototype.setOpacity = function(t) {
			this.layerVector.setOpacity(t)
		}, h.prototype.cleanSource = function() {
			this.sourceObj.clear()
		}, h.prototype.setVisible = function(t) {
			this.layerVector.setVisible(t)
		}, h.prototype.getVisible = function() {
			return this.layerVector.getVisible()
		}, h.prototype.setZIndex = function(t) {
			return this.layerVector.setZIndex(t)
		}, h.prototype.setFeaHighlight = function(t) {
			for (var e = [], i = 0; i < t.length; i++) e.push(this.sourceObj.getFeatureById(t[i]));
			a.switchSelFea({
				mapId: this.gisMapObj.getCurrMap().getTarget().id,
				layerType: this.layerVector.get("iGisProperty").type,
				featureArr: e,
				selType: "click"
			})
		}, h.prototype.startTwinkleFea = function(t) {
			for (var e = this, i = this.sourceObj, n = this.setIntervalArr, r = function(t) {
					e.si = setInterval((function() {
						t.getStyle() && t.setStyle(null)
					}), 300), n.push(e.si)
				}, o = 0; o < t.length; o++) r(i.getFeatureById(t[o]))
		}, h.prototype.stopTwinkleFea = function() {
			this.si && (clearInterval(this.si), this.si = void 0)
		}, h.prototype.addClickEvent = function(t) {
			this.layerVector.get("iGisProperty").clickEvent = t
		}, h.prototype.addHoverEvent = function(t) {
			this.layerVector.get("iGisProperty").hoverEvent = t
		}, e.LayerType = {
			CIRCLE: "CIRCLE",
			ICON: "ICON",
			LINE: "LINE",
			POLYGON: "POLYGON",
			FONT: "FONT",
			CIRCLECLUSTER: "CIRCLECLUSTER",
			ICONCLUSTER: "ICONCLUSTER",
			HEAT: "HEAT",
			DATASERVER: "DATASERVER"
		}, e.DefaultStyle = u, e.BaseLayer = h
	}, function(t, e, i) {
		"use strict";
		var n = i(0),
			r = function() {};
		r.prototype.disposed_ = !1, r.prototype.dispose = function() {
			this.disposed_ || (this.disposed_ = !0, this.disposeInternal())
		}, r.prototype.disposeInternal = n.
	default.nullFunction, e.a = r
	}, function(t, e, i) {
		"use strict";
		e.a = {
			POSTRENDER: "postrender",
			MOVESTART: "movestart",
			MOVEEND: "moveend"
		}
	}, function(t, e, i) {
		"use strict";
		var n = i(11),
			r = {
				disable: function(t, e) {
					return void 0 !== t ? 0 : void 0
				},
				none: function(t, e) {
					return void 0 !== t ? t + e : void 0
				},
				createSnapToN: function(t) {
					var e = 2 * Math.PI / t;
					return (function(t, i) {
						return void 0 !== t ? t = Math.floor((t + i) / e + .5) * e : void 0
					})
				},
				createSnapToZero: function(t) {
					var e = t || n.a.toRadians(5);
					return (function(t, i) {
						return void 0 !== t ? Math.abs(t + i) <= e ? 0 : t + i : void 0
					})
				}
			};
		e.a = r
	}, function(t, e, i) {
		"use strict";
		var n = i(0),
			r = i(50),
			o = i(5),
			s = function(t, e, i, n) {
				r.a.call(this), this.extent = t, this.pixelRatio_ = i, this.resolution = e, this.state = n
			};
		n.
	default.inherits(s, r.a), s.prototype.changed = function() {
			this.dispatchEvent(o.a.CHANGE)
		}, s.prototype.getExtent = function() {
			return this.extent
		}, s.prototype.getImage = function() {}, s.prototype.getPixelRatio = function() {
			return this.pixelRatio_
		}, s.prototype.getResolution = function() {
			return this.resolution
		}, s.prototype.getState = function() {
			return this.state
		}, s.prototype.load = function() {}, e.a = s
	}, function(t, e, i) {
		"use strict";
		var n = i(0),
			r = i(62),
			o = i(16),
			s = i(35),
			a = i(17),
			l = i(12),
			u = i(108),
			h = function(t) {
				this.checksums_ = null, this.canvas_ = null, this.hitDetectionCanvas_ = null, this.fill_ = void 0 !== t.fill ? t.fill : null, this.origin_ = [0, 0], this.points_ = t.points, this.radius_ = void 0 !== t.radius ? t.radius : t.radius1, this.radius2_ = t.radius2, this.angle_ = void 0 !== t.angle ? t.angle : 0, this.stroke_ = void 0 !== t.stroke ? t.stroke : null, this.anchor_ = null, this.size_ = null, this.imageSize_ = null, this.hitDetectionImageSize_ = null, this.atlasManager_ = t.atlasManager, this.render_(this.atlasManager_);
				var e = void 0 === t.snapToPixel || t.snapToPixel,
					i = void 0 !== t.rotateWithView && t.rotateWithView;
				u.a.call(this, {
					opacity: 1,
					rotateWithView: i,
					rotation: void 0 !== t.rotation ? t.rotation : 0,
					scale: 1,
					snapToPixel: e
				})
			};
		n.
	default.inherits(h, u.a), h.prototype.clone = function() {
			var t = new h({
				fill: this.getFill() ? this.getFill().clone() : void 0,
				points: this.getPoints(),
				radius: this.getRadius(),
				radius2: this.getRadius2(),
				angle: this.getAngle(),
				snapToPixel: this.getSnapToPixel(),
				stroke: this.getStroke() ? this.getStroke().clone() : void 0,
				rotation: this.getRotation(),
				rotateWithView: this.getRotateWithView(),
				atlasManager: this.atlasManager_
			});
			return t.setOpacity(this.getOpacity()), t.setScale(this.getScale()), t
		}, h.prototype.getAnchor = function() {
			return this.anchor_
		}, h.prototype.getAngle = function() {
			return this.angle_
		}, h.prototype.getFill = function() {
			return this.fill_
		}, h.prototype.getHitDetectionImage = function(t) {
			return this.hitDetectionCanvas_
		}, h.prototype.getImage = function(t) {
			return this.canvas_
		}, h.prototype.getImageSize = function() {
			return this.imageSize_
		}, h.prototype.getHitDetectionImageSize = function() {
			return this.hitDetectionImageSize_
		}, h.prototype.getImageState = function() {
			return a.a.LOADED
		}, h.prototype.getOrigin = function() {
			return this.origin_
		}, h.prototype.getPoints = function() {
			return this.points_
		}, h.prototype.getRadius = function() {
			return this.radius_
		}, h.prototype.getRadius2 = function() {
			return this.radius2_
		}, h.prototype.getSize = function() {
			return this.size_
		}, h.prototype.getStroke = function() {
			return this.stroke_
		}, h.prototype.listenImageChange = function(t, e) {}, h.prototype.load = function() {}, h.prototype.unlistenImageChange = function(t, e) {}, h.prototype.render_ = function(t) {
			var e, i, n = "",
				a = "",
				u = 0,
				h = null,
				c = 0,
				d = 0;
			this.stroke_ && (null === (i = this.stroke_.getColor()) && (i = l.a.defaultStrokeStyle), i = r.a.asColorLike(i), void 0 === (d = this.stroke_.getWidth()) && (d = l.a.defaultLineWidth), h = this.stroke_.getLineDash(), c = this.stroke_.getLineDashOffset(), s.a.CANVAS_LINE_DASH || (h = null, c = 0), void 0 === (a = this.stroke_.getLineJoin()) && (a = l.a.defaultLineJoin), void 0 === (n = this.stroke_.getLineCap()) && (n = l.a.defaultLineCap), void 0 === (u = this.stroke_.getMiterLimit()) && (u = l.a.defaultMiterLimit));
			var f = 2 * (this.radius_ + d) + 1,
				A = {
					strokeStyle: i,
					strokeWidth: d,
					size: f,
					lineCap: n,
					lineDash: h,
					lineDashOffset: c,
					lineJoin: a,
					miterLimit: u
				};
			if (void 0 === t) {
				var p = o.a.createCanvasContext2D(f, f);
				this.canvas_ = p.canvas, e = f = this.canvas_.width, this.draw_(A, p, 0, 0), this.createHitDetectionCanvas_(A)
			} else {
				f = Math.round(f);
				var g, m = !this.fill_;
				m && (g = this.drawHitDetectionCanvas_.bind(this, A));
				var v = this.getChecksum(),
					y = t.add(v, f, f, this.draw_.bind(this, A), g);
				this.canvas_ = y.image, this.origin_ = [y.offsetX, y.offsetY], e = y.image.width, m ? (this.hitDetectionCanvas_ = y.hitImage, this.hitDetectionImageSize_ = [y.hitImage.width, y.hitImage.height]) : (this.hitDetectionCanvas_ = this.canvas_, this.hitDetectionImageSize_ = [e, e])
			}
			this.anchor_ = [f / 2, f / 2], this.size_ = [f, f], this.imageSize_ = [e, e]
		}, h.prototype.draw_ = function(t, e, i, n) {
			var o, s, a;
			e.setTransform(1, 0, 0, 1, 0, 0), e.translate(i, n), e.beginPath();
			var u = this.points_;
			if (u === 1 / 0) e.arc(t.size / 2, t.size / 2, this.radius_, 0, 2 * Math.PI, !0);
			else {
				var h = void 0 !== this.radius2_ ? this.radius2_ : this.radius_;
				for (h !== this.radius_ && (u *= 2), o = 0; o <= u; o++) s = 2 * o * Math.PI / u - Math.PI / 2 + this.angle_, a = o % 2 == 0 ? this.radius_ : h, e.lineTo(t.size / 2 + a * Math.cos(s), t.size / 2 + a * Math.sin(s))
			}
			if (this.fill_) {
				var c = this.fill_.getColor();
				null === c && (c = l.a.defaultFillStyle), e.fillStyle = r.a.asColorLike(c), e.fill()
			}
			this.stroke_ && (e.strokeStyle = t.strokeStyle, e.lineWidth = t.strokeWidth, t.lineDash && (e.setLineDash(t.lineDash), e.lineDashOffset = t.lineDashOffset), e.lineCap = t.lineCap, e.lineJoin = t.lineJoin, e.miterLimit = t.miterLimit, e.stroke()), e.closePath()
		}, h.prototype.createHitDetectionCanvas_ = function(t) {
			if (this.hitDetectionImageSize_ = [t.size, t.size], this.fill_) this.hitDetectionCanvas_ = this.canvas_;
			else {
				var e = o.a.createCanvasContext2D(t.size, t.size);
				this.hitDetectionCanvas_ = e.canvas, this.drawHitDetectionCanvas_(t, e, 0, 0)
			}
		}, h.prototype.drawHitDetectionCanvas_ = function(t, e, i, n) {
			e.setTransform(1, 0, 0, 1, 0, 0), e.translate(i, n), e.beginPath();
			var r = this.points_;
			if (r === 1 / 0) e.arc(t.size / 2, t.size / 2, this.radius_, 0, 2 * Math.PI, !0);
			else {
				var o, s, a, u = void 0 !== this.radius2_ ? this.radius2_ : this.radius_;
				for (u !== this.radius_ && (r *= 2), o = 0; o <= r; o++) a = 2 * o * Math.PI / r - Math.PI / 2 + this.angle_, s = o % 2 == 0 ? this.radius_ : u, e.lineTo(t.size / 2 + s * Math.cos(a), t.size / 2 + s * Math.sin(a))
			}
			e.fillStyle = l.a.defaultFillStyle, e.fill(), this.stroke_ && (e.strokeStyle = t.strokeStyle, e.lineWidth = t.strokeWidth, t.lineDash && (e.setLineDash(t.lineDash), e.lineDashOffset = t.lineDashOffset), e.stroke()), e.closePath()
		}, h.prototype.getChecksum = function() {
			var t = this.stroke_ ? this.stroke_.getChecksum() : "-",
				e = this.fill_ ? this.fill_.getChecksum() : "-";
			if (!this.checksums_ || t != this.checksums_[1] || e != this.checksums_[2] || this.radius_ != this.checksums_[3] || this.radius2_ != this.checksums_[4] || this.angle_ != this.checksums_[5] || this.points_ != this.checksums_[6]) {
				var i = "r" + t + e + (void 0 !== this.radius_ ? this.radius_.toString() : "-") + (void 0 !== this.radius2_ ? this.radius2_.toString() : "-") + (void 0 !== this.angle_ ? this.angle_.toString() : "-") + (void 0 !== this.points_ ? this.points_.toString() : "-");
				this.checksums_ = [i, t, e, this.radius_, this.radius2_, this.angle_, this.points_]
			}
			return this.checksums_[0]
		}, e.a = h
	}, function(t, e, i) {
		"use strict";
		e.a = {
			ARRAY_BUFFER: "arraybuffer",
			JSON: "json",
			TEXT: "text",
			XML: "xml"
		}
	}, function(t, e, i) {
		"use strict";
		i.r(e);
		var n = i(0),
			r = i(10),
			o = i(1),
			s = i(18),
			a = i(4),
			l = i(58),
			u = i(40),
			h = i(70),
			c = i(64),
			d = i(65),
			f = i(122),
			A = i(103),
			p = i(76),
			g = function(t, e) {
				u.a.call(this), this.ends_ = [], this.maxDelta_ = -1, this.maxDeltaRevision_ = -1, this.setCoordinates(t, e)
			};
		n.
	default.inherits(g, u.a), g.prototype.appendLineString = function(t) {
			this.flatCoordinates ? r.a.extend(this.flatCoordinates, t.getFlatCoordinates().slice()) : this.flatCoordinates = t.getFlatCoordinates().slice(), this.ends_.push(this.flatCoordinates.length), this.changed()
		}, g.prototype.clone = function() {
			var t = new g(null);
			return t.setFlatCoordinates(this.layout, this.flatCoordinates.slice(), this.ends_.slice()), t
		}, g.prototype.closestPointXY = function(t, e, i, n) {
			return n < o.
		default.closestSquaredDistanceXY(this.getExtent(), t, e) ? n:
			(this.maxDeltaRevision_ != this.getRevision() && (this.maxDelta_ = Math.sqrt(h.a.getsMaxSquaredDelta(this.flatCoordinates, 0, this.ends_, this.stride, 0)), this.maxDeltaRevision_ = this.getRevision()), h.a.getsClosestPoint(this.flatCoordinates, 0, this.ends_, this.stride, this.maxDelta_, !1, t, e, i, n))
		}, g.prototype.getCoordinateAtM = function(t, e, i) {
			if (this.layout != s.a.XYM && this.layout != s.a.XYZM || 0 === this.flatCoordinates.length) return null;
			var n = void 0 !== e && e,
				r = void 0 !== i && i;
			return f.a.lineStringsCoordinateAtM(this.flatCoordinates, 0, this.ends_, this.stride, t, n, r)
		}, g.prototype.getCoordinates = function() {
			return d.a.coordinatess(this.flatCoordinates, 0, this.ends_, this.stride)
		}, g.prototype.getEnds = function() {
			return this.ends_
		}, g.prototype.getLineString = function(t) {
			if (t < 0 || this.ends_.length <= t) return null;
			var e = new l.
		default (null);
			return e.setFlatCoordinates(this.layout, this.flatCoordinates.slice(0 === t ? 0 : this.ends_[t - 1], this.ends_[t])), e
		}, g.prototype.getLineStrings = function() {
			var t, e, i = this.flatCoordinates,
				n = this.ends_,
				r = this.layout,
				o = [],
				s = 0;
			for (t = 0, e = n.length; t < e; ++t) {
				var a = n[t],
					u = new l.
				default (null);
				u.setFlatCoordinates(r, i.slice(s, a)), o.push(u), s = a
			}
			return o
		}, g.prototype.getFlatMidpoints = function() {
			var t, e, i = [],
				n = this.flatCoordinates,
				o = 0,
				s = this.ends_,
				a = this.stride;
			for (t = 0, e = s.length; t < e; ++t) {
				var l = s[t],
					u = f.a.lineString(n, o, l, a, .5);
				r.a.extend(i, u), o = l
			}
			return i
		}, g.prototype.getSimplifiedGeometryInternal = function(t) {
			var e = [],
				i = [];
			e.length = p.a.douglasPeuckers(this.flatCoordinates, 0, this.ends_, this.stride, t, e, 0, i);
			var n = new g(null);
			return n.setFlatCoordinates(s.a.XY, e, i), n
		}, g.prototype.getType = function() {
			return a.a.MULTI_LINE_STRING
		}, g.prototype.intersectsExtent = function(t) {
			return A.a.lineStrings(this.flatCoordinates, 0, this.ends_, this.stride, t)
		}, g.prototype.setCoordinates = function(t, e) {
			if (t) {
				this.setLayout(e, t, 2), this.flatCoordinates || (this.flatCoordinates = []);
				var i = c.a.coordinatess(this.flatCoordinates, 0, t, this.stride, this.ends_);
				this.flatCoordinates.length = 0 === i.length ? 0 : i[i.length - 1], this.changed()
			} else this.setFlatCoordinates(s.a.XY, null, this.ends_)
		}, g.prototype.setFlatCoordinates = function(t, e, i) {
			this.setFlatCoordinatesInternal(t, e), this.ends_ = i, this.changed()
		}, g.prototype.setLineStrings = function(t) {
			var e, i, n = this.getLayout(),
				o = [],
				s = [];
			for (e = 0, i = t.length; e < i; ++e) {
				var a = t[e];
				0 === e && (n = a.getLayout()), r.a.extend(o, a.getFlatCoordinates()), s.push(o.length)
			}
			this.setFlatCoordinates(n, o, s)
		}, e.
	default = g
	}, function(t, e, i) {
		"use strict";
		var n = i(0),
			r = i(47),
			o = i(118),
			s = function(t) {
				this.code_ = t.code, this.units_ = t.units, this.extent_ = void 0 !== t.extent ? t.extent : null, this.worldExtent_ = void 0 !== t.worldExtent ? t.worldExtent : null, this.axisOrientation_ = void 0 !== t.axisOrientation ? t.axisOrientation : "enu", this.global_ = void 0 !== t.global && t.global, this.canWrapX_ = !(!this.global_ || !this.extent_), this.getPointResolutionFunc_ = t.getPointResolution, this.defaultTileGrid_ = null, this.metersPerUnit_ = t.metersPerUnit;
				var e = t.code;
				if (n.
			default.ENABLE_PROJ4JS) {
					var i = o.a.get();
					if ("function" == typeof i) {
						var r = i.defs(e);
						void 0 !== r && (void 0 !== r.axis && void 0 === t.axisOrientation && (this.axisOrientation_ = r.axis), void 0 === t.metersPerUnit && (this.metersPerUnit_ = r.to_meter), void 0 === t.units && (this.units_ = r.units))
					}
				}
			};
		s.prototype.canWrapX = function() {
			return this.canWrapX_
		}, s.prototype.getCode = function() {
			return this.code_
		}, s.prototype.getExtent = function() {
			return this.extent_
		}, s.prototype.getUnits = function() {
			return this.units_
		}, s.prototype.getMetersPerUnit = function() {
			return this.metersPerUnit_ || r.a.METERS_PER_UNIT[this.units_]
		}, s.prototype.getWorldExtent = function() {
			return this.worldExtent_
		}, s.prototype.getAxisOrientation = function() {
			return this.axisOrientation_
		}, s.prototype.isGlobal = function() {
			return this.global_
		}, s.prototype.setGlobal = function(t) {
			this.global_ = t, this.canWrapX_ = !(!t || !this.extent_)
		}, s.prototype.getDefaultTileGrid = function() {
			return this.defaultTileGrid_
		}, s.prototype.setDefaultTileGrid = function(t) {
			this.defaultTileGrid_ = t
		}, s.prototype.setExtent = function(t) {
			this.extent_ = t, this.canWrapX_ = !(!this.global_ || !t)
		}, s.prototype.setWorldExtent = function(t) {
			this.worldExtent_ = t
		}, s.prototype.setGetPointResolution = function(t) {
			this.getPointResolutionFunc_ = t
		}, s.prototype.getPointResolutionFunc = function() {
			return this.getPointResolutionFunc_
		}, e.a = s
	}, function(t, e, i) {
		"use strict";
		var n = i(15),
			r = i(8),
			o = function(t, e) {
				this.priorityFunction_ = t, this.keyFunction_ = e, this.elements_ = [], this.priorities_ = [], this.queuedElements_ = {}
			};
		o.DROP = 1 / 0, o.prototype.clear = function() {
			this.elements_.length = 0, this.priorities_.length = 0, r.a.clear(this.queuedElements_)
		}, o.prototype.dequeue = function() {
			var t = this.elements_,
				e = this.priorities_,
				i = t[0];
			1 == t.length ? (t.length = 0, e.length = 0) : (t[0] = t.pop(), e[0] = e.pop(), this.siftUp_(0));
			var n = this.keyFunction_(i);
			return delete this.queuedElements_[n], i
		}, o.prototype.enqueue = function(t) {
			n.a.assert(!(this.keyFunction_(t) in this.queuedElements_), 31);
			var e = this.priorityFunction_(t);
			return e != o.DROP && (this.elements_.push(t), this.priorities_.push(e), this.queuedElements_[this.keyFunction_(t)] = !0, this.siftDown_(0, this.elements_.length - 1), !0)
		}, o.prototype.getCount = function() {
			return this.elements_.length
		}, o.prototype.getLeftChildIndex_ = function(t) {
			return 2 * t + 1
		}, o.prototype.getRightChildIndex_ = function(t) {
			return 2 * t + 2
		}, o.prototype.getParentIndex_ = function(t) {
			return t - 1 >> 1
		}, o.prototype.heapify_ = function() {
			var t;
			for (t = (this.elements_.length >> 1) - 1; t >= 0; t--) this.siftUp_(t)
		}, o.prototype.isEmpty = function() {
			return 0 === this.elements_.length
		}, o.prototype.isKeyQueued = function(t) {
			return t in this.queuedElements_
		}, o.prototype.isQueued = function(t) {
			return this.isKeyQueued(this.keyFunction_(t))
		}, o.prototype.siftUp_ = function(t) {
			for (var e = this.elements_, i = this.priorities_, n = e.length, r = e[t], o = i[t], s = t; t < n >> 1;) {
				var a = this.getLeftChildIndex_(t),
					l = this.getRightChildIndex_(t),
					u = l < n && i[l] < i[a] ? l : a;
				e[t] = e[u], i[t] = i[u], t = u
			}
			e[t] = r, i[t] = o, this.siftDown_(s, t)
		}, o.prototype.siftDown_ = function(t, e) {
			for (var i = this.elements_, n = this.priorities_, r = i[e], o = n[e]; e > t;) {
				var s = this.getParentIndex_(e);
				if (!(n[s] > o)) break;
				i[e] = i[s], n[e] = n[s], e = s
			}
			i[e] = r, n[e] = o
		}, o.prototype.reprioritize = function() {
			var t, e, i, n = this.priorityFunction_,
				r = this.elements_,
				s = this.priorities_,
				a = 0,
				l = r.length;
			for (e = 0; e < l; ++e)(i = n(t = r[e])) == o.DROP ? delete this.queuedElements_[this.keyFunction_(t)] : (s[a] = i, r[a++] = t);
			r.length = a, s.length = a, this.heapify_()
		}, e.a = o
	}, function(t, e, i) {
		"use strict";
		var n = i(0),
			r = i(119),
			o = i(14),
			s = i(9),
			a = i(59),
			l = function(t) {
				o.a.call(this), this.projection_ = s.
			default.get(t.projection), this.attributions_ = null, this.attributions2_ = this.adaptAttributions_(t.attributions), this.logo_ = t.logo, this.state_ = void 0 !== t.state ? t.state:
				a.a.READY, this.wrapX_ = void 0 !== t.wrapX && t.wrapX
			};
		n.
	default.inherits(l, o.a), l.prototype.adaptAttributions_ = function(t) {
			if (!t) return null;
			if (t instanceof r.
		default) return this.attributions_ = [t], function(e) {
				return [t.getHTML()]
			};
			if (Array.isArray(t)) {
				if (t[0] instanceof r.
			default) {
					this.attributions_ = t;
					var e = t.map((function(t) {
						return t.getHTML()
					}));
					return function(t) {
						return e
					}
				}
				return this.attributions_ = t.map((function(t) {
					return new r.
				default ({
						html: t
					})
				})), function(e) {
					return t
				}
			}
			return "function" == typeof t ? t : (this.attributions_ = [new r.
		default ({
				html: t
			})], function(e) {
				return [t]
			})
		}, l.prototype.forEachFeatureAtCoordinate = n.
	default.nullFunction, l.prototype.getAttributions = function() {
			return this.attributions_
		}, l.prototype.getAttributions2 = function() {
			return this.attributions2_
		}, l.prototype.getLogo = function() {
			return this.logo_
		}, l.prototype.getProjection = function() {
			return this.projection_
		}, l.prototype.getResolutions = function() {}, l.prototype.getState = function() {
			return this.state_
		}, l.prototype.getWrapX = function() {
			return this.wrapX_
		}, l.prototype.refresh = function() {
			this.changed()
		}, l.prototype.setAttributions = function(t) {
			this.attributions2_ = this.adaptAttributions_(t), this.changed()
		}, l.prototype.setLogo = function(t) {
			this.logo_ = t
		}, l.prototype.setState = function(t) {
			this.state_ = t, this.changed()
		}, e.a = l
	}, function(t, e, i) {
		"use strict";
		var n = i(0),
			r = i(21),
			o = function(t, e, i) {
				r.a.call(this, t), this.map = e, this.frameState = void 0 !== i ? i : null
			};
		n.
	default.inherits(o, r.a), e.a = o
	}, function(t, e, i) {
		"use strict";
		i.r(e);
		var n = i(0),
			r = i(10),
			o = i(1),
			s = i(69),
			a = i(32),
			l = i(41),
			u = i(60),
			h = i(18),
			c = i(58),
			d = i(94),
			f = i(106),
			A = i(31),
			p = i(8),
			g = i(9),
			m = i(2),
			v = function(t) {
				var e = t || {};
				a.a.call(this, e), this.surface_ = void 0 !== e.surface && e.surface, this.curve_ = void 0 !== e.curve && e.curve, this.multiCurve_ = void 0 === e.multiCurve || e.multiCurve, this.multiSurface_ = void 0 === e.multiSurface || e.multiSurface, this.schemaLocation = e.schemaLocation ? e.schemaLocation : v.schemaLocation_, this.hasZ = void 0 !== e.hasZ && e.hasZ
			};
		n.
	default.inherits(v, a.a), v.schemaLocation_ = a.a.GMLNS + " http://schemas.opengis.net/gml/3.1.1/profiles/gmlsfProfile/1.0.0/gmlsf.xsd", v.prototype.readMultiCurve_ = function(t, e) {
			var i = m.a.pushParseAndPop([], this.MULTICURVE_PARSERS_, t, e, this);
			if (i) {
				var n = new d.
			default (null);
				return n.setLineStrings(i), n
			}
		}, v.prototype.readMultiSurface_ = function(t, e) {
			var i = m.a.pushParseAndPop([], this.MULTISURFACE_PARSERS_, t, e, this);
			if (i) {
				var n = new f.a(null);
				return n.setPolygons(i), n
			}
		}, v.prototype.curveMemberParser_ = function(t, e) {
			m.a.parseNode(this.CURVEMEMBER_PARSERS_, t, e, this)
		}, v.prototype.surfaceMemberParser_ = function(t, e) {
			m.a.parseNode(this.SURFACEMEMBER_PARSERS_, t, e, this)
		}, v.prototype.readPatch_ = function(t, e) {
			return m.a.pushParseAndPop([null], this.PATCHES_PARSERS_, t, e, this)
		}, v.prototype.readSegment_ = function(t, e) {
			return m.a.pushParseAndPop([null], this.SEGMENTS_PARSERS_, t, e, this)
		}, v.prototype.readPolygonPatch_ = function(t, e) {
			return m.a.pushParseAndPop([null], this.FLAT_LINEAR_RINGS_PARSERS_, t, e, this)
		}, v.prototype.readLineStringSegment_ = function(t, e) {
			return m.a.pushParseAndPop([null], this.GEOMETRY_FLAT_COORDINATES_PARSERS_, t, e, this)
		}, v.prototype.interiorParser_ = function(t, e) {
			var i = m.a.pushParseAndPop(void 0, this.RING_PARSERS, t, e, this);
			i && e[e.length - 1].push(i)
		}, v.prototype.exteriorParser_ = function(t, e) {
			var i = m.a.pushParseAndPop(void 0, this.RING_PARSERS, t, e, this);
			i && (e[e.length - 1][0] = i)
		}, v.prototype.readSurface_ = function(t, e) {
			var i = m.a.pushParseAndPop([null], this.SURFACE_PARSERS_, t, e, this);
			if (i && i[0]) {
				var n, o, s = new A.
			default (null),
					a = i[0],
					l = [a.length];
				for (n = 1, o = i.length; n < o; ++n) r.a.extend(a, i[n]), l.push(a.length);
				return s.setFlatCoordinates(h.a.XYZ, a, l), s
			}
		}, v.prototype.readCurve_ = function(t, e) {
			var i = m.a.pushParseAndPop([null], this.CURVE_PARSERS_, t, e, this);
			if (i) {
				var n = new c.
			default (null);
				return n.setFlatCoordinates(h.a.XYZ, i), n
			}
		}, v.prototype.readEnvelope_ = function(t, e) {
			var i = m.a.pushParseAndPop([null], this.ENVELOPE_PARSERS_, t, e, this);
			return o.
		default.createOrUpdate(i[1][0], i[1][1], i[2][0], i[2][1])
		}, v.prototype.readFlatPos_ = function(t, e) {
			for (var i, n = m.a.getAllTextContent(t, !1), r = /^\s*([+\-]?\d*\.?\d+(?:[eE][+\-]?\d+)?)\s*/, o = []; i = r.exec(n);) o.push(parseFloat(i[1])), n = n.substr(i[0].length);
			if ("" === n) {
				var s, a, l = e[0].srsName,
					u = "enu";
				if (l) u = g.
			default.get(l).getAxisOrientation();
				if ("neu" === u) for (s = 0, a = o.length; s < a; s += 3) {
					var h = o[s],
						c = o[s + 1];
					o[s] = c, o[s + 1] = h
				}
				var d = o.length;
				if (2 == d && o.push(0), 0 !== d) return o
			}
		}, v.prototype.readFlatPosList_ = function(t, e) {
			var i = m.a.getAllTextContent(t, !1).replace(/^\s*|\s*$/g, ""),
				n = e[0],
				r = n.srsName,
				o = n.srsDimension,
				s = "enu";
			r && (s = g.
		default.get(r).getAxisOrientation());
			var a, u, h, c = i.split(/\s+/),
				d = 2;
			t.getAttribute("srsDimension") ? d = l.a.readNonNegativeIntegerString(t.getAttribute("srsDimension")) : t.getAttribute("dimension") ? d = l.a.readNonNegativeIntegerString(t.getAttribute("dimension")) : t.parentNode.getAttribute("srsDimension") ? d = l.a.readNonNegativeIntegerString(t.parentNode.getAttribute("srsDimension")) : o && (d = l.a.readNonNegativeIntegerString(o));
			for (var f = [], A = 0, p = c.length; A < p; A += d) a = parseFloat(c[A]), u = parseFloat(c[A + 1]), h = 3 === d ? parseFloat(c[A + 2]) : 0, "en" === s.substr(0, 2) ? f.push(a, u, h) : f.push(u, a, h);
			return f
		}, v.prototype.GEOMETRY_FLAT_COORDINATES_PARSERS_ = {
			"http://www.opengis.net/gml": {
				pos: m.a.makeReplacer(v.prototype.readFlatPos_),
				posList: m.a.makeReplacer(v.prototype.readFlatPosList_)
			}
		}, v.prototype.FLAT_LINEAR_RINGS_PARSERS_ = {
			"http://www.opengis.net/gml": {
				interior: v.prototype.interiorParser_,
				exterior: v.prototype.exteriorParser_
			}
		}, v.prototype.GEOMETRY_PARSERS_ = {
			"http://www.opengis.net/gml": {
				Point: m.a.makeReplacer(a.a.prototype.readPoint),
				MultiPoint: m.a.makeReplacer(a.a.prototype.readMultiPoint),
				LineString: m.a.makeReplacer(a.a.prototype.readLineString),
				MultiLineString: m.a.makeReplacer(a.a.prototype.readMultiLineString),
				LinearRing: m.a.makeReplacer(a.a.prototype.readLinearRing),
				Polygon: m.a.makeReplacer(a.a.prototype.readPolygon),
				MultiPolygon: m.a.makeReplacer(a.a.prototype.readMultiPolygon),
				Surface: m.a.makeReplacer(v.prototype.readSurface_),
				MultiSurface: m.a.makeReplacer(v.prototype.readMultiSurface_),
				Curve: m.a.makeReplacer(v.prototype.readCurve_),
				MultiCurve: m.a.makeReplacer(v.prototype.readMultiCurve_),
				Envelope: m.a.makeReplacer(v.prototype.readEnvelope_)
			}
		}, v.prototype.MULTICURVE_PARSERS_ = {
			"http://www.opengis.net/gml": {
				curveMember: m.a.makeArrayPusher(v.prototype.curveMemberParser_),
				curveMembers: m.a.makeArrayPusher(v.prototype.curveMemberParser_)
			}
		}, v.prototype.MULTISURFACE_PARSERS_ = {
			"http://www.opengis.net/gml": {
				surfaceMember: m.a.makeArrayPusher(v.prototype.surfaceMemberParser_),
				surfaceMembers: m.a.makeArrayPusher(v.prototype.surfaceMemberParser_)
			}
		}, v.prototype.CURVEMEMBER_PARSERS_ = {
			"http://www.opengis.net/gml": {
				LineString: m.a.makeArrayPusher(a.a.prototype.readLineString),
				Curve: m.a.makeArrayPusher(v.prototype.readCurve_)
			}
		}, v.prototype.SURFACEMEMBER_PARSERS_ = {
			"http://www.opengis.net/gml": {
				Polygon: m.a.makeArrayPusher(a.a.prototype.readPolygon),
				Surface: m.a.makeArrayPusher(v.prototype.readSurface_)
			}
		}, v.prototype.SURFACE_PARSERS_ = {
			"http://www.opengis.net/gml": {
				patches: m.a.makeReplacer(v.prototype.readPatch_)
			}
		}, v.prototype.CURVE_PARSERS_ = {
			"http://www.opengis.net/gml": {
				segments: m.a.makeReplacer(v.prototype.readSegment_)
			}
		}, v.prototype.ENVELOPE_PARSERS_ = {
			"http://www.opengis.net/gml": {
				lowerCorner: m.a.makeArrayPusher(v.prototype.readFlatPosList_),
				upperCorner: m.a.makeArrayPusher(v.prototype.readFlatPosList_)
			}
		}, v.prototype.PATCHES_PARSERS_ = {
			"http://www.opengis.net/gml": {
				PolygonPatch: m.a.makeReplacer(v.prototype.readPolygonPatch_)
			}
		}, v.prototype.SEGMENTS_PARSERS_ = {
			"http://www.opengis.net/gml": {
				LineStringSegment: m.a.makeReplacer(v.prototype.readLineStringSegment_)
			}
		}, v.prototype.writePos_ = function(t, e, i) {
			var n = i[i.length - 1],
				r = n.hasZ,
				o = r ? 3 : 2;
			t.setAttribute("srsDimension", o);
			var s = n.srsName,
				a = "enu";
			s && (a = g.
		default.get(s).getAxisOrientation());
			var u, h = e.getCoordinates();
			(u = "en" === a.substr(0, 2) ? h[0] + " " + h[1] : h[1] + " " + h[0], r) && (u += " " + (h[2] || 0));
			l.a.writeStringTextNode(t, u)
		}, v.prototype.getCoords_ = function(t, e, i) {
			var n = "enu";
			e && (n = g.
		default.get(e).getAxisOrientation());
			var r = "en" === n.substr(0, 2) ? t[0] + " " + t[1] : t[1] + " " + t[0];
			i && (r += " " + (t[2] || 0));
			return r
		}, v.prototype.writePosList_ = function(t, e, i) {
			var n = i[i.length - 1],
				r = n.hasZ,
				o = r ? 3 : 2;
			t.setAttribute("srsDimension", o);
			for (var s, a = n.srsName, u = e.getCoordinates(), h = u.length, c = new Array(h), d = 0; d < h; ++d) s = u[d], c[d] = this.getCoords_(s, a, r);
			l.a.writeStringTextNode(t, c.join(" "))
		}, v.prototype.writePoint_ = function(t, e, i) {
			var n = i[i.length - 1].srsName;
			n && t.setAttribute("srsName", n);
			var r = m.a.createElementNS(t.namespaceURI, "pos");
			t.appendChild(r), this.writePos_(r, e, i)
		}, v.ENVELOPE_SERIALIZERS_ = {
			"http://www.opengis.net/gml": {
				lowerCorner: m.a.makeChildAppender(l.a.writeStringTextNode),
				upperCorner: m.a.makeChildAppender(l.a.writeStringTextNode)
			}
		}, v.prototype.writeEnvelope = function(t, e, i) {
			var n = i[i.length - 1].srsName;
			n && t.setAttribute("srsName", n);
			var r = [e[0] + " " + e[1], e[2] + " " + e[3]];
			m.a.pushSerializeAndPop({
				node: t
			}, v.ENVELOPE_SERIALIZERS_, m.a.OBJECT_PROPERTY_NODE_FACTORY, r, i, ["lowerCorner", "upperCorner"], this)
		}, v.prototype.writeLinearRing_ = function(t, e, i) {
			var n = i[i.length - 1].srsName;
			n && t.setAttribute("srsName", n);
			var r = m.a.createElementNS(t.namespaceURI, "posList");
			t.appendChild(r), this.writePosList_(r, e, i)
		}, v.prototype.RING_NODE_FACTORY_ = function(t, e, i) {
			var n = e[e.length - 1],
				r = n.node,
				o = n.exteriorWritten;
			return void 0 === o && (n.exteriorWritten = !0), m.a.createElementNS(r.namespaceURI, void 0 !== o ? "interior" : "exterior")
		}, v.prototype.writeSurfaceOrPolygon_ = function(t, e, i) {
			var n = i[i.length - 1],
				r = n.hasZ,
				o = n.srsName;
			if ("PolygonPatch" !== t.nodeName && o && t.setAttribute("srsName", o), "Polygon" === t.nodeName || "PolygonPatch" === t.nodeName) {
				var s = e.getLinearRings();
				m.a.pushSerializeAndPop({
					node: t,
					hasZ: r,
					srsName: o
				}, v.RING_SERIALIZERS_, this.RING_NODE_FACTORY_, s, i, void 0, this)
			} else if ("Surface" === t.nodeName) {
				var a = m.a.createElementNS(t.namespaceURI, "patches");
				t.appendChild(a), this.writeSurfacePatches_(a, e, i)
			}
		}, v.prototype.writeCurveOrLineString_ = function(t, e, i) {
			var n = i[i.length - 1].srsName;
			if ("LineStringSegment" !== t.nodeName && n && t.setAttribute("srsName", n), "LineString" === t.nodeName || "LineStringSegment" === t.nodeName) {
				var r = m.a.createElementNS(t.namespaceURI, "posList");
				t.appendChild(r), this.writePosList_(r, e, i)
			} else if ("Curve" === t.nodeName) {
				var o = m.a.createElementNS(t.namespaceURI, "segments");
				t.appendChild(o), this.writeCurveSegments_(o, e, i)
			}
		}, v.prototype.writeMultiSurfaceOrPolygon_ = function(t, e, i) {
			var n = i[i.length - 1],
				r = n.hasZ,
				o = n.srsName,
				s = n.surface;
			o && t.setAttribute("srsName", o);
			var a = e.getPolygons();
			m.a.pushSerializeAndPop({
				node: t,
				hasZ: r,
				srsName: o,
				surface: s
			}, v.SURFACEORPOLYGONMEMBER_SERIALIZERS_, this.MULTIGEOMETRY_MEMBER_NODE_FACTORY_, a, i, void 0, this)
		}, v.prototype.writeMultiPoint_ = function(t, e, i) {
			var n = i[i.length - 1],
				r = n.srsName,
				o = n.hasZ;
			r && t.setAttribute("srsName", r);
			var s = e.getPoints();
			m.a.pushSerializeAndPop({
				node: t,
				hasZ: o,
				srsName: r
			}, v.POINTMEMBER_SERIALIZERS_, m.a.makeSimpleNodeFactory("pointMember"), s, i, void 0, this)
		}, v.prototype.writeMultiCurveOrLineString_ = function(t, e, i) {
			var n = i[i.length - 1],
				r = n.hasZ,
				o = n.srsName,
				s = n.curve;
			o && t.setAttribute("srsName", o);
			var a = e.getLineStrings();
			m.a.pushSerializeAndPop({
				node: t,
				hasZ: r,
				srsName: o,
				curve: s
			}, v.LINESTRINGORCURVEMEMBER_SERIALIZERS_, this.MULTIGEOMETRY_MEMBER_NODE_FACTORY_, a, i, void 0, this)
		}, v.prototype.writeRing_ = function(t, e, i) {
			var n = m.a.createElementNS(t.namespaceURI, "LinearRing");
			t.appendChild(n), this.writeLinearRing_(n, e, i)
		}, v.prototype.writeSurfaceOrPolygonMember_ = function(t, e, i) {
			var n = this.GEOMETRY_NODE_FACTORY_(e, i);
			n && (t.appendChild(n), this.writeSurfaceOrPolygon_(n, e, i))
		}, v.prototype.writePointMember_ = function(t, e, i) {
			var n = m.a.createElementNS(t.namespaceURI, "Point");
			t.appendChild(n), this.writePoint_(n, e, i)
		}, v.prototype.writeLineStringOrCurveMember_ = function(t, e, i) {
			var n = this.GEOMETRY_NODE_FACTORY_(e, i);
			n && (t.appendChild(n), this.writeCurveOrLineString_(n, e, i))
		}, v.prototype.writeSurfacePatches_ = function(t, e, i) {
			var n = m.a.createElementNS(t.namespaceURI, "PolygonPatch");
			t.appendChild(n), this.writeSurfaceOrPolygon_(n, e, i)
		}, v.prototype.writeCurveSegments_ = function(t, e, i) {
			var n = m.a.createElementNS(t.namespaceURI, "LineStringSegment");
			t.appendChild(n), this.writeCurveOrLineString_(n, e, i)
		}, v.prototype.writeGeometryElement = function(t, e, i) {
			var n, r = i[i.length - 1],
				o = p.a.assign({}, r);
			o.node = t, n = Array.isArray(e) ? r.dataProjection ? g.
		default.transformExtent(e, r.featureProjection, r.dataProjection):
			e : s.a.transformWithOptions(e, !0, r), m.a.pushSerializeAndPop(o, v.GEOMETRY_SERIALIZERS_, this.GEOMETRY_NODE_FACTORY_, [n], i, void 0, this)
		}, v.prototype.writeFeatureElement = function(t, e, i) {
			var n = e.getId();
			n && t.setAttribute("fid", n);
			var r = i[i.length - 1],
				o = r.featureNS,
				s = e.getGeometryName();
			r.serializers || (r.serializers = {}, r.serializers[o] = {});
			var a = e.getProperties(),
				h = [],
				c = [];
			for (var d in a) {
				var f = a[d];
				null !== f && (h.push(d), c.push(f), d == s || f instanceof u.a ? d in r.serializers[o] || (r.serializers[o][d] = m.a.makeChildAppender(this.writeGeometryElement, this)) : d in r.serializers[o] || (r.serializers[o][d] = m.a.makeChildAppender(l.a.writeStringTextNode)))
			}
			var A = p.a.assign({}, r);
			A.node = t, m.a.pushSerializeAndPop(A, r.serializers, m.a.makeSimpleNodeFactory(void 0, o), c, i, h)
		}, v.prototype.writeFeatureMembers_ = function(t, e, i) {
			var n = i[i.length - 1],
				r = n.featureType,
				o = n.featureNS,
				s = {};
			s[o] = {}, s[o][r] = m.a.makeChildAppender(this.writeFeatureElement, this);
			var a = p.a.assign({}, n);
			a.node = t, m.a.pushSerializeAndPop(a, s, m.a.makeSimpleNodeFactory(r, o), e, i)
		}, v.SURFACEORPOLYGONMEMBER_SERIALIZERS_ = {
			"http://www.opengis.net/gml": {
				surfaceMember: m.a.makeChildAppender(v.prototype.writeSurfaceOrPolygonMember_),
				polygonMember: m.a.makeChildAppender(v.prototype.writeSurfaceOrPolygonMember_)
			}
		}, v.POINTMEMBER_SERIALIZERS_ = {
			"http://www.opengis.net/gml": {
				pointMember: m.a.makeChildAppender(v.prototype.writePointMember_)
			}
		}, v.LINESTRINGORCURVEMEMBER_SERIALIZERS_ = {
			"http://www.opengis.net/gml": {
				lineStringMember: m.a.makeChildAppender(v.prototype.writeLineStringOrCurveMember_),
				curveMember: m.a.makeChildAppender(v.prototype.writeLineStringOrCurveMember_)
			}
		}, v.RING_SERIALIZERS_ = {
			"http://www.opengis.net/gml": {
				exterior: m.a.makeChildAppender(v.prototype.writeRing_),
				interior: m.a.makeChildAppender(v.prototype.writeRing_)
			}
		}, v.GEOMETRY_SERIALIZERS_ = {
			"http://www.opengis.net/gml": {
				Curve: m.a.makeChildAppender(v.prototype.writeCurveOrLineString_),
				MultiCurve: m.a.makeChildAppender(v.prototype.writeMultiCurveOrLineString_),
				Point: m.a.makeChildAppender(v.prototype.writePoint_),
				MultiPoint: m.a.makeChildAppender(v.prototype.writeMultiPoint_),
				LineString: m.a.makeChildAppender(v.prototype.writeCurveOrLineString_),
				MultiLineString: m.a.makeChildAppender(v.prototype.writeMultiCurveOrLineString_),
				LinearRing: m.a.makeChildAppender(v.prototype.writeLinearRing_),
				Polygon: m.a.makeChildAppender(v.prototype.writeSurfaceOrPolygon_),
				MultiPolygon: m.a.makeChildAppender(v.prototype.writeMultiSurfaceOrPolygon_),
				Surface: m.a.makeChildAppender(v.prototype.writeSurfaceOrPolygon_),
				MultiSurface: m.a.makeChildAppender(v.prototype.writeMultiSurfaceOrPolygon_),
				Envelope: m.a.makeChildAppender(v.prototype.writeEnvelope)
			}
		}, v.MULTIGEOMETRY_TO_MEMBER_NODENAME_ = {
			MultiLineString: "lineStringMember",
			MultiCurve: "curveMember",
			MultiPolygon: "polygonMember",
			MultiSurface: "surfaceMember"
		}, v.prototype.MULTIGEOMETRY_MEMBER_NODE_FACTORY_ = function(t, e, i) {
			var n = e[e.length - 1].node;
			return m.a.createElementNS("http://www.opengis.net/gml", v.MULTIGEOMETRY_TO_MEMBER_NODENAME_[n.nodeName])
		}, v.prototype.GEOMETRY_NODE_FACTORY_ = function(t, e, i) {
			var n, r = e[e.length - 1],
				o = r.multiSurface,
				s = r.surface,
				a = r.curve,
				l = r.multiCurve;
			return Array.isArray(t) ? n = "Envelope" : "MultiPolygon" === (n = t.getType()) && !0 === o ? n = "MultiSurface" : "Polygon" === n && !0 === s ? n = "Surface" : "LineString" === n && !0 === a ? n = "Curve" : "MultiLineString" === n && !0 === l && (n = "MultiCurve"), m.a.createElementNS("http://www.opengis.net/gml", n)
		}, v.prototype.writeGeometryNode = function(t, e) {
			e = this.adaptOptions(e);
			var i = m.a.createElementNS("http://www.opengis.net/gml", "geom"),
				n = {
					node: i,
					hasZ: this.hasZ,
					srsName: this.srsName,
					curve: this.curve_,
					surface: this.surface_,
					multiSurface: this.multiSurface_,
					multiCurve: this.multiCurve_
				};
			return e && p.a.assign(n, e), this.writeGeometryElement(i, t, [n]), i
		}, v.prototype.writeFeatures, v.prototype.writeFeaturesNode = function(t, e) {
			e = this.adaptOptions(e);
			var i = m.a.createElementNS("http://www.opengis.net/gml", "featureMembers");
			m.a.setAttributeNS(i, "http://www.w3.org/2001/XMLSchema-instance", "xsi:schemaLocation", this.schemaLocation);
			var n = {
				srsName: this.srsName,
				hasZ: this.hasZ,
				curve: this.curve_,
				surface: this.surface_,
				multiSurface: this.multiSurface_,
				multiCurve: this.multiCurve_,
				featureNS: this.featureNS,
				featureType: this.featureType
			};
			return e && p.a.assign(n, e), this.writeFeatureMembers_(i, t, [n]), i
		}, e.
	default = v
	}, function(t, e, i) {
		"use strict";
		i.r(e);
		var n = i(0),
			r = i(17),
			o = i(15),
			s = i(44),
			a = i(3),
			l = i(5),
			u = {
				FRACTION: "fraction",
				PIXELS: "pixels"
			},
			h = i(16),
			c = i(50),
			d = i(141),
			f = function(t, e, i, n, o, s) {
				c.a.call(this), this.hitDetectionImage_ = null, this.image_ = t || new Image, null !== n && (this.image_.crossOrigin = n), this.canvas_ = s ? document.createElement("CANVAS") : null, this.color_ = s, this.imageListenerKeys_ = null, this.imageState_ = o, this.size_ = i, this.src_ = e, this.tainting_ = !1, this.imageState_ == r.a.LOADED && this.determineTainting_()
			};
		n.
	default.inherits(f, c.a), f.get = function(t, e, i, n, r, o) {
			var s = d.a.iconImageCache,
				a = s.get(e, n, o);
			return a || (a = new f(t, e, i, n, r, o), s.set(e, n, o, a)), a
		}, f.prototype.determineTainting_ = function() {
			var t = h.a.createCanvasContext2D(1, 1);
			try {
				t.drawImage(this.image_, 0, 0), t.getImageData(0, 0, 1, 1)
			} catch (t) {
				this.tainting_ = !0
			}
		}, f.prototype.dispatchChangeEvent_ = function() {
			this.dispatchEvent(l.a.CHANGE)
		}, f.prototype.handleImageError_ = function() {
			this.imageState_ = r.a.ERROR, this.unlistenImage_(), this.dispatchChangeEvent_()
		}, f.prototype.handleImageLoad_ = function() {
			this.imageState_ = r.a.LOADED, this.size_ && (this.image_.width = this.size_[0], this.image_.height = this.size_[1]), this.size_ = [this.image_.width, this.image_.height], this.unlistenImage_(), this.determineTainting_(), this.replaceColor_(), this.dispatchChangeEvent_()
		}, f.prototype.getImage = function(t) {
			return this.canvas_ ? this.canvas_ : this.image_
		}, f.prototype.getImageState = function() {
			return this.imageState_
		}, f.prototype.getHitDetectionImage = function(t) {
			if (!this.hitDetectionImage_) if (this.tainting_) {
				var e = this.size_[0],
					i = this.size_[1],
					n = h.a.createCanvasContext2D(e, i);
				n.fillRect(0, 0, e, i), this.hitDetectionImage_ = n.canvas
			} else this.hitDetectionImage_ = this.image_;
			return this.hitDetectionImage_
		}, f.prototype.getSize = function() {
			return this.size_
		}, f.prototype.getSrc = function() {
			return this.src_
		}, f.prototype.load = function() {
			if (this.imageState_ == r.a.IDLE) {
				this.imageState_ = r.a.LOADING, this.imageListenerKeys_ = [a.a.listenOnce(this.image_, l.a.ERROR, this.handleImageError_, this), a.a.listenOnce(this.image_, l.a.LOAD, this.handleImageLoad_, this)];
				try {
					this.image_.src = this.src_
				} catch (t) {
					this.handleImageError_()
				}
			}
		}, f.prototype.replaceColor_ = function() {
			if (!this.tainting_ && null !== this.color_) {
				this.canvas_.width = this.image_.width, this.canvas_.height = this.image_.height;
				var t = this.canvas_.getContext("2d");
				t.drawImage(this.image_, 0, 0);
				for (var e = t.getImageData(0, 0, this.image_.width, this.image_.height), i = e.data, n = this.color_[0] / 255, r = this.color_[1] / 255, o = this.color_[2] / 255, s = 0, a = i.length; s < a; s += 4) i[s] *= n, i[s + 1] *= r, i[s + 2] *= o;
				t.putImageData(e, 0, 0)
			}
		}, f.prototype.unlistenImage_ = function() {
			this.imageListenerKeys_.forEach(a.a.unlistenByKey), this.imageListenerKeys_ = null
		};
		var A = f,
			p = {
				BOTTOM_LEFT: "bottom-left",
				BOTTOM_RIGHT: "bottom-right",
				TOP_LEFT: "top-left",
				TOP_RIGHT: "top-right"
			},
			g = i(108),
			m = function(t) {
				var e = t || {};
				this.anchor_ = void 0 !== e.anchor ? e.anchor : [.5, .5], this.normalizedAnchor_ = null, this.anchorOrigin_ = void 0 !== e.anchorOrigin ? e.anchorOrigin : p.TOP_LEFT, this.anchorXUnits_ = void 0 !== e.anchorXUnits ? e.anchorXUnits : u.FRACTION, this.anchorYUnits_ = void 0 !== e.anchorYUnits ? e.anchorYUnits : u.FRACTION, this.crossOrigin_ = void 0 !== e.crossOrigin ? e.crossOrigin : null;
				var i = void 0 !== e.img ? e.img : null,
					a = void 0 !== e.imgSize ? e.imgSize : null,
					l = e.src;
				o.a.assert(!(void 0 !== l && i), 4), o.a.assert(!i || i && a, 5), void 0 !== l && 0 !== l.length || !i || (l = i.src || n.
			default.getUid(i).toString()), o.a.assert(void 0 !== l && l.length > 0, 6);
				var h = void 0 !== e.src ? r.a.IDLE : r.a.LOADED;
				this.color_ = void 0 !== e.color ? s.a.asArray(e.color) : null, this.iconImage_ = A.get(i, l, a, this.crossOrigin_, h, this.color_), this.offset_ = void 0 !== e.offset ? e.offset : [0, 0], this.offsetOrigin_ = void 0 !== e.offsetOrigin ? e.offsetOrigin : p.TOP_LEFT, this.origin_ = null, this.size_ = void 0 !== e.size ? e.size : null;
				var c = void 0 !== e.opacity ? e.opacity : 1,
					d = void 0 !== e.rotateWithView && e.rotateWithView,
					f = void 0 !== e.rotation ? e.rotation : 0,
					m = void 0 !== e.scale ? e.scale : 1,
					v = void 0 === e.snapToPixel || e.snapToPixel;
				g.a.call(this, {
					opacity: c,
					rotation: f,
					scale: m,
					snapToPixel: v,
					rotateWithView: d
				})
			};
		n.
	default.inherits(m, g.a), m.prototype.clone = function() {
			return new m({
				anchor: this.anchor_.slice(),
				anchorOrigin: this.anchorOrigin_,
				anchorXUnits: this.anchorXUnits_,
				anchorYUnits: this.anchorYUnits_,
				crossOrigin: this.crossOrigin_,
				color: this.color_ && this.color_.slice ? this.color_.slice() : this.color_ || void 0,
				src: this.getSrc(),
				offset: this.offset_.slice(),
				offsetOrigin: this.offsetOrigin_,
				size: null !== this.size_ ? this.size_.slice() : void 0,
				opacity: this.getOpacity(),
				scale: this.getScale(),
				snapToPixel: this.getSnapToPixel(),
				rotation: this.getRotation(),
				rotateWithView: this.getRotateWithView()
			})
		}, m.prototype.getAnchor = function() {
			if (this.normalizedAnchor_) return this.normalizedAnchor_;
			var t = this.anchor_,
				e = this.getSize();
			if (this.anchorXUnits_ == u.FRACTION || this.anchorYUnits_ == u.FRACTION) {
				if (!e) return null;
				t = this.anchor_.slice(), this.anchorXUnits_ == u.FRACTION && (t[0] *= e[0]), this.anchorYUnits_ == u.FRACTION && (t[1] *= e[1])
			}
			if (this.anchorOrigin_ != p.TOP_LEFT) {
				if (!e) return null;
				t === this.anchor_ && (t = this.anchor_.slice()), this.anchorOrigin_ != p.TOP_RIGHT && this.anchorOrigin_ != p.BOTTOM_RIGHT || (t[0] = -t[0] + e[0]), this.anchorOrigin_ != p.BOTTOM_LEFT && this.anchorOrigin_ != p.BOTTOM_RIGHT || (t[1] = -t[1] + e[1])
			}
			return this.normalizedAnchor_ = t, this.normalizedAnchor_
		}, m.prototype.getColor = function() {
			return this.color_
		}, m.prototype.getImage = function(t) {
			return this.iconImage_.getImage(t)
		}, m.prototype.getImageSize = function() {
			return this.iconImage_.getSize()
		}, m.prototype.getHitDetectionImageSize = function() {
			return this.getImageSize()
		}, m.prototype.getImageState = function() {
			return this.iconImage_.getImageState()
		}, m.prototype.getHitDetectionImage = function(t) {
			return this.iconImage_.getHitDetectionImage(t)
		}, m.prototype.getOrigin = function() {
			if (this.origin_) return this.origin_;
			var t = this.offset_;
			if (this.offsetOrigin_ != p.TOP_LEFT) {
				var e = this.getSize(),
					i = this.iconImage_.getSize();
				if (!e || !i) return null;
				t = t.slice(), this.offsetOrigin_ != p.TOP_RIGHT && this.offsetOrigin_ != p.BOTTOM_RIGHT || (t[0] = i[0] - e[0] - t[0]), this.offsetOrigin_ != p.BOTTOM_LEFT && this.offsetOrigin_ != p.BOTTOM_RIGHT || (t[1] = i[1] - e[1] - t[1])
			}
			return this.origin_ = t, this.origin_
		}, m.prototype.getSrc = function() {
			return this.iconImage_.getSrc()
		}, m.prototype.getSize = function() {
			return this.size_ ? this.size_ : this.iconImage_.getSize()
		}, m.prototype.listenImageChange = function(t, e) {
			return a.a.listen(this.iconImage_, l.a.CHANGE, t, e)
		}, m.prototype.load = function() {
			this.iconImage_.load()
		}, m.prototype.unlistenImageChange = function(t, e) {
			a.a.unlisten(this.iconImage_, l.a.CHANGE, t, e)
		};
		e.
	default = m
	}, function(t, e, i) {
		"use strict";
		i.r(e);
		var n = i(11),
			r = i(4),
			o = function(t) {
				this.radius = t
			};
		o.prototype.geodesicArea = function(t) {
			return o.getArea_(t, this.radius)
		}, o.prototype.haversineDistance = function(t, e) {
			return o.getDistance_(t, e, this.radius)
		}, o.prototype.offset = function(t, e, i) {
			var r = n.a.toRadians(t[1]),
				o = n.a.toRadians(t[0]),
				s = e / this.radius,
				a = Math.asin(Math.sin(r) * Math.cos(s) + Math.cos(r) * Math.sin(s) * Math.cos(i)),
				l = o + Math.atan2(Math.sin(i) * Math.sin(s) * Math.cos(r), Math.cos(s) - Math.sin(r) * Math.sin(a));
			return [n.a.toDegrees(l), n.a.toDegrees(a)]
		}, o.DEFAULT_RADIUS = 6371008.8, o.getLength = function(t, e) {
			var i, n, s, a, l, u, h = e || {},
				c = h.radius || o.DEFAULT_RADIUS,
				d = h.projection || "EPSG:3857",
				f = (t = t.clone().transform(d, "EPSG:4326")).getType(),
				A = 0;
			switch (f) {
			case r.a.POINT:
			case r.a.MULTI_POINT:
				break;
			case r.a.LINE_STRING:
			case r.a.LINEAR_RING:
				i = t.getCoordinates(), A = o.getLength_(i, c);
				break;
			case r.a.MULTI_LINE_STRING:
			case r.a.POLYGON:
				for (s = 0, a = (i = t.getCoordinates()).length; s < a; ++s) A += o.getLength_(i[s], c);
				break;
			case r.a.MULTI_POLYGON:
				for (s = 0, a = (i = t.getCoordinates()).length; s < a; ++s) for (l = 0, u = (n = i[s]).length; l < u; ++l) A += o.getLength_(n[l], c);
				break;
			case r.a.GEOMETRY_COLLECTION:
				var p = t.getGeometries();
				for (s = 0, a = p.length; s < a; ++s) A += o.getLength(p[s], e);
				break;
			default:
				throw new Error("Unsupported geometry type: " + f)
			}
			return A
		}, o.getLength_ = function(t, e) {
			for (var i = 0, n = 0, r = t.length; n < r - 1; ++n) i += o.getDistance_(t[n], t[n + 1], e);
			return i
		}, o.getDistance_ = function(t, e, i) {
			var r = n.a.toRadians(t[1]),
				o = n.a.toRadians(e[1]),
				s = (o - r) / 2,
				a = n.a.toRadians(e[0] - t[0]) / 2,
				l = Math.sin(s) * Math.sin(s) + Math.sin(a) * Math.sin(a) * Math.cos(r) * Math.cos(o);
			return 2 * i * Math.atan2(Math.sqrt(l), Math.sqrt(1 - l))
		}, o.getArea = function(t, e) {
			var i, n, s, a, l, u, h = e || {},
				c = h.radius || o.DEFAULT_RADIUS,
				d = h.projection || "EPSG:3857",
				f = (t = t.clone().transform(d, "EPSG:4326")).getType(),
				A = 0;
			switch (f) {
			case r.a.POINT:
			case r.a.MULTI_POINT:
			case r.a.LINE_STRING:
			case r.a.MULTI_LINE_STRING:
			case r.a.LINEAR_RING:
				break;
			case r.a.POLYGON:
				for (i = t.getCoordinates(), A = Math.abs(o.getArea_(i[0], c)), s = 1, a = i.length; s < a; ++s) A -= Math.abs(o.getArea_(i[s], c));
				break;
			case r.a.MULTI_POLYGON:
				for (s = 0, a = (i = t.getCoordinates()).length; s < a; ++s) for (n = i[s], A += Math.abs(o.getArea_(n[0], c)), l = 1, u = n.length; l < u; ++l) A -= Math.abs(o.getArea_(n[l], c));
				break;
			case r.a.GEOMETRY_COLLECTION:
				var p = t.getGeometries();
				for (s = 0, a = p.length; s < a; ++s) A += o.getArea(p[s], e);
				break;
			default:
				throw new Error("Unsupported geometry type: " + f)
			}
			return A
		}, o.getArea_ = function(t, e) {
			for (var i = 0, r = t.length, o = t[r - 1][0], s = t[r - 1][1], a = 0; a < r; a++) {
				var l = t[a][0],
					u = t[a][1];
				i += n.a.toRadians(l - o) * (2 + Math.sin(n.a.toRadians(s)) + Math.sin(n.a.toRadians(u))), o = l, s = u
			}
			return i * e * e / 2
		}, e.
	default = o
	}, function(t, e, i) {
		"use strict";
		var n = {
			linearRing: function(t, e, i, n) {
				for (var r = 0, o = t[i - n], s = t[i - n + 1]; e < i; e += n) {
					var a = t[e],
						l = t[e + 1];
					r += s * a - o * l, o = a, s = l
				}
				return r / 2
			},
			linearRings: function(t, e, i, r) {
				var o, s, a = 0;
				for (o = 0, s = i.length; o < s; ++o) {
					var l = i[o];
					a += n.linearRing(t, e, l, r), e = l
				}
				return a
			},
			linearRingss: function(t, e, i, r) {
				var o, s, a = 0;
				for (o = 0, s = i.length; o < s; ++o) {
					var l = i[o];
					a += n.linearRings(t, e, l, r), e = l[l.length - 1]
				}
				return a
			}
		};
		e.a = n
	}, function(t, e, i) {
		"use strict";
		var n = i(1),
			r = i(72),
			o = i(134),
			s = {
				lineString: function(t, e, i, r, s) {
					var a = n.
				default.extendFlatCoordinates(n.
				default.createEmpty(), t, e, i, r);
					return !!n.
				default.intersects(s, a) && ( !! n.
				default.containsExtent(s, a) || (a[0] >= s[0] && a[2] <= s[2] || (a[1] >= s[1] && a[3] <= s[3] || o.a.forEach(t, e, i, r, (function(t, e) {
						return n.
					default.intersectsSegment(s, t, e)
					})))))
				},
				lineStrings: function(t, e, i, n, r) {
					var o, a;
					for (o = 0, a = i.length; o < a; ++o) {
						if (s.lineString(t, e, i[o], n, r)) return !0;
						e = i[o]
					}
					return !1
				},
				linearRing: function(t, e, i, n, o) {
					return !!s.lineString(t, e, i, n, o) || ( !! r.a.linearRingContainsXY(t, e, i, n, o[0], o[1]) || ( !! r.a.linearRingContainsXY(t, e, i, n, o[0], o[3]) || ( !! r.a.linearRingContainsXY(t, e, i, n, o[2], o[1]) || !! r.a.linearRingContainsXY(t, e, i, n, o[2], o[3]))))
				},
				linearRings: function(t, e, i, n, o) {
					if (!s.linearRing(t, e, i[0], n, o)) return !1;
					if (1 === i.length) return !0;
					var a, l;
					for (a = 1, l = i.length; a < l; ++a) if (r.a.linearRingContainsExtent(t, i[a - 1], i[a], n, o)) return !1;
					return !0
				},
				linearRingss: function(t, e, i, n, r) {
					var o, a;
					for (o = 0, a = i.length; o < a; ++o) {
						var l = i[o];
						if (s.linearRings(t, e, l, n, r)) return !0;
						e = l[l.length - 1]
					}
					return !1
				}
			};
		e.a = s
	}, function(t, e, i) {
		"use strict";
		var n = i(0),
			r = i(10),
			o = i(1),
			s = i(18),
			a = i(4),
			l = i(25),
			u = i(40),
			h = i(64),
			c = i(65),
			d = i(11),
			f = function(t, e) {
				u.a.call(this), this.setCoordinates(t, e)
			};
		n.
	default.inherits(f, u.a), f.prototype.appendPoint = function(t) {
			this.flatCoordinates ? r.a.extend(this.flatCoordinates, t.getFlatCoordinates()) : this.flatCoordinates = t.getFlatCoordinates().slice(), this.changed()
		}, f.prototype.clone = function() {
			var t = new f(null);
			return t.setFlatCoordinates(this.layout, this.flatCoordinates.slice()), t
		}, f.prototype.closestPointXY = function(t, e, i, n) {
			if (n < o.
		default.closestSquaredDistanceXY(this.getExtent(), t, e)) return n;
			var r, s, a, l = this.flatCoordinates,
				u = this.stride;
			for (r = 0, s = l.length; r < s; r += u) {
				var h = d.a.squaredDistance(t, e, l[r], l[r + 1]);
				if (h < n) {
					for (n = h, a = 0; a < u; ++a) i[a] = l[r + a];
					i.length = u
				}
			}
			return n
		}, f.prototype.getCoordinates = function() {
			return c.a.coordinates(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride)
		}, f.prototype.getPoint = function(t) {
			var e = this.flatCoordinates ? this.flatCoordinates.length / this.stride : 0;
			if (t < 0 || e <= t) return null;
			var i = new l.
		default (null);
			return i.setFlatCoordinates(this.layout, this.flatCoordinates.slice(t * this.stride, (t + 1) * this.stride)), i
		}, f.prototype.getPoints = function() {
			var t, e, i = this.flatCoordinates,
				n = this.layout,
				r = this.stride,
				o = [];
			for (t = 0, e = i.length; t < e; t += r) {
				var s = new l.
			default (null);
				s.setFlatCoordinates(n, i.slice(t, t + r)), o.push(s)
			}
			return o
		}, f.prototype.getType = function() {
			return a.a.MULTI_POINT
		}, f.prototype.intersectsExtent = function(t) {
			var e, i, n, r, s = this.flatCoordinates,
				a = this.stride;
			for (e = 0, i = s.length; e < i; e += a) if (n = s[e], r = s[e + 1], o.
		default.containsXY(t, n, r)) return !0;
			return !1
		}, f.prototype.setCoordinates = function(t, e) {
			t ? (this.setLayout(e, t, 1), this.flatCoordinates || (this.flatCoordinates = []), this.flatCoordinates.length = h.a.coordinates(this.flatCoordinates, 0, t, this.stride), this.changed()) : this.setFlatCoordinates(s.a.XY, null)
		}, f.prototype.setFlatCoordinates = function(t, e) {
			this.setFlatCoordinatesInternal(t, e), this.changed()
		}, e.a = f
	}, function(t, e, i) {
		"use strict";
		i.r(e);
		var n = i(0),
			r = i(1),
			o = i(18),
			s = i(4),
			a = i(40),
			l = i(64),
			u = function(t, e, i) {
				a.a.call(this);
				var n = e || 0;
				this.setCenterAndRadius(t, n, i)
			};
		n.
	default.inherits(u, a.a), u.prototype.clone = function() {
			var t = new u(null);
			return t.setFlatCoordinates(this.layout, this.flatCoordinates.slice()), t
		}, u.prototype.closestPointXY = function(t, e, i, n) {
			var r = this.flatCoordinates,
				o = t - r[0],
				s = e - r[1],
				a = o * o + s * s;
			if (a < n) {
				var l;
				if (0 === a) for (l = 0; l < this.stride; ++l) i[l] = r[l];
				else {
					var u = this.getRadius() / Math.sqrt(a);
					for (i[0] = r[0] + u * o, i[1] = r[1] + u * s, l = 2; l < this.stride; ++l) i[l] = r[l]
				}
				return i.length = this.stride, a
			}
			return n
		}, u.prototype.containsXY = function(t, e) {
			var i = this.flatCoordinates,
				n = t - i[0],
				r = e - i[1];
			return n * n + r * r <= this.getRadiusSquared_()
		}, u.prototype.getCenter = function() {
			return this.flatCoordinates.slice(0, this.stride)
		}, u.prototype.computeExtent = function(t) {
			var e = this.flatCoordinates,
				i = e[this.stride] - e[0];
			return r.
		default.createOrUpdate(e[0] - i, e[1] - i, e[0] + i, e[1] + i, t)
		}, u.prototype.getRadius = function() {
			return Math.sqrt(this.getRadiusSquared_())
		}, u.prototype.getRadiusSquared_ = function() {
			var t = this.flatCoordinates[this.stride] - this.flatCoordinates[0],
				e = this.flatCoordinates[this.stride + 1] - this.flatCoordinates[1];
			return t * t + e * e
		}, u.prototype.getType = function() {
			return s.a.CIRCLE
		}, u.prototype.intersectsExtent = function(t) {
			var e = this.getExtent();
			if (r.
		default.intersects(t, e)) {
				var i = this.getCenter();
				return t[0] <= i[0] && t[2] >= i[0] || (t[1] <= i[1] && t[3] >= i[1] || r.
			default.forEachCorner(t, this.intersectsCoordinate, this))
			}
			return !1
		}, u.prototype.setCenter = function(t) {
			var e, i = this.stride,
				n = this.flatCoordinates[i] - this.flatCoordinates[0],
				r = t.slice();
			for (r[i] = r[0] + n, e = 1; e < i; ++e) r[i + e] = t[e];
			this.setFlatCoordinates(this.layout, r)
		}, u.prototype.setCenterAndRadius = function(t, e, i) {
			if (t) {
				this.setLayout(i, t, 0), this.flatCoordinates || (this.flatCoordinates = []);
				var n, r, s = this.flatCoordinates,
					a = l.a.coordinate(s, 0, t, this.stride);
				for (s[a++] = s[0] + e, n = 1, r = this.stride; n < r; ++n) s[a++] = s[n];
				s.length = a, this.changed()
			} else this.setFlatCoordinates(o.a.XY, null)
		}, u.prototype.getCoordinates = function() {}, u.prototype.setCoordinates = function(t, e) {}, u.prototype.setFlatCoordinates = function(t, e) {
			this.setFlatCoordinatesInternal(t, e), this.changed()
		}, u.prototype.setRadius = function(t) {
			this.flatCoordinates[this.stride] = this.flatCoordinates[0] + t, this.changed()
		}, u.prototype.transform, e.
	default = u
	}, function(t, e, i) {
		"use strict";
		var n = i(0),
			r = i(10),
			o = i(1),
			s = i(18),
			a = i(4),
			l = i(104),
			u = i(31),
			h = i(40),
			c = i(102),
			d = {
				linearRingss: function(t, e, i, n) {
					var r, s, a = [],
						l = o.
					default.createEmpty();
					for (r = 0, s = i.length; r < s; ++r) {
						var u = i[r];
						l = o.
					default.createOrUpdateFromFlatCoordinates(t, e, u[0], n), a.push((l[0] + l[2]) / 2, (l[1] + l[3]) / 2), e = u[u.length - 1]
					}
					return a
				}
			},
			f = d,
			A = i(70),
			p = i(72),
			g = i(64),
			m = i(65),
			v = i(133),
			y = i(103),
			_ = i(73),
			E = i(76),
			x = function(t, e) {
				h.a.call(this), this.endss_ = [], this.flatInteriorPointsRevision_ = -1, this.flatInteriorPoints_ = null, this.maxDelta_ = -1, this.maxDeltaRevision_ = -1, this.orientedRevision_ = -1, this.orientedFlatCoordinates_ = null, this.setCoordinates(t, e)
			};
		n.
	default.inherits(x, h.a), x.prototype.appendPolygon = function(t) {
			var e;
			if (this.flatCoordinates) {
				var i, n, o = this.flatCoordinates.length;
				for (r.a.extend(this.flatCoordinates, t.getFlatCoordinates()), i = 0, n = (e = t.getEnds().slice()).length; i < n; ++i) e[i] += o
			} else this.flatCoordinates = t.getFlatCoordinates().slice(), e = t.getEnds().slice(), this.endss_.push();
			this.endss_.push(e), this.changed()
		}, x.prototype.clone = function() {
			for (var t = new x(null), e = this.endss_.length, i = new Array(e), n = 0; n < e; ++n) i[n] = this.endss_[n].slice();
			return t.setFlatCoordinates(this.layout, this.flatCoordinates.slice(), i), t
		}, x.prototype.closestPointXY = function(t, e, i, n) {
			return n < o.
		default.closestSquaredDistanceXY(this.getExtent(), t, e) ? n:
			(this.maxDeltaRevision_ != this.getRevision() && (this.maxDelta_ = Math.sqrt(A.a.getssMaxSquaredDelta(this.flatCoordinates, 0, this.endss_, this.stride, 0)), this.maxDeltaRevision_ = this.getRevision()), A.a.getssClosestPoint(this.getOrientedFlatCoordinates(), 0, this.endss_, this.stride, this.maxDelta_, !0, t, e, i, n))
		}, x.prototype.containsXY = function(t, e) {
			return p.a.linearRingssContainsXY(this.getOrientedFlatCoordinates(), 0, this.endss_, this.stride, t, e)
		}, x.prototype.getArea = function() {
			return c.a.linearRingss(this.getOrientedFlatCoordinates(), 0, this.endss_, this.stride)
		}, x.prototype.getCoordinates = function(t) {
			var e;
			return void 0 !== t ? (e = this.getOrientedFlatCoordinates().slice(), _.a.orientLinearRingss(e, 0, this.endss_, this.stride, t)) : e = this.flatCoordinates, m.a.coordinatesss(e, 0, this.endss_, this.stride)
		}, x.prototype.getEndss = function() {
			return this.endss_
		}, x.prototype.getFlatInteriorPoints = function() {
			if (this.flatInteriorPointsRevision_ != this.getRevision()) {
				var t = f.linearRingss(this.flatCoordinates, 0, this.endss_, this.stride);
				this.flatInteriorPoints_ = v.a.linearRingss(this.getOrientedFlatCoordinates(), 0, this.endss_, this.stride, t), this.flatInteriorPointsRevision_ = this.getRevision()
			}
			return this.flatInteriorPoints_
		}, x.prototype.getInteriorPoints = function() {
			var t = new l.a(null);
			return t.setFlatCoordinates(s.a.XYM, this.getFlatInteriorPoints().slice()), t
		}, x.prototype.getOrientedFlatCoordinates = function() {
			if (this.orientedRevision_ != this.getRevision()) {
				var t = this.flatCoordinates;
				_.a.linearRingssAreOriented(t, 0, this.endss_, this.stride) ? this.orientedFlatCoordinates_ = t : (this.orientedFlatCoordinates_ = t.slice(), this.orientedFlatCoordinates_.length = _.a.orientLinearRingss(this.orientedFlatCoordinates_, 0, this.endss_, this.stride)), this.orientedRevision_ = this.getRevision()
			}
			return this.orientedFlatCoordinates_
		}, x.prototype.getSimplifiedGeometryInternal = function(t) {
			var e = [],
				i = [];
			e.length = E.a.quantizess(this.flatCoordinates, 0, this.endss_, this.stride, Math.sqrt(t), e, 0, i);
			var n = new x(null);
			return n.setFlatCoordinates(s.a.XY, e, i), n
		}, x.prototype.getPolygon = function(t) {
			if (t < 0 || this.endss_.length <= t) return null;
			var e;
			if (0 === t) e = 0;
			else {
				var i = this.endss_[t - 1];
				e = i[i.length - 1]
			}
			var n, r, o = this.endss_[t].slice(),
				s = o[o.length - 1];
			if (0 !== e) for (n = 0, r = o.length; n < r; ++n) o[n] -= e;
			var a = new u.
		default (null);
			return a.setFlatCoordinates(this.layout, this.flatCoordinates.slice(e, s), o), a
		}, x.prototype.getPolygons = function() {
			var t, e, i, n, r = this.layout,
				o = this.flatCoordinates,
				s = this.endss_,
				a = [],
				l = 0;
			for (t = 0, e = s.length; t < e; ++t) {
				var h = s[t].slice(),
					c = h[h.length - 1];
				if (0 !== l) for (i = 0, n = h.length; i < n; ++i) h[i] -= l;
				var d = new u.
			default (null);
				d.setFlatCoordinates(r, o.slice(l, c), h), a.push(d), l = c
			}
			return a
		}, x.prototype.getType = function() {
			return a.a.MULTI_POLYGON
		}, x.prototype.intersectsExtent = function(t) {
			return y.a.linearRingss(this.getOrientedFlatCoordinates(), 0, this.endss_, this.stride, t)
		}, x.prototype.setCoordinates = function(t, e) {
			if (t) {
				this.setLayout(e, t, 3), this.flatCoordinates || (this.flatCoordinates = []);
				var i = g.a.coordinatesss(this.flatCoordinates, 0, t, this.stride, this.endss_);
				if (0 === i.length) this.flatCoordinates.length = 0;
				else {
					var n = i[i.length - 1];
					this.flatCoordinates.length = 0 === n.length ? 0 : n[n.length - 1]
				}
				this.changed()
			} else this.setFlatCoordinates(s.a.XY, null, this.endss_)
		}, x.prototype.setFlatCoordinates = function(t, e, i) {
			this.setFlatCoordinatesInternal(t, e), this.endss_ = i, this.changed()
		}, x.prototype.setPolygons = function(t) {
			var e, i, n, o = this.getLayout(),
				s = [],
				a = [];
			for (e = 0, i = t.length; e < i; ++e) {
				var l = t[e];
				0 === e && (o = l.getLayout());
				var u, h, c = s.length;
				for (u = 0, h = (n = l.getEnds()).length; u < h; ++u) n[u] += c;
				r.a.extend(s, l.getFlatCoordinates()), a.push(n)
			}
			this.setFlatCoordinates(o, s, a)
		};
		e.a = x
	}, function(t, e, i) {
		"use strict";
		var n = i(16),
			r = i(1),
			o = i(11),
			s = i(9),
			a = {
				calculateSourceResolution: function(t, e, i, n) {
					var o = s.
				default.transform(i, e, t),
						a = s.
					default.getPointResolution(e, n, i),
						l = e.getMetersPerUnit();
					void 0 !== l && (a *= l);
					var u = t.getMetersPerUnit();
					void 0 !== u && (a /= u);
					var h = t.getExtent();
					if (!h || r.
				default.containsCoordinate(h, o)) {
						var c = s.
					default.getPointResolution(t, a, o) / a;
						isFinite(c) && c > 0 && (a /= c)
					}
					return a
				},
				enlargeClipPoint_: function(t, e, i, n) {
					var r = i - t,
						o = n - e,
						s = Math.sqrt(r * r + o * o);
					return [Math.round(i + r / s), Math.round(n + o / s)]
				},
				render: function(t, e, i, s, l, u, h, c, d, f, A) {
					var p = n.a.createCanvasContext2D(Math.round(i * t), Math.round(i * e));
					if (0 === d.length) return p.canvas;
					p.scale(i, i);
					var g = r.
				default.createEmpty();
					d.forEach((function(t, e, i) {
						r.
					default.extend(g, t.extent)
					}));
					var m = r.
				default.getWidth(g),
						v = r.
					default.getHeight(g),
						y = n.a.createCanvasContext2D(Math.round(i * m / s), Math.round(i * v / s)),
						_ = i / s;
					d.forEach((function(t, e, i) {
						var n = t.extent[0] - g[0],
							o = -(t.extent[3] - g[3]),
							s = r.
						default.getWidth(t.extent),
							a = r.
						default.getHeight(t.extent);
						y.drawImage(t.image, f, f, t.image.width - 2 * f, t.image.height - 2 * f, n * _, o * _, s * _, a * _)
					}));
					var E = r.
				default.getTopLeft(h);
					return c.getTriangles().forEach((function(t, e, n) {
						var r = t.source,
							l = t.target,
							h = r[0][0],
							c = r[0][1],
							d = r[1][0],
							f = r[1][1],
							A = r[2][0],
							m = r[2][1],
							v = (l[0][0] - E[0]) / u,
							_ = -(l[0][1] - E[1]) / u,
							x = (l[1][0] - E[0]) / u,
							C = -(l[1][1] - E[1]) / u,
							I = (l[2][0] - E[0]) / u,
							S = -(l[2][1] - E[1]) / u,
							T = h,
							R = c;
						h = 0, c = 0;
						var w = [
							[d -= T, f -= R, 0, 0, x - v],
							[A -= T, m -= R, 0, 0, I - v],
							[0, 0, d, f, C - _],
							[0, 0, A, m, S - _]
						],
							L = o.a.solveLinearSystem(w);
						if (L) {
							p.save(), p.beginPath();
							var N = (v + x + I) / 3,
								P = (_ + C + S) / 3,
								O = a.enlargeClipPoint_(N, P, v, _),
								M = a.enlargeClipPoint_(N, P, x, C),
								b = a.enlargeClipPoint_(N, P, I, S);
							p.moveTo(M[0], M[1]), p.lineTo(O[0], O[1]), p.lineTo(b[0], b[1]), p.clip(), p.transform(L[0], L[2], L[1], L[3], v, _), p.translate(g[0] - T, g[3] - R), p.scale(s / i, -s / i), p.drawImage(y.canvas, 0, 0), p.restore()
						}
					})), A && (p.save(), p.strokeStyle = "black", p.lineWidth = 1, c.getTriangles().forEach((function(t, e, i) {
						var n = t.target,
							r = (n[0][0] - E[0]) / u,
							o = -(n[0][1] - E[1]) / u,
							s = (n[1][0] - E[0]) / u,
							a = -(n[1][1] - E[1]) / u,
							l = (n[2][0] - E[0]) / u,
							h = -(n[2][1] - E[1]) / u;
						p.beginPath(), p.moveTo(s, a), p.lineTo(r, o), p.lineTo(l, h), p.closePath(), p.stroke()
					})), p.restore()), p.canvas
				}
			};
		e.a = a
	}, function(t, e, i) {
		"use strict";
		var n = function(t) {
				this.opacity_ = t.opacity, this.rotateWithView_ = t.rotateWithView, this.rotation_ = t.rotation, this.scale_ = t.scale, this.snapToPixel_ = t.snapToPixel
			};
		n.prototype.getOpacity = function() {
			return this.opacity_
		}, n.prototype.getRotateWithView = function() {
			return this.rotateWithView_
		}, n.prototype.getRotation = function() {
			return this.rotation_
		}, n.prototype.getScale = function() {
			return this.scale_
		}, n.prototype.getSnapToPixel = function() {
			return this.snapToPixel_
		}, n.prototype.getAnchor = function() {}, n.prototype.getImage = function(t) {}, n.prototype.getHitDetectionImage = function(t) {}, n.prototype.getImageState = function() {}, n.prototype.getImageSize = function() {}, n.prototype.getHitDetectionImageSize = function() {}, n.prototype.getOrigin = function() {}, n.prototype.getSize = function() {}, n.prototype.setOpacity = function(t) {
			this.opacity_ = t
		}, n.prototype.setRotateWithView = function(t) {
			this.rotateWithView_ = t
		}, n.prototype.setRotation = function(t) {
			this.rotation_ = t
		}, n.prototype.setScale = function(t) {
			this.scale_ = t
		}, n.prototype.setSnapToPixel = function(t) {
			this.snapToPixel_ = t
		}, n.prototype.listenImageChange = function(t, e) {}, n.prototype.load = function() {}, n.prototype.unlistenImageChange = function(t, e) {}, e.a = n
	}, function(t, e, i) {
		"use strict";
		e.a = {
			MAP_RENDERER: "MAP_RENDERER",
			LAYER_RENDERER: "LAYER_RENDERER"
		}
	}, function(t, e, i) {
		"use strict";
		i.r(e);
		var n = i(0),
			r = i(89),
			o = i(14),
			s = i(67),
			a = i(37),
			l = i(16),
			u = i(3),
			h = i(1),
			c = function(t) {
				o.a.call(this), this.options = t, this.id = t.id, this.insertFirst = void 0 === t.insertFirst || t.insertFirst, this.stopEvent = void 0 === t.stopEvent || t.stopEvent, this.element = document.createElement("DIV"), this.element.className = void 0 !== t.className ? t.className : "ol-overlay-container " + a.a.CLASS_SELECTABLE, this.element.style.position = "absolute", this.autoPan = void 0 !== t.autoPan && t.autoPan, this.autoPanAnimation = t.autoPanAnimation || {}, this.autoPanMargin = void 0 !== t.autoPanMargin ? t.autoPanMargin : 20, this.rendered = {
					bottom_: "",
					left_: "",
					right_: "",
					top_: "",
					visible: !0
				}, this.mapPostrenderListenerKey = null, u.a.listen(this, o.a.getChangeEventType(c.Property.ELEMENT), this.handleElementChanged, this), u.a.listen(this, o.a.getChangeEventType(c.Property.MAP), this.handleMapChanged, this), u.a.listen(this, o.a.getChangeEventType(c.Property.OFFSET), this.handleOffsetChanged, this), u.a.listen(this, o.a.getChangeEventType(c.Property.POSITION), this.handlePositionChanged, this), u.a.listen(this, o.a.getChangeEventType(c.Property.POSITIONING), this.handlePositioningChanged, this), void 0 !== t.element && this.setElement(t.element), this.setOffset(void 0 !== t.offset ? t.offset : [0, 0]), this.setPositioning(void 0 !== t.positioning ? t.positioning : s.a.TOP_LEFT), void 0 !== t.position && this.setPosition(t.position)
			};
		n.
	default.inherits(c, o.a), c.prototype.getElement = function() {
			return this.get(c.Property.ELEMENT)
		}, c.prototype.getId = function() {
			return this.id
		}, c.prototype.getMap = function() {
			return this.get(c.Property.MAP)
		}, c.prototype.getOffset = function() {
			return this.get(c.Property.OFFSET)
		}, c.prototype.getPosition = function() {
			return this.get(c.Property.POSITION)
		}, c.prototype.getPositioning = function() {
			return this.get(c.Property.POSITIONING)
		}, c.prototype.handleElementChanged = function() {
			l.a.removeChildren(this.element);
			var t = this.getElement();
			t && this.element.appendChild(t)
		}, c.prototype.handleMapChanged = function() {
			this.mapPostrenderListenerKey && (l.a.removeNode(this.element), u.a.unlistenByKey(this.mapPostrenderListenerKey), this.mapPostrenderListenerKey = null);
			var t = this.getMap();
			if (t) {
				this.mapPostrenderListenerKey = u.a.listen(t, r.a.POSTRENDER, this.render, this), this.updatePixelPosition();
				var e = this.stopEvent ? t.getOverlayContainerStopEvent() : t.getOverlayContainer();
				this.insertFirst ? e.insertBefore(this.element, e.childNodes[0] || null) : e.appendChild(this.element)
			}
		}, c.prototype.render = function() {
			this.updatePixelPosition()
		}, c.prototype.handleOffsetChanged = function() {
			this.updatePixelPosition()
		}, c.prototype.handlePositionChanged = function() {
			this.updatePixelPosition(), this.get(c.Property.POSITION) && this.autoPan && this.panIntoView()
		}, c.prototype.handlePositioningChanged = function() {
			this.updatePixelPosition()
		}, c.prototype.setElement = function(t) {
			this.set(c.Property.ELEMENT, t)
		}, c.prototype.setMap = function(t) {
			this.set(c.Property.MAP, t)
		}, c.prototype.setOffset = function(t) {
			this.set(c.Property.OFFSET, t)
		}, c.prototype.setPosition = function(t) {
			this.set(c.Property.POSITION, t)
		}, c.prototype.panIntoView = function() {
			var t = this.getMap();
			if (t && t.getTargetElement()) {
				var e = this.getRect(t.getTargetElement(), t.getSize()),
					i = this.getElement(),
					n = this.getRect(i, [l.a.outerWidth(i), l.a.outerHeight(i)]),
					r = this.autoPanMargin;
				if (!h.
			default.containsExtent(e, n)) {
					var o = n[0] - e[0],
						s = e[2] - n[2],
						a = n[1] - e[1],
						u = e[3] - n[3],
						c = [0, 0];
					if (o < 0 ? c[0] = o - r : s < 0 && (c[0] = Math.abs(s) + r), a < 0 ? c[1] = a - r : u < 0 && (c[1] = Math.abs(u) + r), 0 !== c[0] || 0 !== c[1]) {
						var d = t.getView().getCenter(),
							f = t.getPixelFromCoordinate(d),
							A = [f[0] + c[0], f[1] + c[1]];
						t.getView().animate({
							center: t.getCoordinateFromPixel(A),
							duration: this.autoPanAnimation.duration,
							easing: this.autoPanAnimation.easing
						})
					}
				}
			}
		}, c.prototype.getRect = function(t, e) {
			var i = t.getBoundingClientRect(),
				n = i.left + window.pageXOffset,
				r = i.top + window.pageYOffset;
			return [n, r, n + e[0], r + e[1]]
		}, c.prototype.setPositioning = function(t) {
			this.set(c.Property.POSITIONING, t)
		}, c.prototype.setVisible = function(t) {
			this.rendered.visible !== t && (this.element.style.display = t ? "" : "none", this.rendered.visible = t)
		}, c.prototype.updatePixelPosition = function() {
			var t = this.getMap(),
				e = this.getPosition();
			if (t && t.isRendered() && e) {
				var i = t.getPixelFromCoordinate(e),
					n = t.getSize();
				this.updateRenderedPosition(i, n)
			} else this.setVisible(!1)
		}, c.prototype.updateRenderedPosition = function(t, e) {
			var i = this.element.style,
				n = this.getOffset(),
				r = this.getPositioning();
			this.setVisible(!0);
			var o = n[0],
				a = n[1];
			if (r == s.a.BOTTOM_RIGHT || r == s.a.CENTER_RIGHT || r == s.a.TOP_RIGHT) {
				"" !== this.rendered.left_ && (this.rendered.left_ = i.left = "");
				var l = Math.round(e[0] - t[0] - o) + "px";
				this.rendered.right_ != l && (this.rendered.right_ = i.right = l)
			} else {
				"" !== this.rendered.right_ && (this.rendered.right_ = i.right = ""), r != s.a.BOTTOM_CENTER && r != s.a.CENTER_CENTER && r != s.a.TOP_CENTER || (o -= this.element.offsetWidth / 2);
				var u = Math.round(t[0] + o) + "px";
				this.rendered.left_ != u && (this.rendered.left_ = i.left = u)
			}
			if (r == s.a.BOTTOM_LEFT || r == s.a.BOTTOM_CENTER || r == s.a.BOTTOM_RIGHT) {
				"" !== this.rendered.top_ && (this.rendered.top_ = i.top = "");
				var h = Math.round(e[1] - t[1] - a) + "px";
				this.rendered.bottom_ != h && (this.rendered.bottom_ = i.bottom = h)
			} else {
				"" !== this.rendered.bottom_ && (this.rendered.bottom_ = i.bottom = ""), r != s.a.CENTER_LEFT && r != s.a.CENTER_CENTER && r != s.a.CENTER_RIGHT || (a -= this.element.offsetHeight / 2);
				var c = Math.round(t[1] + a) + "px";
				this.rendered.top_ != c && (this.rendered.top_ = i.top = c)
			}
		}, c.prototype.getOptions = function() {
			return this.options
		}, c.Property = {
			ELEMENT: "element",
			MAP: "map",
			OFFSET: "offset",
			POSITION: "position",
			POSITIONING: "positioning"
		}, e.
	default = c
	}, function(t, e, i) {
		"use strict";
		e.a = {
			ACTIVE: "active"
		}
	}, function(t, e, i) {
		"use strict";
		var n = i(0),
			r = i(15),
			o = i(50),
			s = i(5),
			a = function(t) {
				o.a.call(this), this.highWaterMark = void 0 !== t ? t : 2048, this.count_ = 0, this.entries_ = {}, this.oldest_ = null, this.newest_ = null
			};
		n.
	default.inherits(a, o.a), a.prototype.canExpireCache = function() {
			return this.getCount() > this.highWaterMark
		}, a.prototype.clear = function() {
			this.count_ = 0, this.entries_ = {}, this.oldest_ = null, this.newest_ = null, this.dispatchEvent(s.a.CLEAR)
		}, a.prototype.containsKey = function(t) {
			return this.entries_.hasOwnProperty(t)
		}, a.prototype.forEach = function(t, e) {
			for (var i = this.oldest_; i;) t.call(e, i.value_, i.key_, this), i = i.newer
		}, a.prototype.get = function(t) {
			var e = this.entries_[t];
			return r.a.assert(void 0 !== e, 15), e === this.newest_ ? e.value_ : (e === this.oldest_ ? (this.oldest_ = this.oldest_.newer, this.oldest_.older = null) : (e.newer.older = e.older, e.older.newer = e.newer), e.newer = null, e.older = this.newest_, this.newest_.newer = e, this.newest_ = e, e.value_)
		}, a.prototype.remove = function(t) {
			var e = this.entries_[t];
			return r.a.assert(void 0 !== e, 15), e === this.newest_ ? (this.newest_ = e.older, this.newest_ && (this.newest_.newer = null)) : e === this.oldest_ ? (this.oldest_ = e.newer, this.oldest_ && (this.oldest_.older = null)) : (e.newer.older = e.older, e.older.newer = e.newer), delete this.entries_[t], --this.count_, e.value_
		}, a.prototype.getCount = function() {
			return this.count_
		}, a.prototype.getKeys = function() {
			var t, e = new Array(this.count_),
				i = 0;
			for (t = this.newest_; t; t = t.older) e[i++] = t.key_;
			return e
		}, a.prototype.getValues = function() {
			var t, e = new Array(this.count_),
				i = 0;
			for (t = this.newest_; t; t = t.older) e[i++] = t.value_;
			return e
		}, a.prototype.peekLast = function() {
			return this.oldest_.value_
		}, a.prototype.peekLastKey = function() {
			return this.oldest_.key_
		}, a.prototype.peekFirstKey = function() {
			return this.newest_.key_
		}, a.prototype.pop = function() {
			var t = this.oldest_;
			return delete this.entries_[t.key_], t.newer && (t.newer.older = null), this.oldest_ = t.newer, this.oldest_ || (this.newest_ = null), --this.count_, t.value_
		}, a.prototype.replace = function(t, e) {
			this.get(t), this.entries_[t].value_ = e
		}, a.prototype.set = function(t, e) {
			r.a.assert(!(t in this.entries_), 16);
			var i = {
				key_: t,
				newer: null,
				older: this.newest_,
				value_: e
			};
			this.newest_ ? this.newest_.newer = i : this.oldest_ = i, this.newest_ = i, this.entries_[t] = i, ++this.count_
		}, a.prototype.prune = function() {
			for (; this.canExpireCache();) this.pop()
		}, e.a = a
	}, function(t, e, i) {
		"use strict";
		var n = {
			appendParams: function(t, e) {
				var i = [];
				Object.keys(e).forEach((function(t) {
					null !== e[t] && void 0 !== e[t] && i.push(t + "=" + encodeURIComponent(e[t]))
				}));
				var n = i.join("&");
				return (t = -1 === (t = t.replace(/[?&]$/, "")).indexOf("?") ? t + "?" : t + "&") + n
			}
		};
		e.a = n
	}, function(t, e, i) {
		"use strict";
		e.a = {
			BOTTOM_LEFT: "bottom-left",
			BOTTOM_RIGHT: "bottom-right",
			TOP_LEFT: "top-left",
			TOP_RIGHT: "top-right"
		}
	}, function(t, e, i) {
		"use strict";
		Object.defineProperty(e, "__esModule", {
			value: !0
		});
		var n = {
			showZoomLabel: "级别",
			mousePositionMsg: "鼠标已超出地图范围",
			continuePolygonMsg: "点击继续画多边形，双击结束",
			helpMsg: "点击开始测面积",
			continueLineMsg: "点击继续测距，双击结束",
			rangeMsg: "点击开始测距"
		},
			r = {
				showZoomLabel: "level",
				mousePositionMsg: "The mouse is out of the map",
				continuePolygonMsg: "click continue to draw the polygon, double click the end",
				helpMsg: "click to start measuring area",
				continueLineMsg: "click continue range, double click end",
				rangeMsg: "click Start range"
			},
			o = n;
		e.I18n = o, e.setI18n = function(t) {
			e.I18n = o = "zh" == t ? n : r
		}
	}, function(t, e, i) {
		"use strict";
		t.exports = r;
		var n = i(166);

		function r(t, e) {
			if (!(this instanceof r)) return new r(t, e);
			this._maxEntries = Math.max(4, t || 9), this._minEntries = Math.max(2, Math.ceil(.4 * this._maxEntries)), e && this._initFormat(e), this.clear()
		}
		function o(t, e, i) {
			if (!i) return e.indexOf(t);
			for (var n = 0; n < e.length; n++) if (i(t, e[n])) return n;
			return -1
		}
		function s(t, e) {
			a(t, 0, t.children.length, e, t)
		}
		function a(t, e, i, n, r) {
			r || (r = p(null)), r.minX = 1 / 0, r.minY = 1 / 0, r.maxX = -1 / 0, r.maxY = -1 / 0;
			for (var o, s = e; s < i; s++) o = t.children[s], l(r, t.leaf ? n(o) : o);
			return r
		}
		function l(t, e) {
			return t.minX = Math.min(t.minX, e.minX), t.minY = Math.min(t.minY, e.minY), t.maxX = Math.max(t.maxX, e.maxX), t.maxY = Math.max(t.maxY, e.maxY), t
		}
		function u(t, e) {
			return t.minX - e.minX
		}
		function h(t, e) {
			return t.minY - e.minY
		}
		function c(t) {
			return (t.maxX - t.minX) * (t.maxY - t.minY)
		}
		function d(t) {
			return t.maxX - t.minX + (t.maxY - t.minY)
		}
		function f(t, e) {
			return t.minX <= e.minX && t.minY <= e.minY && e.maxX <= t.maxX && e.maxY <= t.maxY
		}
		function A(t, e) {
			return e.minX <= t.maxX && e.minY <= t.maxY && e.maxX >= t.minX && e.maxY >= t.minY
		}
		function p(t) {
			return {
				children: t,
				height: 1,
				leaf: !0,
				minX: 1 / 0,
				minY: 1 / 0,
				maxX: -1 / 0,
				maxY: -1 / 0
			}
		}
		function g(t, e, i, r, o) {
			for (var s, a = [e, i]; a.length;)(i = a.pop()) - (e = a.pop()) <= r || (s = e + Math.ceil((i - e) / r / 2) * r, n(t, s, e, i, o), a.push(e, s, s, i))
		}
		r.prototype = {
			all: function() {
				return this._all(this.data, [])
			},
			search: function(t) {
				var e = this.data,
					i = [],
					n = this.toBBox;
				if (!A(t, e)) return i;
				for (var r, o, s, a, l = []; e;) {
					for (r = 0, o = e.children.length; r < o; r++) s = e.children[r], A(t, a = e.leaf ? n(s) : s) && (e.leaf ? i.push(s) : f(t, a) ? this._all(s, i) : l.push(s));
					e = l.pop()
				}
				return i
			},
			collides: function(t) {
				var e = this.data,
					i = this.toBBox;
				if (!A(t, e)) return !1;
				for (var n, r, o, s, a = []; e;) {
					for (n = 0, r = e.children.length; n < r; n++) if (o = e.children[n], A(t, s = e.leaf ? i(o) : o)) {
						if (e.leaf || f(t, s)) return !0;
						a.push(o)
					}
					e = a.pop()
				}
				return !1
			},
			load: function(t) {
				if (!t || !t.length) return this;
				if (t.length < this._minEntries) {
					for (var e = 0, i = t.length; e < i; e++) this.insert(t[e]);
					return this
				}
				var n = this._build(t.slice(), 0, t.length - 1, 0);
				if (this.data.children.length) if (this.data.height === n.height) this._splitRoot(this.data, n);
				else {
					if (this.data.height < n.height) {
						var r = this.data;
						this.data = n, n = r
					}
					this._insert(n, this.data.height - n.height - 1, !0)
				} else this.data = n;
				return this
			},
			insert: function(t) {
				return t && this._insert(t, this.data.height - 1), this
			},
			clear: function() {
				return this.data = p([]), this
			},
			remove: function(t, e) {
				if (!t) return this;
				for (var i, n, r, s, a = this.data, l = this.toBBox(t), u = [], h = []; a || u.length;) {
					if (a || (a = u.pop(), n = u[u.length - 1], i = h.pop(), s = !0), a.leaf && -1 !== (r = o(t, a.children, e))) return a.children.splice(r, 1), u.push(a), this._condense(u), this;
					s || a.leaf || !f(a, l) ? n ? (i++, a = n.children[i], s = !1) : a = null : (u.push(a), h.push(i), i = 0, n = a, a = a.children[0])
				}
				return this
			},
			toBBox: function(t) {
				return t
			},
			compareMinX: u,
			compareMinY: h,
			toJSON: function() {
				return this.data
			},
			fromJSON: function(t) {
				return this.data = t, this
			},
			_all: function(t, e) {
				for (var i = []; t;) t.leaf ? e.push.apply(e, t.children) : i.push.apply(i, t.children), t = i.pop();
				return e
			},
			_build: function(t, e, i, n) {
				var r, o = i - e + 1,
					a = this._maxEntries;
				if (o <= a) return s(r = p(t.slice(e, i + 1)), this.toBBox), r;
				n || (n = Math.ceil(Math.log(o) / Math.log(a)), a = Math.ceil(o / Math.pow(a, n - 1))), (r = p([])).leaf = !1, r.height = n;
				var l, u, h, c, d = Math.ceil(o / a),
					f = d * Math.ceil(Math.sqrt(a));
				for (g(t, e, i, f, this.compareMinX), l = e; l <= i; l += f) for (g(t, l, h = Math.min(l + f - 1, i), d, this.compareMinY), u = l; u <= h; u += d) c = Math.min(u + d - 1, h), r.children.push(this._build(t, u, c, n - 1));
				return s(r, this.toBBox), r
			},
			_chooseSubtree: function(t, e, i, n) {
				for (var r, o, s, a, l, u, h, d, f, A; n.push(e), !e.leaf && n.length - 1 !== i;) {
					for (h = d = 1 / 0, r = 0, o = e.children.length; r < o; r++) l = c(s = e.children[r]), f = t, A = s, (u = (Math.max(A.maxX, f.maxX) - Math.min(A.minX, f.minX)) * (Math.max(A.maxY, f.maxY) - Math.min(A.minY, f.minY)) - l) < d ? (d = u, h = l < h ? l : h, a = s) : u === d && l < h && (h = l, a = s);
					e = a || e.children[0]
				}
				return e
			},
			_insert: function(t, e, i) {
				var n = this.toBBox,
					r = i ? t : n(t),
					o = [],
					s = this._chooseSubtree(r, this.data, e, o);
				for (s.children.push(t), l(s, r); e >= 0 && o[e].children.length > this._maxEntries;) this._split(o, e), e--;
				this._adjustParentBBoxes(r, o, e)
			},
			_split: function(t, e) {
				var i = t[e],
					n = i.children.length,
					r = this._minEntries;
				this._chooseSplitAxis(i, r, n);
				var o = this._chooseSplitIndex(i, r, n),
					a = p(i.children.splice(o, i.children.length - o));
				a.height = i.height, a.leaf = i.leaf, s(i, this.toBBox), s(a, this.toBBox), e ? t[e - 1].children.push(a) : this._splitRoot(i, a)
			},
			_splitRoot: function(t, e) {
				this.data = p([t, e]), this.data.height = t.height + 1, this.data.leaf = !1, s(this.data, this.toBBox)
			},
			_chooseSplitIndex: function(t, e, i) {
				var n, r, o, s, l, u, h, d, f, A, p, g, m, v;
				for (u = h = 1 / 0, n = e; n <= i - e; n++) r = a(t, 0, n, this.toBBox), o = a(t, n, i, this.toBBox), f = r, A = o, p = void 0, g = void 0, m = void 0, v = void 0, p = Math.max(f.minX, A.minX), g = Math.max(f.minY, A.minY), m = Math.min(f.maxX, A.maxX), v = Math.min(f.maxY, A.maxY), s = Math.max(0, m - p) * Math.max(0, v - g), l = c(r) + c(o), s < u ? (u = s, d = n, h = l < h ? l : h) : s === u && l < h && (h = l, d = n);
				return d
			},
			_chooseSplitAxis: function(t, e, i) {
				var n = t.leaf ? this.compareMinX : u,
					r = t.leaf ? this.compareMinY : h;
				this._allDistMargin(t, e, i, n) < this._allDistMargin(t, e, i, r) && t.children.sort(n)
			},
			_allDistMargin: function(t, e, i, n) {
				t.children.sort(n);
				var r, o, s = this.toBBox,
					u = a(t, 0, e, s),
					h = a(t, i - e, i, s),
					c = d(u) + d(h);
				for (r = e; r < i - e; r++) o = t.children[r], l(u, t.leaf ? s(o) : o), c += d(u);
				for (r = i - e - 1; r >= e; r--) o = t.children[r], l(h, t.leaf ? s(o) : o), c += d(h);
				return c
			},
			_adjustParentBBoxes: function(t, e, i) {
				for (var n = i; n >= 0; n--) l(e[n], t)
			},
			_condense: function(t) {
				for (var e, i = t.length - 1; i >= 0; i--) 0 === t[i].children.length ? i > 0 ? (e = t[i - 1].children).splice(e.indexOf(t[i]), 1) : this.clear() : s(t[i], this.toBBox)
			},
			_initFormat: function(t) {
				var e = ["return a", " - b", ";"];
				this.compareMinX = new Function("a", "b", e.join(t[0])), this.compareMinY = new Function("a", "b", e.join(t[1])), this.toBBox = new Function("a", "return {minX: a" + t[0] + ", minY: a" + t[1] + ", maxX: a" + t[2] + ", maxY: a" + t[3] + "};")
			}
		}
	}, function(t, e, i) {
		"use strict";
		i.r(e);
		var n = i(0),
			r = i(129),
			o = i(109),
			s = i(151),
			a = i(27),
			l = function(t, e, i) {
				this.decay_ = t, this.minVelocity_ = e, this.delay_ = i, this.points_ = [], this.angle_ = 0, this.initialVelocity_ = 0
			};
		l.prototype.begin = function() {
			this.points_.length = 0, this.angle_ = 0, this.initialVelocity_ = 0
		}, l.prototype.update = function(t, e) {
			this.points_.push(t, e, Date.now())
		}, l.prototype.end = function() {
			if (this.points_.length < 6) return !1;
			var t = Date.now() - this.delay_,
				e = this.points_.length - 3;
			if (this.points_[e + 2] < t) return !1;
			for (var i = e - 3; i > 0 && this.points_[i + 2] > t;) i -= 3;
			var n = this.points_[e + 2] - this.points_[i + 2];
			if (n < 1e3 / 60) return !1;
			var r = this.points_[e] - this.points_[i],
				o = this.points_[e + 1] - this.points_[i + 1];
			return this.angle_ = Math.atan2(o, r), this.initialVelocity_ = Math.sqrt(r * r + o * o) / n, this.initialVelocity_ > this.minVelocity_
		}, l.prototype.getDistance = function() {
			return (this.minVelocity_ - this.initialVelocity_) / this.decay_
		}, l.prototype.getAngle = function() {
			return this.angle_
		};
		var u = l,
			h = i(24),
			c = i(29),
			d = function(t) {
				var e = t || {};
				this.delta_ = e.delta ? e.delta : 1, c.a.call(this, {
					handleEvent: d.handleEvent
				}), this.duration_ = void 0 !== e.duration ? e.duration : 250
			};
		n.
	default.inherits(d, c.a), d.handleEvent = function(t) {
			var e = !1,
				i = t.originalEvent;
			if (t.type == h.a.DBLCLICK) {
				var n = t.map,
					r = t.coordinate,
					o = i.shiftKey ? -this.delta_ : this.delta_,
					s = n.getView();
				c.a.zoomByDelta(s, o, r, this.duration_), t.preventDefault(), e = !0
			}
			return !e
		};
		var f = d,
			A = i(22),
			p = i(19),
			g = i(39),
			m = i(28),
			v = i(20),
			y = i(23),
			_ = function(t) {
				y.a.call(this, {
					handleDownEvent: _.handleDownEvent_,
					handleDragEvent: _.handleDragEvent_,
					handleUpEvent: _.handleUpEvent_
				});
				var e = t || {};
				this.kinetic_ = e.kinetic, this.lastCentroid = null, this.lastPointersCount_, this.condition_ = e.condition ? e.condition : m.
			default.noModifierKeys, this.noKinetic_ = !1
			};
		n.
	default.inherits(_, y.a), _.handleDragEvent_ = function(t) {
			var e = this.targetPointers,
				i = y.a.centroid(e);
			if (e.length == this.lastPointersCount_) {
				if (this.kinetic_ && this.kinetic_.update(i[0], i[1]), this.lastCentroid) {
					var n = this.lastCentroid[0] - i[0],
						r = i[1] - this.lastCentroid[1],
						o = t.map.getView(),
						s = o.getState(),
						a = [n, r];
					p.
				default.scale(a, s.resolution), p.
				default.rotate(a, s.rotation), p.
				default.add(a, s.center), a = o.constrainCenter(a), o.setCenter(a)
				}
			} else this.kinetic_ && this.kinetic_.begin();
			this.lastCentroid = i, this.lastPointersCount_ = e.length
		}, _.handleUpEvent_ = function(t) {
			var e = t.map,
				i = e.getView();
			if (0 === this.targetPointers.length) {
				if (!this.noKinetic_ && this.kinetic_ && this.kinetic_.end()) {
					var n = this.kinetic_.getDistance(),
						r = this.kinetic_.getAngle(),
						o = i.getCenter(),
						s = e.getPixelFromCoordinate(o),
						a = e.getCoordinateFromPixel([s[0] - n * Math.cos(r), s[1] - n * Math.sin(r)]);
					i.animate({
						center: i.constrainCenter(a),
						duration: 500,
						easing: g.
					default.easeOut
					})
				}
				return i.setHint(A.a.INTERACTING, -1), !1
			}
			return this.kinetic_ && this.kinetic_.begin(), this.lastCentroid = null, !0
		}, _.handleDownEvent_ = function(t) {
			if (this.targetPointers.length > 0 && this.condition_(t)) {
				var e = t.map.getView();
				return this.lastCentroid = null, this.handlingDownUpSequence || e.setHint(A.a.INTERACTING, 1), e.getAnimating() && e.setCenter(t.frameState.viewState.center), this.kinetic_ && this.kinetic_.begin(), this.noKinetic_ = this.targetPointers.length > 1, !0
			}
			return !1
		}, _.prototype.shouldStopEvent = v.a.FALSE;
		var E = _,
			x = i(90),
			C = function(t) {
				var e = t || {};
				y.a.call(this, {
					handleDownEvent: C.handleDownEvent_,
					handleDragEvent: C.handleDragEvent_,
					handleUpEvent: C.handleUpEvent_
				}), this.condition_ = e.condition ? e.condition : m.
			default.altShiftKeysOnly, this.lastAngle_ = void 0, this.duration_ = void 0 !== e.duration ? e.duration:
				250
			};
		n.
	default.inherits(C, y.a), C.handleDragEvent_ = function(t) {
			if (m.
		default.mouseOnly(t)) {
				var e = t.map,
					i = e.getView();
				if (i.getConstraints().rotation !== x.a.disable) {
					var n = e.getSize(),
						r = t.pixel,
						o = Math.atan2(n[1] / 2 - r[1], r[0] - n[0] / 2);
					if (void 0 !== this.lastAngle_) {
						var s = o - this.lastAngle_,
							a = i.getRotation();
						c.a.rotateWithoutConstraints(i, a - s)
					}
					this.lastAngle_ = o
				}
			}
		}, C.handleUpEvent_ = function(t) {
			if (!m.
		default.mouseOnly(t)) return !0;
			var e = t.map.getView();
			e.setHint(A.a.INTERACTING, -1);
			var i = e.getRotation();
			return c.a.rotate(e, i, void 0, this.duration_), !1
		}, C.handleDownEvent_ = function(t) {
			return !!m.
		default.mouseOnly(t) && (!(!m.
		default.mouseActionButton(t) || !this.condition_(t)) && (t.map.getView().setHint(A.a.INTERACTING, 1), this.lastAngle_ = void 0, !0))
		}, C.prototype.shouldStopEvent = v.a.FALSE;
		var I = C,
			S = i(146),
			T = i(5),
			R = {
				LEFT: 37,
				UP: 38,
				RIGHT: 39,
				DOWN: 40
			},
			w = function(t) {
				c.a.call(this, {
					handleEvent: w.handleEvent
				});
				var e = t || {};
				this.defaultCondition_ = function(t) {
					return m.
				default.noModifierKeys(t) && m.
				default.targetNotEditable(t)
				}, this.condition_ = void 0 !== e.condition ? e.condition : this.defaultCondition_, this.duration_ = void 0 !== e.duration ? e.duration : 100, this.pixelDelta_ = void 0 !== e.pixelDelta ? e.pixelDelta : 128
			};
		n.
	default.inherits(w, c.a), w.handleEvent = function(t) {
			var e = !1;
			if (t.type == T.a.KEYDOWN) {
				var i = t.originalEvent.keyCode;
				if (this.condition_(t) && (i == R.DOWN || i == R.LEFT || i == R.RIGHT || i == R.UP)) {
					var n = t.map.getView(),
						r = n.getResolution() * this.pixelDelta_,
						o = 0,
						s = 0;
					i == R.DOWN ? s = -r : i == R.LEFT ? o = -r : i == R.RIGHT ? o = r : s = r;
					var a = [o, s];
					p.
				default.rotate(a, n.getRotation()), c.a.pan(n, a, this.duration_), t.preventDefault(), e = !0
				}
			}
			return !e
		};
		var L = w,
			N = function(t) {
				c.a.call(this, {
					handleEvent: N.handleEvent
				});
				var e = t || {};
				this.condition_ = e.condition ? e.condition : m.
			default.targetNotEditable, this.delta_ = e.delta ? e.delta:
				1, this.duration_ = void 0 !== e.duration ? e.duration : 100
			};
		n.
	default.inherits(N, c.a), N.handleEvent = function(t) {
			var e = !1;
			if (t.type == T.a.KEYDOWN || t.type == T.a.KEYPRESS) {
				var i = t.originalEvent.charCode;
				if (this.condition_(t) && (i == "+".charCodeAt(0) || i == "-".charCodeAt(0))) {
					var n = t.map,
						r = i == "+".charCodeAt(0) ? this.delta_ : -this.delta_,
						o = n.getView();
					c.a.zoomByDelta(o, r, void 0, this.duration_), t.preventDefault(), e = !0
				}
			}
			return !e
		};
		var P = N,
			O = i(35),
			M = i(11),
			b = function(t) {
				c.a.call(this, {
					handleEvent: b.handleEvent
				});
				var e = t || {};
				this.delta_ = 0, this.duration_ = void 0 !== e.duration ? e.duration : 250, this.timeout_ = void 0 !== e.timeout ? e.timeout : 80, this.useAnchor_ = void 0 === e.useAnchor || e.useAnchor, this.constrainResolution_ = e.constrainResolution || !1, this.lastAnchor_ = null, this.startTime_ = void 0, this.timeoutId_ = void 0, this.mode_ = void 0, this.trackpadEventGap_ = 400, this.trackpadTimeoutId_ = void 0, this.trackpadDeltaPerZoom_ = 300, this.trackpadZoomBuffer_ = 1.5
			};
		n.
	default.inherits(b, c.a), b.handleEvent = function(t) {
			var e = t.type;
			if (e !== T.a.WHEEL && e !== T.a.MOUSEWHEEL) return !0;
			t.preventDefault();
			var i, n = t.map,
				r = t.originalEvent;
			if (this.useAnchor_ && (this.lastAnchor_ = t.coordinate), t.type == T.a.WHEEL ? (i = r.deltaY, O.a.FIREFOX && r.deltaMode === WheelEvent.DOM_DELTA_PIXEL && (i /= O.a.DEVICE_PIXEL_RATIO), r.deltaMode === WheelEvent.DOM_DELTA_LINE && (i *= 40)) : t.type == T.a.MOUSEWHEEL && (i = -r.wheelDeltaY, O.a.SAFARI && (i /= 3)), 0 === i) return !1;
			var o = Date.now();
			if (void 0 === this.startTime_ && (this.startTime_ = o), (!this.mode_ || o - this.startTime_ > this.trackpadEventGap_) && (this.mode_ = Math.abs(i) < 4 ? b.Mode_.TRACKPAD : b.Mode_.WHEEL), this.mode_ === b.Mode_.TRACKPAD) {
				var s = n.getView();
				this.trackpadTimeoutId_ ? clearTimeout(this.trackpadTimeoutId_) : s.setHint(A.a.INTERACTING, 1), this.trackpadTimeoutId_ = setTimeout(this.decrementInteractingHint_.bind(this), this.trackpadEventGap_);
				var a = s.getResolution() * Math.pow(2, i / this.trackpadDeltaPerZoom_),
					l = s.getMinResolution(),
					u = s.getMaxResolution(),
					h = 0;
				if (a < l ? (a = Math.max(a, l / this.trackpadZoomBuffer_), h = 1) : a > u && (a = Math.min(a, u * this.trackpadZoomBuffer_), h = -1), this.lastAnchor_) {
					var c = s.calculateCenterZoom(a, this.lastAnchor_);
					s.setCenter(s.constrainCenter(c))
				}
				return s.setResolution(a), 0 === h && this.constrainResolution_ && s.animate({
					resolution: s.constrainResolution(a, i > 0 ? -1 : 1),
					easing: g.
				default.easeOut,
					anchor:
					this.lastAnchor_,
					duration: this.duration_
				}), h > 0 ? s.animate({
					resolution: l,
					easing: g.
				default.easeOut,
					anchor:
					this.lastAnchor_,
					duration: 500
				}) : h < 0 && s.animate({
					resolution: u,
					easing: g.
				default.easeOut,
					anchor:
					this.lastAnchor_,
					duration: 500
				}), this.startTime_ = o, !1
			}
			this.delta_ += i;
			var d = Math.max(this.timeout_ - (o - this.startTime_), 0);
			return clearTimeout(this.timeoutId_), this.timeoutId_ = setTimeout(this.handleWheelZoom_.bind(this, n), d), !1
		}, b.prototype.decrementInteractingHint_ = function() {
			this.trackpadTimeoutId_ = void 0, this.getMap().getView().setHint(A.a.INTERACTING, -1)
		}, b.prototype.handleWheelZoom_ = function(t) {
			var e = t.getView();
			e.getAnimating() && e.cancelAnimations();
			var i = n.
		default.MOUSEWHEELZOOM_MAXDELTA,
				r = M.a.clamp(this.delta_, -i, i);
			c.a.zoomByDelta(e, -r, this.lastAnchor_, this.duration_), this.mode_ = void 0, this.delta_ = 0, this.lastAnchor_ = null, this.startTime_ = void 0, this.timeoutId_ = void 0
		}, b.prototype.setMouseAnchor = function(t) {
			this.useAnchor_ = t, t || (this.lastAnchor_ = null)
		}, b.Mode_ = {
			TRACKPAD: "trackpad",
			WHEEL: "wheel"
		};
		var F = b,
			D = function(t) {
				y.a.call(this, {
					handleDownEvent: D.handleDownEvent_,
					handleDragEvent: D.handleDragEvent_,
					handleUpEvent: D.handleUpEvent_
				});
				var e = t || {};
				this.anchor_ = null, this.lastAngle_ = void 0, this.rotating_ = !1, this.rotationDelta_ = 0, this.threshold_ = void 0 !== e.threshold ? e.threshold : .3, this.duration_ = void 0 !== e.duration ? e.duration : 250
			};
		n.
	default.inherits(D, y.a), D.handleDragEvent_ = function(t) {
			var e = 0,
				i = this.targetPointers[0],
				n = this.targetPointers[1],
				r = Math.atan2(n.clientY - i.clientY, n.clientX - i.clientX);
			if (void 0 !== this.lastAngle_) {
				var o = r - this.lastAngle_;
				this.rotationDelta_ += o, !this.rotating_ && Math.abs(this.rotationDelta_) > this.threshold_ && (this.rotating_ = !0), e = o
			}
			this.lastAngle_ = r;
			var s = t.map,
				a = s.getView();
			if (a.getConstraints().rotation !== x.a.disable) {
				var l = s.getViewport().getBoundingClientRect(),
					u = y.a.centroid(this.targetPointers);
				if (u[0] -= l.left, u[1] -= l.top, this.anchor_ = s.getCoordinateFromPixel(u), this.rotating_) {
					var h = a.getRotation();
					s.render(), c.a.rotateWithoutConstraints(a, h + e, this.anchor_)
				}
			}
		}, D.handleUpEvent_ = function(t) {
			if (this.targetPointers.length < 2) {
				var e = t.map.getView();
				if (e.setHint(A.a.INTERACTING, -1), this.rotating_) {
					var i = e.getRotation();
					c.a.rotate(e, i, this.anchor_, this.duration_)
				}
				return !1
			}
			return !0
		}, D.handleDownEvent_ = function(t) {
			if (this.targetPointers.length >= 2) {
				var e = t.map;
				return this.anchor_ = null, this.lastAngle_ = void 0, this.rotating_ = !1, this.rotationDelta_ = 0, this.handlingDownUpSequence || e.getView().setHint(A.a.INTERACTING, 1), !0
			}
			return !1
		}, D.prototype.shouldStopEvent = v.a.FALSE;
		var G = D,
			k = function(t) {
				y.a.call(this, {
					handleDownEvent: k.handleDownEvent_,
					handleDragEvent: k.handleDragEvent_,
					handleUpEvent: k.handleUpEvent_
				});
				var e = t || {};
				this.constrainResolution_ = e.constrainResolution || !1, this.anchor_ = null, this.duration_ = void 0 !== e.duration ? e.duration : 400, this.lastDistance_ = void 0, this.lastScaleDelta_ = 1
			};
		n.
	default.inherits(k, y.a), k.handleDragEvent_ = function(t) {
			var e = 1,
				i = this.targetPointers[0],
				n = this.targetPointers[1],
				r = i.clientX - n.clientX,
				o = i.clientY - n.clientY,
				s = Math.sqrt(r * r + o * o);
			void 0 !== this.lastDistance_ && (e = this.lastDistance_ / s), this.lastDistance_ = s;
			var a = t.map,
				l = a.getView(),
				u = l.getResolution(),
				h = l.getMaxResolution(),
				d = l.getMinResolution(),
				f = u * e;
			f > h ? (e = h / u, f = h) : f < d && (e = d / u, f = d), 1 != e && (this.lastScaleDelta_ = e);
			var A = a.getViewport().getBoundingClientRect(),
				p = y.a.centroid(this.targetPointers);
			p[0] -= A.left, p[1] -= A.top, this.anchor_ = a.getCoordinateFromPixel(p), a.render(), c.a.zoomWithoutConstraints(l, f, this.anchor_)
		}, k.handleUpEvent_ = function(t) {
			if (this.targetPointers.length < 2) {
				var e = t.map.getView();
				e.setHint(A.a.INTERACTING, -1);
				var i = e.getResolution();
				if (this.constrainResolution_ || i < e.getMinResolution() || i > e.getMaxResolution()) {
					var n = this.lastScaleDelta_ - 1;
					c.a.zoom(e, i, this.anchor_, this.duration_, n)
				}
				return !1
			}
			return !0
		}, k.handleDownEvent_ = function(t) {
			if (this.targetPointers.length >= 2) {
				var e = t.map;
				return this.anchor_ = null, this.lastDistance_ = void 0, this.lastScaleDelta_ = 1, this.handlingDownUpSequence || e.getView().setHint(A.a.INTERACTING, 1), !0
			}
			return !1
		}, k.prototype.shouldStopEvent = v.a.FALSE;
		var U = k,
			B = {
				defaults: function(t) {
					var e = t || {},
						i = new a.
					default,
						n = new u(-.005, .05, 100);
					return (void 0 === e.altShiftDragRotate || e.altShiftDragRotate) && i.push(new I), (void 0 === e.doubleClickZoom || e.doubleClickZoom) && i.push(new f({
						delta: e.zoomDelta,
						duration: e.zoomDuration
					})), (void 0 === e.dragPan || e.dragPan) && i.push(new E({
						kinetic: n
					})), (void 0 === e.pinchRotate || e.pinchRotate) && i.push(new G), (void 0 === e.pinchZoom || e.pinchZoom) && i.push(new U({
						constrainResolution: e.constrainResolution,
						duration: e.zoomDuration
					})), (void 0 === e.keyboard || e.keyboard) && (i.push(new L), i.push(new P({
						delta: e.zoomDelta,
						duration: e.zoomDuration
					}))), (void 0 === e.mouseWheelZoom || e.mouseWheelZoom) && i.push(new F({
						constrainResolution: e.constrainResolution,
						duration: e.zoomDuration
					})), (void 0 === e.shiftDragZoom || e.shiftDragZoom) && i.push(new S.
				default ({
						duration: e.zoomDuration
					})), i
				}
			},
			j = B,
			V = i(8),
			Y = i(83),
			z = i(91),
			X = i(17),
			W = function(t, e, i, n, r) {
				this.loader_ = void 0 !== r ? r : null;
				var o = void 0 !== r ? X.a.IDLE : X.a.LOADED;
				z.a.call(this, t, e, i, o), this.canvas_ = n, this.error_ = null
			};
		n.
	default.inherits(W, z.a), W.prototype.getError = function() {
			return this.error_
		}, W.prototype.handleLoad_ = function(t) {
			t ? (this.error_ = t, this.state = X.a.ERROR) : this.state = X.a.LOADED, this.changed()
		}, W.prototype.load = function() {
			this.state == X.a.IDLE && (this.state = X.a.LOADING, this.changed(), this.loader_(this.handleLoad_.bind(this)))
		}, W.prototype.getImage = function() {
			return this.canvas_
		};
		var q = W,
			H = i(51),
			Z = i(10),
			K = i(1),
			J = i(135),
			Q = i(46),
			$ = i(16),
			tt = i(21),
			et = function(t, e, i, n, r) {
				tt.a.call(this, t), this.vectorContext = e, this.frameState = i, this.context = n, this.glContext = r
			};
		n.
	default.inherits(et, tt.a);
		var it = et,
			nt = i(57),
			rt = i(12),
			ot = i(62),
			st = i(4),
			at = i(40),
			lt = i(45),
			ut = function() {};
		ut.prototype.drawCustom = function(t, e, i) {}, ut.prototype.drawGeometry = function(t) {}, ut.prototype.setStyle = function(t) {}, ut.prototype.drawCircle = function(t, e) {}, ut.prototype.drawFeature = function(t, e) {}, ut.prototype.drawGeometryCollection = function(t, e) {}, ut.prototype.drawLineString = function(t, e) {}, ut.prototype.drawMultiLineString = function(t, e) {}, ut.prototype.drawMultiPoint = function(t, e) {}, ut.prototype.drawMultiPolygon = function(t, e) {}, ut.prototype.drawPoint = function(t, e) {}, ut.prototype.drawPolygon = function(t, e) {}, ut.prototype.drawText = function(t, e) {}, ut.prototype.setFillStrokeStyle = function(t, e) {}, ut.prototype.setImageStyle = function(t, e) {}, ut.prototype.setTextStyle = function(t, e) {};
		var ht = ut,
			ct = i(6),
			dt = function(t, e, i, n, r) {
				ht.call(this), this.context_ = t, this.pixelRatio_ = e, this.extent_ = i, this.transform_ = n, this.viewRotation_ = r, this.contextFillState_ = null, this.contextStrokeState_ = null, this.contextTextState_ = null, this.fillState_ = null, this.strokeState_ = null, this.image_ = null, this.imageAnchorX_ = 0, this.imageAnchorY_ = 0, this.imageHeight_ = 0, this.imageOpacity_ = 0, this.imageOriginX_ = 0, this.imageOriginY_ = 0, this.imageRotateWithView_ = !1, this.imageRotation_ = 0, this.imageScale_ = 0, this.imageSnapToPixel_ = !1, this.imageWidth_ = 0, this.text_ = "", this.textOffsetX_ = 0, this.textOffsetY_ = 0, this.textRotateWithView_ = !1, this.textRotation_ = 0, this.textScale_ = 0, this.textFillState_ = null, this.textStrokeState_ = null, this.textState_ = null, this.pixelCoordinates_ = [], this.tmpLocalTransform_ = ct.a.create()
			};
		n.
	default.inherits(dt, ht), dt.prototype.drawImages_ = function(t, e, i, n) {
			if (this.image_) {
				var r = lt.a.transform2D(t, e, i, 2, this.transform_, this.pixelCoordinates_),
					o = this.context_,
					s = this.tmpLocalTransform_,
					a = o.globalAlpha;
				1 != this.imageOpacity_ && (o.globalAlpha = a * this.imageOpacity_);
				var l, u, h = this.imageRotation_;
				for (this.imageRotateWithView_ && (h += this.viewRotation_), l = 0, u = r.length; l < u; l += 2) {
					var c = r[l] - this.imageAnchorX_,
						d = r[l + 1] - this.imageAnchorY_;
					if (this.imageSnapToPixel_ && (c = Math.round(c), d = Math.round(d)), 0 !== h || 1 != this.imageScale_) {
						var f = c + this.imageAnchorX_,
							A = d + this.imageAnchorY_;
						ct.a.compose(s, f, A, this.imageScale_, this.imageScale_, h, -f, -A), o.setTransform.apply(o, s)
					}
					o.drawImage(this.image_, this.imageOriginX_, this.imageOriginY_, this.imageWidth_, this.imageHeight_, c, d, this.imageWidth_, this.imageHeight_)
				}
				0 === h && 1 == this.imageScale_ || o.setTransform(1, 0, 0, 1, 0, 0), 1 != this.imageOpacity_ && (o.globalAlpha = a)
			}
		}, dt.prototype.drawText_ = function(t, e, i, n) {
			if (this.textState_ && "" !== this.text_) {
				this.textFillState_ && this.setContextFillState_(this.textFillState_), this.textStrokeState_ && this.setContextStrokeState_(this.textStrokeState_), this.setContextTextState_(this.textState_);
				var r = lt.a.transform2D(t, e, i, n, this.transform_, this.pixelCoordinates_),
					o = this.context_,
					s = this.textRotation_;
				for (this.textRotateWithView_ && (s += this.viewRotation_); e < i; e += n) {
					var a = r[e] + this.textOffsetX_,
						l = r[e + 1] + this.textOffsetY_;
					if (0 !== s || 1 != this.textScale_) {
						var u = ct.a.compose(this.tmpLocalTransform_, a, l, this.textScale_, this.textScale_, s, -a, -l);
						o.setTransform.apply(o, u)
					}
					this.textStrokeState_ && o.strokeText(this.text_, a, l), this.textFillState_ && o.fillText(this.text_, a, l)
				}
				0 === s && 1 == this.textScale_ || o.setTransform(1, 0, 0, 1, 0, 0)
			}
		}, dt.prototype.moveToLineTo_ = function(t, e, i, n, r) {
			var o = this.context_,
				s = lt.a.transform2D(t, e, i, n, this.transform_, this.pixelCoordinates_);
			o.moveTo(s[0], s[1]);
			var a = s.length;
			r && (a -= 2);
			for (var l = 2; l < a; l += 2) o.lineTo(s[l], s[l + 1]);
			return r && o.closePath(), i
		}, dt.prototype.drawRings_ = function(t, e, i, n) {
			var r, o;
			for (r = 0, o = i.length; r < o; ++r) e = this.moveToLineTo_(t, e, i[r], n, !0);
			return e
		}, dt.prototype.drawCircle = function(t) {
			if (K.
		default.intersects(this.extent_, t.getExtent())) {
				if (this.fillState_ || this.strokeState_) {
					this.fillState_ && this.setContextFillState_(this.fillState_), this.strokeState_ && this.setContextStrokeState_(this.strokeState_);
					var e = at.a.transform2D(t, this.transform_, this.pixelCoordinates_),
						i = e[2] - e[0],
						n = e[3] - e[1],
						r = Math.sqrt(i * i + n * n),
						o = this.context_;
					o.beginPath(), o.arc(e[0], e[1], r, 0, 2 * Math.PI), this.fillState_ && o.fill(), this.strokeState_ && o.stroke()
				}
				"" !== this.text_ && this.drawText_(t.getCenter(), 0, 2, 2)
			}
		}, dt.prototype.setStyle = function(t) {
			this.setFillStrokeStyle(t.getFill(), t.getStroke()), this.setImageStyle(t.getImage()), this.setTextStyle(t.getText())
		}, dt.prototype.drawGeometry = function(t) {
			switch (t.getType()) {
			case st.a.POINT:
				this.drawPoint(t);
				break;
			case st.a.LINE_STRING:
				this.drawLineString(t);
				break;
			case st.a.POLYGON:
				this.drawPolygon(t);
				break;
			case st.a.MULTI_POINT:
				this.drawMultiPoint(t);
				break;
			case st.a.MULTI_LINE_STRING:
				this.drawMultiLineString(t);
				break;
			case st.a.MULTI_POLYGON:
				this.drawMultiPolygon(t);
				break;
			case st.a.GEOMETRY_COLLECTION:
				this.drawGeometryCollection(t);
				break;
			case st.a.CIRCLE:
				this.drawCircle(t)
			}
		}, dt.prototype.drawFeature = function(t, e) {
			var i = e.getGeometryFunction()(t);
			i && K.
		default.intersects(this.extent_, i.getExtent()) && (this.setStyle(e), this.drawGeometry(i))
		}, dt.prototype.drawGeometryCollection = function(t) {
			var e, i, n = t.getGeometriesArray();
			for (e = 0, i = n.length; e < i; ++e) this.drawGeometry(n[e])
		}, dt.prototype.drawPoint = function(t) {
			var e = t.getFlatCoordinates(),
				i = t.getStride();
			this.image_ && this.drawImages_(e, 0, e.length, i), "" !== this.text_ && this.drawText_(e, 0, e.length, i)
		}, dt.prototype.drawMultiPoint = function(t) {
			var e = t.getFlatCoordinates(),
				i = t.getStride();
			this.image_ && this.drawImages_(e, 0, e.length, i), "" !== this.text_ && this.drawText_(e, 0, e.length, i)
		}, dt.prototype.drawLineString = function(t) {
			if (K.
		default.intersects(this.extent_, t.getExtent())) {
				if (this.strokeState_) {
					this.setContextStrokeState_(this.strokeState_);
					var e = this.context_,
						i = t.getFlatCoordinates();
					e.beginPath(), this.moveToLineTo_(i, 0, i.length, t.getStride(), !1), e.stroke()
				}
				if ("" !== this.text_) {
					var n = t.getFlatMidpoint();
					this.drawText_(n, 0, 2, 2)
				}
			}
		}, dt.prototype.drawMultiLineString = function(t) {
			var e = t.getExtent();
			if (K.
		default.intersects(this.extent_, e)) {
				if (this.strokeState_) {
					this.setContextStrokeState_(this.strokeState_);
					var i, n, r = this.context_,
						o = t.getFlatCoordinates(),
						s = 0,
						a = t.getEnds(),
						l = t.getStride();
					for (r.beginPath(), i = 0, n = a.length; i < n; ++i) s = this.moveToLineTo_(o, s, a[i], l, !1);
					r.stroke()
				}
				if ("" !== this.text_) {
					var u = t.getFlatMidpoints();
					this.drawText_(u, 0, u.length, 2)
				}
			}
		}, dt.prototype.drawPolygon = function(t) {
			if (K.
		default.intersects(this.extent_, t.getExtent())) {
				if (this.strokeState_ || this.fillState_) {
					this.fillState_ && this.setContextFillState_(this.fillState_), this.strokeState_ && this.setContextStrokeState_(this.strokeState_);
					var e = this.context_;
					e.beginPath(), this.drawRings_(t.getOrientedFlatCoordinates(), 0, t.getEnds(), t.getStride()), this.fillState_ && e.fill(), this.strokeState_ && e.stroke()
				}
				if ("" !== this.text_) {
					var i = t.getFlatInteriorPoint();
					this.drawText_(i, 0, 2, 2)
				}
			}
		}, dt.prototype.drawMultiPolygon = function(t) {
			if (K.
		default.intersects(this.extent_, t.getExtent())) {
				if (this.strokeState_ || this.fillState_) {
					this.fillState_ && this.setContextFillState_(this.fillState_), this.strokeState_ && this.setContextStrokeState_(this.strokeState_);
					var e, i, n = this.context_,
						r = t.getOrientedFlatCoordinates(),
						o = 0,
						s = t.getEndss(),
						a = t.getStride();
					for (n.beginPath(), e = 0, i = s.length; e < i; ++e) {
						var l = s[e];
						o = this.drawRings_(r, o, l, a)
					}
					this.fillState_ && n.fill(), this.strokeState_ && n.stroke()
				}
				if ("" !== this.text_) {
					var u = t.getFlatInteriorPoints();
					this.drawText_(u, 0, u.length, 2)
				}
			}
		}, dt.prototype.setContextFillState_ = function(t) {
			var e = this.context_,
				i = this.contextFillState_;
			i ? i.fillStyle != t.fillStyle && (i.fillStyle = e.fillStyle = t.fillStyle) : (e.fillStyle = t.fillStyle, this.contextFillState_ = {
				fillStyle: t.fillStyle
			})
		}, dt.prototype.setContextStrokeState_ = function(t) {
			var e = this.context_,
				i = this.contextStrokeState_;
			i ? (i.lineCap != t.lineCap && (i.lineCap = e.lineCap = t.lineCap), O.a.CANVAS_LINE_DASH && (Z.a.equals(i.lineDash, t.lineDash) || e.setLineDash(i.lineDash = t.lineDash), i.lineDashOffset != t.lineDashOffset && (i.lineDashOffset = e.lineDashOffset = t.lineDashOffset)), i.lineJoin != t.lineJoin && (i.lineJoin = e.lineJoin = t.lineJoin), i.lineWidth != t.lineWidth && (i.lineWidth = e.lineWidth = t.lineWidth), i.miterLimit != t.miterLimit && (i.miterLimit = e.miterLimit = t.miterLimit), i.strokeStyle != t.strokeStyle && (i.strokeStyle = e.strokeStyle = t.strokeStyle)) : (e.lineCap = t.lineCap, O.a.CANVAS_LINE_DASH && (e.setLineDash(t.lineDash), e.lineDashOffset = t.lineDashOffset), e.lineJoin = t.lineJoin, e.lineWidth = t.lineWidth, e.miterLimit = t.miterLimit, e.strokeStyle = t.strokeStyle, this.contextStrokeState_ = {
				lineCap: t.lineCap,
				lineDash: t.lineDash,
				lineDashOffset: t.lineDashOffset,
				lineJoin: t.lineJoin,
				lineWidth: t.lineWidth,
				miterLimit: t.miterLimit,
				strokeStyle: t.strokeStyle
			})
		}, dt.prototype.setContextTextState_ = function(t) {
			var e = this.context_,
				i = this.contextTextState_,
				n = t.textAlign ? t.textAlign : rt.a.defaultTextAlign;
			i ? (i.font != t.font && (i.font = e.font = t.font), i.textAlign != n && (i.textAlign = n), i.textBaseline != t.textBaseline && (i.textBaseline = e.textBaseline = t.textBaseline)) : (e.font = t.font, e.textAlign = n, e.textBaseline = t.textBaseline, this.contextTextState_ = {
				font: t.font,
				textAlign: n,
				textBaseline: t.textBaseline
			})
		}, dt.prototype.setFillStrokeStyle = function(t, e) {
			if (t) {
				var i = t.getColor();
				this.fillState_ = {
					fillStyle: ot.a.asColorLike(i || rt.a.defaultFillStyle)
				}
			} else this.fillState_ = null;
			if (e) {
				var n = e.getColor(),
					r = e.getLineCap(),
					o = e.getLineDash(),
					s = e.getLineDashOffset(),
					a = e.getLineJoin(),
					l = e.getWidth(),
					u = e.getMiterLimit();
				this.strokeState_ = {
					lineCap: void 0 !== r ? r : rt.a.defaultLineCap,
					lineDash: o || rt.a.defaultLineDash,
					lineDashOffset: s || rt.a.defaultLineDashOffset,
					lineJoin: void 0 !== a ? a : rt.a.defaultLineJoin,
					lineWidth: this.pixelRatio_ * (void 0 !== l ? l : rt.a.defaultLineWidth),
					miterLimit: void 0 !== u ? u : rt.a.defaultMiterLimit,
					strokeStyle: ot.a.asColorLike(n || rt.a.defaultStrokeStyle)
				}
			} else this.strokeState_ = null
		}, dt.prototype.setImageStyle = function(t) {
			if (t) {
				var e = t.getAnchor(),
					i = t.getImage(1),
					n = t.getOrigin(),
					r = t.getSize();
				this.imageAnchorX_ = e[0], this.imageAnchorY_ = e[1], this.imageHeight_ = r[1], this.image_ = i, this.imageOpacity_ = t.getOpacity(), this.imageOriginX_ = n[0], this.imageOriginY_ = n[1], this.imageRotateWithView_ = t.getRotateWithView(), this.imageRotation_ = t.getRotation(), this.imageScale_ = t.getScale() * this.pixelRatio_, this.imageSnapToPixel_ = t.getSnapToPixel(), this.imageWidth_ = r[0]
			} else this.image_ = null
		}, dt.prototype.setTextStyle = function(t) {
			if (t) {
				var e = t.getFill();
				if (e) {
					var i = e.getColor();
					this.textFillState_ = {
						fillStyle: ot.a.asColorLike(i || rt.a.defaultFillStyle)
					}
				} else this.textFillState_ = null;
				var n = t.getStroke();
				if (n) {
					var r = n.getColor(),
						o = n.getLineCap(),
						s = n.getLineDash(),
						a = n.getLineDashOffset(),
						l = n.getLineJoin(),
						u = n.getWidth(),
						h = n.getMiterLimit();
					this.textStrokeState_ = {
						lineCap: void 0 !== o ? o : rt.a.defaultLineCap,
						lineDash: s || rt.a.defaultLineDash,
						lineDashOffset: a || rt.a.defaultLineDashOffset,
						lineJoin: void 0 !== l ? l : rt.a.defaultLineJoin,
						lineWidth: void 0 !== u ? u : rt.a.defaultLineWidth,
						miterLimit: void 0 !== h ? h : rt.a.defaultMiterLimit,
						strokeStyle: ot.a.asColorLike(r || rt.a.defaultStrokeStyle)
					}
				} else this.textStrokeState_ = null;
				var c = t.getFont(),
					d = t.getOffsetX(),
					f = t.getOffsetY(),
					A = t.getRotateWithView(),
					p = t.getRotation(),
					g = t.getScale(),
					m = t.getText(),
					v = t.getTextAlign(),
					y = t.getTextBaseline();
				this.textState_ = {
					font: void 0 !== c ? c : rt.a.defaultFont,
					textAlign: void 0 !== v ? v : rt.a.defaultTextAlign,
					textBaseline: void 0 !== y ? y : rt.a.defaultTextBaseline
				}, this.text_ = void 0 !== m ? m : "", this.textOffsetX_ = void 0 !== d ? this.pixelRatio_ * d : 0, this.textOffsetY_ = void 0 !== f ? this.pixelRatio_ * f : 0, this.textRotateWithView_ = void 0 !== A && A, this.textRotation_ = void 0 !== p ? p : 0, this.textScale_ = this.pixelRatio_ * (void 0 !== g ? g : 1)
			} else this.text_ = ""
		};
		var ft = dt,
			At = i(81),
			pt = i(13),
			gt = i(15),
			mt = i(3),
			vt = i(59),
			yt = function(t) {
				At.
			default.call(this), this.layer_ = t
			};
		n.
	default.inherits(yt, At.
	default), yt.prototype.forEachFeatureAtCoordinate = n.
	default.nullFunction, yt.prototype.hasFeatureAtCoordinate = v.a.FALSE, yt.prototype.createLoadedTileFinder = function(t, e, i) {
			return function(n, r) {
				return t.forEachLoadedTile(e, n, r, (function(t) {
					i[n] || (i[n] = {}), i[n][t.tileCoord.toString()] = t
				}))
			}
		}, yt.prototype.getLayer = function() {
			return this.layer_
		}, yt.prototype.handleImageChange_ = function(t) {
			t.target.getState() === X.a.LOADED && this.renderIfReadyAndVisible()
		}, yt.prototype.loadImage = function(t) {
			var e = t.getState();
			return e != X.a.LOADED && e != X.a.ERROR && mt.a.listen(t, T.a.CHANGE, this.handleImageChange_, this), e == X.a.IDLE && (t.load(), e = t.getState()), e == X.a.LOADED
		}, yt.prototype.renderIfReadyAndVisible = function() {
			var t = this.getLayer();
			t.getVisible() && t.getSourceState() == vt.a.READY && this.changed()
		}, yt.prototype.scheduleExpireCache = function(t, e) {
			if (e.canExpireCache()) {
				var i = function(t, e, i) {
						var r = n.
					default.getUid(t).toString();
						r in i.usedTiles && t.expireCache(i.viewState.projection, i.usedTiles[r])
					}.bind(null, e);
				t.postRenderFunctions.push(i)
			}
		}, yt.prototype.updateLogos = function(t, e) {
			var i = e.getLogo();
			void 0 !== i && ("string" == typeof i ? t.logos[i] = "" : i && (gt.a.assert("string" == typeof i.href, 44), gt.a.assert("string" == typeof i.src, 45), t.logos[i.src] = i.href))
		}, yt.prototype.updateUsedTiles = function(t, e, i, r) {
			var o = n.
		default.getUid(e).toString(),
				s = i.toString();
			o in t ? s in t[o] ? t[o][s].extend(r):
			t[o][s] = r : (t[o] = {}, t[o][s] = r)
		}, yt.prototype.manageTilePyramid = function(t, e, i, r, o, s, a, l, u, h) {
			var c = n.
		default.getUid(e).toString();
			c in t.wantedTiles || (t.wantedTiles[c] = {});
			var d, f, A, p, g, m, v = t.wantedTiles[c],
				y = t.tileQueue;
			for (m = i.getMinZoom(); m <= a; ++m) for (f = i.getTileRangeForExtentAndZ(s, m, f), A = i.getResolution(m), p = f.minX; p <= f.maxX; ++p) for (g = f.minY; g <= f.maxY; ++g) a - m <= l ? ((d = e.getTile(m, p, g, r, o)).getState() == pt.a.IDLE && (v[d.getKey()] = !0, y.isKeyQueued(d.getKey()) || y.enqueue([d, c, i.getTileCoordCenter(d.tileCoord), A])), void 0 !== u && u.call(h, d)):
			e.useTile(m, p, g, o)
		};
		var _t = yt,
			Et = function(t) {
				_t.call(this, t), this.renderedResolution, this.transform_ = ct.a.create()
			};
		n.
	default.inherits(Et, _t), Et.prototype.clip = function(t, e, i) {
			var n = e.pixelRatio,
				r = e.size[0] * n,
				o = e.size[1] * n,
				s = e.viewState.rotation,
				a = K.
			default.getTopLeft(i),
				l = K.
			default.getTopRight(i),
				u = K.
			default.getBottomRight(i),
				h = K.
			default.getBottomLeft(i);
			ct.a.apply(e.coordinateToPixelTransform, a), ct.a.apply(e.coordinateToPixelTransform, l), ct.a.apply(e.coordinateToPixelTransform, u), ct.a.apply(e.coordinateToPixelTransform, h), t.save(), rt.a.rotateAtOffset(t, -s, r / 2, o / 2), t.beginPath(), t.moveTo(a[0] * n, a[1] * n), t.lineTo(l[0] * n, l[1] * n), t.lineTo(u[0] * n, u[1] * n), t.lineTo(h[0] * n, h[1] * n), t.clip(), rt.a.rotateAtOffset(t, s, r / 2, o / 2)
		}, Et.prototype.dispatchComposeEvent_ = function(t, e, i, n) {
			var r = this.getLayer();
			if (r.hasListener(t)) {
				var o = i.size[0] * i.pixelRatio,
					s = i.size[1] * i.pixelRatio,
					a = i.viewState.rotation;
				rt.a.rotateAtOffset(e, -a, o / 2, s / 2);
				var l = void 0 !== n ? n : this.getTransform(i, 0),
					u = new ft(e, i.pixelRatio, i.extent, l, i.viewState.rotation),
					h = new it(t, u, i, e, null);
				r.dispatchEvent(h), rt.a.rotateAtOffset(e, a, o / 2, s / 2)
			}
		}, Et.prototype.forEachLayerAtCoordinate = function(t, e, i, n) {
			return this.forEachFeatureAtCoordinate(t, e, 0, v.a.TRUE, this) ? i.call(n, this.getLayer(), null) : void 0
		}, Et.prototype.postCompose = function(t, e, i, n) {
			this.dispatchComposeEvent_(nt.a.POSTCOMPOSE, t, e, n)
		}, Et.prototype.preCompose = function(t, e, i) {
			this.dispatchComposeEvent_(nt.a.PRECOMPOSE, t, e, i)
		}, Et.prototype.dispatchRenderEvent = function(t, e, i) {
			this.dispatchComposeEvent_(nt.a.RENDER, t, e, i)
		}, Et.prototype.getTransform = function(t, e) {
			var i = t.viewState,
				n = t.pixelRatio,
				r = n * t.size[0] / 2,
				o = n * t.size[1] / 2,
				s = n / i.resolution,
				a = -s,
				l = -i.rotation,
				u = -i.center[0] + e,
				h = -i.center[1];
			return ct.a.compose(this.transform_, r, o, s, a, l, u, h)
		}, Et.prototype.composeFrame = function(t, e, i) {}, Et.prototype.prepareFrame = function(t, e) {};
		var xt = Et,
			Ct = function(t) {
				xt.call(this, t), this.coordinateToCanvasPixelTransform = ct.a.create(), this.hitCanvasContext_ = null
			};
		n.
	default.inherits(Ct, xt), Ct.prototype.composeFrame = function(t, e, i) {
			this.preCompose(i, t);
			var n = this.getImage();
			if (n) {
				var r = e.extent,
					o = void 0 !== r && !K.
				default.containsExtent(r, t.extent) && K.
				default.intersects(r, t.extent);
				o && this.clip(i, t, r);
				var s = this.getImageTransform(),
					a = i.globalAlpha;
				i.globalAlpha = e.opacity;
				var l = s[4],
					u = s[5],
					h = n.width * s[0],
					c = n.height * s[3];
				i.drawImage(n, 0, 0, +n.width, +n.height, Math.round(l), Math.round(u), Math.round(h), Math.round(c)), i.globalAlpha = a, o && i.restore()
			}
			this.postCompose(i, t, e)
		}, Ct.prototype.getImage = function() {}, Ct.prototype.getImageTransform = function() {}, Ct.prototype.forEachFeatureAtCoordinate = function(t, e, i, n, r) {
			var o = this.getLayer(),
				s = o.getSource(),
				a = e.viewState.resolution,
				l = e.viewState.rotation,
				u = e.skippedFeatureUids;
			return s.forEachFeatureAtCoordinate(t, a, l, i, u, (function(t) {
				return n.call(r, t, o)
			}))
		}, Ct.prototype.forEachLayerAtCoordinate = function(t, e, i, r) {
			if (this.getImage()) {
				if (this.getLayer().getSource().forEachFeatureAtCoordinate !== n.
			default.nullFunction) return xt.prototype.forEachLayerAtCoordinate.apply(this, arguments);
				var o = ct.a.apply(this.coordinateToCanvasPixelTransform, t.slice());
				p.
			default.scale(o, e.viewState.resolution / this.renderedResolution), this.hitCanvasContext_ || (this.hitCanvasContext_ = $.a.createCanvasContext2D(1, 1)), this.hitCanvasContext_.clearRect(0, 0, 1, 1), this.hitCanvasContext_.drawImage(this.getImage(), o[0], o[1], 1, 1, 0, 0, 1, 1);
				var s = this.hitCanvasContext_.getImageData(0, 0, 1, 1).data;
				return s[3] > 0 ? i.call(r, this.getLayer(), s):
				void 0
			}
		};
		var It = Ct,
			St = function(t) {
				It.call(this, t), this.image_ = null, this.imageTransform_ = ct.a.create(), this.skippedFeatures_ = [], this.vectorRenderer_ = null
			};
		n.
	default.inherits(St, It), St.handles = function(t, e) {
			return t === Q.a.CANVAS && (e.getType() === H.a.IMAGE || e.getType() === H.a.VECTOR && e.getRenderMode() === J.a.IMAGE)
		}, St.create = function(t, e) {
			var i = new St(e);
			if (e.getType() === H.a.VECTOR) for (var n = Y.a.getLayerRendererPlugins(), r = 0, o = n.length; r < o; ++r) {
				var s = n[r];
				s !== St && s.handles(Q.a.CANVAS, e) && i.setVectorRenderer(s.create(t, e))
			}
			return i
		}, St.prototype.getImage = function() {
			return this.image_ ? this.image_.getImage() : null
		}, St.prototype.getImageTransform = function() {
			return this.imageTransform_
		}, St.prototype.prepareFrame = function(t, e) {
			var i, r = t.pixelRatio,
				o = t.size,
				s = t.viewState,
				a = s.center,
				l = s.resolution,
				u = this.getLayer().getSource(),
				h = t.viewHints,
				c = t.extent;
			if (void 0 !== e.extent && (c = K.
		default.getIntersection(c, e.extent)), !h[A.a.ANIMATING] && !h[A.a.INTERACTING] && !K.
		default.isEmpty(c)) {
				var d = s.projection;
				if (!n.
			default.ENABLE_RASTER_REPROJECTION) {
					var f = u.getProjection();
					f && (d = f)
				}
				var p = this.vectorRenderer_;
				if (p) {
					var g = p.context,
						m = V.a.assign({}, t, {
							size: [K.
						default.getWidth(c) / l, K.
						default.getHeight(c) / l],
							viewState: V.a.assign({}, t.viewState, {
								rotation: 0
							})
						}),
						v = Object.keys(m.skippedFeatureUids).sort();
					!p.prepareFrame(m, e) || !p.replayGroupChanged && Z.a.equals(v, this.skippedFeatures_) || (g.canvas.width = m.size[0] * r, g.canvas.height = m.size[1] * r, p.composeFrame(m, e, g), this.image_ = new q(c, l, r, g.canvas), this.skippedFeatures_ = v)
				} else {
					if (i = u.getImage(c, l, r, d)) this.loadImage(i) && (this.image_ = i)
				}
			}
			if (this.image_) {
				var y = (i = this.image_).getExtent(),
					_ = i.getResolution(),
					E = i.getPixelRatio(),
					x = r * _ / (l * E),
					C = ct.a.compose(this.imageTransform_, r * o[0] / 2, r * o[1] / 2, x, x, 0, E * (y[0] - a[0]) / _, E * (a[1] - y[3]) / _);
				ct.a.compose(this.coordinateToCanvasPixelTransform, r * o[0] / 2 - C[4], r * o[1] / 2 - C[5], r / l, -r / l, 0, -a[0], -a[1]), this.updateLogos(t, u), this.renderedResolution = _ * r / E
			}
			return !!this.image_
		}, St.prototype.forEachFeatureAtCoordinate = function(t, e, i, n, r) {
			return this.vectorRenderer_ ? this.vectorRenderer_.forEachFeatureAtCoordinate(t, e, i, n, r) : It.prototype.forEachFeatureAtCoordinate.call(this, t, e, i, n, r)
		}, St.prototype.setVectorRenderer = function(t) {
			this.vectorRenderer_ = t
		};
		var Tt = St,
			Rt = i(37),
			wt = i(53),
			Lt = i(88),
			Nt = i(141),
			Pt = function(t, e) {
				Lt.a.call(this), this.map_ = e, this.layerRenderers_ = {}, this.layerRendererListeners_ = {}
			};
		n.
	default.inherits(Pt, Lt.a), Pt.prototype.calculateMatrices2D = function(t) {
			var e = t.viewState,
				i = t.coordinateToPixelTransform,
				n = t.pixelToCoordinateTransform;
			ct.a.compose(i, t.size[0] / 2, t.size[1] / 2, 1 / e.resolution, -1 / e.resolution, -e.rotation, -e.center[0], -e.center[1]), ct.a.invert(ct.a.setFromArray(n, i))
		}, Pt.prototype.removeLayerRenderers = function() {
			for (var t in this.layerRenderers_) this.removeLayerRendererByKey_(t).dispose()
		}, Pt.expireIconCache_ = function(t, e) {
			Nt.a.iconImageCache.expire()
		}, Pt.prototype.forEachFeatureAtCoordinate = function(t, e, i, r, o, s, a) {
			var l, u = e.viewState,
				h = u.resolution;

			function c(t, i) {
				var s = n.
			default.getUid(t).toString(),
					a = e.layerStates[n.
				default.getUid(i)].managed;
				if (!(s in e.skippedFeatureUids) || a) return r.call(o, t, a ? i : null)
			}
			var d = u.projection,
				f = t;
			if (d.canWrapX()) {
				var A = d.getExtent(),
					p = K.
				default.getWidth(A),
					g = t[0];
				if (g < A[0] || g > A[2]) f = [g + p * Math.ceil((A[0] - g) / p), t[1]]
			}
			var m, v = e.layerStatesArray;
			for (m = v.length - 1; m >= 0; --m) {
				var y = v[m],
					_ = y.layer;
				if (wt.a.visibleAtResolution(y, h) && s.call(a, _)) {
					var E = this.getLayerRenderer(_);
					if (_.getSource() && (l = E.forEachFeatureAtCoordinate(_.getSource().getWrapX() ? f : t, e, i, c, o)), l) return l
				}
			}
		}, Pt.prototype.forEachLayerAtPixel = function(t, e, i, n, r, o) {}, Pt.prototype.hasFeatureAtCoordinate = function(t, e, i, n, r) {
			return void 0 !== this.forEachFeatureAtCoordinate(t, e, i, v.a.TRUE, this, n, r)
		}, Pt.prototype.getLayerRenderer = function(t) {
			var e = n.
		default.getUid(t).toString();
			if (e in this.layerRenderers_) return this.layerRenderers_[e];
			for (var i, r = Y.a.getLayerRendererPlugins(), o = this.getType(), s = 0, a = r.length; s < a; ++s) {
				var l = r[s];
				if (l.handles(o, t)) {
					i = l.create(this, t);
					break
				}
			}
			if (!i) throw new Error("Unable to create renderer for layer: " + t.getType());
			return this.layerRenderers_[e] = i, this.layerRendererListeners_[e] = mt.a.listen(i, T.a.CHANGE, this.handleLayerRendererChange_, this), i
		}, Pt.prototype.getLayerRendererByKey = function(t) {
			return this.layerRenderers_[t]
		}, Pt.prototype.getLayerRenderers = function() {
			return this.layerRenderers_
		}, Pt.prototype.getMap = function() {
			return this.map_
		}, Pt.prototype.getType = function() {}, Pt.prototype.handleLayerRendererChange_ = function() {
			this.map_.render()
		}, Pt.prototype.removeLayerRendererByKey_ = function(t) {
			var e = this.layerRenderers_[t];
			return delete this.layerRenderers_[t], mt.a.unlistenByKey(this.layerRendererListeners_[t]), delete this.layerRendererListeners_[t], e
		}, Pt.prototype.renderFrame = n.
	default.nullFunction, Pt.prototype.removeUnusedLayerRenderers_ = function(t, e) {
			var i;
			for (i in this.layerRenderers_) e && i in e.layerStates || this.removeLayerRendererByKey_(i).dispose()
		}, Pt.prototype.scheduleExpireIconCache = function(t) {
			t.postRenderFunctions.push(Pt.expireIconCache_)
		}, Pt.prototype.scheduleRemoveUnusedLayerRenderers = function(t) {
			var e;
			for (e in this.layerRenderers_) if (!(e in t.layerStates)) return void t.postRenderFunctions.push(this.removeUnusedLayerRenderers_.bind(this))
		}, Pt.sortByZIndex = function(t, e) {
			return t.zIndex - e.zIndex
		};
		var Ot = Pt,
			Mt = function(t, e) {
				Ot.call(this, t, e), this.context_ = $.a.createCanvasContext2D(), this.canvas_ = this.context_.canvas, this.canvas_.style.width = "100%", this.canvas_.style.height = "100%", this.canvas_.style.display = "block", this.canvas_.className = Rt.a.CLASS_UNSELECTABLE, t.insertBefore(this.canvas_, t.childNodes[0] || null), this.renderedVisible_ = !0, this.transform_ = ct.a.create()
			};
		n.
	default.inherits(Mt, Ot), Mt.handles = function(t) {
			return t === Q.a.CANVAS
		}, Mt.create = function(t, e) {
			return new Mt(t, e)
		}, Mt.prototype.dispatchComposeEvent_ = function(t, e) {
			var i = this.getMap(),
				n = this.context_;
			if (i.hasListener(t)) {
				var r = e.extent,
					o = e.pixelRatio,
					s = e.viewState.rotation,
					a = this.getTransform(e),
					l = new ft(n, o, r, a, s),
					u = new it(t, l, e, n, null);
				i.dispatchEvent(u)
			}
		}, Mt.prototype.getTransform = function(t) {
			var e = t.viewState,
				i = this.canvas_.width / 2,
				n = this.canvas_.height / 2,
				r = t.pixelRatio / e.resolution,
				o = -r,
				s = -e.rotation,
				a = -e.center[0],
				l = -e.center[1];
			return ct.a.compose(this.transform_, i, n, r, o, s, a, l)
		}, Mt.prototype.getType = function() {
			return Q.a.CANVAS
		}, Mt.prototype.renderFrame = function(t) {
			if (t) {
				var e = this.context_,
					i = t.pixelRatio,
					n = Math.round(t.size[0] * i),
					r = Math.round(t.size[1] * i);
				this.canvas_.width != n || this.canvas_.height != r ? (this.canvas_.width = n, this.canvas_.height = r) : e.clearRect(0, 0, n, r);
				var o = t.viewState.rotation;
				this.calculateMatrices2D(t), this.dispatchComposeEvent_(nt.a.PRECOMPOSE, t);
				var s = t.layerStatesArray;
				Z.a.stableSort(s, Ot.sortByZIndex), o && (e.save(), rt.a.rotateAtOffset(e, o, n / 2, r / 2));
				var a, l, u, h, c, d = t.viewState.resolution;
				for (a = 0, l = s.length; a < l; ++a) u = (c = s[a]).layer, h = this.getLayerRenderer(u), wt.a.visibleAtResolution(c, d) && c.sourceState == vt.a.READY && h.prepareFrame(t, c) && h.composeFrame(t, c, e);
				o && e.restore(), this.dispatchComposeEvent_(nt.a.POSTCOMPOSE, t), this.renderedVisible_ || (this.canvas_.style.display = "", this.renderedVisible_ = !0), this.scheduleRemoveUnusedLayerRenderers(t), this.scheduleExpireIconCache(t)
			} else this.renderedVisible_ && (this.canvas_.style.display = "none", this.renderedVisible_ = !1)
		}, Mt.prototype.forEachLayerAtPixel = function(t, e, i, n, r, o) {
			var s, a, l = e.viewState.resolution,
				u = e.layerStatesArray,
				h = u.length,
				c = ct.a.apply(e.pixelToCoordinateTransform, t.slice());
			for (a = h - 1; a >= 0; --a) {
				var d = u[a],
					f = d.layer;
				if (wt.a.visibleAtResolution(d, l) && r.call(o, f)) if (s = this.getLayerRenderer(f).forEachLayerAtCoordinate(c, e, i, n)) return s
			}
		};
		var bt = Mt,
			Ft = i(82),
			Dt = function(t) {
				It.call(this, t), this.context = null === this.context ? null : $.a.createCanvasContext2D(), this.oversampling_, this.renderedExtent_ = null, this.renderedRevision, this.renderedTiles = [], this.tmpExtent = K.
			default.createEmpty(), this.tmpTileRange_ = new Ft.a(0, 0, 0, 0), this.imageTransform_ = ct.a.create(), this.zDirection = 0
			};
		n.
	default.inherits(Dt, It), Dt.handles = function(t, e) {
			return t === Q.a.CANVAS && e.getType() === H.a.TILE
		}, Dt.create = function(t, e) {
			return new Dt(e)
		}, Dt.prototype.isDrawableTile_ = function(t) {
			var e = t.getState(),
				i = this.getLayer().getUseInterimTilesOnError();
			return e == pt.a.LOADED || e == pt.a.EMPTY || e == pt.a.ERROR && !i
		}, Dt.prototype.prepareFrame = function(t, e) {
			var i = t.pixelRatio,
				r = t.size,
				o = t.viewState,
				s = o.projection,
				a = o.resolution,
				l = o.center,
				u = this.getLayer(),
				h = u.getSource(),
				c = h.getRevision(),
				d = h.getTileGridForProjection(s),
				f = d.getZForResolution(a, this.zDirection),
				p = d.getResolution(f),
				g = Math.round(a / p) || 1,
				m = t.extent;
			if (void 0 !== e.extent && (m = K.
		default.getIntersection(m, e.extent)), K.
		default.isEmpty(m)) return !1;
			var v = d.getTileRangeForExtentAndZ(m, f),
				y = d.getTileRangeExtent(f, v),
				_ = h.getTilePixelRatio(i),
				E = {};
			E[f] = {};
			var x, C, I, S = this.createLoadedTileFinder(h, s, E),
				T = this.tmpExtent,
				R = this.tmpTileRange_,
				w = !1;
			for (C = v.minX; C <= v.maxX; ++C) for (I = v.minY; I <= v.maxY; ++I) {
				if ((x = h.getTile(f, C, I, i, s)).getState() == pt.a.ERROR && (u.getUseInterimTilesOnError() ? u.getPreload() > 0 && (w = !0) : x.setState(pt.a.LOADED)), this.isDrawableTile_(x) || (x = x.getInterimTile()), this.isDrawableTile_(x)) {
					var L = n.
				default.getUid(this);
					if (x.getState() == pt.a.LOADED) {
						E[f][x.tileCoord.toString()] = x;
						var N = x.inTransition(L);
						w || !N && -1 !== this.renderedTiles.indexOf(x) || (w = !0)
					}
					if (1 === x.getAlpha(L, t.time)) continue
				}
				var P = d.getTileCoordChildTileRange(x.tileCoord, R, T),
					O = !1;
				P && (O = S(f + 1, P)), O || d.forEachTileCoordParentTileRange(x.tileCoord, S, null, R, T)
			}
			var M = p * i / _ * g,
				b = t.viewHints,
				F = b[A.a.ANIMATING] || b[A.a.INTERACTING];
			if (!(this.renderedResolution && Date.now() - t.time > 16 && F) && (w || !this.renderedExtent_ || !K.
		default.containsExtent(this.renderedExtent_, m) || this.renderedRevision != c || g != this.oversampling_ || !F && M != this.renderedResolution)) {
				var D = this.context;
				if (D) {
					var G = h.getTilePixelSize(f, i, s),
						k = Math.round(v.getWidth() * G[0] / g),
						U = Math.round(v.getHeight() * G[1] / g),
						B = D.canvas;
					B.width != k || B.height != U ? (this.oversampling_ = g, B.width = k, B.height = U) : (this.renderedExtent_ && !K.
				default.equals(y, this.renderedExtent_) && D.clearRect(0, 0, k, U), g = this.oversampling_)
				}
				this.renderedTiles.length = 0;
				var j, V, Y, z, X, W, q, H, Z, J, Q = Object.keys(E).map(Number);
				for (Q.sort((function(t, e) {
					return t === f ? 1 : e === f ? -1 : t > e ? 1 : t < e ? -1 : 0
				})), z = 0, X = Q.length; z < X; ++z) for (var $ in Y = Q[z], V = h.getTilePixelSize(Y, i, s), j = d.getResolution(Y) / p, q = _ * h.getGutter(s), H = E[Y]) x = H[$], C = ((W = d.getTileCoordExtent(x.getTileCoord(), T))[0] - y[0]) / p * _ / g, I = (y[3] - W[3]) / p * _ / g, Z = V[0] * j / g, J = V[1] * j / g, this.drawTileImage(x, t, e, C, I, Z, J, q, f === Y), this.renderedTiles.push(x);
				this.renderedRevision = c, this.renderedResolution = p * i / _ * g, this.renderedExtent_ = y
			}
			var tt = this.renderedResolution / a,
				et = ct.a.compose(this.imageTransform_, i * r[0] / 2, i * r[1] / 2, tt, tt, 0, (this.renderedExtent_[0] - l[0]) / this.renderedResolution * i, (l[1] - this.renderedExtent_[3]) / this.renderedResolution * i);
			return ct.a.compose(this.coordinateToCanvasPixelTransform, i * r[0] / 2 - et[4], i * r[1] / 2 - et[5], i / a, -i / a, 0, -l[0], -l[1]), this.updateUsedTiles(t.usedTiles, h, f, v), this.manageTilePyramid(t, h, d, i, s, m, f, u.getPreload()), this.scheduleExpireCache(t, h), this.updateLogos(t, h), this.renderedTiles.length > 0
		}, Dt.prototype.drawTileImage = function(t, e, i, r, o, s, a, l, u) {
			var h = t.getImage(this.getLayer());
			if (h) {
				var c = n.
			default.getUid(this),
					d = u ? t.getAlpha(c, e.time):
					1;
				1 !== d || this.getLayer().getSource().getOpaque(e.viewState.projection) || this.context.clearRect(r, o, s, a);
				var f = d !== this.context.globalAlpha;
				f && (this.context.save(), this.context.globalAlpha = d), this.context.drawImage(h, l, l, h.width - 2 * l, h.height - 2 * l, r, o, s, a), f && this.context.restore(), 1 !== d ? e.animate = !0 : u && t.endTransition(c)
			}
		}, Dt.prototype.getImage = function() {
			var t = this.context;
			return t ? t.canvas : null
		}, Dt.prototype.getLayer, Dt.prototype.getImageTransform = function() {
			return this.imageTransform_
		};
		var Gt = Dt,
			kt = i(116),
			Ut = i.n(kt),
			Bt = function() {};
		Bt.prototype.getReplay = function(t, e) {}, Bt.prototype.isEmpty = function() {};
		var jt = Bt,
			Vt = {
				CIRCLE: "Circle",
				DEFAULT: "Default",
				IMAGE: "Image",
				LINE_STRING: "LineString",
				POLYGON: "Polygon",
				TEXT: "Text"
			},
			Yt = i(56),
			zt = i(65),
			Xt = i(136),
			Wt = {
				lineString: function(t, e, i, n, r, o, s, a) {
					for (var l, u, h, c = [], d = t[e] > t[i - n], f = r.length, A = t[e], p = t[e + 1], g = t[e += n], m = t[e + 1], v = 0, y = Math.sqrt(Math.pow(g - A, 2) + Math.pow(m - p, 2)), _ = "", E = 0, x = 0; x < f; ++x) {
						u = d ? f - x - 1 : x;
						var C = r.charAt(u),
							I = o(_ = d ? C + _ : _ + C) - E;
						E += I;
						for (var S = s + I / 2; e < i - n && v + y < S;) A = g, p = m, g = t[e += n], m = t[e + 1], v += y, y = Math.sqrt(Math.pow(g - A, 2) + Math.pow(m - p, 2));
						var T = S - v,
							R = Math.atan2(m - p, g - A);
						if (d && (R += R > 0 ? -Math.PI : Math.PI), void 0 !== h) {
							var w = R - h;
							if (w += w > Math.PI ? -2 * Math.PI : w < -Math.PI ? 2 * Math.PI : 0, Math.abs(w) > a) return null
						}
						var L = T / y,
							N = M.a.lerp(A, g, L),
							P = M.a.lerp(p, m, L);
						h == R ? (d && (l[0] = N, l[1] = P, l[2] = I / 2), l[4] = _) : (E = I, l = [N, P, I / 2, R, _ = C], d ? c.unshift(l) : c.push(l), h = R), s += I
					}
					return c
				}
			},
			qt = Wt,
			Ht = {
				BEGIN_GEOMETRY: 0,
				BEGIN_PATH: 1,
				CIRCLE: 2,
				CLOSE_PATH: 3,
				CUSTOM: 4,
				DRAW_CHARS: 5,
				DRAW_IMAGE: 6,
				END_GEOMETRY: 7,
				FILL: 8,
				MOVE_TO_LINE_TO: 9,
				SET_FILL_STYLE: 10,
				SET_STROKE_STYLE: 11,
				STROKE: 12
			},
			Zt = {};
		Zt.ORDER = [Vt.POLYGON, Vt.CIRCLE, Vt.LINE_STRING, Vt.IMAGE, Vt.TEXT, Vt.DEFAULT], Zt.TEXT_ALIGN = {}, Zt.TEXT_ALIGN.left = 0, Zt.TEXT_ALIGN.end = 0, Zt.TEXT_ALIGN.center = .5, Zt.TEXT_ALIGN.right = 1, Zt.TEXT_ALIGN.start = 1, Zt.TEXT_ALIGN.top = 0, Zt.TEXT_ALIGN.middle = .5, Zt.TEXT_ALIGN.hanging = .2, Zt.TEXT_ALIGN.alphabetic = .8, Zt.TEXT_ALIGN.ideographic = .8, Zt.TEXT_ALIGN.bottom = 1;
		var Kt = Zt,
			Jt = function(t, e, i, n, r, o) {
				ht.call(this), this.declutterTree = o, this.tmpExtent_ = K.
			default.createEmpty(), this.tolerance = t, this.maxExtent = e, this.overlaps = r, this.pixelRatio = n, this.maxLineWidth = 0, this.resolution = i, this.fillOrigin_, this.beginGeometryInstruction1_ = null, this.beginGeometryInstruction2_ = null, this.bufferedMaxExtent_ = null, this.instructions = [], this.coordinates = [], this.coordinateCache_ = {}, this.renderedTransform_ = ct.a.create(), this.hitDetectionInstructions = [], this.pixelCoordinates_ = null, this.state = {}, this.viewRotation_ = 0, this.tmpLocalTransform_ = ct.a.create(), this.resetTransform_ = ct.a.create()
			};
		n.
	default.inherits(Jt, ht), Jt.prototype.replayTextBackground_ = function(t, e, i, n, r, o, s) {
			t.beginPath(), t.moveTo.apply(t, e), t.lineTo.apply(t, i), t.lineTo.apply(t, n), t.lineTo.apply(t, r), t.lineTo.apply(t, e), o && (this.fillOrigin_ = o[2], this.fill_(t)), s && (this.setStrokeStyle_(t, s), t.stroke())
		}, Jt.prototype.replayImage_ = function(t, e, i, n, r, o, s, a, l, u, h, c, d, f, A, p, g, m) {
			var v = g || m,
				y = this.tmpLocalTransform_;
			e -= r *= d, i -= o *= d, f && (e = Math.round(e), i = Math.round(i));
			var _, E, x, C, I = A + u > n.width ? n.width - u : A,
				S = a + h > n.height ? n.height - h : a,
				T = this.tmpExtent_,
				R = p[3] + I * d + p[1],
				w = p[0] + S * d + p[2],
				L = e - p[3],
				N = i - p[0];
			(v || 0 !== c) && (_ = [L, N], E = [L + R, N], x = [L + R, N + w], C = [L, N + w]);
			var P = null;
			if (0 !== c) {
				var O = e + r,
					M = i + o;
				P = ct.a.compose(y, O, M, 1, 1, c, -O, -M), K.
			default.createOrUpdateEmpty(T), K.
			default.extendCoordinate(T, ct.a.apply(y, _)), K.
			default.extendCoordinate(T, ct.a.apply(y, E)), K.
			default.extendCoordinate(T, ct.a.apply(y, x)), K.
			default.extendCoordinate(T, ct.a.apply(y, C))
			} else K.
		default.createOrUpdate(L, N, L + R, N + w, T);
			var b = t.canvas,
				F = T[0] <= b.width && T[2] >= 0 && T[1] <= b.height && T[3] >= 0;
			if (s) {
				if (!F && 1 == s[4]) return;
				K.
			default.extend(s, T);
				var D = F ? [t, P ? P.slice(0) : null, l, n, u, h, I, S, e, i, d]:
				null;
				D && v && D.push(g, m, _, E, x, C), s.push(D)
			} else F && (v && this.replayTextBackground_(t, _, E, x, C, g, m), rt.a.drawImage(t, P, l, n, u, h, I, S, e, i, d))
		}, Jt.prototype.applyPixelRatio = function(t) {
			var e = this.pixelRatio;
			return 1 == e ? t : t.map((function(t) {
				return t * e
			}))
		}, Jt.prototype.appendFlatCoordinates = function(t, e, i, n, r, o) {
			var s = this.coordinates.length,
				a = this.getBufferedMaxExtent();
			o && (e += n);
			var l, u, h, c = [t[e], t[e + 1]],
				d = [NaN, NaN],
				f = !0;
			for (l = e + n; l < i; l += n) d[0] = t[l], d[1] = t[l + 1], (h = K.
		default.coordinateRelationship(a, d)) !== u ? (f && (this.coordinates[s++] = c[0], this.coordinates[s++] = c[1]), this.coordinates[s++] = d[0], this.coordinates[s++] = d[1], f = !1) : h === Yt.a.INTERSECTING ? (this.coordinates[s++] = d[0], this.coordinates[s++] = d[1], f = !1) : f = !0, c[0] = d[0], c[1] = d[1], u = h;
			return (r && f || l === e + n) && (this.coordinates[s++] = c[0], this.coordinates[s++] = c[1]), s
		}, Jt.prototype.drawCustomCoordinates_ = function(t, e, i, n, r) {
			for (var o = 0, s = i.length; o < s; ++o) {
				var a = i[o],
					l = this.appendFlatCoordinates(t, e, a, n, !1, !1);
				r.push(l), e = a
			}
			return e
		}, Jt.prototype.drawCustom = function(t, e, i) {
			this.beginGeometry(t, e);
			var n, r, o, s, a, l = t.getType(),
				u = t.getStride(),
				h = this.coordinates.length;
			if (l == st.a.MULTI_POLYGON) {
				n = (t = t).getOrientedFlatCoordinates(), s = [];
				var c = t.getEndss();
				a = 0;
				for (var d = 0, f = c.length; d < f; ++d) {
					var A = [];
					a = this.drawCustomCoordinates_(n, a, c[d], u, A), s.push(A)
				}
				this.instructions.push([Ht.CUSTOM, h, s, t, i, zt.a.coordinatesss])
			} else l == st.a.POLYGON || l == st.a.MULTI_LINE_STRING ? (o = [], n = l == st.a.POLYGON ? t.getOrientedFlatCoordinates() : t.getFlatCoordinates(), a = this.drawCustomCoordinates_(n, 0, t.getEnds(), u, o), this.instructions.push([Ht.CUSTOM, h, o, t, i, zt.a.coordinatess])) : l == st.a.LINE_STRING || l == st.a.MULTI_POINT ? (n = t.getFlatCoordinates(), r = this.appendFlatCoordinates(n, 0, n.length, u, !1, !1), this.instructions.push([Ht.CUSTOM, h, r, t, i, zt.a.coordinates])) : l == st.a.POINT && (n = t.getFlatCoordinates(), this.coordinates.push(n[0], n[1]), r = this.coordinates.length, this.instructions.push([Ht.CUSTOM, h, r, t, i]));
			this.endGeometry(t, e)
		}, Jt.prototype.beginGeometry = function(t, e) {
			this.beginGeometryInstruction1_ = [Ht.BEGIN_GEOMETRY, e, 0], this.instructions.push(this.beginGeometryInstruction1_), this.beginGeometryInstruction2_ = [Ht.BEGIN_GEOMETRY, e, 0], this.hitDetectionInstructions.push(this.beginGeometryInstruction2_)
		}, Jt.prototype.fill_ = function(t) {
			if (this.fillOrigin_) {
				var e = ct.a.apply(this.renderedTransform_, this.fillOrigin_.slice());
				t.translate(e[0], e[1]), t.rotate(this.viewRotation_)
			}
			t.fill(), this.fillOrigin_ && t.setTransform.apply(t, rt.a.resetTransform_)
		}, Jt.prototype.setStrokeStyle_ = function(t, e) {
			t.strokeStyle = e[1], t.lineWidth = e[2], t.lineCap = e[3], t.lineJoin = e[4], t.miterLimit = e[5], O.a.CANVAS_LINE_DASH && (t.lineDashOffset = e[7], t.setLineDash(e[6]))
		}, Jt.prototype.renderDeclutter_ = function(t, e) {
			if (t && t.length > 5) {
				var i = t[4];
				if (1 == i || i == t.length - 5) {
					var n = {
						minX: t[0],
						minY: t[1],
						maxX: t[2],
						maxY: t[3],
						value: e
					};
					if (!this.declutterTree.collides(n)) {
						this.declutterTree.insert(n);
						for (var r = rt.a.drawImage, o = 5, s = t.length; o < s; ++o) {
							var a = t[o];
							a && (a.length > 11 && this.replayTextBackground_(a[0], a[13], a[14], a[15], a[16], a[11], a[12]), r.apply(void 0, a))
						}
					}
					t.length = 5, K.
				default.createOrUpdateEmpty(t)
				}
			}
		}, Jt.prototype.replay_ = function(t, e, i, r, o, s) {
			var a;
			this.pixelCoordinates_ && Z.a.equals(e, this.renderedTransform_) ? a = this.pixelCoordinates_ : (this.pixelCoordinates_ || (this.pixelCoordinates_ = []), a = lt.a.transform2D(this.coordinates, 0, this.coordinates.length, 2, e, this.pixelCoordinates_), ct.a.setFromArray(this.renderedTransform_, e));
			for (var l, u, h, c, d, f, A, p, g, m = !V.a.isEmpty(i), v = 0, y = r.length, _ = 0, E = 0, x = 0, C = null, I = null, S = this.coordinateCache_, T = this.viewRotation_, R = {
				context: t,
				pixelRatio: this.pixelRatio,
				resolution: this.resolution,
				rotation: T
			}, w = this.instructions != r || this.overlaps ? 0 : 200; v < y;) {
				var L, N, P, O = r[v];
				switch (O[0]) {
				case Ht.BEGIN_GEOMETRY:
					L = O[1], m && i[n.
				default.getUid(L).toString()] || !L.getGeometry() ? v = O[2] : void 0 === s || K.
				default.intersects(s, L.getGeometry().getExtent()) ? ++v:
					v = O[2] + 1;
					break;
				case Ht.BEGIN_PATH:
					E > w && (this.fill_(t), E = 0), x > w && (t.stroke(), x = 0), E || x || (t.beginPath(), c = d = NaN), ++v;
					break;
				case Ht.CIRCLE:
					var M = a[_ = O[1]],
						b = a[_ + 1],
						F = a[_ + 2] - M,
						D = a[_ + 3] - b,
						G = Math.sqrt(F * F + D * D);
					t.moveTo(M + G, b), t.arc(M, b, G, 0, 2 * Math.PI, !0), ++v;
					break;
				case Ht.CLOSE_PATH:
					t.closePath(), ++v;
					break;
				case Ht.CUSTOM:
					_ = O[1], l = O[2];
					var k = O[3],
						U = O[4],
						B = 6 == O.length ? O[5] : void 0;
					R.geometry = k, R.feature = L, v in S || (S[v] = []);
					var j = S[v];
					B ? B(a, _, l, 2, j) : (j[0] = a[_], j[1] = a[_ + 1], j.length = 2), U(j, R), ++v;
					break;
				case Ht.DRAW_IMAGE:
					_ = O[1], l = O[2], g = O[3], u = O[4], h = O[5], p = o ? null : O[6];
					var Y, z, X, W = O[7],
						q = O[8],
						H = O[9],
						J = O[10],
						Q = O[11],
						$ = O[12],
						tt = O[13],
						et = O[14],
						it = O[15];
					for (O.length > 16 ? (Y = O[16], z = O[17], X = O[18]) : (Y = rt.a.defaultPadding, z = X = !1), Q && ($ += T); _ < l; _ += 2) this.replayImage_(t, a[_], a[_ + 1], g, u, h, p, W, q, H, J, $, tt, et, it, Y, z ? C : null, X ? I : null);
					this.renderDeclutter_(p, L), ++v;
					break;
				case Ht.DRAW_CHARS:
					var nt = O[1],
						ot = O[2],
						st = O[3];
					p = o ? null : O[4];
					var at = O[5],
						ut = O[6],
						ht = O[7],
						dt = O[8],
						ft = O[9],
						At = O[10],
						pt = O[11],
						gt = O[12],
						mt = O[13],
						vt = O[14],
						yt = Xt.a.lineString(a, nt, ot, 2),
						_t = dt(gt);
					if (at || _t <= yt) {
						var Et = this.textStates[mt].textAlign,
							xt = (yt - _t) * Kt.TEXT_ALIGN[Et],
							Ct = qt.lineString(a, nt, ot, 2, gt, dt, xt, ht);
						if (Ct) {
							var It, St, Tt, Rt, wt;
							if (At) for (It = 0, St = Ct.length; It < St; ++It) Tt = (wt = Ct[It])[4], Rt = this.getImage(Tt, mt, "", At), u = wt[2] + pt, h = st * Rt.height + 2 * (.5 - st) * pt - ft, this.replayImage_(t, wt[0], wt[1], Rt, u, h, p, Rt.height, 1, 0, 0, wt[3], vt, !1, Rt.width, rt.a.defaultPadding, null, null);
							if (ut) for (It = 0, St = Ct.length; It < St; ++It) Tt = (wt = Ct[It])[4], Rt = this.getImage(Tt, mt, ut, ""), u = wt[2], h = st * Rt.height - ft, this.replayImage_(t, wt[0], wt[1], Rt, u, h, p, Rt.height, 1, 0, 0, wt[3], vt, !1, Rt.width, rt.a.defaultPadding, null, null)
						}
					}
					this.renderDeclutter_(p, L), ++v;
					break;
				case Ht.END_GEOMETRY:
					if (void 0 !== o) {
						var Lt = o(L = O[1]);
						if (Lt) return Lt
					}++v;
					break;
				case Ht.FILL:
					w ? E++ : this.fill_(t), ++v;
					break;
				case Ht.MOVE_TO_LINE_TO:
					for (_ = O[1], l = O[2], N = a[_], A = (P = a[_ + 1]) + .5 | 0, (f = N + .5 | 0) === c && A === d || (t.moveTo(N, P), c = f, d = A), _ += 2; _ < l; _ += 2) f = (N = a[_]) + .5 | 0, A = (P = a[_ + 1]) + .5 | 0, _ != l - 2 && f === c && A === d || (t.lineTo(N, P), c = f, d = A);
					++v;
					break;
				case Ht.SET_FILL_STYLE:
					C = O, this.fillOrigin_ = O[2], E && (this.fill_(t), E = 0, x && (t.stroke(), x = 0)), t.fillStyle = O[1], ++v;
					break;
				case Ht.SET_STROKE_STYLE:
					I = O, x && (t.stroke(), x = 0), this.setStrokeStyle_(t, O), ++v;
					break;
				case Ht.STROKE:
					w ? x++ : t.stroke(), ++v;
					break;
				default:
					++v
				}
			}
			E && this.fill_(t), x && t.stroke()
		}, Jt.prototype.replay = function(t, e, i, n) {
			this.viewRotation_ = i, this.replay_(t, e, n, this.instructions, void 0, void 0)
		}, Jt.prototype.replayHitDetection = function(t, e, i, n, r, o) {
			return this.viewRotation_ = i, this.replay_(t, e, n, this.hitDetectionInstructions, r, o)
		}, Jt.prototype.reverseHitDetectionInstructions = function() {
			var t, e = this.hitDetectionInstructions;
			e.reverse();
			var i, n, r = e.length,
				o = -1;
			for (t = 0; t < r; ++t)(n = (i = e[t])[0]) == Ht.END_GEOMETRY ? o = t : n == Ht.BEGIN_GEOMETRY && (i[2] = t, Z.a.reverseSubArray(this.hitDetectionInstructions, o, t), o = -1)
		}, Jt.prototype.setFillStrokeStyle = function(t, e) {
			var i = this.state;
			if (t) {
				var n = t.getColor();
				i.fillStyle = ot.a.asColorLike(n || rt.a.defaultFillStyle)
			} else i.fillStyle = void 0;
			if (e) {
				var r = e.getColor();
				i.strokeStyle = ot.a.asColorLike(r || rt.a.defaultStrokeStyle);
				var o = e.getLineCap();
				i.lineCap = void 0 !== o ? o : rt.a.defaultLineCap;
				var s = e.getLineDash();
				i.lineDash = s ? s.slice() : rt.a.defaultLineDash;
				var a = e.getLineDashOffset();
				i.lineDashOffset = a || rt.a.defaultLineDashOffset;
				var l = e.getLineJoin();
				i.lineJoin = void 0 !== l ? l : rt.a.defaultLineJoin;
				var u = e.getWidth();
				i.lineWidth = void 0 !== u ? u : rt.a.defaultLineWidth;
				var h = e.getMiterLimit();
				i.miterLimit = void 0 !== h ? h : rt.a.defaultMiterLimit, i.lineWidth > this.maxLineWidth && (this.maxLineWidth = i.lineWidth, this.bufferedMaxExtent_ = null)
			} else i.strokeStyle = void 0, i.lineCap = void 0, i.lineDash = null, i.lineDashOffset = void 0, i.lineJoin = void 0, i.lineWidth = void 0, i.miterLimit = void 0
		}, Jt.prototype.applyFill = function(t, e) {
			var i = t.fillStyle,
				n = [Ht.SET_FILL_STYLE, i];
			if ("string" != typeof i) {
				var r = e.getExtent();
				n.push([r[0], r[3]])
			}
			this.instructions.push(n)
		}, Jt.prototype.applyStroke = function(t) {
			this.instructions.push([Ht.SET_STROKE_STYLE, t.strokeStyle, t.lineWidth * this.pixelRatio, t.lineCap, t.lineJoin, t.miterLimit, this.applyPixelRatio(t.lineDash), t.lineDashOffset * this.pixelRatio])
		}, Jt.prototype.updateFillStyle = function(t, e, i) {
			var n = t.fillStyle;
			"string" == typeof n && t.currentFillStyle == n || (e.call(this, t, i), t.currentFillStyle = n)
		}, Jt.prototype.updateStrokeStyle = function(t, e) {
			var i = t.strokeStyle,
				n = t.lineCap,
				r = t.lineDash,
				o = t.lineDashOffset,
				s = t.lineJoin,
				a = t.lineWidth,
				l = t.miterLimit;
			(t.currentStrokeStyle != i || t.currentLineCap != n || r != t.currentLineDash && !Z.a.equals(t.currentLineDash, r) || t.currentLineDashOffset != o || t.currentLineJoin != s || t.currentLineWidth != a || t.currentMiterLimit != l) && (e.call(this, t), t.currentStrokeStyle = i, t.currentLineCap = n, t.currentLineDash = r, t.currentLineDashOffset = o, t.currentLineJoin = s, t.currentLineWidth = a, t.currentMiterLimit = l)
		}, Jt.prototype.endGeometry = function(t, e) {
			this.beginGeometryInstruction1_[2] = this.instructions.length, this.beginGeometryInstruction1_ = null, this.beginGeometryInstruction2_[2] = this.hitDetectionInstructions.length, this.beginGeometryInstruction2_ = null;
			var i = [Ht.END_GEOMETRY, e];
			this.instructions.push(i), this.hitDetectionInstructions.push(i)
		}, Jt.prototype.finish = n.
	default.nullFunction, Jt.prototype.getBufferedMaxExtent = function() {
			if (!this.bufferedMaxExtent_ && (this.bufferedMaxExtent_ = K.
		default.clone(this.maxExtent), this.maxLineWidth > 0)) {
				var t = this.resolution * (this.maxLineWidth + 1) / 2;
				K.
			default.buffer(this.bufferedMaxExtent_, t, this.bufferedMaxExtent_)
			}
			return this.bufferedMaxExtent_
		};
		var Qt = Jt,
			$t = function(t, e, i, n, r, o) {
				Qt.call(this, t, e, i, n, r, o), this.declutterGroup_ = null, this.hitDetectionImage_ = null, this.image_ = null, this.anchorX_ = void 0, this.anchorY_ = void 0, this.height_ = void 0, this.opacity_ = void 0, this.originX_ = void 0, this.originY_ = void 0, this.rotateWithView_ = void 0, this.rotation_ = void 0, this.scale_ = void 0, this.snapToPixel_ = void 0, this.width_ = void 0
			};
		n.
	default.inherits($t, Qt), $t.prototype.drawCoordinates_ = function(t, e, i, n) {
			return this.appendFlatCoordinates(t, e, i, n, !1, !1)
		}, $t.prototype.drawPoint = function(t, e) {
			if (this.image_) {
				this.beginGeometry(t, e);
				var i = t.getFlatCoordinates(),
					n = t.getStride(),
					r = this.coordinates.length,
					o = this.drawCoordinates_(i, 0, i.length, n);
				this.instructions.push([Ht.DRAW_IMAGE, r, o, this.image_, this.anchorX_, this.anchorY_, this.declutterGroup_, this.height_, this.opacity_, this.originX_, this.originY_, this.rotateWithView_, this.rotation_, this.scale_ * this.pixelRatio, this.snapToPixel_, this.width_]), this.hitDetectionInstructions.push([Ht.DRAW_IMAGE, r, o, this.hitDetectionImage_, this.anchorX_, this.anchorY_, this.declutterGroup_, this.height_, this.opacity_, this.originX_, this.originY_, this.rotateWithView_, this.rotation_, this.scale_, this.snapToPixel_, this.width_]), this.endGeometry(t, e)
			}
		}, $t.prototype.drawMultiPoint = function(t, e) {
			if (this.image_) {
				this.beginGeometry(t, e);
				var i = t.getFlatCoordinates(),
					n = t.getStride(),
					r = this.coordinates.length,
					o = this.drawCoordinates_(i, 0, i.length, n);
				this.instructions.push([Ht.DRAW_IMAGE, r, o, this.image_, this.anchorX_, this.anchorY_, this.declutterGroup_, this.height_, this.opacity_, this.originX_, this.originY_, this.rotateWithView_, this.rotation_, this.scale_ * this.pixelRatio, this.snapToPixel_, this.width_]), this.hitDetectionInstructions.push([Ht.DRAW_IMAGE, r, o, this.hitDetectionImage_, this.anchorX_, this.anchorY_, this.declutterGroup_, this.height_, this.opacity_, this.originX_, this.originY_, this.rotateWithView_, this.rotation_, this.scale_, this.snapToPixel_, this.width_]), this.endGeometry(t, e)
			}
		}, $t.prototype.finish = function() {
			this.reverseHitDetectionInstructions(), this.anchorX_ = void 0, this.anchorY_ = void 0, this.hitDetectionImage_ = null, this.image_ = null, this.height_ = void 0, this.scale_ = void 0, this.opacity_ = void 0, this.originX_ = void 0, this.originY_ = void 0, this.rotateWithView_ = void 0, this.rotation_ = void 0, this.snapToPixel_ = void 0, this.width_ = void 0
		}, $t.prototype.setImageStyle = function(t, e) {
			var i = t.getAnchor(),
				n = t.getSize(),
				r = t.getHitDetectionImage(1),
				o = t.getImage(1),
				s = t.getOrigin();
			this.anchorX_ = i[0], this.anchorY_ = i[1], this.declutterGroup_ = e, this.hitDetectionImage_ = r, this.image_ = o, this.height_ = n[1], this.opacity_ = t.getOpacity(), this.originX_ = s[0], this.originY_ = s[1], this.rotateWithView_ = t.getRotateWithView(), this.rotation_ = t.getRotation(), this.scale_ = t.getScale(), this.snapToPixel_ = t.getSnapToPixel(), this.width_ = n[0]
		};
		var te = $t,
			ee = function(t, e, i, n, r, o) {
				Qt.call(this, t, e, i, n, r, o)
			};
		n.
	default.inherits(ee, Qt), ee.prototype.drawFlatCoordinates_ = function(t, e, i, n) {
			var r = this.coordinates.length,
				o = this.appendFlatCoordinates(t, e, i, n, !1, !1),
				s = [Ht.MOVE_TO_LINE_TO, r, o];
			return this.instructions.push(s), this.hitDetectionInstructions.push(s), i
		}, ee.prototype.drawLineString = function(t, e) {
			var i = this.state,
				n = i.strokeStyle,
				r = i.lineWidth;
			if (void 0 !== n && void 0 !== r) {
				this.updateStrokeStyle(i, this.applyStroke), this.beginGeometry(t, e), this.hitDetectionInstructions.push([Ht.SET_STROKE_STYLE, i.strokeStyle, i.lineWidth, i.lineCap, i.lineJoin, i.miterLimit, i.lineDash, i.lineDashOffset], [Ht.BEGIN_PATH]);
				var o = t.getFlatCoordinates(),
					s = t.getStride();
				this.drawFlatCoordinates_(o, 0, o.length, s), this.hitDetectionInstructions.push([Ht.STROKE]), this.endGeometry(t, e)
			}
		}, ee.prototype.drawMultiLineString = function(t, e) {
			var i = this.state,
				n = i.strokeStyle,
				r = i.lineWidth;
			if (void 0 !== n && void 0 !== r) {
				this.updateStrokeStyle(i, this.applyStroke), this.beginGeometry(t, e), this.hitDetectionInstructions.push([Ht.SET_STROKE_STYLE, i.strokeStyle, i.lineWidth, i.lineCap, i.lineJoin, i.miterLimit, i.lineDash, i.lineDashOffset], [Ht.BEGIN_PATH]);
				var o, s, a = t.getEnds(),
					l = t.getFlatCoordinates(),
					u = t.getStride(),
					h = 0;
				for (o = 0, s = a.length; o < s; ++o) h = this.drawFlatCoordinates_(l, h, a[o], u);
				this.hitDetectionInstructions.push([Ht.STROKE]), this.endGeometry(t, e)
			}
		}, ee.prototype.finish = function() {
			var t = this.state;
			null != t.lastStroke && t.lastStroke != this.coordinates.length && this.instructions.push([Ht.STROKE]), this.reverseHitDetectionInstructions(), this.state = null
		}, ee.prototype.applyStroke = function(t) {
			null != t.lastStroke && t.lastStroke != this.coordinates.length && (this.instructions.push([Ht.STROKE]), t.lastStroke = this.coordinates.length), t.lastStroke = 0, Qt.prototype.applyStroke.call(this, t), this.instructions.push([Ht.BEGIN_PATH])
		};
		var ie = ee,
			ne = i(44),
			re = i(76),
			oe = function(t, e, i, n, r, o) {
				Qt.call(this, t, e, i, n, r, o)
			};
		n.
	default.inherits(oe, Qt), oe.prototype.drawFlatCoordinatess_ = function(t, e, i, n) {
			var r = this.state,
				o = void 0 !== r.fillStyle,
				s = null != r.strokeStyle,
				a = i.length,
				l = [Ht.BEGIN_PATH];
			this.instructions.push(l), this.hitDetectionInstructions.push(l);
			for (var u = 0; u < a; ++u) {
				var h = i[u],
					c = this.coordinates.length,
					d = this.appendFlatCoordinates(t, e, h, n, !0, !s),
					f = [Ht.MOVE_TO_LINE_TO, c, d];
				if (this.instructions.push(f), this.hitDetectionInstructions.push(f), s) {
					var A = [Ht.CLOSE_PATH];
					this.instructions.push(A), this.hitDetectionInstructions.push(A)
				}
				e = h
			}
			var p = [Ht.FILL];
			if (this.hitDetectionInstructions.push(p), o && this.instructions.push(p), s) {
				var g = [Ht.STROKE];
				this.instructions.push(g), this.hitDetectionInstructions.push(g)
			}
			return e
		}, oe.prototype.drawCircle = function(t, e) {
			var i = this.state,
				n = i.fillStyle,
				r = i.strokeStyle;
			if (void 0 !== n || void 0 !== r) {
				this.setFillStrokeStyles_(t), this.beginGeometry(t, e), this.hitDetectionInstructions.push([Ht.SET_FILL_STYLE, ne.a.asString(rt.a.defaultFillStyle)]), void 0 !== i.strokeStyle && this.hitDetectionInstructions.push([Ht.SET_STROKE_STYLE, i.strokeStyle, i.lineWidth, i.lineCap, i.lineJoin, i.miterLimit, i.lineDash, i.lineDashOffset]);
				var o = t.getFlatCoordinates(),
					s = t.getStride(),
					a = this.coordinates.length;
				this.appendFlatCoordinates(o, 0, o.length, s, !1, !1);
				var l = [Ht.BEGIN_PATH],
					u = [Ht.CIRCLE, a];
				this.instructions.push(l, u), this.hitDetectionInstructions.push(l, u);
				var h = [Ht.FILL];
				if (this.hitDetectionInstructions.push(h), void 0 !== i.fillStyle && this.instructions.push(h), void 0 !== i.strokeStyle) {
					var c = [Ht.STROKE];
					this.instructions.push(c), this.hitDetectionInstructions.push(c)
				}
				this.endGeometry(t, e)
			}
		}, oe.prototype.drawPolygon = function(t, e) {
			var i = this.state;
			this.setFillStrokeStyles_(t), this.beginGeometry(t, e), this.hitDetectionInstructions.push([Ht.SET_FILL_STYLE, ne.a.asString(rt.a.defaultFillStyle)]), void 0 !== i.strokeStyle && this.hitDetectionInstructions.push([Ht.SET_STROKE_STYLE, i.strokeStyle, i.lineWidth, i.lineCap, i.lineJoin, i.miterLimit, i.lineDash, i.lineDashOffset]);
			var n = t.getEnds(),
				r = t.getOrientedFlatCoordinates(),
				o = t.getStride();
			this.drawFlatCoordinatess_(r, 0, n, o), this.endGeometry(t, e)
		}, oe.prototype.drawMultiPolygon = function(t, e) {
			var i = this.state,
				n = i.fillStyle,
				r = i.strokeStyle;
			if (void 0 !== n || void 0 !== r) {
				this.setFillStrokeStyles_(t), this.beginGeometry(t, e), this.hitDetectionInstructions.push([Ht.SET_FILL_STYLE, ne.a.asString(rt.a.defaultFillStyle)]), void 0 !== i.strokeStyle && this.hitDetectionInstructions.push([Ht.SET_STROKE_STYLE, i.strokeStyle, i.lineWidth, i.lineCap, i.lineJoin, i.miterLimit, i.lineDash, i.lineDashOffset]);
				var o, s, a = t.getEndss(),
					l = t.getOrientedFlatCoordinates(),
					u = t.getStride(),
					h = 0;
				for (o = 0, s = a.length; o < s; ++o) h = this.drawFlatCoordinatess_(l, h, a[o], u);
				this.endGeometry(t, e)
			}
		}, oe.prototype.finish = function() {
			this.reverseHitDetectionInstructions(), this.state = null;
			var t = this.tolerance;
			if (0 !== t) {
				var e, i, n = this.coordinates;
				for (e = 0, i = n.length; e < i; ++e) n[e] = re.a.snap(n[e], t)
			}
		}, oe.prototype.setFillStrokeStyles_ = function(t) {
			var e = this.state;
			void 0 !== e.fillStyle && this.updateFillStyle(e, this.applyFill, t), void 0 !== e.strokeStyle && this.updateStrokeStyle(e, this.applyStroke)
		};
		var se = oe,
			ae = {
				lineString: function(t, e, i, n, r) {
					var o, s, a, l, u, h, c, d, f, A = i,
						p = i,
						g = 0,
						m = 0,
						v = i;
					for (o = i; o < n; o += r) {
						var y = e[o],
							_ = e[o + 1];
						void 0 !== l && (d = y - l, f = _ - u, a = Math.sqrt(d * d + f * f), void 0 !== h && (m += s, Math.acos((h * d + c * f) / (s * a)) > t && (m > g && (g = m, A = v, p = o), m = 0, v = o - r)), s = a, h = d, c = f), l = y, u = _
					}
					return (m += a) > g ? [v, o] : [A, p]
				}
			},
			le = ae,
			ue = i(137),
			he = function(t, e, i, n, r, o) {
				Qt.call(this, t, e, i, n, r, o), this.declutterGroup_, this.labels_ = null, this.text_ = "", this.textOffsetX_ = 0, this.textOffsetY_ = 0, this.textRotateWithView_ = void 0, this.textRotation_ = 0, this.textFillState_ = null, this.fillStates = {}, this.textStrokeState_ = null, this.strokeStates = {}, this.textState_ = {}, this.textStates = {}, this.textKey_ = "", this.fillKey_ = "", this.strokeKey_ = "", this.widths_ = {}, rt.a.labelCache.prune()
			};
		n.
	default.inherits(he, Qt), he.measureTextWidths = function(t, e, i) {
			var n, r, o = e.length,
				s = 0;
			for (r = 0; r < o; ++r) n = rt.a.measureTextWidth(t, e[r]), s = Math.max(s, n), i.push(n);
			return s
		}, he.prototype.drawText = function(t, e) {
			var i = this.textFillState_,
				n = this.textStrokeState_,
				r = this.textState_;
			if ("" !== this.text_ && r && (i || n)) {
				var o, s, a = this.coordinates.length,
					l = t.getType(),
					u = null,
					h = 2,
					c = 2;
				if (r.placement === ue.a.LINE) {
					if (!K.
				default.intersects(this.getBufferedMaxExtent(), t.getExtent())) return;
					var d;
					if (u = t.getFlatCoordinates(), c = t.getStride(), l == st.a.LINE_STRING) d = [u.length];
					else if (l == st.a.MULTI_LINE_STRING) d = t.getEnds();
					else if (l == st.a.POLYGON) d = t.getEnds().slice(0, 1);
					else if (l == st.a.MULTI_POLYGON) {
						var f = t.getEndss();
						for (d = [], o = 0, s = f.length; o < s; ++o) d.push(f[o][0])
					}
					this.beginGeometry(t, e);
					for (var A, p = r.textAlign, g = 0, m = 0, v = d.length; m < v; ++m) {
						if (null == p) {
							var y = le.lineString(r.maxAngle, u, g, d[m], c);
							g = y[0], A = y[1]
						} else A = d[m];
						for (o = g; o < A; o += c) this.coordinates.push(u[o], u[o + 1]);
						h = this.coordinates.length, g = d[m], this.drawChars_(a, h, this.declutterGroup_), a = h
					}
					this.endGeometry(t, e)
				} else {
					var _ = this.getImage(this.text_, this.textKey_, this.fillKey_, this.strokeKey_),
						E = _.width / this.pixelRatio;
					switch (l) {
					case st.a.POINT:
					case st.a.MULTI_POINT:
						h = (u = t.getFlatCoordinates()).length;
						break;
					case st.a.LINE_STRING:
						u = t.getFlatMidpoint();
						break;
					case st.a.CIRCLE:
						u = t.getCenter();
						break;
					case st.a.MULTI_LINE_STRING:
						h = (u = t.getFlatMidpoints()).length;
						break;
					case st.a.POLYGON:
						if (u = t.getFlatInteriorPoint(), !r.overflow && u[2] / this.resolution < E) return;
						c = 3;
						break;
					case st.a.MULTI_POLYGON:
						var x = t.getFlatInteriorPoints();
						for (u = [], o = 0, s = x.length; o < s; o += 3)(r.overflow || x[o + 2] / this.resolution >= E) && u.push(x[o], x[o + 1]);
						if (0 == (h = u.length)) return
					}
					h = this.appendFlatCoordinates(u, 0, h, c, !1, !1), this.beginGeometry(t, e), (r.backgroundFill || r.backgroundStroke) && (this.setFillStrokeStyle(r.backgroundFill, r.backgroundStroke), this.updateFillStyle(this.state, this.applyFill, t), this.updateStrokeStyle(this.state, this.applyStroke)), this.drawTextImage_(_, a, h), this.endGeometry(t, e)
				}
			}
		}, he.prototype.getImage = function(t, e, i, n) {
			var r, o = n + e + t + i + this.pixelRatio,
				s = rt.a.labelCache;
			if (!s.containsKey(o)) {
				var a = n ? this.strokeStates[n] || this.textStrokeState_ : null,
					l = i ? this.fillStates[i] || this.textFillState_ : null,
					u = this.textStates[e] || this.textState_,
					h = this.pixelRatio,
					c = u.scale * h,
					d = Kt.TEXT_ALIGN[u.textAlign || rt.a.defaultTextAlign],
					f = n && a.lineWidth ? a.lineWidth : 0,
					A = t.split("\n"),
					p = A.length,
					g = [],
					m = he.measureTextWidths(u.font, A, g),
					v = rt.a.measureTextHeight(u.font),
					y = v * p,
					_ = m + f,
					E = $.a.createCanvasContext2D(Math.ceil(_ * c), Math.ceil((y + f) * c));
				r = E.canvas, s.set(o, r), 1 != c && E.scale(c, c), E.font = u.font, n && (E.strokeStyle = a.strokeStyle, E.lineWidth = f * (O.a.SAFARI ? c : 1), E.lineCap = a.lineCap, E.lineJoin = a.lineJoin, E.miterLimit = a.miterLimit, O.a.CANVAS_LINE_DASH && a.lineDash.length && (E.setLineDash(a.lineDash), E.lineDashOffset = a.lineDashOffset)), i && (E.fillStyle = l.fillStyle), E.textBaseline = "middle", E.textAlign = "center";
				var x, C = .5 - d,
					I = d * r.width / c + C * f;
				if (n) for (x = 0; x < p; ++x) E.strokeText(A[x], I + C * g[x], .5 * (f + v) + x * v);
				if (i) for (x = 0; x < p; ++x) E.fillText(A[x], I + C * g[x], .5 * (f + v) + x * v)
			}
			return s.get(o)
		}, he.prototype.drawTextImage_ = function(t, e, i) {
			var n = this.textState_,
				r = this.textStrokeState_,
				o = this.pixelRatio,
				s = Kt.TEXT_ALIGN[n.textAlign || rt.a.defaultTextAlign],
				a = Kt.TEXT_ALIGN[n.textBaseline],
				l = r && r.lineWidth ? r.lineWidth : 0,
				u = s * t.width / o + 2 * (.5 - s) * l,
				h = a * t.height / o + 2 * (.5 - a) * l;
			this.instructions.push([Ht.DRAW_IMAGE, e, i, t, (u - this.textOffsetX_) * o, (h - this.textOffsetY_) * o, this.declutterGroup_, t.height, 1, 0, 0, this.textRotateWithView_, this.textRotation_, 1, !0, t.width, n.padding == rt.a.defaultPadding ? rt.a.defaultPadding : n.padding.map((function(t) {
				return t * o
			})), !! n.backgroundFill, !! n.backgroundStroke]), this.hitDetectionInstructions.push([Ht.DRAW_IMAGE, e, i, t, (u - this.textOffsetX_) * o, (h - this.textOffsetY_) * o, this.declutterGroup_, t.height, 1, 0, 0, this.textRotateWithView_, this.textRotation_, 1 / o, !0, t.width, n.padding, !! n.backgroundFill, !! n.backgroundStroke])
		}, he.prototype.drawChars_ = function(t, e, i) {
			var n = this.textStrokeState_,
				r = this.textState_,
				o = this.textFillState_,
				s = this.strokeKey_;
			n && (s in this.strokeStates || (this.strokeStates[s] = {
				strokeStyle: n.strokeStyle,
				lineCap: n.lineCap,
				lineDashOffset: n.lineDashOffset,
				lineWidth: n.lineWidth,
				lineJoin: n.lineJoin,
				miterLimit: n.miterLimit,
				lineDash: n.lineDash
			}));
			var a = this.textKey_;
			this.textKey_ in this.textStates || (this.textStates[this.textKey_] = {
				font: r.font,
				textAlign: r.textAlign || rt.a.defaultTextAlign,
				scale: r.scale
			});
			var l = this.fillKey_;
			o && (l in this.fillStates || (this.fillStates[l] = {
				fillStyle: o.fillStyle
			}));
			var u = this.pixelRatio,
				h = Kt.TEXT_ALIGN[r.textBaseline],
				c = this.textOffsetY_ * u,
				d = this.text_,
				f = r.font,
				A = r.scale,
				p = n ? n.lineWidth * A / 2 : 0,
				g = this.widths_[f];
			g || (this.widths_[f] = g = {}), this.instructions.push([Ht.DRAW_CHARS, t, e, h, i, r.overflow, l, r.maxAngle, function(t) {
				var e = g[t];
				return e || (e = g[t] = rt.a.measureTextWidth(f, t)), e * A * u
			},
			c, s, p * u, d, a, 1]), this.hitDetectionInstructions.push([Ht.DRAW_CHARS, t, e, h, i, r.overflow, l, r.maxAngle, function(t) {
				var e = g[t];
				return e || (e = g[t] = rt.a.measureTextWidth(f, t)), e * A
			},
			c, s, p, d, a, 1 / u])
		}, he.prototype.setTextStyle = function(t, e) {
			var i, r, o;
			if (t) {
				this.declutterGroup_ = e;
				var s = t.getFill();
				s ? ((r = this.textFillState_) || (r = this.textFillState_ = {}), r.fillStyle = ot.a.asColorLike(s.getColor() || rt.a.defaultFillStyle)) : r = this.textFillState_ = null;
				var a = t.getStroke();
				if (a) {
					(o = this.textStrokeState_) || (o = this.textStrokeState_ = {});
					var l = a.getLineDash(),
						u = a.getLineDashOffset(),
						h = a.getWidth(),
						c = a.getMiterLimit();
					o.lineCap = a.getLineCap() || rt.a.defaultLineCap, o.lineDash = l ? l.slice() : rt.a.defaultLineDash, o.lineDashOffset = void 0 === u ? rt.a.defaultLineDashOffset : u, o.lineJoin = a.getLineJoin() || rt.a.defaultLineJoin, o.lineWidth = void 0 === h ? rt.a.defaultLineWidth : h, o.miterLimit = void 0 === c ? rt.a.defaultMiterLimit : c, o.strokeStyle = ot.a.asColorLike(a.getColor() || rt.a.defaultStrokeStyle)
				} else o = this.textStrokeState_ = null;
				i = this.textState_;
				var d = t.getFont() || rt.a.defaultFont;
				rt.a.checkFont(d);
				var f = t.getScale();
				i.overflow = t.getOverflow(), i.font = d, i.maxAngle = t.getMaxAngle(), i.placement = t.getPlacement(), i.textAlign = t.getTextAlign(), i.textBaseline = t.getTextBaseline() || rt.a.defaultTextBaseline, i.backgroundFill = t.getBackgroundFill(), i.backgroundStroke = t.getBackgroundStroke(), i.padding = t.getPadding() || rt.a.defaultPadding, i.scale = void 0 === f ? 1 : f;
				var A = t.getOffsetX(),
					p = t.getOffsetY(),
					g = t.getRotateWithView(),
					m = t.getRotation();
				this.text_ = t.getText() || "", this.textOffsetX_ = void 0 === A ? 0 : A, this.textOffsetY_ = void 0 === p ? 0 : p, this.textRotateWithView_ = void 0 !== g && g, this.textRotation_ = void 0 === m ? 0 : m, this.strokeKey_ = o ? ("string" == typeof o.strokeStyle ? o.strokeStyle : n.
			default.getUid(o.strokeStyle)) + o.lineCap + o.lineDashOffset + "|" + o.lineWidth + o.lineJoin + o.miterLimit + "[" + o.lineDash.join() + "]" : "", this.textKey_ = i.font + i.scale + (i.textAlign || "?"), this.fillKey_ = r ? "string" == typeof r.fillStyle ? r.fillStyle : "|" + n.
			default.getUid(r.fillStyle):
				""
			} else this.text_ = ""
		};
		var ce = he,
			de = function(t, e, i, n, r, o, s) {
				jt.call(this), this.declutterTree_ = o, this.declutterGroup_ = null, this.tolerance_ = t, this.maxExtent_ = e, this.overlaps_ = r, this.pixelRatio_ = n, this.resolution_ = i, this.renderBuffer_ = s, this.replaysByZIndex_ = {}, this.hitDetectionContext_ = $.a.createCanvasContext2D(1, 1), this.hitDetectionTransform_ = ct.a.create()
			};
		n.
	default.inherits(de, jt), de.circleArrayCache_ = {
			0: [
				[!0]
			]
		}, de.fillCircleArrayRowToMiddle_ = function(t, e, i) {
			var n, r = Math.floor(t.length / 2);
			if (e >= r) for (n = r; n < e; n++) t[n][i] = !0;
			else if (e < r) for (n = e + 1; n < r; n++) t[n][i] = !0
		}, de.getCircleArray_ = function(t) {
			if (void 0 !== de.circleArrayCache_[t]) return de.circleArrayCache_[t];
			for (var e = 2 * t + 1, i = new Array(e), n = 0; n < e; n++) i[n] = new Array(e);
			for (var r = t, o = 0, s = 0; r >= o;) de.fillCircleArrayRowToMiddle_(i, t + r, t + o), de.fillCircleArrayRowToMiddle_(i, t + o, t + r), de.fillCircleArrayRowToMiddle_(i, t - o, t + r), de.fillCircleArrayRowToMiddle_(i, t - r, t + o), de.fillCircleArrayRowToMiddle_(i, t - r, t - o), de.fillCircleArrayRowToMiddle_(i, t - o, t - r), de.fillCircleArrayRowToMiddle_(i, t + o, t - r), de.fillCircleArrayRowToMiddle_(i, t + r, t - o), 2 * ((s += 1 + 2 * ++o) - r) + 1 > 0 && (s += 1 - 2 * (r -= 1));
			return de.circleArrayCache_[t] = i, i
		}, de.replayDeclutter = function(t, e, i) {
			for (var n = Object.keys(t).map(Number).sort(Z.a.numberSafeCompareFunction), r = {}, o = 0, s = n.length; o < s; ++o) for (var a = t[n[o].toString()], l = 0, u = a.length; l < u;) {
				var h = a[l++],
					c = a[l++];
				h.replay(e, c, i, r)
			}
		}, de.prototype.addDeclutter = function(t) {
			var e = null;
			return this.declutterTree_ && (t ? (e = this.declutterGroup_)[4]++ : (e = this.declutterGroup_ = K.
		default.createEmpty()).push(1)), e
		}, de.prototype.clip = function(t, e) {
			var i = this.getClipCoords(e);
			t.beginPath(), t.moveTo(i[0], i[1]), t.lineTo(i[2], i[3]), t.lineTo(i[4], i[5]), t.lineTo(i[6], i[7]), t.clip()
		}, de.prototype.hasReplays = function(t) {
			for (var e in this.replaysByZIndex_) for (var i = this.replaysByZIndex_[e], n = 0, r = t.length; n < r; ++n) if (t[n] in i) return !0;
			return !1
		}, de.prototype.finish = function() {
			var t;
			for (t in this.replaysByZIndex_) {
				var e, i = this.replaysByZIndex_[t];
				for (e in i) i[e].finish()
			}
		}, de.prototype.forEachFeatureAtCoordinate = function(t, e, i, n, r, o, s) {
			var a, l = 2 * (n = Math.round(n)) + 1,
				u = ct.a.compose(this.hitDetectionTransform_, n + .5, n + .5, 1 / e, -1 / e, -i, -t[0], -t[1]),
				h = this.hitDetectionContext_;
			h.canvas.width !== l || h.canvas.height !== l ? (h.canvas.width = l, h.canvas.height = l) : h.clearRect(0, 0, l, l), void 0 !== this.renderBuffer_ && (a = K.
		default.createEmpty(), K.
		default.extendCoordinate(a, t), K.
		default.buffer(a, e * (this.renderBuffer_ + n), a));
			var c, d, f = de.getCircleArray_(n);

			function A(t) {
				for (var e = h.getImageData(0, 0, l, l).data, i = 0; i < l; i++) for (var n = 0; n < l; n++) {
					var r;
					if (f[i][n]) if (e[4 * (n * l + i) + 3] > 0) return (!c || d != Vt.IMAGE && d != Vt.TEXT || -1 !== c.indexOf(t)) && (r = o(t)), r || void h.clearRect(0, 0, l, l)
				}
			}
			this.declutterTree_ && (c = this.declutterTree_.all().map((function(t) {
				return t.value
			})));
			var p, g, m, v, y, _ = Object.keys(this.replaysByZIndex_).map(Number);
			for (_.sort(Z.a.numberSafeCompareFunction), p = _.length - 1; p >= 0; --p) {
				var E = _[p].toString();
				for (m = this.replaysByZIndex_[E], g = Kt.ORDER.length - 1; g >= 0; --g) if (void 0 !== (v = m[d = Kt.ORDER[g]])) if (!s || d != Vt.IMAGE && d != Vt.TEXT) {
					if (y = v.replayHitDetection(h, u, i, r, A, a)) return y
				} else {
					var x = s[E];
					x ? x.push(v, u.slice(0)) : s[E] = [v, u.slice(0)]
				}
			}
		}, de.prototype.getClipCoords = function(t) {
			var e = this.maxExtent_,
				i = e[0],
				n = e[1],
				r = e[2],
				o = e[3],
				s = [i, n, i, o, r, o, r, n];
			return lt.a.transform2D(s, 0, 8, 2, t, s), s
		}, de.prototype.getReplay = function(t, e) {
			var i = void 0 !== t ? t.toString() : "0",
				n = this.replaysByZIndex_[i];
			void 0 === n && (n = {}, this.replaysByZIndex_[i] = n);
			var r = n[e];
			void 0 === r && (r = new(0, de.BATCH_CONSTRUCTORS_[e])(this.tolerance_, this.maxExtent_, this.resolution_, this.pixelRatio_, this.overlaps_, this.declutterTree_), n[e] = r);
			return r
		}, de.prototype.getReplays = function() {
			return this.replaysByZIndex_
		}, de.prototype.isEmpty = function() {
			return V.a.isEmpty(this.replaysByZIndex_)
		}, de.prototype.replay = function(t, e, i, n, r, o) {
			var s = Object.keys(this.replaysByZIndex_).map(Number);
			s.sort(Z.a.numberSafeCompareFunction), t.save(), this.clip(t, e);
			var a, l, u, h, c, d, f = r || Kt.ORDER;
			for (a = 0, l = s.length; a < l; ++a) {
				var A = s[a].toString();
				for (c = this.replaysByZIndex_[A], u = 0, h = f.length; u < h; ++u) {
					var p = f[u];
					if (void 0 !== (d = c[p])) if (!o || p != Vt.IMAGE && p != Vt.TEXT) d.replay(t, e, i, n);
					else {
						var g = o[A];
						g ? g.push(d, e.slice(0)) : o[A] = [d, e.slice(0)]
					}
				}
			}
			t.restore()
		}, de.BATCH_CONSTRUCTORS_ = {
			Circle: se,
			Default: Qt,
			Image: te,
			LineString: ie,
			Polygon: se,
			Text: ce
		};
		var fe = de,
			Ae = {
				defaultOrder: function(t, e) {
					return n.
				default.getUid(t) - n.
				default.getUid(e)
				},
				getSquaredTolerance: function(t, e) {
					var i = Ae.getTolerance(t, e);
					return i * i
				},
				getTolerance: function(t, e) {
					return n.
				default.SIMPLIFY_TOLERANCE * t / e
				},
				renderCircleGeometry_: function(t, e, i, n) {
					var r = i.getFill(),
						o = i.getStroke();
					if (r || o) {
						var s = t.getReplay(i.getZIndex(), Vt.CIRCLE);
						s.setFillStrokeStyle(r, o), s.drawCircle(e, n)
					}
					var a = i.getText();
					if (a) {
						var l = t.getReplay(i.getZIndex(), Vt.TEXT);
						l.setTextStyle(a, t.addDeclutter(!1)), l.drawText(e, n)
					}
				},
				renderFeature: function(t, e, i, n, r, o) {
					var s, a, l = !1;
					return (s = i.getImage()) && ((a = s.getImageState()) == X.a.LOADED || a == X.a.ERROR ? s.unlistenImageChange(r, o) : (a == X.a.IDLE && s.load(), a = s.getImageState(), s.listenImageChange(r, o), l = !0)), Ae.renderFeature_(t, e, i, n), l
				},
				renderFeature_: function(t, e, i, n) {
					var r = i.getGeometryFunction()(e);
					if (r) {
						var o = r.getSimplifiedGeometry(n);
						if (i.getRenderer()) Ae.renderGeometry_(t, o, i, e);
						else(0, Ae.GEOMETRY_RENDERERS_[o.getType()])(t, o, i, e)
					}
				},
				renderGeometry_: function(t, e, i, n) {
					if (e.getType() != st.a.GEOMETRY_COLLECTION) t.getReplay(i.getZIndex(), Vt.DEFAULT).drawCustom(e, n, i.getRenderer());
					else for (var r = e.getGeometries(), o = 0, s = r.length; o < s; ++o) Ae.renderGeometry_(t, r[o], i, n)
				},
				renderGeometryCollectionGeometry_: function(t, e, i, n) {
					var r, o, s = e.getGeometriesArray();
					for (r = 0, o = s.length; r < o; ++r) {
						(0, Ae.GEOMETRY_RENDERERS_[s[r].getType()])(t, s[r], i, n)
					}
				},
				renderLineStringGeometry_: function(t, e, i, n) {
					var r = i.getStroke();
					if (r) {
						var o = t.getReplay(i.getZIndex(), Vt.LINE_STRING);
						o.setFillStrokeStyle(null, r), o.drawLineString(e, n)
					}
					var s = i.getText();
					if (s) {
						var a = t.getReplay(i.getZIndex(), Vt.TEXT);
						a.setTextStyle(s, t.addDeclutter(!1)), a.drawText(e, n)
					}
				},
				renderMultiLineStringGeometry_: function(t, e, i, n) {
					var r = i.getStroke();
					if (r) {
						var o = t.getReplay(i.getZIndex(), Vt.LINE_STRING);
						o.setFillStrokeStyle(null, r), o.drawMultiLineString(e, n)
					}
					var s = i.getText();
					if (s) {
						var a = t.getReplay(i.getZIndex(), Vt.TEXT);
						a.setTextStyle(s, t.addDeclutter(!1)), a.drawText(e, n)
					}
				},
				renderMultiPolygonGeometry_: function(t, e, i, n) {
					var r = i.getFill(),
						o = i.getStroke();
					if (o || r) {
						var s = t.getReplay(i.getZIndex(), Vt.POLYGON);
						s.setFillStrokeStyle(r, o), s.drawMultiPolygon(e, n)
					}
					var a = i.getText();
					if (a) {
						var l = t.getReplay(i.getZIndex(), Vt.TEXT);
						l.setTextStyle(a, t.addDeclutter(!1)), l.drawText(e, n)
					}
				},
				renderPointGeometry_: function(t, e, i, n) {
					var r = i.getImage();
					if (r) {
						if (r.getImageState() != X.a.LOADED) return;
						var o = t.getReplay(i.getZIndex(), Vt.IMAGE);
						o.setImageStyle(r, t.addDeclutter(!1)), o.drawPoint(e, n)
					}
					var s = i.getText();
					if (s) {
						var a = t.getReplay(i.getZIndex(), Vt.TEXT);
						a.setTextStyle(s, t.addDeclutter( !! r)), a.drawText(e, n)
					}
				},
				renderMultiPointGeometry_: function(t, e, i, n) {
					var r = i.getImage();
					if (r) {
						if (r.getImageState() != X.a.LOADED) return;
						var o = t.getReplay(i.getZIndex(), Vt.IMAGE);
						o.setImageStyle(r, t.addDeclutter(!1)), o.drawMultiPoint(e, n)
					}
					var s = i.getText();
					if (s) {
						var a = t.getReplay(i.getZIndex(), Vt.TEXT);
						a.setTextStyle(s, t.addDeclutter( !! r)), a.drawText(e, n)
					}
				},
				renderPolygonGeometry_: function(t, e, i, n) {
					var r = i.getFill(),
						o = i.getStroke();
					if (r || o) {
						var s = t.getReplay(i.getZIndex(), Vt.POLYGON);
						s.setFillStrokeStyle(r, o), s.drawPolygon(e, n)
					}
					var a = i.getText();
					if (a) {
						var l = t.getReplay(i.getZIndex(), Vt.TEXT);
						l.setTextStyle(a, t.addDeclutter(!1)), l.drawText(e, n)
					}
				}
			};
		Ae.GEOMETRY_RENDERERS_ = {
			Point: Ae.renderPointGeometry_,
			LineString: Ae.renderLineStringGeometry_,
			Polygon: Ae.renderPolygonGeometry_,
			MultiPoint: Ae.renderMultiPointGeometry_,
			MultiLineString: Ae.renderMultiLineStringGeometry_,
			MultiPolygon: Ae.renderMultiPolygonGeometry_,
			GeometryCollection: Ae.renderGeometryCollectionGeometry_,
			Circle: Ae.renderCircleGeometry_
		};
		var pe = Ae,
			ge = function(t) {
				xt.call(this, t), this.declutterTree_ = t.getDeclutter() ? Ut()(9) : null, this.dirty_ = !1, this.renderedRevision_ = -1, this.renderedResolution_ = NaN, this.renderedExtent_ = K.
			default.createEmpty(), this.renderedRenderOrder_ = null, this.replayGroup_ = null, this.replayGroupChanged = !0, this.context = $.a.createCanvasContext2D(), mt.a.listen(rt.a.labelCache, T.a.CLEAR, this.handleFontsChanged_, this)
			};
		n.
	default.inherits(ge, xt), ge.handles = function(t, e) {
			return t === Q.a.CANVAS && e.getType() === H.a.VECTOR
		}, ge.create = function(t, e) {
			return new ge(e)
		}, ge.prototype.disposeInternal = function() {
			mt.a.unlisten(rt.a.labelCache, T.a.CLEAR, this.handleFontsChanged_, this), xt.prototype.disposeInternal.call(this)
		}, ge.prototype.composeFrame = function(t, e, i) {
			var n = t.extent,
				r = t.pixelRatio,
				o = e.managed ? t.skippedFeatureUids : {},
				s = t.viewState,
				a = s.projection,
				l = s.rotation,
				u = a.getExtent(),
				h = this.getLayer().getSource(),
				c = this.getTransform(t, 0);
			this.preCompose(i, t, c);
			var d = e.extent,
				f = void 0 !== d;
			f && this.clip(i, t, d);
			var A = this.replayGroup_;
			if (A && !A.isEmpty()) {
				this.declutterTree_ && this.declutterTree_.clear();
				var p, g = this.getLayer(),
					m = 0,
					v = 0,
					y = 1 !== e.opacity,
					_ = g.hasListener(nt.a.RENDER);
				if (y || _) {
					var E = i.canvas.width,
						x = i.canvas.height;
					if (l) {
						var C = Math.round(Math.sqrt(E * E + x * x));
						m = (C - E) / 2, v = (C - x) / 2, E = x = C
					}
					this.context.canvas.width = E, this.context.canvas.height = x, p = this.context
				} else p = i;
				var I = p.globalAlpha;
				y || (p.globalAlpha = e.opacity), p != i && p.translate(m, v);
				var S = t.size[0] * r,
					T = t.size[1] * r;
				if (rt.a.rotateAtOffset(p, -l, S / 2, T / 2), A.replay(p, c, l, o), h.getWrapX() && a.canWrapX() && !K.
			default.containsExtent(u, n)) {
					for (var R, w = n[0], L = K.
				default.getWidth(u), N = 0; w < u[0];) R = L * --N, c = this.getTransform(t, R), A.replay(p, c, l, o), w += L;
					for (N = 0, w = n[2]; w > u[2];) R = L * ++N, c = this.getTransform(t, R), A.replay(p, c, l, o), w -= L;
					c = this.getTransform(t, 0)
				}
				if (rt.a.rotateAtOffset(p, l, S / 2, T / 2), p != i) {
					if (_ && this.dispatchRenderEvent(p, t, c), y) {
						var P = i.globalAlpha;
						i.globalAlpha = e.opacity, i.drawImage(p.canvas, -m, -v), i.globalAlpha = P
					} else i.drawImage(p.canvas, -m, -v);
					p.translate(-m, -v)
				}
				y || (p.globalAlpha = I)
			}
			f && i.restore(), this.postCompose(i, t, e, c)
		}, ge.prototype.forEachFeatureAtCoordinate = function(t, e, i, r, o) {
			if (this.replayGroup_) {
				var s = e.viewState.resolution,
					a = e.viewState.rotation,
					l = this.getLayer(),
					u = {};
				return this.replayGroup_.forEachFeatureAtCoordinate(t, s, a, i, {}, (function(t) {
					var e = n.
				default.getUid(t).toString();
					if (!(e in u)) return u[e] = !0, r.call(o, t, l)
				}), null)
			}
		}, ge.prototype.handleFontsChanged_ = function(t) {
			var e = this.getLayer();
			e.getVisible() && this.replayGroup_ && e.changed()
		}, ge.prototype.handleStyleImageChange_ = function(t) {
			this.renderIfReadyAndVisible()
		}, ge.prototype.prepareFrame = function(t, e) {
			var i = this.getLayer(),
				n = i.getSource();
			this.updateLogos(t, n);
			var r = t.viewHints[A.a.ANIMATING],
				o = t.viewHints[A.a.INTERACTING],
				s = i.getUpdateWhileAnimating(),
				a = i.getUpdateWhileInteracting();
			if (!this.dirty_ && !s && r || !a && o) return !0;
			var l = t.extent,
				u = t.viewState,
				h = u.projection,
				c = u.resolution,
				d = t.pixelRatio,
				f = i.getRevision(),
				p = i.getRenderBuffer(),
				g = i.getRenderOrder();
			void 0 === g && (g = pe.defaultOrder);
			var m = K.
		default.buffer(l, p * c),
				v = u.projection.getExtent();
			if (n.getWrapX() && u.projection.canWrapX() && !K.
		default.containsExtent(v, t.extent)) {
				var y = K.
			default.getWidth(v),
					_ = Math.max(K.
				default.getWidth(m) / 2, y);
				m[0] = v[0] - _, m[2] = v[2] + _
			}
			if (!this.dirty_ && this.renderedResolution_ == c && this.renderedRevision_ == f && this.renderedRenderOrder_ == g && K.
		default.containsExtent(this.renderedExtent_, m)) return this.replayGroupChanged = !1, !0;
			this.replayGroup_ = null, this.dirty_ = !1;
			var E = new fe(pe.getTolerance(c, d), m, c, d, n.getOverlaps(), this.declutterTree_, i.getRenderBuffer());
			n.loadFeatures(m, c, h);
			var x = function(t) {
					var e, n = t.getStyleFunction();
					if (n ? e = n.call(t, c) : (n = i.getStyleFunction()) && (e = n(t, c)), e) {
						var r = this.renderFeature(t, c, d, e, E);
						this.dirty_ = this.dirty_ || r
					}
				}.bind(this);
			if (g) {
				var C = [];
				n.forEachFeatureInExtent(m, (function(t) {
					C.push(t)
				}), this), C.sort(g);
				for (var I = 0, S = C.length; I < S; ++I) x(C[I])
			} else n.forEachFeatureInExtent(m, x, this);
			return E.finish(), this.renderedResolution_ = c, this.renderedRevision_ = f, this.renderedRenderOrder_ = g, this.renderedExtent_ = m, this.replayGroup_ = E, this.replayGroupChanged = !0, !0
		}, ge.prototype.renderFeature = function(t, e, i, n, r) {
			if (!n) return !1;
			var o = !1;
			if (Array.isArray(n)) for (var s = 0, a = n.length; s < a; ++s) o = pe.renderFeature(r, t, n[s], pe.getSquaredTolerance(e, i), this.handleStyleImageChange_, this) || o;
			else o = pe.renderFeature(r, t, n, pe.getSquaredTolerance(e, i), this.handleStyleImageChange_, this);
			return o
		};
		var me = ge,
			ve = {
				IMAGE: "image",
				HYBRID: "hybrid",
				VECTOR: "vector"
			},
			ye = i(9),
			_e = i(47),
			Ee = function(t) {
				this.context = null, Gt.call(this, t), this.declutterTree_ = t.getDeclutter() ? Ut()(9) : null, this.dirty_ = !1, this.renderedLayerRevision_, this.tmpTransform_ = ct.a.create(), this.zDirection = t.getRenderMode() == ve.VECTOR ? 1 : 0, mt.a.listen(rt.a.labelCache, T.a.CLEAR, this.handleFontsChanged_, this)
			};
		n.
	default.inherits(Ee, Gt), Ee.handles = function(t, e) {
			return t === Q.a.CANVAS && e.getType() === H.a.VECTOR_TILE
		}, Ee.create = function(t, e) {
			return new Ee(e)
		}, Ee.IMAGE_REPLAYS = {
			image: [Vt.POLYGON, Vt.CIRCLE, Vt.LINE_STRING, Vt.IMAGE, Vt.TEXT],
			hybrid: [Vt.POLYGON, Vt.LINE_STRING]
		}, Ee.VECTOR_REPLAYS = {
			image: [Vt.DEFAULT],
			hybrid: [Vt.IMAGE, Vt.TEXT, Vt.DEFAULT],
			vector: Kt.ORDER
		}, Ee.prototype.disposeInternal = function() {
			mt.a.unlisten(rt.a.labelCache, T.a.CLEAR, this.handleFontsChanged_, this), Gt.prototype.disposeInternal.call(this)
		}, Ee.prototype.prepareFrame = function(t, e) {
			var i = this.getLayer(),
				n = i.getRevision();
			if (this.renderedLayerRevision_ != n) {
				this.renderedTiles.length = 0;
				var r = i.getRenderMode();
				this.context || r == ve.VECTOR || (this.context = $.a.createCanvasContext2D()), this.context && r == ve.VECTOR && (this.context = null)
			}
			return this.renderedLayerRevision_ = n, Gt.prototype.prepareFrame.apply(this, arguments)
		}, Ee.prototype.createReplayGroup_ = function(t, e) {
			var i = this.getLayer(),
				n = e.pixelRatio,
				r = e.viewState.projection,
				o = i.getRevision(),
				s = i.getRenderOrder() || null,
				a = t.getReplayState(i);
			if (a.dirty || a.renderedRevision != o || a.renderedRenderOrder != s) {
				for (var l = i.getSource(), u = l.getTileGrid(), h = l.getTileGridForProjection(r), c = h.getResolution(t.tileCoord[0]), d = h.getTileCoordExtent(t.wrappedTileCoord), f = {}, A = 0, p = t.tileKeys.length; A < p; ++A) {
					var g = t.getTile(t.tileKeys[A]);
					if (g.getState() != pt.a.ERROR) {
						var m = g.tileCoord,
							v = u.getTileCoordExtent(m),
							y = K.
						default.getIntersection(d, v),
							_ = K.
						default.equals(v, y) ? null:
							K.
						default.buffer(y, i.getRenderBuffer() * c),
							E = g.getProjection(),
							x = !1;
						ye.
					default.equivalent(r, E) || (x = !0, g.setProjection(r)), a.dirty = !1;
						var C, I = new fe(0, y, c, n, l.getOverlaps(), this.declutterTree_, i.getRenderBuffer()),
							S = pe.getSquaredTolerance(c, n),
							T = function(t) {
								var e, n = t.getStyleFunction();
								if (n ? e = n.call(t, c) : (n = i.getStyleFunction()) && (e = n(t, c)), e) {
									var r = this.renderFeature(t, S, e, I);
									this.dirty_ = this.dirty_ || r, a.dirty = a.dirty || r
								}
							},
							R = g.getFeatures();
						s && s !== a.renderedRenderOrder && R.sort(s);
						for (var w = 0, L = R.length; w < L; ++w) C = R[w], x && (E.getUnits() == _e.a.TILE_PIXELS && (E.setWorldExtent(v), E.setExtent(g.getExtent())), C.getGeometry().transform(E, r)), _ && !K.
					default.intersects(_, C.getGeometry().getExtent()) || T.call(this, C);
						for (var N in I.finish(), I.getReplays()) f[N] = !0;
						g.setReplayGroup(i, t.tileCoord.toString(), I)
					}
				}
				a.renderedRevision = o, a.renderedRenderOrder = s
			}
		}, Ee.prototype.drawTileImage = function(t, e, i, n, r, o, s, a, l) {
			var u = t;
			this.createReplayGroup_(u, e), this.context && (this.renderTileImage_(u, e, i), Gt.prototype.drawTileImage.apply(this, arguments))
		}, Ee.prototype.forEachFeatureAtCoordinate = function(t, e, i, r, o) {
			var s = e.viewState.resolution,
				a = e.viewState.rotation;
			i = null == i ? 0 : i;
			var l, u, h, c, d, f, A, p, g = this.getLayer(),
				m = {},
				v = this.renderedTiles,
				y = g.getSource().getTileGridForProjection(e.viewState.projection);
			for (h = 0, c = v.length; h < c; ++h) if (A = (f = v[h]).wrappedTileCoord, p = y.getTileCoordExtent(A, this.tmpExtent), l = K.
		default.buffer(p, i * s, l), K.
		default.containsCoordinate(l, t)) for (var _ = 0, E = f.tileKeys.length; _ < E; ++_) {
				var x = f.getTile(f.tileKeys[_]);
				x.getState() != pt.a.ERROR && (d = x.getReplayGroup(g, f.tileCoord.toString()), u = u || d.forEachFeatureAtCoordinate(t, s, a, i, {}, (function(t) {
					var e = n.
				default.getUid(t).toString();
					if (!(e in m)) return m[e] = !0, r.call(o, t, g)
				}), null))
			}
			return u
		}, Ee.prototype.getReplayTransform_ = function(t, e) {
			var i = this.getLayer().getSource().getTileGrid(),
				n = t.tileCoord,
				r = i.getResolution(n[0]),
				o = e.viewState,
				s = e.pixelRatio,
				a = o.resolution / s,
				l = i.getTileCoordExtent(n, this.tmpExtent),
				u = o.center,
				h = K.
			default.getTopLeft(l),
				c = e.size,
				d = Math.round(s * c[0] / 2),
				f = Math.round(s * c[1] / 2);
			return ct.a.compose(this.tmpTransform_, d, f, r / a, r / a, o.rotation, (h[0] - u[0]) / r, (u[1] - h[1]) / r)
		}, Ee.prototype.handleFontsChanged_ = function(t) {
			var e = this.getLayer();
			e.getVisible() && void 0 !== this.renderedLayerRevision_ && e.changed()
		}, Ee.prototype.handleStyleImageChange_ = function(t) {
			this.renderIfReadyAndVisible()
		}, Ee.prototype.postCompose = function(t, e, i) {
			var n, r, o = this.getLayer(),
				s = o.getDeclutter() ? {} : null,
				a = o.getSource(),
				l = o.getRenderMode(),
				u = Ee.VECTOR_REPLAYS[l],
				h = e.pixelRatio,
				c = e.viewState.rotation,
				d = e.size;
			c && (n = Math.round(h * d[0] / 2), r = Math.round(h * d[1] / 2), rt.a.rotateAtOffset(t, -c, n, r)), s && this.declutterTree_.clear();
			for (var f = this.renderedTiles, A = a.getTileGridForProjection(e.viewState.projection), p = [], g = [], m = f.length - 1; m >= 0; --m) {
				var v = f[m];
				if (v.getState() != pt.a.ABORT) for (var y = v.tileCoord, _ = A.getTileCoordExtent(y)[0] - A.getTileCoordExtent(v.wrappedTileCoord)[0], E = void 0, x = 0, C = v.tileKeys.length; x < C; ++x) {
					var I = v.getTile(v.tileKeys[x]);
					if (I.getState() != pt.a.ERROR) {
						var S = I.getReplayGroup(o, y.toString());
						if (l == ve.VECTOR || S.hasReplays(u)) {
							E || (E = this.getTransform(e, _));
							var T = I.tileCoord[0],
								R = S.getClipCoords(E);
							t.save(), t.globalAlpha = i.opacity;
							for (var w = 0, L = p.length; w < L; ++w) {
								var N = p[w];
								T < g[w] && (t.beginPath(), t.moveTo(R[0], R[1]), t.lineTo(R[2], R[3]), t.lineTo(R[4], R[5]), t.lineTo(R[6], R[7]), t.moveTo(N[6], N[7]), t.lineTo(N[4], N[5]), t.lineTo(N[2], N[3]), t.lineTo(N[0], N[1]), t.clip())
							}
							S.replay(t, E, c, {}, u, s), t.restore(), p.push(R), g.push(T)
						}
					}
				}
			}
			s && fe.replayDeclutter(s, t, c), c && rt.a.rotateAtOffset(t, c, n, r), Gt.prototype.postCompose.apply(this, arguments)
		}, Ee.prototype.renderFeature = function(t, e, i, n) {
			if (!i) return !1;
			var r = !1;
			if (Array.isArray(i)) for (var o = 0, s = i.length; o < s; ++o) r = pe.renderFeature(n, t, i[o], e, this.handleStyleImageChange_, this) || r;
			else r = pe.renderFeature(n, t, i, e, this.handleStyleImageChange_, this);
			return r
		}, Ee.prototype.renderTileImage_ = function(t, e, i) {
			var n = this.getLayer(),
				r = t.getReplayState(n),
				o = n.getRevision(),
				s = Ee.IMAGE_REPLAYS[n.getRenderMode()];
			if (s && r.renderedTileRevision !== o) {
				r.renderedTileRevision = o;
				var a = t.wrappedTileCoord,
					l = a[0],
					u = e.pixelRatio,
					h = n.getSource(),
					c = h.getTileGridForProjection(e.viewState.projection),
					d = c.getResolution(l),
					f = t.getContext(n),
					A = h.getTilePixelSize(l, u, e.viewState.projection);
				f.canvas.width = A[0], f.canvas.height = A[1];
				for (var p = c.getTileCoordExtent(a), g = 0, m = t.tileKeys.length; g < m; ++g) {
					var v = t.getTile(t.tileKeys[g]);
					if (v.getState() != pt.a.ERROR) {
						var y = u / d,
							_ = ct.a.reset(this.tmpTransform_);
						ct.a.scale(_, y, -y), ct.a.translate(_, -p[0], -p[3]), v.getReplayGroup(n, t.tileCoord.toString()).replay(f, _, 0, {}, s)
					}
				}
			}
		};
		var xe = Ee,
			Ce = i(7),
			Ie = function(t) {
				this.source_ = t
			};
		Ie.prototype.getType = function() {}, Ie.prototype.getSource = function() {
			return this.source_
		}, Ie.prototype.isAnimated = v.a.FALSE;
		var Se = Ie,
			Te = function(t) {
				Se.call(this, t)
			};
		n.
	default.inherits(Te, Se), Te.prototype.getType = function() {
			return Ce.a.FRAGMENT_SHADER
		};
		var Re = Te,
			we = function(t) {
				Se.call(this, t)
			};
		n.
	default.inherits(we, Se), we.prototype.getType = function() {
			return Ce.a.VERTEX_SHADER
		};
		var Le = we,
			Ne = {};
		Ne.fragment = new Re(n.
	default.DEBUG_WEBGL ? "precision mediump float;\nvarying vec2 v_center;\nvarying vec2 v_offset;\nvarying float v_halfWidth;\nvarying float v_pixelRatio;\n\n\n\nuniform float u_opacity;\nuniform vec4 u_fillColor;\nuniform vec4 u_strokeColor;\nuniform vec2 u_size;\n\nvoid main(void) {\n  vec2 windowCenter = vec2((v_center.x + 1.0) / 2.0 * u_size.x * v_pixelRatio,\n      (v_center.y + 1.0) / 2.0 * u_size.y * v_pixelRatio);\n  vec2 windowOffset = vec2((v_offset.x + 1.0) / 2.0 * u_size.x * v_pixelRatio,\n      (v_offset.y + 1.0) / 2.0 * u_size.y * v_pixelRatio);\n  float radius = length(windowCenter - windowOffset);\n  float dist = length(windowCenter - gl_FragCoord.xy);\n  if (dist > radius + v_halfWidth) {\n    if (u_strokeColor.a == 0.0) {\n      gl_FragColor = u_fillColor;\n    } else {\n      gl_FragColor = u_strokeColor;\n    }\n    gl_FragColor.a = gl_FragColor.a - (dist - (radius + v_halfWidth));\n  } else if (u_fillColor.a == 0.0) {\n    // Hooray, no fill, just stroke. We can use real antialiasing.\n    gl_FragColor = u_strokeColor;\n    if (dist < radius - v_halfWidth) {\n      gl_FragColor.a = gl_FragColor.a - (radius - v_halfWidth - dist);\n    }\n  } else {\n    gl_FragColor = u_fillColor;\n    float strokeDist = radius - v_halfWidth;\n    float antialias = 2.0 * v_pixelRatio;\n    if (dist > strokeDist) {\n      gl_FragColor = u_strokeColor;\n    } else if (dist >= strokeDist - antialias) {\n      float step = smoothstep(strokeDist - antialias, strokeDist, dist);\n      gl_FragColor = mix(u_fillColor, u_strokeColor, step);\n    }\n  }\n  gl_FragColor.a = gl_FragColor.a * u_opacity;\n  if (gl_FragColor.a <= 0.0) {\n    discard;\n  }\n}\n":
		"precision mediump float;varying vec2 a;varying vec2 b;varying float c;varying float d;uniform float m;uniform vec4 n;uniform vec4 o;uniform vec2 p;void main(void){vec2 windowCenter=vec2((a.x+1.0)/2.0*p.x*d,(a.y+1.0)/2.0*p.y*d);vec2 windowOffset=vec2((b.x+1.0)/2.0*p.x*d,(b.y+1.0)/2.0*p.y*d);float radius=length(windowCenter-windowOffset);float dist=length(windowCenter-gl_FragCoord.xy);if(dist>radius+c){if(o.a==0.0){gl_FragColor=n;}else{gl_FragColor=o;}gl_FragColor.a=gl_FragColor.a-(dist-(radius+c));}else if(n.a==0.0){gl_FragColor=o;if(dist<radius-c){gl_FragColor.a=gl_FragColor.a-(radius-c-dist);}} else{gl_FragColor=n;float strokeDist=radius-c;float antialias=2.0*d;if(dist>strokeDist){gl_FragColor=o;}else if(dist>=strokeDist-antialias){float step=smoothstep(strokeDist-antialias,strokeDist,dist);gl_FragColor=mix(n,o,step);}} gl_FragColor.a=gl_FragColor.a*m;if(gl_FragColor.a<=0.0){discard;}}"), Ne.vertex = new Le(n.
	default.DEBUG_WEBGL ? "varying vec2 v_center;\nvarying vec2 v_offset;\nvarying float v_halfWidth;\nvarying float v_pixelRatio;\n\n\nattribute vec2 a_position;\nattribute float a_instruction;\nattribute float a_radius;\n\nuniform mat4 u_projectionMatrix;\nuniform mat4 u_offsetScaleMatrix;\nuniform mat4 u_offsetRotateMatrix;\nuniform float u_lineWidth;\nuniform float u_pixelRatio;\n\nvoid main(void) {\n  mat4 offsetMatrix = u_offsetScaleMatrix * u_offsetRotateMatrix;\n  v_center = vec4(u_projectionMatrix * vec4(a_position, 0.0, 1.0)).xy;\n  v_pixelRatio = u_pixelRatio;\n  float lineWidth = u_lineWidth * u_pixelRatio;\n  v_halfWidth = lineWidth / 2.0;\n  if (lineWidth == 0.0) {\n    lineWidth = 2.0 * u_pixelRatio;\n  }\n  vec2 offset;\n  // Radius with anitaliasing (roughly).\n  float radius = a_radius + 3.0 * u_pixelRatio;\n  // Until we get gl_VertexID in WebGL, we store an instruction.\n  if (a_instruction == 0.0) {\n    // Offsetting the edges of the triangle by lineWidth / 2 is necessary, however\n    // we should also leave some space for the antialiasing, thus we offset by lineWidth.\n    offset = vec2(-1.0, 1.0);\n  } else if (a_instruction == 1.0) {\n    offset = vec2(-1.0, -1.0);\n  } else if (a_instruction == 2.0) {\n    offset = vec2(1.0, -1.0);\n  } else {\n    offset = vec2(1.0, 1.0);\n  }\n\n  gl_Position = u_projectionMatrix * vec4(a_position + offset * radius, 0.0, 1.0) +\n      offsetMatrix * vec4(offset * lineWidth, 0.0, 0.0);\n  v_offset = vec4(u_projectionMatrix * vec4(a_position.x + a_radius, a_position.y,\n      0.0, 1.0)).xy;\n\n  if (distance(v_center, v_offset) > 20000.0) {\n    gl_Position = vec4(v_center, 0.0, 1.0);\n  }\n}\n\n\n":
		"varying vec2 a;varying vec2 b;varying float c;varying float d;attribute vec2 e;attribute float f;attribute float g;uniform mat4 h;uniform mat4 i;uniform mat4 j;uniform float k;uniform float l;void main(void){mat4 offsetMatrix=i*j;a=vec4(h*vec4(e,0.0,1.0)).xy;d=l;float lineWidth=k*l;c=lineWidth/2.0;if(lineWidth==0.0){lineWidth=2.0*l;}vec2 offset;float radius=g+3.0*l;//Until we get gl_VertexID in WebGL,we store an instruction.if(f==0.0){//Offsetting the edges of the triangle by lineWidth/2 is necessary,however//we should also leave some space for the antialiasing,thus we offset by lineWidth.offset=vec2(-1.0,1.0);}else if(f==1.0){offset=vec2(-1.0,-1.0);}else if(f==2.0){offset=vec2(1.0,-1.0);}else{offset=vec2(1.0,1.0);}gl_Position=h*vec4(e+offset*radius,0.0,1.0)+offsetMatrix*vec4(offset*lineWidth,0.0,0.0);b=vec4(h*vec4(e.x+g,e.y,0.0,1.0)).xy;if(distance(a,b)>20000.0){gl_Position=vec4(a,0.0,1.0);}}");
		var Pe = Ne,
			Oe = function(t, e) {
				this.u_projectionMatrix = t.getUniformLocation(e, n.
			default.DEBUG_WEBGL ? "u_projectionMatrix":
				"h"), this.u_offsetScaleMatrix = t.getUniformLocation(e, n.
			default.DEBUG_WEBGL ? "u_offsetScaleMatrix":
				"i"), this.u_offsetRotateMatrix = t.getUniformLocation(e, n.
			default.DEBUG_WEBGL ? "u_offsetRotateMatrix":
				"j"), this.u_lineWidth = t.getUniformLocation(e, n.
			default.DEBUG_WEBGL ? "u_lineWidth":
				"k"), this.u_pixelRatio = t.getUniformLocation(e, n.
			default.DEBUG_WEBGL ? "u_pixelRatio":
				"l"), this.u_opacity = t.getUniformLocation(e, n.
			default.DEBUG_WEBGL ? "u_opacity":
				"m"), this.u_fillColor = t.getUniformLocation(e, n.
			default.DEBUG_WEBGL ? "u_fillColor":
				"n"), this.u_strokeColor = t.getUniformLocation(e, n.
			default.DEBUG_WEBGL ? "u_strokeColor":
				"o"), this.u_size = t.getUniformLocation(e, n.
			default.DEBUG_WEBGL ? "u_size":
				"p"), this.a_position = t.getAttribLocation(e, n.
			default.DEBUG_WEBGL ? "a_position":
				"e"), this.a_instruction = t.getAttribLocation(e, n.
			default.DEBUG_WEBGL ? "a_instruction":
				"f"), this.a_radius = t.getAttribLocation(e, n.
			default.DEBUG_WEBGL ? "a_radius":
				"g")
			},
			Me = {
				create: function() {
					return [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]
				},
				fromTransform: function(t, e) {
					return t[0] = e[0], t[1] = e[1], t[4] = e[2], t[5] = e[3], t[12] = e[4], t[13] = e[5], t
				}
			},
			be = Me,
			Fe = function(t, e) {
				ht.call(this), this.tolerance = t, this.maxExtent = e, this.origin = K.
			default.getCenter(e), this.projectionMatrix_ = ct.a.create(), this.offsetRotateMatrix_ = ct.a.create(), this.offsetScaleMatrix_ = ct.a.create(), this.tmpMat4_ = be.create(), this.indices = [], this.indicesBuffer = null, this.startIndices = [], this.startIndicesFeature = [], this.vertices = [], this.verticesBuffer = null, this.lineStringReplay = void 0
			};
		n.
	default.inherits(Fe, ht), Fe.prototype.getDeleteResourcesFunction = function(t) {}, Fe.prototype.finish = function(t) {}, Fe.prototype.setUpProgram = function(t, e, i, n) {}, Fe.prototype.shutDownProgram = function(t, e) {}, Fe.prototype.drawReplay = function(t, e, i, n) {}, Fe.prototype.drawHitDetectionReplayOneByOne = function(t, e, i, n, r) {}, Fe.prototype.drawHitDetectionReplay = function(t, e, i, n, r, o) {
			return r ? this.drawHitDetectionReplayOneByOne(t, e, i, n, o) : this.drawHitDetectionReplayAll(t, e, i, n)
		}, Fe.prototype.drawHitDetectionReplayAll = function(t, e, i, n) {
			t.clear(t.COLOR_BUFFER_BIT | t.DEPTH_BUFFER_BIT), this.drawReplay(t, e, i, !0);
			var r = n(null);
			return r || void 0
		}, Fe.prototype.replay = function(t, e, i, n, r, o, s, a, l, u, h) {
			var c, d, f, A, p, g, m, v, y = t.getGL();
			this.lineStringReplay && (c = y.isEnabled(y.STENCIL_TEST), d = y.getParameter(y.STENCIL_FUNC), f = y.getParameter(y.STENCIL_VALUE_MASK), A = y.getParameter(y.STENCIL_REF), p = y.getParameter(y.STENCIL_WRITEMASK), g = y.getParameter(y.STENCIL_FAIL), m = y.getParameter(y.STENCIL_PASS_DEPTH_PASS), v = y.getParameter(y.STENCIL_PASS_DEPTH_FAIL), y.enable(y.STENCIL_TEST), y.clear(y.STENCIL_BUFFER_BIT), y.stencilMask(255), y.stencilFunc(y.ALWAYS, 1, 255), y.stencilOp(y.KEEP, y.KEEP, y.REPLACE), this.lineStringReplay.replay(t, e, i, n, r, o, s, a, l, u, h), y.stencilMask(0), y.stencilFunc(y.NOTEQUAL, 1, 255)), t.bindBuffer(Ce.a.ARRAY_BUFFER, this.verticesBuffer), t.bindBuffer(Ce.a.ELEMENT_ARRAY_BUFFER, this.indicesBuffer);
			var _ = this.setUpProgram(y, t, r, o),
				E = ct.a.reset(this.projectionMatrix_);
			ct.a.scale(E, 2 / (i * r[0]), 2 / (i * r[1])), ct.a.rotate(E, -n), ct.a.translate(E, -(e[0] - this.origin[0]), -(e[1] - this.origin[1]));
			var x = ct.a.reset(this.offsetScaleMatrix_);
			ct.a.scale(x, 2 / r[0], 2 / r[1]);
			var C, I = ct.a.reset(this.offsetRotateMatrix_);
			return 0 !== n && ct.a.rotate(I, -n), y.uniformMatrix4fv(_.u_projectionMatrix, !1, be.fromTransform(this.tmpMat4_, E)), y.uniformMatrix4fv(_.u_offsetScaleMatrix, !1, be.fromTransform(this.tmpMat4_, x)), y.uniformMatrix4fv(_.u_offsetRotateMatrix, !1, be.fromTransform(this.tmpMat4_, I)), y.uniform1f(_.u_opacity, s), void 0 === l ? this.drawReplay(y, t, a, !1) : C = this.drawHitDetectionReplay(y, t, a, l, u, h), this.shutDownProgram(y, _), this.lineStringReplay && (c || y.disable(y.STENCIL_TEST), y.clear(y.STENCIL_BUFFER_BIT), y.stencilFunc(d, A, f), y.stencilMask(p), y.stencilOp(g, v, m)), C
		}, Fe.prototype.drawElements = function(t, e, i, n) {
			var r = e.hasOESElementIndexUint ? Ce.a.UNSIGNED_INT : Ce.a.UNSIGNED_SHORT,
				o = n - i,
				s = i * (e.hasOESElementIndexUint ? 4 : 2);
			t.drawElements(Ce.a.TRIANGLES, o, r, s)
		};
		var De = Fe,
			Ge = {
				defaultFont: "10px sans-serif",
				defaultFillStyle: [0, 0, 0, 1],
				defaultLineCap: "round",
				defaultLineDash: [],
				defaultLineDashOffset: 0,
				defaultLineJoin: "round",
				defaultMiterLimit: 10,
				defaultStrokeStyle: [0, 0, 0, 1],
				defaultTextAlign: .5,
				defaultTextBaseline: .5,
				defaultLineWidth: 1,
				triangleIsCounterClockwise: function(t, e, i, n, r, o) {
					var s = (i - t) * (o - e) - (r - t) * (n - e);
					return s <= Ge.EPSILON && s >= -Ge.EPSILON ? void 0 : s > 0
				}
			};
		Ge.EPSILON = Number.EPSILON || 2220446049250313e-31;
		var ke = Ge,
			Ue = function(t, e) {
				this.arr_ = void 0 !== t ? t : [], this.usage_ = void 0 !== e ? e : Ue.Usage_.STATIC_DRAW
			};
		Ue.prototype.getArray = function() {
			return this.arr_
		}, Ue.prototype.getUsage = function() {
			return this.usage_
		}, Ue.Usage_ = {
			STATIC_DRAW: Ce.a.STATIC_DRAW,
			STREAM_DRAW: Ce.a.STREAM_DRAW,
			DYNAMIC_DRAW: Ce.a.DYNAMIC_DRAW
		};
		var Be = Ue,
			je = function(t, e) {
				De.call(this, t, e), this.defaultLocations_ = null, this.styles_ = [], this.styleIndices_ = [], this.radius_ = 0, this.state_ = {
					fillColor: null,
					strokeColor: null,
					lineDash: null,
					lineDashOffset: void 0,
					lineWidth: void 0,
					changed: !1
				}
			};
		n.
	default.inherits(je, De), je.prototype.drawCoordinates_ = function(t, e, i, n) {
			var r, o, s = this.vertices.length,
				a = this.indices.length,
				l = s / 4;
			for (r = e, o = i; r < o; r += n) this.vertices[s++] = t[r], this.vertices[s++] = t[r + 1], this.vertices[s++] = 0, this.vertices[s++] = this.radius_, this.vertices[s++] = t[r], this.vertices[s++] = t[r + 1], this.vertices[s++] = 1, this.vertices[s++] = this.radius_, this.vertices[s++] = t[r], this.vertices[s++] = t[r + 1], this.vertices[s++] = 2, this.vertices[s++] = this.radius_, this.vertices[s++] = t[r], this.vertices[s++] = t[r + 1], this.vertices[s++] = 3, this.vertices[s++] = this.radius_, this.indices[a++] = l, this.indices[a++] = l + 1, this.indices[a++] = l + 2, this.indices[a++] = l + 2, this.indices[a++] = l + 3, this.indices[a++] = l, l += 4
		}, je.prototype.drawCircle = function(t, e) {
			var i = t.getRadius(),
				n = t.getStride();
			if (i) {
				this.startIndices.push(this.indices.length), this.startIndicesFeature.push(e), this.state_.changed && (this.styleIndices_.push(this.indices.length), this.state_.changed = !1), this.radius_ = i;
				var r = t.getFlatCoordinates();
				r = lt.a.translate(r, 0, 2, n, -this.origin[0], -this.origin[1]), this.drawCoordinates_(r, 0, 2, n)
			} else if (this.state_.changed && (this.styles_.pop(), this.styles_.length)) {
				var o = this.styles_[this.styles_.length - 1];
				this.state_.fillColor = o[0], this.state_.strokeColor = o[1], this.state_.lineWidth = o[2], this.state_.changed = !1
			}
		}, je.prototype.finish = function(t) {
			this.verticesBuffer = new Be(this.vertices), this.indicesBuffer = new Be(this.indices), this.startIndices.push(this.indices.length), 0 === this.styleIndices_.length && this.styles_.length > 0 && (this.styles_ = []), this.vertices = null, this.indices = null
		}, je.prototype.getDeleteResourcesFunction = function(t) {
			var e = this.verticesBuffer,
				i = this.indicesBuffer;
			return function() {
				t.deleteBuffer(e), t.deleteBuffer(i)
			}
		}, je.prototype.setUpProgram = function(t, e, i, n) {
			var r, o;
			r = Pe.fragment, o = Pe.vertex;
			var s, a = e.getProgram(r, o);
			return this.defaultLocations_ ? s = this.defaultLocations_ : (s = new Oe(t, a), this.defaultLocations_ = s), e.useProgram(a), t.enableVertexAttribArray(s.a_position), t.vertexAttribPointer(s.a_position, 2, Ce.a.FLOAT, !1, 16, 0), t.enableVertexAttribArray(s.a_instruction), t.vertexAttribPointer(s.a_instruction, 1, Ce.a.FLOAT, !1, 16, 8), t.enableVertexAttribArray(s.a_radius), t.vertexAttribPointer(s.a_radius, 1, Ce.a.FLOAT, !1, 16, 12), t.uniform2fv(s.u_size, i), t.uniform1f(s.u_pixelRatio, n), s
		}, je.prototype.shutDownProgram = function(t, e) {
			t.disableVertexAttribArray(e.a_position), t.disableVertexAttribArray(e.a_instruction), t.disableVertexAttribArray(e.a_radius)
		}, je.prototype.drawReplay = function(t, e, i, n) {
			var r, o, s, a;
			if (V.a.isEmpty(i)) for (s = this.startIndices[this.startIndices.length - 1], r = this.styleIndices_.length - 1; r >= 0; --r) o = this.styleIndices_[r], a = this.styles_[r], this.setFillStyle_(t, a[0]), this.setStrokeStyle_(t, a[1], a[2]), this.drawElements(t, e, o, s), s = o;
			else this.drawReplaySkipping_(t, e, i)
		}, je.prototype.drawHitDetectionReplayOneByOne = function(t, e, i, r, o) {
			var s, a, l, u, h, c, d;
			for (d = this.startIndices.length - 2, l = this.startIndices[d + 1], s = this.styleIndices_.length - 1; s >= 0; --s) for (u = this.styles_[s], this.setFillStyle_(t, u[0]), this.setStrokeStyle_(t, u[1], u[2]), h = this.styleIndices_[s]; d >= 0 && this.startIndices[d] >= h;) {
				if (a = this.startIndices[d], c = this.startIndicesFeature[d], void 0 === i[n.
			default.getUid(c).toString()] && c.getGeometry() && (void 0 === o || K.
			default.intersects(o, c.getGeometry().getExtent()))) {
					t.clear(t.COLOR_BUFFER_BIT | t.DEPTH_BUFFER_BIT), this.drawElements(t, e, a, l);
					var f = r(c);
					if (f) return f
				}
				d--, l = a
			}
		}, je.prototype.drawReplaySkipping_ = function(t, e, i) {
			var r, o, s, a, l, u, h, c;
			for (h = this.startIndices.length - 2, s = o = this.startIndices[h + 1], r = this.styleIndices_.length - 1; r >= 0; --r) {
				for (a = this.styles_[r], this.setFillStyle_(t, a[0]), this.setStrokeStyle_(t, a[1], a[2]), l = this.styleIndices_[r]; h >= 0 && this.startIndices[h] >= l;) c = this.startIndices[h], u = this.startIndicesFeature[h], i[n.
			default.getUid(u).toString()] && (o !== s && this.drawElements(t, e, o, s), s = c), h--, o = c;
				o !== s && this.drawElements(t, e, o, s), o = s = l
			}
		}, je.prototype.setFillStyle_ = function(t, e) {
			t.uniform4fv(this.defaultLocations_.u_fillColor, e)
		}, je.prototype.setStrokeStyle_ = function(t, e, i) {
			t.uniform4fv(this.defaultLocations_.u_strokeColor, e), t.uniform1f(this.defaultLocations_.u_lineWidth, i)
		}, je.prototype.setFillStrokeStyle = function(t, e) {
			var i, n;
			if (e) {
				var r = e.getLineDash();
				this.state_.lineDash = r || ke.defaultLineDash;
				var o = e.getLineDashOffset();
				this.state_.lineDashOffset = o || ke.defaultLineDashOffset, i = (i = e.getColor()) instanceof CanvasGradient || i instanceof CanvasPattern ? ke.defaultStrokeStyle : ne.a.asArray(i).map((function(t, e) {
					return 3 != e ? t / 255 : t
				})) || ke.defaultStrokeStyle, n = void 0 !== (n = e.getWidth()) ? n : ke.defaultLineWidth
			} else i = [0, 0, 0, 0], n = 0;
			var s = t ? t.getColor() : [0, 0, 0, 0];
			s = s instanceof CanvasGradient || s instanceof CanvasPattern ? ke.defaultFillStyle : ne.a.asArray(s).map((function(t, e) {
				return 3 != e ? t / 255 : t
			})) || ke.defaultFillStyle, this.state_.strokeColor && Z.a.equals(this.state_.strokeColor, i) && this.state_.fillColor && Z.a.equals(this.state_.fillColor, s) && this.state_.lineWidth === n || (this.state_.changed = !0, this.state_.fillColor = s, this.state_.strokeColor = i, this.state_.lineWidth = n, this.styles_.push([s, i, n]))
		};
		var Ve = je,
			Ye = {};
		Ye.fragment = new Re(n.
	default.DEBUG_WEBGL ? "precision mediump float;\nvarying vec2 v_texCoord;\nvarying float v_opacity;\n\nuniform float u_opacity;\nuniform sampler2D u_image;\n\nvoid main(void) {\n  vec4 texColor = texture2D(u_image, v_texCoord);\n  gl_FragColor.rgb = texColor.rgb;\n  float alpha = texColor.a * v_opacity * u_opacity;\n  if (alpha == 0.0) {\n    discard;\n  }\n  gl_FragColor.a = alpha;\n}\n":
		"precision mediump float;varying vec2 a;varying float b;uniform float k;uniform sampler2D l;void main(void){vec4 texColor=texture2D(l,a);gl_FragColor.rgb=texColor.rgb;float alpha=texColor.a*b*k;if(alpha==0.0){discard;}gl_FragColor.a=alpha;}"), Ye.vertex = new Le(n.
	default.DEBUG_WEBGL ? "varying vec2 v_texCoord;\nvarying float v_opacity;\n\nattribute vec2 a_position;\nattribute vec2 a_texCoord;\nattribute vec2 a_offsets;\nattribute float a_opacity;\nattribute float a_rotateWithView;\n\nuniform mat4 u_projectionMatrix;\nuniform mat4 u_offsetScaleMatrix;\nuniform mat4 u_offsetRotateMatrix;\n\nvoid main(void) {\n  mat4 offsetMatrix = u_offsetScaleMatrix;\n  if (a_rotateWithView == 1.0) {\n    offsetMatrix = u_offsetScaleMatrix * u_offsetRotateMatrix;\n  }\n  vec4 offsets = offsetMatrix * vec4(a_offsets, 0.0, 0.0);\n  gl_Position = u_projectionMatrix * vec4(a_position, 0.0, 1.0) + offsets;\n  v_texCoord = a_texCoord;\n  v_opacity = a_opacity;\n}\n\n\n":
		"varying vec2 a;varying float b;attribute vec2 c;attribute vec2 d;attribute vec2 e;attribute float f;attribute float g;uniform mat4 h;uniform mat4 i;uniform mat4 j;void main(void){mat4 offsetMatrix=i;if(g==1.0){offsetMatrix=i*j;}vec4 offsets=offsetMatrix*vec4(e,0.0,0.0);gl_Position=h*vec4(c,0.0,1.0)+offsets;a=d;b=f;}");
		var ze = Ye,
			Xe = function(t, e) {
				this.u_projectionMatrix = t.getUniformLocation(e, n.
			default.DEBUG_WEBGL ? "u_projectionMatrix":
				"h"), this.u_offsetScaleMatrix = t.getUniformLocation(e, n.
			default.DEBUG_WEBGL ? "u_offsetScaleMatrix":
				"i"), this.u_offsetRotateMatrix = t.getUniformLocation(e, n.
			default.DEBUG_WEBGL ? "u_offsetRotateMatrix":
				"j"), this.u_opacity = t.getUniformLocation(e, n.
			default.DEBUG_WEBGL ? "u_opacity":
				"k"), this.u_image = t.getUniformLocation(e, n.
			default.DEBUG_WEBGL ? "u_image":
				"l"), this.a_position = t.getAttribLocation(e, n.
			default.DEBUG_WEBGL ? "a_position":
				"c"), this.a_texCoord = t.getAttribLocation(e, n.
			default.DEBUG_WEBGL ? "a_texCoord":
				"d"), this.a_offsets = t.getAttribLocation(e, n.
			default.DEBUG_WEBGL ? "a_offsets":
				"e"), this.a_opacity = t.getAttribLocation(e, n.
			default.DEBUG_WEBGL ? "a_opacity":
				"f"), this.a_rotateWithView = t.getAttribLocation(e, n.
			default.DEBUG_WEBGL ? "a_rotateWithView":
				"g")
			},
			We = {
				LOST: "webglcontextlost",
				RESTORED: "webglcontextrestored"
			},
			qe = function(t, e) {
				this.canvas_ = t, this.gl_ = e, this.bufferCache_ = {}, this.shaderCache_ = {}, this.programCache_ = {}, this.currentProgram_ = null, this.hitDetectionFramebuffer_ = null, this.hitDetectionTexture_ = null, this.hitDetectionRenderbuffer_ = null, this.hasOESElementIndexUint = Z.a.includes(n.
			default.WEBGL_EXTENSIONS, "OES_element_index_uint"), this.hasOESElementIndexUint && e.getExtension("OES_element_index_uint"), mt.a.listen(this.canvas_, We.LOST, this.handleWebGLContextLost, this), mt.a.listen(this.canvas_, We.RESTORED, this.handleWebGLContextRestored, this)
			};
		n.
	default.inherits(qe, Lt.a), qe.prototype.bindBuffer = function(t, e) {
			var i = this.getGL(),
				r = e.getArray(),
				o = String(n.
			default.getUid(e));
			if (o in this.bufferCache_) {
				var s = this.bufferCache_[o];
				i.bindBuffer(t, s.buffer)
			} else {
				var a, l = i.createBuffer();
				i.bindBuffer(t, l), t == Ce.a.ARRAY_BUFFER ? a = new Float32Array(r) : t == Ce.a.ELEMENT_ARRAY_BUFFER && (a = this.hasOESElementIndexUint ? new Uint32Array(r) : new Uint16Array(r)), i.bufferData(t, a, e.getUsage()), this.bufferCache_[o] = {
					buf: e,
					buffer: l
				}
			}
		}, qe.prototype.deleteBuffer = function(t) {
			var e = this.getGL(),
				i = String(n.
			default.getUid(t)),
				r = this.bufferCache_[i];
			e.isContextLost() || e.deleteBuffer(r.buffer), delete this.bufferCache_[i]
		}, qe.prototype.disposeInternal = function() {
			mt.a.unlistenAll(this.canvas_);
			var t = this.getGL();
			if (!t.isContextLost()) {
				var e;
				for (e in this.bufferCache_) t.deleteBuffer(this.bufferCache_[e].buffer);
				for (e in this.programCache_) t.deleteProgram(this.programCache_[e]);
				for (e in this.shaderCache_) t.deleteShader(this.shaderCache_[e]);
				t.deleteFramebuffer(this.hitDetectionFramebuffer_), t.deleteRenderbuffer(this.hitDetectionRenderbuffer_), t.deleteTexture(this.hitDetectionTexture_)
			}
		}, qe.prototype.getCanvas = function() {
			return this.canvas_
		}, qe.prototype.getGL = function() {
			return this.gl_
		}, qe.prototype.getHitDetectionFramebuffer = function() {
			return this.hitDetectionFramebuffer_ || this.initHitDetectionFramebuffer_(), this.hitDetectionFramebuffer_
		}, qe.prototype.getShader = function(t) {
			var e = String(n.
		default.getUid(t));
			if (e in this.shaderCache_) return this.shaderCache_[e];
			var i = this.getGL(),
				r = i.createShader(t.getType());
			return i.shaderSource(r, t.getSource()), i.compileShader(r), this.shaderCache_[e] = r, r
		}, qe.prototype.getProgram = function(t, e) {
			var i = n.
		default.getUid(t) + "/" + n.
		default.getUid(e);
			if (i in this.programCache_) return this.programCache_[i];
			var r = this.getGL(),
				o = r.createProgram();
			return r.attachShader(o, this.getShader(t)), r.attachShader(o, this.getShader(e)), r.linkProgram(o), this.programCache_[i] = o, o
		}, qe.prototype.handleWebGLContextLost = function() {
			V.a.clear(this.bufferCache_), V.a.clear(this.shaderCache_), V.a.clear(this.programCache_), this.currentProgram_ = null, this.hitDetectionFramebuffer_ = null, this.hitDetectionTexture_ = null, this.hitDetectionRenderbuffer_ = null
		}, qe.prototype.handleWebGLContextRestored = function() {}, qe.prototype.initHitDetectionFramebuffer_ = function() {
			var t = this.gl_,
				e = t.createFramebuffer();
			t.bindFramebuffer(t.FRAMEBUFFER, e);
			var i = qe.createEmptyTexture(t, 1, 1),
				n = t.createRenderbuffer();
			t.bindRenderbuffer(t.RENDERBUFFER, n), t.renderbufferStorage(t.RENDERBUFFER, t.DEPTH_COMPONENT16, 1, 1), t.framebufferTexture2D(t.FRAMEBUFFER, t.COLOR_ATTACHMENT0, t.TEXTURE_2D, i, 0), t.framebufferRenderbuffer(t.FRAMEBUFFER, t.DEPTH_ATTACHMENT, t.RENDERBUFFER, n), t.bindTexture(t.TEXTURE_2D, null), t.bindRenderbuffer(t.RENDERBUFFER, null), t.bindFramebuffer(t.FRAMEBUFFER, null), this.hitDetectionFramebuffer_ = e, this.hitDetectionTexture_ = i, this.hitDetectionRenderbuffer_ = n
		}, qe.prototype.useProgram = function(t) {
			return t != this.currentProgram_ && (this.getGL().useProgram(t), this.currentProgram_ = t, !0)
		}, qe.createTexture_ = function(t, e, i) {
			var n = t.createTexture();
			return t.bindTexture(t.TEXTURE_2D, n), t.texParameteri(t.TEXTURE_2D, t.TEXTURE_MAG_FILTER, t.LINEAR), t.texParameteri(t.TEXTURE_2D, t.TEXTURE_MIN_FILTER, t.LINEAR), void 0 !== e && t.texParameteri(Ce.a.TEXTURE_2D, Ce.a.TEXTURE_WRAP_S, e), void 0 !== i && t.texParameteri(Ce.a.TEXTURE_2D, Ce.a.TEXTURE_WRAP_T, i), n
		}, qe.createEmptyTexture = function(t, e, i, n, r) {
			var o = qe.createTexture_(t, n, r);
			return t.texImage2D(t.TEXTURE_2D, 0, t.RGBA, e, i, 0, t.RGBA, t.UNSIGNED_BYTE, null), o
		}, qe.createTexture = function(t, e, i, n) {
			var r = qe.createTexture_(t, i, n);
			return t.texImage2D(t.TEXTURE_2D, 0, t.RGBA, t.RGBA, t.UNSIGNED_BYTE, e), r
		};
		var He = qe,
			Ze = function(t, e) {
				De.call(this, t, e), this.anchorX = void 0, this.anchorY = void 0, this.groupIndices = [], this.hitDetectionGroupIndices = [], this.height = void 0, this.imageHeight = void 0, this.imageWidth = void 0, this.defaultLocations = null, this.opacity = void 0, this.originX = void 0, this.originY = void 0, this.rotateWithView = void 0, this.rotation = void 0, this.scale = void 0, this.width = void 0
			};
		n.
	default.inherits(Ze, De), Ze.prototype.getDeleteResourcesFunction = function(t) {
			var e = this.verticesBuffer,
				i = this.indicesBuffer,
				n = this.getTextures(!0),
				r = t.getGL();
			return function() {
				var o, s;
				if (!r.isContextLost()) for (o = 0, s = n.length; o < s; ++o) r.deleteTexture(n[o]);
				t.deleteBuffer(e), t.deleteBuffer(i)
			}
		}, Ze.prototype.drawCoordinates = function(t, e, i, n) {
			var r, o, s, a, l, u, h = this.anchorX,
				c = this.anchorY,
				d = this.height,
				f = this.imageHeight,
				A = this.imageWidth,
				p = this.opacity,
				g = this.originX,
				m = this.originY,
				v = this.rotateWithView ? 1 : 0,
				y = -this.rotation,
				_ = this.scale,
				E = this.width,
				x = Math.cos(y),
				C = Math.sin(y),
				I = this.indices.length,
				S = this.vertices.length;
			for (r = e; r < i; r += n) l = t[r] - this.origin[0], u = t[r + 1] - this.origin[1], o = S / 8, s = -_ * h, a = -_ * (d - c), this.vertices[S++] = l, this.vertices[S++] = u, this.vertices[S++] = s * x - a * C, this.vertices[S++] = s * C + a * x, this.vertices[S++] = g / A, this.vertices[S++] = (m + d) / f, this.vertices[S++] = p, this.vertices[S++] = v, s = _ * (E - h), a = -_ * (d - c), this.vertices[S++] = l, this.vertices[S++] = u, this.vertices[S++] = s * x - a * C, this.vertices[S++] = s * C + a * x, this.vertices[S++] = (g + E) / A, this.vertices[S++] = (m + d) / f, this.vertices[S++] = p, this.vertices[S++] = v, s = _ * (E - h), a = _ * c, this.vertices[S++] = l, this.vertices[S++] = u, this.vertices[S++] = s * x - a * C, this.vertices[S++] = s * C + a * x, this.vertices[S++] = (g + E) / A, this.vertices[S++] = m / f, this.vertices[S++] = p, this.vertices[S++] = v, s = -_ * h, a = _ * c, this.vertices[S++] = l, this.vertices[S++] = u, this.vertices[S++] = s * x - a * C, this.vertices[S++] = s * C + a * x, this.vertices[S++] = g / A, this.vertices[S++] = m / f, this.vertices[S++] = p, this.vertices[S++] = v, this.indices[I++] = o, this.indices[I++] = o + 1, this.indices[I++] = o + 2, this.indices[I++] = o, this.indices[I++] = o + 2, this.indices[I++] = o + 3;
			return S
		}, Ze.prototype.createTextures = function(t, e, i, r) {
			var o, s, a, l, u = e.length;
			for (l = 0; l < u; ++l) s = e[l], (a = n.
		default.getUid(s).toString()) in i ? o = i[a] : (o = He.createTexture(r, s, Ce.a.CLAMP_TO_EDGE, Ce.a.CLAMP_TO_EDGE), i[a] = o), t[l] = o
		}, Ze.prototype.setUpProgram = function(t, e, i, n) {
			var r, o = ze.fragment,
				s = ze.vertex,
				a = e.getProgram(o, s);
			return this.defaultLocations ? r = this.defaultLocations : (r = new Xe(t, a), this.defaultLocations = r), e.useProgram(a), t.enableVertexAttribArray(r.a_position), t.vertexAttribPointer(r.a_position, 2, Ce.a.FLOAT, !1, 32, 0), t.enableVertexAttribArray(r.a_offsets), t.vertexAttribPointer(r.a_offsets, 2, Ce.a.FLOAT, !1, 32, 8), t.enableVertexAttribArray(r.a_texCoord), t.vertexAttribPointer(r.a_texCoord, 2, Ce.a.FLOAT, !1, 32, 16), t.enableVertexAttribArray(r.a_opacity), t.vertexAttribPointer(r.a_opacity, 1, Ce.a.FLOAT, !1, 32, 24), t.enableVertexAttribArray(r.a_rotateWithView), t.vertexAttribPointer(r.a_rotateWithView, 1, Ce.a.FLOAT, !1, 32, 28), r
		}, Ze.prototype.shutDownProgram = function(t, e) {
			t.disableVertexAttribArray(e.a_position), t.disableVertexAttribArray(e.a_offsets), t.disableVertexAttribArray(e.a_texCoord), t.disableVertexAttribArray(e.a_opacity), t.disableVertexAttribArray(e.a_rotateWithView)
		}, Ze.prototype.drawReplay = function(t, e, i, n) {
			var r, o, s, a = n ? this.getHitDetectionTextures() : this.getTextures(),
				l = n ? this.hitDetectionGroupIndices : this.groupIndices;
			if (V.a.isEmpty(i)) for (r = 0, o = a.length, s = 0; r < o; ++r) {
				t.bindTexture(Ce.a.TEXTURE_2D, a[r]);
				var u = l[r];
				this.drawElements(t, e, s, u), s = u
			} else this.drawReplaySkipping(t, e, i, a, l)
		}, Ze.prototype.drawReplaySkipping = function(t, e, i, r, o) {
			var s, a, l = 0;
			for (s = 0, a = r.length; s < a; ++s) {
				t.bindTexture(Ce.a.TEXTURE_2D, r[s]);
				for (var u = s > 0 ? o[s - 1] : 0, h = o[s], c = u, d = u; l < this.startIndices.length && this.startIndices[l] <= h;) {
					var f = this.startIndicesFeature[l];
					void 0 !== i[n.
				default.getUid(f).toString()] ? (c !== d && this.drawElements(t, e, c, d), d = c = l === this.startIndices.length - 1 ? h : this.startIndices[l + 1]) : d = l === this.startIndices.length - 1 ? h : this.startIndices[l + 1], l++
				}
				c !== d && this.drawElements(t, e, c, d)
			}
		}, Ze.prototype.drawHitDetectionReplayOneByOne = function(t, e, i, r, o) {
			var s, a, l, u, h, c = this.startIndices.length - 1,
				d = this.getHitDetectionTextures();
			for (s = d.length - 1; s >= 0; --s) for (t.bindTexture(Ce.a.TEXTURE_2D, d[s]), a = s > 0 ? this.hitDetectionGroupIndices[s - 1] : 0, u = this.hitDetectionGroupIndices[s]; c >= 0 && this.startIndices[c] >= a;) {
				if (l = this.startIndices[c], h = this.startIndicesFeature[c], void 0 === i[n.
			default.getUid(h).toString()] && h.getGeometry() && (void 0 === o || K.
			default.intersects(o, h.getGeometry().getExtent()))) {
					t.clear(t.COLOR_BUFFER_BIT | t.DEPTH_BUFFER_BIT), this.drawElements(t, e, l, u);
					var f = r(h);
					if (f) return f
				}
				u = l, c--
			}
		}, Ze.prototype.finish = function(t) {
			this.anchorX = void 0, this.anchorY = void 0, this.height = void 0, this.imageHeight = void 0, this.imageWidth = void 0, this.indices = null, this.opacity = void 0, this.originX = void 0, this.originY = void 0, this.rotateWithView = void 0, this.rotation = void 0, this.scale = void 0, this.vertices = null, this.width = void 0
		}, Ze.prototype.getTextures = function(t) {}, Ze.prototype.getHitDetectionTextures = function() {};
		var Ke = Ze,
			Je = function(t, e) {
				Ke.call(this, t, e), this.images_ = [], this.hitDetectionImages_ = [], this.textures_ = [], this.hitDetectionTextures_ = []
			};
		n.
	default.inherits(Je, Ke), Je.prototype.drawMultiPoint = function(t, e) {
			this.startIndices.push(this.indices.length), this.startIndicesFeature.push(e);
			var i = t.getFlatCoordinates(),
				n = t.getStride();
			this.drawCoordinates(i, 0, i.length, n)
		}, Je.prototype.drawPoint = function(t, e) {
			this.startIndices.push(this.indices.length), this.startIndicesFeature.push(e);
			var i = t.getFlatCoordinates(),
				n = t.getStride();
			this.drawCoordinates(i, 0, i.length, n)
		}, Je.prototype.finish = function(t) {
			var e = t.getGL();
			this.groupIndices.push(this.indices.length), this.hitDetectionGroupIndices.push(this.indices.length), this.verticesBuffer = new Be(this.vertices);
			var i = this.indices;
			this.indicesBuffer = new Be(i);
			var n = {};
			this.createTextures(this.textures_, this.images_, n, e), this.createTextures(this.hitDetectionTextures_, this.hitDetectionImages_, n, e), this.images_ = null, this.hitDetectionImages_ = null, Ke.prototype.finish.call(this, t)
		}, Je.prototype.setImageStyle = function(t) {
			var e, i = t.getAnchor(),
				r = t.getImage(1),
				o = t.getImageSize(),
				s = t.getHitDetectionImage(1),
				a = t.getOpacity(),
				l = t.getOrigin(),
				u = t.getRotateWithView(),
				h = t.getRotation(),
				c = t.getSize(),
				d = t.getScale();
			0 === this.images_.length ? this.images_.push(r) : (e = this.images_[this.images_.length - 1], n.
		default.getUid(e) != n.
		default.getUid(r) && (this.groupIndices.push(this.indices.length), this.images_.push(r))), 0 === this.hitDetectionImages_.length ? this.hitDetectionImages_.push(s) : (e = this.hitDetectionImages_[this.hitDetectionImages_.length - 1], n.
		default.getUid(e) != n.
		default.getUid(s) && (this.hitDetectionGroupIndices.push(this.indices.length), this.hitDetectionImages_.push(s))), this.anchorX = i[0], this.anchorY = i[1], this.height = c[1], this.imageHeight = o[1], this.imageWidth = o[0], this.opacity = a, this.originX = l[0], this.originY = l[1], this.rotation = h, this.rotateWithView = u, this.scale = d, this.width = c[0]
		}, Je.prototype.getTextures = function(t) {
			return t ? this.textures_.concat(this.hitDetectionTextures_) : this.textures_
		}, Je.prototype.getHitDetectionTextures = function() {
			return this.hitDetectionTextures_
		};
		var Qe = Je,
			$e = i(73),
			ti = i(102),
			ei = {
				lineStringIsClosed: function(t, e, i, n) {
					var r = i - n;
					return t[e] === t[r] && t[e + 1] === t[r + 1] && (i - e) / n > 3 && !! ti.a.linearRing(t, e, i, n)
				}
			},
			ii = ei,
			ni = {};
		ni.fragment = new Re(n.
	default.DEBUG_WEBGL ? "precision mediump float;\nvarying float v_round;\nvarying vec2 v_roundVertex;\nvarying float v_halfWidth;\n\n\n\nuniform float u_opacity;\nuniform vec4 u_color;\nuniform vec2 u_size;\nuniform float u_pixelRatio;\n\nvoid main(void) {\n  if (v_round > 0.0) {\n    vec2 windowCoords = vec2((v_roundVertex.x + 1.0) / 2.0 * u_size.x * u_pixelRatio,\n        (v_roundVertex.y + 1.0) / 2.0 * u_size.y * u_pixelRatio);\n    if (length(windowCoords - gl_FragCoord.xy) > v_halfWidth * u_pixelRatio) {\n      discard;\n    }\n  }\n  gl_FragColor = u_color;\n  float alpha = u_color.a * u_opacity;\n  if (alpha == 0.0) {\n    discard;\n  }\n  gl_FragColor.a = alpha;\n}\n":
		"precision mediump float;varying float a;varying vec2 aVertex;varying float c;uniform float m;uniform vec4 n;uniform vec2 o;uniform float p;void main(void){if(a>0.0){vec2 windowCoords=vec2((aVertex.x+1.0)/2.0*o.x*p,(aVertex.y+1.0)/2.0*o.y*p);if(length(windowCoords-gl_FragCoord.xy)>c*p){discard;}} gl_FragColor=n;float alpha=n.a*m;if(alpha==0.0){discard;}gl_FragColor.a=alpha;}"), ni.vertex = new Le(n.
	default.DEBUG_WEBGL ? "varying float v_round;\nvarying vec2 v_roundVertex;\nvarying float v_halfWidth;\n\n\nattribute vec2 a_lastPos;\nattribute vec2 a_position;\nattribute vec2 a_nextPos;\nattribute float a_direction;\n\nuniform mat4 u_projectionMatrix;\nuniform mat4 u_offsetScaleMatrix;\nuniform mat4 u_offsetRotateMatrix;\nuniform float u_lineWidth;\nuniform float u_miterLimit;\n\nbool nearlyEquals(in float value, in float ref) {\n  float epsilon = 0.000000000001;\n  return value >= ref - epsilon && value <= ref + epsilon;\n}\n\nvoid alongNormal(out vec2 offset, in vec2 nextP, in float turnDir, in float direction) {\n  vec2 dirVect = nextP - a_position;\n  vec2 normal = normalize(vec2(-turnDir * dirVect.y, turnDir * dirVect.x));\n  offset = u_lineWidth / 2.0 * normal * direction;\n}\n\nvoid miterUp(out vec2 offset, out float round, in bool isRound, in float direction) {\n  float halfWidth = u_lineWidth / 2.0;\n  vec2 tangent = normalize(normalize(a_nextPos - a_position) + normalize(a_position - a_lastPos));\n  vec2 normal = vec2(-tangent.y, tangent.x);\n  vec2 dirVect = a_nextPos - a_position;\n  vec2 tmpNormal = normalize(vec2(-dirVect.y, dirVect.x));\n  float miterLength = abs(halfWidth / dot(normal, tmpNormal));\n  offset = normal * direction * miterLength;\n  round = 0.0;\n  if (isRound) {\n    round = 1.0;\n  } else if (miterLength > u_miterLimit + u_lineWidth) {\n    offset = halfWidth * tmpNormal * direction;\n  }\n}\n\nbool miterDown(out vec2 offset, in vec4 projPos, in mat4 offsetMatrix, in float direction) {\n  bool degenerate = false;\n  vec2 tangent = normalize(normalize(a_nextPos - a_position) + normalize(a_position - a_lastPos));\n  vec2 normal = vec2(-tangent.y, tangent.x);\n  vec2 dirVect = a_lastPos - a_position;\n  vec2 tmpNormal = normalize(vec2(-dirVect.y, dirVect.x));\n  vec2 longOffset, shortOffset, longVertex;\n  vec4 shortProjVertex;\n  float halfWidth = u_lineWidth / 2.0;\n  if (length(a_nextPos - a_position) > length(a_lastPos - a_position)) {\n    longOffset = tmpNormal * direction * halfWidth;\n    shortOffset = normalize(vec2(dirVect.y, -dirVect.x)) * direction * halfWidth;\n    longVertex = a_nextPos;\n    shortProjVertex = u_projectionMatrix * vec4(a_lastPos, 0.0, 1.0);\n  } else {\n    shortOffset = tmpNormal * direction * halfWidth;\n    longOffset = normalize(vec2(dirVect.y, -dirVect.x)) * direction * halfWidth;\n    longVertex = a_lastPos;\n    shortProjVertex = u_projectionMatrix * vec4(a_nextPos, 0.0, 1.0);\n  }\n  //Intersection algorithm based on theory by Paul Bourke (http://paulbourke.net/geometry/pointlineplane/).\n  vec4 p1 = u_projectionMatrix * vec4(longVertex, 0.0, 1.0) + offsetMatrix * vec4(longOffset, 0.0, 0.0);\n  vec4 p2 = projPos + offsetMatrix * vec4(longOffset, 0.0, 0.0);\n  vec4 p3 = shortProjVertex + offsetMatrix * vec4(-shortOffset, 0.0, 0.0);\n  vec4 p4 = shortProjVertex + offsetMatrix * vec4(shortOffset, 0.0, 0.0);\n  float denom = (p4.y - p3.y) * (p2.x - p1.x) - (p4.x - p3.x) * (p2.y - p1.y);\n  float firstU = ((p4.x - p3.x) * (p1.y - p3.y) - (p4.y - p3.y) * (p1.x - p3.x)) / denom;\n  float secondU = ((p2.x - p1.x) * (p1.y - p3.y) - (p2.y - p1.y) * (p1.x - p3.x)) / denom;\n  float epsilon = 0.000000000001;\n  if (firstU > epsilon && firstU < 1.0 - epsilon && secondU > epsilon && secondU < 1.0 - epsilon) {\n    shortProjVertex.x = p1.x + firstU * (p2.x - p1.x);\n    shortProjVertex.y = p1.y + firstU * (p2.y - p1.y);\n    offset = shortProjVertex.xy;\n    degenerate = true;\n  } else {\n    float miterLength = abs(halfWidth / dot(normal, tmpNormal));\n    offset = normal * direction * miterLength;\n  }\n  return degenerate;\n}\n\nvoid squareCap(out vec2 offset, out float round, in bool isRound, in vec2 nextP,\n    in float turnDir, in float direction) {\n  round = 0.0;\n  vec2 dirVect = a_position - nextP;\n  vec2 firstNormal = normalize(dirVect);\n  vec2 secondNormal = vec2(turnDir * firstNormal.y * direction, -turnDir * firstNormal.x * direction);\n  vec2 hypotenuse = normalize(firstNormal - secondNormal);\n  vec2 normal = vec2(turnDir * hypotenuse.y * direction, -turnDir * hypotenuse.x * direction);\n  float length = sqrt(v_halfWidth * v_halfWidth * 2.0);\n  offset = normal * length;\n  if (isRound) {\n    round = 1.0;\n  }\n}\n\nvoid main(void) {\n  bool degenerate = false;\n  float direction = float(sign(a_direction));\n  mat4 offsetMatrix = u_offsetScaleMatrix * u_offsetRotateMatrix;\n  vec2 offset;\n  vec4 projPos = u_projectionMatrix * vec4(a_position, 0.0, 1.0);\n  bool round = nearlyEquals(mod(a_direction, 2.0), 0.0);\n\n  v_round = 0.0;\n  v_halfWidth = u_lineWidth / 2.0;\n  v_roundVertex = projPos.xy;\n\n  if (nearlyEquals(mod(a_direction, 3.0), 0.0) || nearlyEquals(mod(a_direction, 17.0), 0.0)) {\n    alongNormal(offset, a_nextPos, 1.0, direction);\n  } else if (nearlyEquals(mod(a_direction, 5.0), 0.0) || nearlyEquals(mod(a_direction, 13.0), 0.0)) {\n    alongNormal(offset, a_lastPos, -1.0, direction);\n  } else if (nearlyEquals(mod(a_direction, 23.0), 0.0)) {\n    miterUp(offset, v_round, round, direction);\n  } else if (nearlyEquals(mod(a_direction, 19.0), 0.0)) {\n    degenerate = miterDown(offset, projPos, offsetMatrix, direction);\n  } else if (nearlyEquals(mod(a_direction, 7.0), 0.0)) {\n    squareCap(offset, v_round, round, a_nextPos, 1.0, direction);\n  } else if (nearlyEquals(mod(a_direction, 11.0), 0.0)) {\n    squareCap(offset, v_round, round, a_lastPos, -1.0, direction);\n  }\n  if (!degenerate) {\n    vec4 offsets = offsetMatrix * vec4(offset, 0.0, 0.0);\n    gl_Position = projPos + offsets;\n  } else {\n    gl_Position = vec4(offset, 0.0, 1.0);\n  }\n}\n\n\n":
		"varying float a;varying vec2 aVertex;varying float c;attribute vec2 d;attribute vec2 e;attribute vec2 f;attribute float g;uniform mat4 h;uniform mat4 i;uniform mat4 j;uniform float k;uniform float l;bool nearlyEquals(in float value,in float ref){float epsilon=0.000000000001;return value>=ref-epsilon&&value<=ref+epsilon;}void alongNormal(out vec2 offset,in vec2 nextP,in float turnDir,in float direction){vec2 dirVect=nextP-e;vec2 normal=normalize(vec2(-turnDir*dirVect.y,turnDir*dirVect.x));offset=k/2.0*normal*direction;}void miterUp(out vec2 offset,out float round,in bool isRound,in float direction){float halfWidth=k/2.0;vec2 tangent=normalize(normalize(f-e)+normalize(e-d));vec2 normal=vec2(-tangent.y,tangent.x);vec2 dirVect=f-e;vec2 tmpNormal=normalize(vec2(-dirVect.y,dirVect.x));float miterLength=abs(halfWidth/dot(normal,tmpNormal));offset=normal*direction*miterLength;round=0.0;if(isRound){round=1.0;}else if(miterLength>l+k){offset=halfWidth*tmpNormal*direction;}} bool miterDown(out vec2 offset,in vec4 projPos,in mat4 offsetMatrix,in float direction){bool degenerate=false;vec2 tangent=normalize(normalize(f-e)+normalize(e-d));vec2 normal=vec2(-tangent.y,tangent.x);vec2 dirVect=d-e;vec2 tmpNormal=normalize(vec2(-dirVect.y,dirVect.x));vec2 longOffset,shortOffset,longVertex;vec4 shortProjVertex;float halfWidth=k/2.0;if(length(f-e)>length(d-e)){longOffset=tmpNormal*direction*halfWidth;shortOffset=normalize(vec2(dirVect.y,-dirVect.x))*direction*halfWidth;longVertex=f;shortProjVertex=h*vec4(d,0.0,1.0);}else{shortOffset=tmpNormal*direction*halfWidth;longOffset=normalize(vec2(dirVect.y,-dirVect.x))*direction*halfWidth;longVertex=d;shortProjVertex=h*vec4(f,0.0,1.0);}vec4 p1=h*vec4(longVertex,0.0,1.0)+offsetMatrix*vec4(longOffset,0.0,0.0);vec4 p2=projPos+offsetMatrix*vec4(longOffset,0.0,0.0);vec4 p3=shortProjVertex+offsetMatrix*vec4(-shortOffset,0.0,0.0);vec4 p4=shortProjVertex+offsetMatrix*vec4(shortOffset,0.0,0.0);float denom=(p4.y-p3.y)*(p2.x-p1.x)-(p4.x-p3.x)*(p2.y-p1.y);float firstU=((p4.x-p3.x)*(p1.y-p3.y)-(p4.y-p3.y)*(p1.x-p3.x))/denom;float secondU=((p2.x-p1.x)*(p1.y-p3.y)-(p2.y-p1.y)*(p1.x-p3.x))/denom;float epsilon=0.000000000001;if(firstU>epsilon&&firstU<1.0-epsilon&&secondU>epsilon&&secondU<1.0-epsilon){shortProjVertex.x=p1.x+firstU*(p2.x-p1.x);shortProjVertex.y=p1.y+firstU*(p2.y-p1.y);offset=shortProjVertex.xy;degenerate=true;}else{float miterLength=abs(halfWidth/dot(normal,tmpNormal));offset=normal*direction*miterLength;}return degenerate;}void squareCap(out vec2 offset,out float round,in bool isRound,in vec2 nextP,in float turnDir,in float direction){round=0.0;vec2 dirVect=e-nextP;vec2 firstNormal=normalize(dirVect);vec2 secondNormal=vec2(turnDir*firstNormal.y*direction,-turnDir*firstNormal.x*direction);vec2 hypotenuse=normalize(firstNormal-secondNormal);vec2 normal=vec2(turnDir*hypotenuse.y*direction,-turnDir*hypotenuse.x*direction);float length=sqrt(c*c*2.0);offset=normal*length;if(isRound){round=1.0;}} void main(void){bool degenerate=false;float direction=float(sign(g));mat4 offsetMatrix=i*j;vec2 offset;vec4 projPos=h*vec4(e,0.0,1.0);bool round=nearlyEquals(mod(g,2.0),0.0);a=0.0;c=k/2.0;aVertex=projPos.xy;if(nearlyEquals(mod(g,3.0),0.0)||nearlyEquals(mod(g,17.0),0.0)){alongNormal(offset,f,1.0,direction);}else if(nearlyEquals(mod(g,5.0),0.0)||nearlyEquals(mod(g,13.0),0.0)){alongNormal(offset,d,-1.0,direction);}else if(nearlyEquals(mod(g,23.0),0.0)){miterUp(offset,a,round,direction);}else if(nearlyEquals(mod(g,19.0),0.0)){degenerate=miterDown(offset,projPos,offsetMatrix,direction);}else if(nearlyEquals(mod(g,7.0),0.0)){squareCap(offset,a,round,f,1.0,direction);}else if(nearlyEquals(mod(g,11.0),0.0)){squareCap(offset,a,round,d,-1.0,direction);}if(!degenerate){vec4 offsets=offsetMatrix*vec4(offset,0.0,0.0);gl_Position=projPos+offsets;}else{gl_Position=vec4(offset,0.0,1.0);}}");
		var ri = ni,
			oi = function(t, e) {
				this.u_projectionMatrix = t.getUniformLocation(e, n.
			default.DEBUG_WEBGL ? "u_projectionMatrix":
				"h"), this.u_offsetScaleMatrix = t.getUniformLocation(e, n.
			default.DEBUG_WEBGL ? "u_offsetScaleMatrix":
				"i"), this.u_offsetRotateMatrix = t.getUniformLocation(e, n.
			default.DEBUG_WEBGL ? "u_offsetRotateMatrix":
				"j"), this.u_lineWidth = t.getUniformLocation(e, n.
			default.DEBUG_WEBGL ? "u_lineWidth":
				"k"), this.u_miterLimit = t.getUniformLocation(e, n.
			default.DEBUG_WEBGL ? "u_miterLimit":
				"l"), this.u_opacity = t.getUniformLocation(e, n.
			default.DEBUG_WEBGL ? "u_opacity":
				"m"), this.u_color = t.getUniformLocation(e, n.
			default.DEBUG_WEBGL ? "u_color":
				"n"), this.u_size = t.getUniformLocation(e, n.
			default.DEBUG_WEBGL ? "u_size":
				"o"), this.u_pixelRatio = t.getUniformLocation(e, n.
			default.DEBUG_WEBGL ? "u_pixelRatio":
				"p"), this.a_lastPos = t.getAttribLocation(e, n.
			default.DEBUG_WEBGL ? "a_lastPos":
				"d"), this.a_position = t.getAttribLocation(e, n.
			default.DEBUG_WEBGL ? "a_position":
				"e"), this.a_nextPos = t.getAttribLocation(e, n.
			default.DEBUG_WEBGL ? "a_nextPos":
				"f"), this.a_direction = t.getAttribLocation(e, n.
			default.DEBUG_WEBGL ? "a_direction":
				"g")
			},
			si = function(t, e) {
				De.call(this, t, e), this.defaultLocations_ = null, this.styles_ = [], this.styleIndices_ = [], this.state_ = {
					strokeColor: null,
					lineCap: void 0,
					lineDash: null,
					lineDashOffset: void 0,
					lineJoin: void 0,
					lineWidth: void 0,
					miterLimit: void 0,
					changed: !1
				}
			};
		n.
	default.inherits(si, De), si.prototype.drawCoordinates_ = function(t, e, i, n) {
			var r, o, s, a, l, u, h, c, d = this.vertices.length,
				f = this.indices.length,
				A = "bevel" === this.state_.lineJoin ? 0 : "miter" === this.state_.lineJoin ? 1 : 2,
				p = "butt" === this.state_.lineCap ? 0 : "square" === this.state_.lineCap ? 1 : 2,
				g = ii.lineStringIsClosed(t, e, i, n),
				m = f,
				v = 1;
			for (r = e, o = i; r < o; r += n) {
				if (l = d / 7, u = h, h = c || [t[r], t[r + 1]], r === e) {
					if (c = [t[r + n], t[r + n + 1]], i - e == 2 * n && Z.a.equals(h, c)) break;
					if (!g) {
						p && (d = this.addVertices_([0, 0], h, c, v * si.Instruction_.BEGIN_LINE_CAP * p, d), d = this.addVertices_([0, 0], h, c, -v * si.Instruction_.BEGIN_LINE_CAP * p, d), this.indices[f++] = l + 2, this.indices[f++] = l, this.indices[f++] = l + 1, this.indices[f++] = l + 1, this.indices[f++] = l + 3, this.indices[f++] = l + 2), d = this.addVertices_([0, 0], h, c, v * si.Instruction_.BEGIN_LINE * (p || 1), d), m = (d = this.addVertices_([0, 0], h, c, -v * si.Instruction_.BEGIN_LINE * (p || 1), d)) / 7 - 1;
						continue
					}
					u = [t[i - 2 * n], t[i - 2 * n + 1]], s = c
				} else {
					if (r === i - n) {
						if (g) {
							c = s;
							break
						}
						u = u || [0, 0], d = this.addVertices_(u, h, [0, 0], v * si.Instruction_.END_LINE * (p || 1), d), d = this.addVertices_(u, h, [0, 0], -v * si.Instruction_.END_LINE * (p || 1), d), this.indices[f++] = l, this.indices[f++] = m - 1, this.indices[f++] = m, this.indices[f++] = m, this.indices[f++] = l + 1, this.indices[f++] = l, p && (d = this.addVertices_(u, h, [0, 0], v * si.Instruction_.END_LINE_CAP * p, d), d = this.addVertices_(u, h, [0, 0], -v * si.Instruction_.END_LINE_CAP * p, d), this.indices[f++] = l + 2, this.indices[f++] = l, this.indices[f++] = l + 1, this.indices[f++] = l + 1, this.indices[f++] = l + 3, this.indices[f++] = l + 2);
						break
					}
					c = [t[r + n], t[r + n + 1]]
				}
				a = ke.triangleIsCounterClockwise(u[0], u[1], h[0], h[1], c[0], c[1]) ? -1 : 1, d = this.addVertices_(u, h, c, a * si.Instruction_.BEVEL_FIRST * (A || 1), d), d = this.addVertices_(u, h, c, a * si.Instruction_.BEVEL_SECOND * (A || 1), d), d = this.addVertices_(u, h, c, -a * si.Instruction_.MITER_BOTTOM * (A || 1), d), r > e && (this.indices[f++] = l, this.indices[f++] = m - 1, this.indices[f++] = m, this.indices[f++] = l + 2, this.indices[f++] = l, this.indices[f++] = v * a > 0 ? m : m - 1), this.indices[f++] = l, this.indices[f++] = l + 2, this.indices[f++] = l + 1, m = l + 2, v = a, A && (d = this.addVertices_(u, h, c, a * si.Instruction_.MITER_TOP * A, d), this.indices[f++] = l + 1, this.indices[f++] = l + 3, this.indices[f++] = l)
			}
			g && (l = l || d / 7, a = $e.a.linearRingIsClockwise([u[0], u[1], h[0], h[1], c[0], c[1]], 0, 6, 2) ? 1 : -1, d = this.addVertices_(u, h, c, a * si.Instruction_.BEVEL_FIRST * (A || 1), d), d = this.addVertices_(u, h, c, -a * si.Instruction_.MITER_BOTTOM * (A || 1), d), this.indices[f++] = l, this.indices[f++] = m - 1, this.indices[f++] = m, this.indices[f++] = l + 1, this.indices[f++] = l, this.indices[f++] = v * a > 0 ? m : m - 1)
		}, si.prototype.addVertices_ = function(t, e, i, n, r) {
			return this.vertices[r++] = t[0], this.vertices[r++] = t[1], this.vertices[r++] = e[0], this.vertices[r++] = e[1], this.vertices[r++] = i[0], this.vertices[r++] = i[1], this.vertices[r++] = n, r
		}, si.prototype.isValid_ = function(t, e, i, n) {
			var r = i - e;
			if (r < 2 * n) return !1;
			if (r === 2 * n) {
				var o = [t[e], t[e + 1]],
					s = [t[e + n], t[e + n + 1]];
				return !Z.a.equals(o, s)
			}
			return !0
		}, si.prototype.drawLineString = function(t, e) {
			var i = t.getFlatCoordinates(),
				n = t.getStride();
			this.isValid_(i, 0, i.length, n) && (i = lt.a.translate(i, 0, i.length, n, -this.origin[0], -this.origin[1]), this.state_.changed && (this.styleIndices_.push(this.indices.length), this.state_.changed = !1), this.startIndices.push(this.indices.length), this.startIndicesFeature.push(e), this.drawCoordinates_(i, 0, i.length, n))
		}, si.prototype.drawMultiLineString = function(t, e) {
			var i = this.indices.length,
				n = t.getEnds();
			n.unshift(0);
			var r, o, s = t.getFlatCoordinates(),
				a = t.getStride();
			if (n.length > 1) for (r = 1, o = n.length; r < o; ++r) if (this.isValid_(s, n[r - 1], n[r], a)) {
				var l = lt.a.translate(s, n[r - 1], n[r], a, -this.origin[0], -this.origin[1]);
				this.drawCoordinates_(l, 0, l.length, a)
			}
			this.indices.length > i && (this.startIndices.push(i), this.startIndicesFeature.push(e), this.state_.changed && (this.styleIndices_.push(i), this.state_.changed = !1))
		}, si.prototype.drawPolygonCoordinates = function(t, e, i) {
			var n, r;
			if (ii.lineStringIsClosed(t, 0, t.length, i) || (t.push(t[0]), t.push(t[1])), this.drawCoordinates_(t, 0, t.length, i), e.length) for (n = 0, r = e.length; n < r; ++n) ii.lineStringIsClosed(e[n], 0, e[n].length, i) || (e[n].push(e[n][0]), e[n].push(e[n][1])), this.drawCoordinates_(e[n], 0, e[n].length, i)
		}, si.prototype.setPolygonStyle = function(t, e) {
			var i = void 0 === e ? this.indices.length : e;
			this.startIndices.push(i), this.startIndicesFeature.push(t), this.state_.changed && (this.styleIndices_.push(i), this.state_.changed = !1)
		}, si.prototype.getCurrentIndex = function() {
			return this.indices.length
		}, si.prototype.finish = function(t) {
			this.verticesBuffer = new Be(this.vertices), this.indicesBuffer = new Be(this.indices), this.startIndices.push(this.indices.length), 0 === this.styleIndices_.length && this.styles_.length > 0 && (this.styles_ = []), this.vertices = null, this.indices = null
		}, si.prototype.getDeleteResourcesFunction = function(t) {
			var e = this.verticesBuffer,
				i = this.indicesBuffer;
			return function() {
				t.deleteBuffer(e), t.deleteBuffer(i)
			}
		}, si.prototype.setUpProgram = function(t, e, i, n) {
			var r, o;
			r = ri.fragment, o = ri.vertex;
			var s, a = e.getProgram(r, o);
			return this.defaultLocations_ ? s = this.defaultLocations_ : (s = new oi(t, a), this.defaultLocations_ = s), e.useProgram(a), t.enableVertexAttribArray(s.a_lastPos), t.vertexAttribPointer(s.a_lastPos, 2, Ce.a.FLOAT, !1, 28, 0), t.enableVertexAttribArray(s.a_position), t.vertexAttribPointer(s.a_position, 2, Ce.a.FLOAT, !1, 28, 8), t.enableVertexAttribArray(s.a_nextPos), t.vertexAttribPointer(s.a_nextPos, 2, Ce.a.FLOAT, !1, 28, 16), t.enableVertexAttribArray(s.a_direction), t.vertexAttribPointer(s.a_direction, 1, Ce.a.FLOAT, !1, 28, 24), t.uniform2fv(s.u_size, i), t.uniform1f(s.u_pixelRatio, n), s
		}, si.prototype.shutDownProgram = function(t, e) {
			t.disableVertexAttribArray(e.a_lastPos), t.disableVertexAttribArray(e.a_position), t.disableVertexAttribArray(e.a_nextPos), t.disableVertexAttribArray(e.a_direction)
		}, si.prototype.drawReplay = function(t, e, i, n) {
			var r, o, s, a, l = t.getParameter(t.DEPTH_FUNC),
				u = t.getParameter(t.DEPTH_WRITEMASK);
			if (n || (t.enable(t.DEPTH_TEST), t.depthMask(!0), t.depthFunc(t.NOTEQUAL)), V.a.isEmpty(i)) for (s = this.startIndices[this.startIndices.length - 1], r = this.styleIndices_.length - 1; r >= 0; --r) o = this.styleIndices_[r], a = this.styles_[r], this.setStrokeStyle_(t, a[0], a[1], a[2]), this.drawElements(t, e, o, s), t.clear(t.DEPTH_BUFFER_BIT), s = o;
			else this.drawReplaySkipping_(t, e, i);
			n || (t.disable(t.DEPTH_TEST), t.clear(t.DEPTH_BUFFER_BIT), t.depthMask(u), t.depthFunc(l))
		}, si.prototype.drawReplaySkipping_ = function(t, e, i) {
			var r, o, s, a, l, u, h, c;
			for (h = this.startIndices.length - 2, s = o = this.startIndices[h + 1], r = this.styleIndices_.length - 1; r >= 0; --r) {
				for (a = this.styles_[r], this.setStrokeStyle_(t, a[0], a[1], a[2]), l = this.styleIndices_[r]; h >= 0 && this.startIndices[h] >= l;) c = this.startIndices[h], u = this.startIndicesFeature[h], i[n.
			default.getUid(u).toString()] && (o !== s && (this.drawElements(t, e, o, s), t.clear(t.DEPTH_BUFFER_BIT)), s = c), h--, o = c;
				o !== s && (this.drawElements(t, e, o, s), t.clear(t.DEPTH_BUFFER_BIT)), o = s = l
			}
		}, si.prototype.drawHitDetectionReplayOneByOne = function(t, e, i, r, o) {
			var s, a, l, u, h, c, d;
			for (d = this.startIndices.length - 2, l = this.startIndices[d + 1], s = this.styleIndices_.length - 1; s >= 0; --s) for (u = this.styles_[s], this.setStrokeStyle_(t, u[0], u[1], u[2]), h = this.styleIndices_[s]; d >= 0 && this.startIndices[d] >= h;) {
				if (a = this.startIndices[d], c = this.startIndicesFeature[d], void 0 === i[n.
			default.getUid(c).toString()] && c.getGeometry() && (void 0 === o || K.
			default.intersects(o, c.getGeometry().getExtent()))) {
					t.clear(t.COLOR_BUFFER_BIT | t.DEPTH_BUFFER_BIT), this.drawElements(t, e, a, l);
					var f = r(c);
					if (f) return f
				}
				d--, l = a
			}
		}, si.prototype.setStrokeStyle_ = function(t, e, i, n) {
			t.uniform4fv(this.defaultLocations_.u_color, e), t.uniform1f(this.defaultLocations_.u_lineWidth, i), t.uniform1f(this.defaultLocations_.u_miterLimit, n)
		}, si.prototype.setFillStrokeStyle = function(t, e) {
			var i = e.getLineCap();
			this.state_.lineCap = void 0 !== i ? i : ke.defaultLineCap;
			var n = e.getLineDash();
			this.state_.lineDash = n || ke.defaultLineDash;
			var r = e.getLineDashOffset();
			this.state_.lineDashOffset = r || ke.defaultLineDashOffset;
			var o = e.getLineJoin();
			this.state_.lineJoin = void 0 !== o ? o : ke.defaultLineJoin;
			var s = e.getColor();
			s = s instanceof CanvasGradient || s instanceof CanvasPattern ? ke.defaultStrokeStyle : ne.a.asArray(s).map((function(t, e) {
				return 3 != e ? t / 255 : t
			})) || ke.defaultStrokeStyle;
			var a = e.getWidth();
			a = void 0 !== a ? a : ke.defaultLineWidth;
			var l = e.getMiterLimit();
			l = void 0 !== l ? l : ke.defaultMiterLimit, this.state_.strokeColor && Z.a.equals(this.state_.strokeColor, s) && this.state_.lineWidth === a && this.state_.miterLimit === l || (this.state_.changed = !0, this.state_.strokeColor = s, this.state_.lineWidth = a, this.state_.miterLimit = l, this.styles_.push([s, a, l]))
		}, si.Instruction_ = {
			ROUND: 2,
			BEGIN_LINE: 3,
			END_LINE: 5,
			BEGIN_LINE_CAP: 7,
			END_LINE_CAP: 11,
			BEVEL_FIRST: 13,
			BEVEL_SECOND: 17,
			MITER_BOTTOM: 19,
			MITER_TOP: 23
		};
		var ai = si,
			li = i(72),
			ui = {};
		ui.fragment = new Re(n.
	default.DEBUG_WEBGL ? "precision mediump float;\n\n\n\nuniform vec4 u_color;\nuniform float u_opacity;\n\nvoid main(void) {\n  gl_FragColor = u_color;\n  float alpha = u_color.a * u_opacity;\n  if (alpha == 0.0) {\n    discard;\n  }\n  gl_FragColor.a = alpha;\n}\n":
		"precision mediump float;uniform vec4 e;uniform float f;void main(void){gl_FragColor=e;float alpha=e.a*f;if(alpha==0.0){discard;}gl_FragColor.a=alpha;}"), ui.vertex = new Le(n.
	default.DEBUG_WEBGL ? "\n\nattribute vec2 a_position;\n\nuniform mat4 u_projectionMatrix;\nuniform mat4 u_offsetScaleMatrix;\nuniform mat4 u_offsetRotateMatrix;\n\nvoid main(void) {\n  gl_Position = u_projectionMatrix * vec4(a_position, 0.0, 1.0);\n}\n\n\n":
		"attribute vec2 a;uniform mat4 b;uniform mat4 c;uniform mat4 d;void main(void){gl_Position=b*vec4(a,0.0,1.0);}");
		var hi = ui,
			ci = function(t, e) {
				this.u_projectionMatrix = t.getUniformLocation(e, n.
			default.DEBUG_WEBGL ? "u_projectionMatrix":
				"b"), this.u_offsetScaleMatrix = t.getUniformLocation(e, n.
			default.DEBUG_WEBGL ? "u_offsetScaleMatrix":
				"c"), this.u_offsetRotateMatrix = t.getUniformLocation(e, n.
			default.DEBUG_WEBGL ? "u_offsetRotateMatrix":
				"d"), this.u_color = t.getUniformLocation(e, n.
			default.DEBUG_WEBGL ? "u_color":
				"e"), this.u_opacity = t.getUniformLocation(e, n.
			default.DEBUG_WEBGL ? "u_opacity":
				"f"), this.a_position = t.getAttribLocation(e, n.
			default.DEBUG_WEBGL ? "a_position":
				"a")
			},
			di = i(36),
			fi = function(t) {
				this.first_ = void 0, this.last_ = void 0, this.head_ = void 0, this.circular_ = void 0 === t || t, this.length_ = 0
			};
		fi.prototype.insertItem = function(t) {
			var e = {
				prev: void 0,
				next: void 0,
				data: t
			},
				i = this.head_;
			if (i) {
				var n = i.next;
				e.prev = i, e.next = n, i.next = e, n && (n.prev = e), i === this.last_ && (this.last_ = e)
			} else this.first_ = e, this.last_ = e, this.circular_ && (e.next = e, e.prev = e);
			this.head_ = e, this.length_++
		}, fi.prototype.removeItem = function() {
			var t = this.head_;
			if (t) {
				var e = t.next,
					i = t.prev;
				e && (e.prev = i), i && (i.next = e), this.head_ = e || i, this.first_ === this.last_ ? (this.head_ = void 0, this.first_ = void 0, this.last_ = void 0) : this.first_ === t ? this.first_ = this.head_ : this.last_ === t && (this.last_ = i ? this.head_.prev : this.head_), this.length_--
			}
		}, fi.prototype.firstItem = function() {
			if (this.head_ = this.first_, this.head_) return this.head_.data
		}, fi.prototype.lastItem = function() {
			if (this.head_ = this.last_, this.head_) return this.head_.data
		}, fi.prototype.nextItem = function() {
			if (this.head_ && this.head_.next) return this.head_ = this.head_.next, this.head_.data
		}, fi.prototype.getNextItem = function() {
			if (this.head_ && this.head_.next) return this.head_.next.data
		}, fi.prototype.prevItem = function() {
			if (this.head_ && this.head_.prev) return this.head_ = this.head_.prev, this.head_.data
		}, fi.prototype.getPrevItem = function() {
			if (this.head_ && this.head_.prev) return this.head_.prev.data
		}, fi.prototype.getCurrItem = function() {
			if (this.head_) return this.head_.data
		}, fi.prototype.setFirstItem = function() {
			this.circular_ && this.head_ && (this.first_ = this.head_, this.last_ = this.head_.prev)
		}, fi.prototype.concat = function(t) {
			if (t.head_) {
				if (this.head_) {
					var e = this.head_.next;
					this.head_.next = t.first_, t.first_.prev = this.head_, e.prev = t.last_, t.last_.next = e, this.length_ += t.length_
				} else this.head_ = t.head_, this.first_ = t.first_, this.last_ = t.last_, this.length_ = t.length_;
				t.head_ = void 0, t.first_ = void 0, t.last_ = void 0, t.length_ = 0
			}
		}, fi.prototype.getLength = function() {
			return this.length_
		};
		var Ai = fi,
			pi = i(84),
			gi = function(t, e) {
				De.call(this, t, e), this.lineStringReplay = new ai(t, e), this.defaultLocations_ = null, this.styles_ = [], this.styleIndices_ = [], this.state_ = {
					fillColor: null,
					changed: !1
				}
			};
		n.
	default.inherits(gi, De), gi.prototype.drawCoordinates_ = function(t, e, i) {
			var n = new Ai,
				r = new pi.a;
			this.processFlatCoordinates_(t, i, n, r, !0);
			var o = this.getMaxCoords_(n);
			if (e.length) {
				var s, a, l = [];
				for (s = 0, a = e.length; s < a; ++s) {
					var u = {
						list: new Ai,
						maxCoords: void 0,
						rtree: new pi.a
					};
					l.push(u), this.processFlatCoordinates_(e[s], i, u.list, u.rtree, !1), this.classifyPoints_(u.list, u.rtree, !0), u.maxCoords = this.getMaxCoords_(u.list)
				}
				for (l.sort((function(t, e) {
					return e.maxCoords[0] === t.maxCoords[0] ? t.maxCoords[1] - e.maxCoords[1] : e.maxCoords[0] - t.maxCoords[0]
				})), s = 0; s < l.length; ++s) {
					var h, c = l[s].list,
						d = c.firstItem(),
						f = d;
					do {
						if (this.getIntersections_(f, r).length) {
							h = !0;
							break
						}
						f = c.nextItem()
					} while (d !== f);
					h || this.bridgeHole_(c, l[s].maxCoords[0], n, o[0], r) && (r.concat(l[s].rtree), this.classifyPoints_(n, r, !1))
				}
			} else this.classifyPoints_(n, r, !1);
			this.triangulate_(n, r)
		}, gi.prototype.processFlatCoordinates_ = function(t, e, i, n, r) {
			var o, s, a, l, u, h = $e.a.linearRingIsClockwise(t, 0, t.length, e),
				c = this.vertices.length / 2,
				d = [],
				f = [];
			if (r === h) {
				for (l = a = this.createPoint_(t[0], t[1], c++), o = e, s = t.length; o < s; o += e) u = this.createPoint_(t[o], t[o + 1], c++), f.push(this.insertItem_(l, u, i)), d.push([Math.min(l.x, u.x), Math.min(l.y, u.y), Math.max(l.x, u.x), Math.max(l.y, u.y)]), l = u;
				f.push(this.insertItem_(u, a, i)), d.push([Math.min(l.x, u.x), Math.min(l.y, u.y), Math.max(l.x, u.x), Math.max(l.y, u.y)])
			} else {
				var A = t.length - e;
				for (l = a = this.createPoint_(t[A], t[A + 1], c++), o = A - e, s = 0; o >= s; o -= e) u = this.createPoint_(t[o], t[o + 1], c++), f.push(this.insertItem_(l, u, i)), d.push([Math.min(l.x, u.x), Math.min(l.y, u.y), Math.max(l.x, u.x), Math.max(l.y, u.y)]), l = u;
				f.push(this.insertItem_(u, a, i)), d.push([Math.min(l.x, u.x), Math.min(l.y, u.y), Math.max(l.x, u.x), Math.max(l.y, u.y)])
			}
			n.load(d, f)
		}, gi.prototype.getMaxCoords_ = function(t) {
			var e = t.firstItem(),
				i = e,
				n = [i.p0.x, i.p0.y];
			do {
				(i = t.nextItem()).p0.x > n[0] && (n = [i.p0.x, i.p0.y])
			} while (i !== e);
			return n
		}, gi.prototype.classifyPoints_ = function(t, e, i) {
			var n = t.firstItem(),
				r = n,
				o = t.nextItem(),
				s = !1;
			do {
				var a = i ? ke.triangleIsCounterClockwise(o.p1.x, o.p1.y, r.p1.x, r.p1.y, r.p0.x, r.p0.y) : ke.triangleIsCounterClockwise(r.p0.x, r.p0.y, r.p1.x, r.p1.y, o.p1.x, o.p1.y);
				void 0 === a ? (this.removeItem_(r, o, t, e), s = !0, o === n && (n = t.getNextItem()), o = r, t.prevItem()) : r.p1.reflex !== a && (r.p1.reflex = a, s = !0), r = o, o = t.nextItem()
			} while (r !== n);
			return s
		}, gi.prototype.bridgeHole_ = function(t, e, i, n, r) {
			for (var o = t.firstItem(); o.p1.x !== e;) o = t.nextItem();
			var s, a, l, u, h = o.p1,
				c = {
					x: n,
					y: h.y,
					i: -1
				},
				d = 1 / 0,
				f = this.getIntersections_({
					p0: h,
					p1: c
				}, r, !0);
			for (s = 0, a = f.length; s < a; ++s) {
				var A = f[s],
					p = this.calculateIntersection_(h, c, A.p0, A.p1, !0),
					g = Math.abs(h.x - p[0]);
				g < d && void 0 !== ke.triangleIsCounterClockwise(h.x, h.y, A.p0.x, A.p0.y, A.p1.x, A.p1.y) && (d = g, u = {
					x: p[0],
					y: p[1],
					i: -1
				}, o = A)
			}
			if (d === 1 / 0) return !1;
			if (l = o.p1, d > 0) {
				var m = this.getPointsInTriangle_(h, u, o.p1, r);
				if (m.length) {
					var v = 1 / 0;
					for (s = 0, a = m.length; s < a; ++s) {
						var y = m[s],
							_ = Math.atan2(h.y - y.y, c.x - y.x);
						(_ < v || _ === v && y.x < l.x) && (v = _, l = y)
					}
				}
			}
			for (o = i.firstItem(); o.p1.x !== l.x || o.p1.y !== l.y;) o = i.nextItem();
			var E = {
				x: h.x,
				y: h.y,
				i: h.i,
				reflex: void 0
			},
				x = {
					x: o.p1.x,
					y: o.p1.y,
					i: o.p1.i,
					reflex: void 0
				};
			return t.getNextItem().p0 = E, this.insertItem_(h, o.p1, t, r), this.insertItem_(x, E, t, r), o.p1 = x, t.setFirstItem(), i.concat(t), !0
		}, gi.prototype.triangulate_ = function(t, e) {
			for (var i = !1, n = this.isSimple_(t, e); t.getLength() > 3;) if (n) {
				if (!this.clipEars_(t, e, n, i) && !this.classifyPoints_(t, e, i) && !this.resolveSelfIntersections_(t, e, !0)) break
			} else if (!this.clipEars_(t, e, n, i) && !this.classifyPoints_(t, e, i) && !this.resolveSelfIntersections_(t, e)) {
				if (!(n = this.isSimple_(t, e))) {
					this.splitPolygon_(t, e);
					break
				}
				i = !this.isClockwise_(t), this.classifyPoints_(t, e, i)
			}
			if (3 === t.getLength()) {
				var r = this.indices.length;
				this.indices[r++] = t.getPrevItem().p0.i, this.indices[r++] = t.getCurrItem().p0.i, this.indices[r++] = t.getNextItem().p0.i
			}
		}, gi.prototype.clipEars_ = function(t, e, i, n) {
			var r, o, s, a = this.indices.length,
				l = t.firstItem(),
				u = t.getPrevItem(),
				h = l,
				c = t.nextItem(),
				d = t.getNextItem(),
				f = !1;
			do {
				var A;
				if (r = h.p0, o = h.p1, s = c.p1, !1 === o.reflex) A = i ? 0 === this.getPointsInTriangle_(r, o, s, e, !0).length : n ? this.diagonalIsInside_(d.p1, s, o, r, u.p0) : this.diagonalIsInside_(u.p0, r, o, s, d.p1), (i || 0 === this.getIntersections_({
					p0: r,
					p1: s
				}, e).length) && A && (i || !1 === r.reflex || !1 === s.reflex || $e.a.linearRingIsClockwise([u.p0.x, u.p0.y, r.x, r.y, o.x, o.y, s.x, s.y, d.p1.x, d.p1.y], 0, 10, 2) === !n) && (this.indices[a++] = r.i, this.indices[a++] = o.i, this.indices[a++] = s.i, this.removeItem_(h, c, t, e), c === l && (l = d), f = !0);
				u = t.getPrevItem(), h = t.getCurrItem(), c = t.nextItem(), d = t.getNextItem()
			} while (h !== l && t.getLength() > 3);
			return f
		}, gi.prototype.resolveSelfIntersections_ = function(t, e, i) {
			var n = t.firstItem();
			t.nextItem();
			var r = n,
				o = t.nextItem(),
				s = !1;
			do {
				var a = this.calculateIntersection_(r.p0, r.p1, o.p0, o.p1, i);
				if (a) {
					var l, u = !1,
						h = this.vertices.length,
						c = this.indices.length,
						d = h / 2,
						f = t.prevItem();
					if (t.removeItem(), e.remove(f), u = f === n, i ? (a[0] === r.p0.x && a[1] === r.p0.y ? (t.prevItem(), l = r.p0, o.p0 = l, e.remove(r), u = u || r === n) : (l = o.p1, r.p1 = l, e.remove(o), u = u || o === n), t.removeItem()) : (l = this.createPoint_(a[0], a[1], d), r.p1 = l, o.p0 = l, e.update([Math.min(r.p0.x, r.p1.x), Math.min(r.p0.y, r.p1.y), Math.max(r.p0.x, r.p1.x), Math.max(r.p0.y, r.p1.y)], r), e.update([Math.min(o.p0.x, o.p1.x), Math.min(o.p0.y, o.p1.y), Math.max(o.p0.x, o.p1.x), Math.max(o.p0.y, o.p1.y)], o)), this.indices[c++] = f.p0.i, this.indices[c++] = f.p1.i, this.indices[c++] = l.i, s = !0, u) break
				}
				r = t.getPrevItem(), o = t.nextItem()
			} while (r !== n);
			return s
		}, gi.prototype.isSimple_ = function(t, e) {
			var i = t.firstItem(),
				n = i;
			do {
				if (this.getIntersections_(n, e).length) return !1;
				n = t.nextItem()
			} while (n !== i);
			return !0
		}, gi.prototype.isClockwise_ = function(t) {
			var e = 2 * t.getLength(),
				i = new Array(e),
				n = t.firstItem(),
				r = n,
				o = 0;
			do {
				i[o++] = r.p0.x, i[o++] = r.p0.y, r = t.nextItem()
			} while (r !== n);
			return $e.a.linearRingIsClockwise(i, 0, e, 2)
		}, gi.prototype.splitPolygon_ = function(t, e) {
			var i = t.firstItem(),
				n = i;
			do {
				var r = this.getIntersections_(n, e);
				if (r.length) {
					var o = r[0],
						s = this.vertices.length / 2,
						a = this.calculateIntersection_(n.p0, n.p1, o.p0, o.p1),
						l = this.createPoint_(a[0], a[1], s),
						u = new Ai,
						h = new pi.a;
					this.insertItem_(l, n.p1, u, h), n.p1 = l, e.update([Math.min(n.p0.x, l.x), Math.min(n.p0.y, l.y), Math.max(n.p0.x, l.x), Math.max(n.p0.y, l.y)], n);
					for (var c = t.nextItem(); c !== o;) this.insertItem_(c.p0, c.p1, u, h), e.remove(c), t.removeItem(), c = t.getCurrItem();
					this.insertItem_(o.p0, l, u, h), o.p0 = l, e.update([Math.min(o.p1.x, l.x), Math.min(o.p1.y, l.y), Math.max(o.p1.x, l.x), Math.max(o.p1.y, l.y)], o), this.classifyPoints_(t, e, !1), this.triangulate_(t, e), this.classifyPoints_(u, h, !1), this.triangulate_(u, h);
					break
				}
				n = t.nextItem()
			} while (n !== i)
		}, gi.prototype.createPoint_ = function(t, e, i) {
			var n = this.vertices.length;
			return this.vertices[n++] = t, this.vertices[n++] = e, {
				x: t,
				y: e,
				i: i,
				reflex: void 0
			}
		}, gi.prototype.insertItem_ = function(t, e, i, n) {
			var r = {
				p0: t,
				p1: e
			};
			return i.insertItem(r), n && n.insert([Math.min(t.x, e.x), Math.min(t.y, e.y), Math.max(t.x, e.x), Math.max(t.y, e.y)], r), r
		}, gi.prototype.removeItem_ = function(t, e, i, n) {
			i.getCurrItem() === e && (i.removeItem(), t.p1 = e.p1, n.remove(e), n.update([Math.min(t.p0.x, t.p1.x), Math.min(t.p0.y, t.p1.y), Math.max(t.p0.x, t.p1.x), Math.max(t.p0.y, t.p1.y)], t))
		}, gi.prototype.getPointsInTriangle_ = function(t, e, i, n, r) {
			var o, s, a, l, u = [],
				h = n.getInExtent([Math.min(t.x, e.x, i.x), Math.min(t.y, e.y, i.y), Math.max(t.x, e.x, i.x), Math.max(t.y, e.y, i.y)]);
			for (o = 0, s = h.length; o < s; ++o) for (a in h[o])"object" != typeof(l = h[o][a]) || r && !l.reflex || l.x === t.x && l.y === t.y || l.x === e.x && l.y === e.y || l.x === i.x && l.y === i.y || -1 !== u.indexOf(l) || !li.a.linearRingContainsXY([t.x, t.y, e.x, e.y, i.x, i.y], 0, 6, 2, l.x, l.y) || u.push(l);
			return u
		}, gi.prototype.getIntersections_ = function(t, e, i) {
			var n, r, o = t.p0,
				s = t.p1,
				a = e.getInExtent([Math.min(o.x, s.x), Math.min(o.y, s.y), Math.max(o.x, s.x), Math.max(o.y, s.y)]),
				l = [];
			for (n = 0, r = a.length; n < r; ++n) {
				var u = a[n];
				t !== u && (i || u.p0 !== s || u.p1 !== o) && this.calculateIntersection_(o, s, u.p0, u.p1, i) && l.push(u)
			}
			return l
		}, gi.prototype.calculateIntersection_ = function(t, e, i, n, r) {
			var o = (n.y - i.y) * (e.x - t.x) - (n.x - i.x) * (e.y - t.y);
			if (0 !== o) {
				var s = ((n.x - i.x) * (t.y - i.y) - (n.y - i.y) * (t.x - i.x)) / o,
					a = ((e.x - t.x) * (t.y - i.y) - (e.y - t.y) * (t.x - i.x)) / o;
				if (!r && s > ke.EPSILON && s < 1 - ke.EPSILON && a > ke.EPSILON && a < 1 - ke.EPSILON || r && s >= 0 && s <= 1 && a >= 0 && a <= 1) return [t.x + s * (e.x - t.x), t.y + s * (e.y - t.y)]
			}
		}, gi.prototype.diagonalIsInside_ = function(t, e, i, n, r) {
			if (void 0 === e.reflex || void 0 === n.reflex) return !1;
			var o = (i.x - n.x) * (e.y - n.y) > (i.y - n.y) * (e.x - n.x),
				s = (r.x - n.x) * (e.y - n.y) < (r.y - n.y) * (e.x - n.x),
				a = (t.x - e.x) * (n.y - e.y) > (t.y - e.y) * (n.x - e.x),
				l = (i.x - e.x) * (n.y - e.y) < (i.y - e.y) * (n.x - e.x),
				u = n.reflex ? s || o : s && o,
				h = e.reflex ? l || a : l && a;
			return u && h
		}, gi.prototype.drawMultiPolygon = function(t, e) {
			var i, n, r, o, s = t.getEndss(),
				a = t.getStride(),
				l = this.indices.length,
				u = this.lineStringReplay.getCurrentIndex(),
				h = t.getFlatCoordinates(),
				c = 0;
			for (i = 0, n = s.length; i < n; ++i) {
				var d = s[i];
				if (d.length > 0) {
					var f = lt.a.translate(h, c, d[0], a, -this.origin[0], -this.origin[1]);
					if (f.length) {
						var A, p = [];
						for (r = 1, o = d.length; r < o; ++r) d[r] !== d[r - 1] && (A = lt.a.translate(h, d[r - 1], d[r], a, -this.origin[0], -this.origin[1]), p.push(A));
						this.lineStringReplay.drawPolygonCoordinates(f, p, a), this.drawCoordinates_(f, p, a)
					}
				}
				c = d[d.length - 1]
			}
			this.indices.length > l && (this.startIndices.push(l), this.startIndicesFeature.push(e), this.state_.changed && (this.styleIndices_.push(l), this.state_.changed = !1)), this.lineStringReplay.getCurrentIndex() > u && this.lineStringReplay.setPolygonStyle(e, u)
		}, gi.prototype.drawPolygon = function(t, e) {
			var i = t.getEnds(),
				n = t.getStride();
			if (i.length > 0) {
				var r = t.getFlatCoordinates().map(Number),
					o = lt.a.translate(r, 0, i[0], n, -this.origin[0], -this.origin[1]);
				if (o.length) {
					var s, a, l, u = [];
					for (s = 1, a = i.length; s < a; ++s) i[s] !== i[s - 1] && (l = lt.a.translate(r, i[s - 1], i[s], n, -this.origin[0], -this.origin[1]), u.push(l));
					this.startIndices.push(this.indices.length), this.startIndicesFeature.push(e), this.state_.changed && (this.styleIndices_.push(this.indices.length), this.state_.changed = !1), this.lineStringReplay.setPolygonStyle(e), this.lineStringReplay.drawPolygonCoordinates(o, u, n), this.drawCoordinates_(o, u, n)
				}
			}
		}, gi.prototype.finish = function(t) {
			this.verticesBuffer = new Be(this.vertices), this.indicesBuffer = new Be(this.indices), this.startIndices.push(this.indices.length), this.lineStringReplay.finish(t), 0 === this.styleIndices_.length && this.styles_.length > 0 && (this.styles_ = []), this.vertices = null, this.indices = null
		}, gi.prototype.getDeleteResourcesFunction = function(t) {
			var e = this.verticesBuffer,
				i = this.indicesBuffer,
				n = this.lineStringReplay.getDeleteResourcesFunction(t);
			return function() {
				t.deleteBuffer(e), t.deleteBuffer(i), n()
			}
		}, gi.prototype.setUpProgram = function(t, e, i, n) {
			var r, o;
			r = hi.fragment, o = hi.vertex;
			var s, a = e.getProgram(r, o);
			return this.defaultLocations_ ? s = this.defaultLocations_ : (s = new ci(t, a), this.defaultLocations_ = s), e.useProgram(a), t.enableVertexAttribArray(s.a_position), t.vertexAttribPointer(s.a_position, 2, Ce.a.FLOAT, !1, 8, 0), s
		}, gi.prototype.shutDownProgram = function(t, e) {
			t.disableVertexAttribArray(e.a_position)
		}, gi.prototype.drawReplay = function(t, e, i, n) {
			var r, o, s, a, l = t.getParameter(t.DEPTH_FUNC),
				u = t.getParameter(t.DEPTH_WRITEMASK);
			if (n || (t.enable(t.DEPTH_TEST), t.depthMask(!0), t.depthFunc(t.NOTEQUAL)), V.a.isEmpty(i)) for (s = this.startIndices[this.startIndices.length - 1], r = this.styleIndices_.length - 1; r >= 0; --r) o = this.styleIndices_[r], a = this.styles_[r], this.setFillStyle_(t, a), this.drawElements(t, e, o, s), s = o;
			else this.drawReplaySkipping_(t, e, i);
			n || (t.disable(t.DEPTH_TEST), t.clear(t.DEPTH_BUFFER_BIT), t.depthMask(u), t.depthFunc(l))
		}, gi.prototype.drawHitDetectionReplayOneByOne = function(t, e, i, r, o) {
			var s, a, l, u, h, c, d;
			for (d = this.startIndices.length - 2, l = this.startIndices[d + 1], s = this.styleIndices_.length - 1; s >= 0; --s) for (u = this.styles_[s], this.setFillStyle_(t, u), h = this.styleIndices_[s]; d >= 0 && this.startIndices[d] >= h;) {
				if (a = this.startIndices[d], c = this.startIndicesFeature[d], void 0 === i[n.
			default.getUid(c).toString()] && c.getGeometry() && (void 0 === o || K.
			default.intersects(o, c.getGeometry().getExtent()))) {
					t.clear(t.COLOR_BUFFER_BIT | t.DEPTH_BUFFER_BIT), this.drawElements(t, e, a, l);
					var f = r(c);
					if (f) return f
				}
				d--, l = a
			}
		}, gi.prototype.drawReplaySkipping_ = function(t, e, i) {
			var r, o, s, a, l, u, h, c;
			for (h = this.startIndices.length - 2, s = o = this.startIndices[h + 1], r = this.styleIndices_.length - 1; r >= 0; --r) {
				for (a = this.styles_[r], this.setFillStyle_(t, a), l = this.styleIndices_[r]; h >= 0 && this.startIndices[h] >= l;) c = this.startIndices[h], u = this.startIndicesFeature[h], i[n.
			default.getUid(u).toString()] && (o !== s && (this.drawElements(t, e, o, s), t.clear(t.DEPTH_BUFFER_BIT)), s = c), h--, o = c;
				o !== s && (this.drawElements(t, e, o, s), t.clear(t.DEPTH_BUFFER_BIT)), o = s = l
			}
		}, gi.prototype.setFillStyle_ = function(t, e) {
			t.uniform4fv(this.defaultLocations_.u_color, e)
		}, gi.prototype.setFillStrokeStyle = function(t, e) {
			var i = t ? t.getColor() : [0, 0, 0, 0];
			if (i = i instanceof CanvasGradient || i instanceof CanvasPattern ? ke.defaultFillStyle : ne.a.asArray(i).map((function(t, e) {
				return 3 != e ? t / 255 : t
			})) || ke.defaultFillStyle, this.state_.fillColor && Z.a.equals(i, this.state_.fillColor) || (this.state_.fillColor = i, this.state_.changed = !0, this.styles_.push(i)), e) this.lineStringReplay.setFillStrokeStyle(null, e);
			else {
				var n = new di.
			default ({
					color: [0, 0, 0, 0],
					lineWidth: 0
				});
				this.lineStringReplay.setFillStrokeStyle(null, n)
			}
		};
		var mi = gi,
			vi = function(t, e) {
				this.space_ = e, this.emptyBlocks_ = [{
					x: 0,
					y: 0,
					width: t,
					height: t
				}], this.entries_ = {}, this.context_ = $.a.createCanvasContext2D(t, t), this.canvas_ = this.context_.canvas
			};
		vi.prototype.get = function(t) {
			return this.entries_[t] || null
		}, vi.prototype.add = function(t, e, i, n, r) {
			var o, s, a;
			for (s = 0, a = this.emptyBlocks_.length; s < a; ++s) if ((o = this.emptyBlocks_[s]).width >= e + this.space_ && o.height >= i + this.space_) {
				var l = {
					offsetX: o.x + this.space_,
					offsetY: o.y + this.space_,
					image: this.canvas_
				};
				return this.entries_[t] = l, n.call(r, this.context_, o.x + this.space_, o.y + this.space_), this.split_(s, o, e + this.space_, i + this.space_), l
			}
			return null
		}, vi.prototype.split_ = function(t, e, i, n) {
			var r, o;
			e.width - i > e.height - n ? (r = {
				x: e.x + i,
				y: e.y,
				width: e.width - i,
				height: e.height
			}, o = {
				x: e.x,
				y: e.y + n,
				width: i,
				height: e.height - n
			}, this.updateBlocks_(t, r, o)) : (r = {
				x: e.x + i,
				y: e.y,
				width: e.width - i,
				height: n
			}, o = {
				x: e.x,
				y: e.y + n,
				width: e.width,
				height: e.height - n
			}, this.updateBlocks_(t, r, o))
		}, vi.prototype.updateBlocks_ = function(t, e, i) {
			var n = [t, 1];
			e.width > 0 && e.height > 0 && n.push(e), i.width > 0 && i.height > 0 && n.push(i), this.emptyBlocks_.splice.apply(this.emptyBlocks_, n)
		};
		var yi = vi,
			_i = function(t) {
				var e = t || {};
				this.currentSize_ = void 0 !== e.initialSize ? e.initialSize : n.
			default.INITIAL_ATLAS_SIZE, this.maxSize_ = void 0 !== e.maxSize ? e.maxSize:
				-1 != n.
			default.MAX_ATLAS_SIZE ? n.
			default.MAX_ATLAS_SIZE:
				void 0 !== n.
			default.WEBGL_MAX_TEXTURE_SIZE ? n.
			default.WEBGL_MAX_TEXTURE_SIZE:
				2048, this.space_ = void 0 !== e.space ? e.space : 1, this.atlases_ = [new yi(this.currentSize_, this.space_)], this.currentHitSize_ = this.currentSize_, this.hitAtlases_ = [new yi(this.currentHitSize_, this.space_)]
			};
		_i.prototype.getInfo = function(t) {
			var e = this.getInfo_(this.atlases_, t);
			if (!e) return null;
			var i = this.getInfo_(this.hitAtlases_, t);
			return this.mergeInfos_(e, i)
		}, _i.prototype.getInfo_ = function(t, e) {
			var i, n, r;
			for (n = 0, r = t.length; n < r; ++n) if (i = t[n].get(e)) return i;
			return null
		}, _i.prototype.mergeInfos_ = function(t, e) {
			return {
				offsetX: t.offsetX,
				offsetY: t.offsetY,
				image: t.image,
				hitImage: e.image
			}
		}, _i.prototype.add = function(t, e, i, r, o, s) {
			if (e + this.space_ > this.maxSize_ || i + this.space_ > this.maxSize_) return null;
			var a = this.add_(!1, t, e, i, r, s);
			if (!a) return null;
			var l = void 0 !== o ? o : n.
		default.nullFunction,
				u = this.add_(!0, t, e, i, l, s);
			return this.mergeInfos_(a, u)
		}, _i.prototype.add_ = function(t, e, i, n, r, o) {
			var s, a, l, u, h = t ? this.hitAtlases_ : this.atlases_;
			for (l = 0, u = h.length; l < u; ++l) {
				if (a = (s = h[l]).add(e, i, n, r, o)) return a;
				var c;
				a || l !== u - 1 || (t ? (c = Math.min(2 * this.currentHitSize_, this.maxSize_), this.currentHitSize_ = c) : (c = Math.min(2 * this.currentSize_, this.maxSize_), this.currentSize_ = c), s = new yi(c, this.space_), h.push(s), ++u)
			}
			return null
		};
		var Ei = _i,
			xi = function(t, e) {
				Ke.call(this, t, e), this.images_ = [], this.textures_ = [], this.measureCanvas_ = $.a.createCanvasContext2D(0, 0).canvas, this.state_ = {
					strokeColor: null,
					lineCap: void 0,
					lineDash: null,
					lineDashOffset: void 0,
					lineJoin: void 0,
					lineWidth: 0,
					miterLimit: void 0,
					fillColor: null,
					font: void 0,
					scale: void 0
				}, this.text_ = "", this.textAlign_ = void 0, this.textBaseline_ = void 0, this.offsetX_ = void 0, this.offsetY_ = void 0, this.atlases_ = {}, this.currAtlas_ = void 0, this.scale = 1, this.opacity = 1
			};
		n.
	default.inherits(xi, Ke), xi.prototype.drawText = function(t, e) {
			if (this.text_) {
				var i = null,
					r = 2,
					o = 2;
				switch (t.getType()) {
				case st.a.POINT:
				case st.a.MULTI_POINT:
					r = (i = t.getFlatCoordinates()).length, o = t.getStride();
					break;
				case st.a.CIRCLE:
					i = t.getCenter();
					break;
				case st.a.LINE_STRING:
					i = t.getFlatMidpoint();
					break;
				case st.a.MULTI_LINE_STRING:
					r = (i = t.getFlatMidpoints()).length;
					break;
				case st.a.POLYGON:
					i = t.getFlatInteriorPoint();
					break;
				case st.a.MULTI_POLYGON:
					r = (i = t.getFlatInteriorPoints()).length
				}
				this.startIndices.push(this.indices.length), this.startIndicesFeature.push(e);
				var s, a, l, u, h, c, d, f, A = this.currAtlas_,
					p = this.text_.split("\n"),
					g = this.getTextSize_(p),
					m = Math.round(g[0] * this.textAlign_ - this.offsetX_),
					v = Math.round(g[1] * this.textBaseline_ - this.offsetY_),
					y = this.state_.lineWidth / 2 * this.state_.scale;
				for (s = 0, a = p.length; s < a; ++s) for (h = 0, c = A.height * s, l = 0, u = (d = p[s].split("")).length; l < u; ++l) {
					if (f = A.atlas.getInfo(d[l])) {
						var _, E = f.image;
						this.anchorX = m - h, this.anchorY = v - c, this.originX = 0 === l ? f.offsetX - y : f.offsetX, this.originY = f.offsetY, this.height = A.height, this.width = 0 === l || l === d.length - 1 ? A.width[d[l]] + y : A.width[d[l]], this.imageHeight = E.height, this.imageWidth = E.width, 0 === this.images_.length ? this.images_.push(E) : (_ = this.images_[this.images_.length - 1], n.
					default.getUid(_) != n.
					default.getUid(E) && (this.groupIndices.push(this.indices.length), this.images_.push(E))), this.drawText_(i, 0, r, o)
					}
					h += this.width
				}
			}
		}, xi.prototype.getTextSize_ = function(t) {
			var e = this,
				i = this.currAtlas_,
				n = t.length * i.height;
			return [t.map((function(t) {
				var n, r, o = 0;
				for (n = 0, r = t.length; n < r; ++n) {
					var s = t[n];
					i.width[s] || e.addCharToAtlas_(s), o += i.width[s] ? i.width[s] : 0
				}
				return o
			})).reduce((function(t, e) {
				return Math.max(t, e)
			})), n]
		}, xi.prototype.drawText_ = function(t, e, i, n) {
			var r, o;
			for (r = e, o = i; r < o; r += n) this.drawCoordinates(t, e, i, n)
		}, xi.prototype.addCharToAtlas_ = function(t) {
			if (1 === t.length) {
				var e = this.currAtlas_,
					i = this.state_,
					n = this.measureCanvas_.getContext("2d");
				n.font = i.font;
				var r = Math.ceil(n.measureText(t).width * i.scale);
				e.atlas.add(t, r, e.height, (function(e, n, r) {
					e.font = i.font, e.fillStyle = i.fillColor, e.strokeStyle = i.strokeColor, e.lineWidth = i.lineWidth, e.lineCap = i.lineCap, e.lineJoin = i.lineJoin, e.miterLimit = i.miterLimit, e.textAlign = "left", e.textBaseline = "top", O.a.CANVAS_LINE_DASH && i.lineDash && (e.setLineDash(i.lineDash), e.lineDashOffset = i.lineDashOffset), 1 !== i.scale && e.setTransform(i.scale, 0, 0, i.scale, 0, 0), i.strokeColor && e.strokeText(t, n, r), i.fillColor && e.fillText(t, n, r)
				})) && (e.width[t] = r)
			}
		}, xi.prototype.finish = function(t) {
			var e = t.getGL();
			this.groupIndices.push(this.indices.length), this.hitDetectionGroupIndices = this.groupIndices, this.verticesBuffer = new Be(this.vertices), this.indicesBuffer = new Be(this.indices);
			this.createTextures(this.textures_, this.images_, {}, e), this.state_ = {
				strokeColor: null,
				lineCap: void 0,
				lineDash: null,
				lineDashOffset: void 0,
				lineJoin: void 0,
				lineWidth: 0,
				miterLimit: void 0,
				fillColor: null,
				font: void 0,
				scale: void 0
			}, this.text_ = "", this.textAlign_ = void 0, this.textBaseline_ = void 0, this.offsetX_ = void 0, this.offsetY_ = void 0, this.images_ = null, this.atlases_ = {}, this.currAtlas_ = void 0, Ke.prototype.finish.call(this, t)
		}, xi.prototype.setTextStyle = function(t) {
			var e = this.state_,
				i = t.getFill(),
				n = t.getStroke();
			if (t && t.getText() && (i || n)) {
				if (i) {
					var r = i.getColor();
					e.fillColor = ot.a.asColorLike(r || ke.defaultFillStyle)
				} else e.fillColor = null;
				if (n) {
					var o = n.getColor();
					e.strokeColor = ot.a.asColorLike(o || ke.defaultStrokeStyle), e.lineWidth = n.getWidth() || ke.defaultLineWidth, e.lineCap = n.getLineCap() || ke.defaultLineCap, e.lineDashOffset = n.getLineDashOffset() || ke.defaultLineDashOffset, e.lineJoin = n.getLineJoin() || ke.defaultLineJoin, e.miterLimit = n.getMiterLimit() || ke.defaultMiterLimit;
					var s = n.getLineDash();
					e.lineDash = s ? s.slice() : ke.defaultLineDash
				} else e.strokeColor = null, e.lineWidth = 0;
				e.font = t.getFont() || ke.defaultFont, e.scale = t.getScale() || 1, this.text_ = t.getText();
				var a = Kt.TEXT_ALIGN[t.getTextAlign()],
					l = Kt.TEXT_ALIGN[t.getTextBaseline()];
				this.textAlign_ = void 0 === a ? ke.defaultTextAlign : a, this.textBaseline_ = void 0 === l ? ke.defaultTextBaseline : l, this.offsetX_ = t.getOffsetX() || 0, this.offsetY_ = t.getOffsetY() || 0, this.rotateWithView = !! t.getRotateWithView(), this.rotation = t.getRotation() || 0, this.currAtlas_ = this.getAtlas_(e)
			} else this.text_ = ""
		}, xi.prototype.getAtlas_ = function(t) {
			var e, i = [];
			for (e in t)(t[e] || 0 === t[e]) && (Array.isArray(t[e]) ? i = i.concat(t[e]) : i.push(t[e]));
			var n = this.calculateHash_(i);
			if (!this.atlases_[n]) {
				var r = this.measureCanvas_.getContext("2d");
				r.font = t.font;
				var o = Math.ceil((1.5 * r.measureText("M").width + t.lineWidth / 2) * t.scale);
				this.atlases_[n] = {
					atlas: new Ei({
						space: t.lineWidth + 1
					}),
					width: {},
					height: o
				}
			}
			return this.atlases_[n]
		}, xi.prototype.calculateHash_ = function(t) {
			var e, i, n = "";
			for (e = 0, i = t.length; e < i; ++e) n += t[e];
			return n
		}, xi.prototype.getTextures = function(t) {
			return this.textures_
		}, xi.prototype.getHitDetectionTextures = function() {
			return this.textures_
		};
		var Ci = xi,
			Ii = function(t, e, i) {
				jt.call(this), this.maxExtent_ = e, this.tolerance_ = t, this.renderBuffer_ = i, this.replaysByZIndex_ = {}
			};
		n.
	default.inherits(Ii, jt), Ii.prototype.addDeclutter = function(t, e) {}, Ii.prototype.getDeleteResourcesFunction = function(t) {
			var e, i = [];
			for (e in this.replaysByZIndex_) {
				var n, r = this.replaysByZIndex_[e];
				for (n in r) i.push(r[n].getDeleteResourcesFunction(t))
			}
			return function() {
				for (var t, e = i.length, n = 0; n < e; n++) t = i[n].apply(this, arguments);
				return t
			}
		}, Ii.prototype.finish = function(t) {
			var e;
			for (e in this.replaysByZIndex_) {
				var i, n = this.replaysByZIndex_[e];
				for (i in n) n[i].finish(t)
			}
		}, Ii.prototype.getReplay = function(t, e) {
			var i = void 0 !== t ? t.toString() : "0",
				n = this.replaysByZIndex_[i];
			void 0 === n && (n = {}, this.replaysByZIndex_[i] = n);
			var r = n[e];
			void 0 === r && (r = new(0, Ii.BATCH_CONSTRUCTORS_[e])(this.tolerance_, this.maxExtent_), n[e] = r);
			return r
		}, Ii.prototype.isEmpty = function() {
			return V.a.isEmpty(this.replaysByZIndex_)
		}, Ii.prototype.replay = function(t, e, i, n, r, o, s, a) {
			var l, u, h, c, d, f, A = Object.keys(this.replaysByZIndex_).map(Number);
			for (A.sort(Z.a.numberSafeCompareFunction), l = 0, u = A.length; l < u; ++l) for (d = this.replaysByZIndex_[A[l].toString()], h = 0, c = Kt.ORDER.length; h < c; ++h) void 0 !== (f = d[Kt.ORDER[h]]) && f.replay(t, e, i, n, r, o, s, a, void 0, !1)
		}, Ii.prototype.replayHitDetection_ = function(t, e, i, n, r, o, s, a, l, u, h) {
			var c, d, f, A, p, g, m = Object.keys(this.replaysByZIndex_).map(Number);
			for (m.sort((function(t, e) {
				return e - t
			})), c = 0, d = m.length; c < d; ++c) for (A = this.replaysByZIndex_[m[c].toString()], f = Kt.ORDER.length - 1; f >= 0; --f) if (void 0 !== (p = A[Kt.ORDER[f]]) && (g = p.replay(t, e, i, n, r, o, s, a, l, u, h))) return g
		}, Ii.prototype.forEachFeatureAtCoordinate = function(t, e, i, n, r, o, s, a, l, u) {
			var h, c = e.getGL();
			return c.bindFramebuffer(c.FRAMEBUFFER, e.getHitDetectionFramebuffer()), void 0 !== this.renderBuffer_ && (h = K.
		default.buffer(K.
		default.createOrUpdateFromCoordinate(t), n * this.renderBuffer_)), this.replayHitDetection_(e, t, n, r, Ii.HIT_DETECTION_SIZE_, s, a, l, (function(t) {
				var e = new Uint8Array(4);
				if (c.readPixels(0, 0, 1, 1, c.RGBA, c.UNSIGNED_BYTE, e), e[3] > 0) {
					var i = u(t);
					if (i) return i
				}
			}), !0, h)
		}, Ii.prototype.hasFeatureAtCoordinate = function(t, e, i, n, r, o, s, a, l) {
			var u = e.getGL();
			return u.bindFramebuffer(u.FRAMEBUFFER, e.getHitDetectionFramebuffer()), void 0 !== this.replayHitDetection_(e, t, n, r, Ii.HIT_DETECTION_SIZE_, s, a, l, (function(t) {
				var e = new Uint8Array(4);
				return u.readPixels(0, 0, 1, 1, u.RGBA, u.UNSIGNED_BYTE, e), e[3] > 0
			}), !1)
		}, Ii.HIT_DETECTION_SIZE_ = [1, 1], Ii.BATCH_CONSTRUCTORS_ = {
			Circle: Ve,
			Image: Qe,
			LineString: ai,
			Polygon: mi,
			Text: Ci
		};
		var Si = Ii,
			Ti = function(t, e, i, n, r, o, s) {
				ht.call(this), this.context_ = t, this.center_ = e, this.extent_ = o, this.pixelRatio_ = s, this.size_ = r, this.rotation_ = n, this.resolution_ = i, this.imageStyle_ = null, this.fillStyle_ = null, this.strokeStyle_ = null, this.textStyle_ = null
			};
		n.
	default.inherits(Ti, ht), Ti.prototype.drawText_ = function(t, e) {
			var i = this.context_,
				n = t.getReplay(0, Vt.TEXT);
			n.setTextStyle(this.textStyle_), n.drawText(e, null), n.finish(i);
			n.replay(this.context_, this.center_, this.resolution_, this.rotation_, this.size_, this.pixelRatio_, 1, {}, void 0, !1), n.getDeleteResourcesFunction(i)()
		}, Ti.prototype.setStyle = function(t) {
			this.setFillStrokeStyle(t.getFill(), t.getStroke()), this.setImageStyle(t.getImage()), this.setTextStyle(t.getText())
		}, Ti.prototype.drawGeometry = function(t) {
			switch (t.getType()) {
			case st.a.POINT:
				this.drawPoint(t, null);
				break;
			case st.a.LINE_STRING:
				this.drawLineString(t, null);
				break;
			case st.a.POLYGON:
				this.drawPolygon(t, null);
				break;
			case st.a.MULTI_POINT:
				this.drawMultiPoint(t, null);
				break;
			case st.a.MULTI_LINE_STRING:
				this.drawMultiLineString(t, null);
				break;
			case st.a.MULTI_POLYGON:
				this.drawMultiPolygon(t, null);
				break;
			case st.a.GEOMETRY_COLLECTION:
				this.drawGeometryCollection(t, null);
				break;
			case st.a.CIRCLE:
				this.drawCircle(t, null)
			}
		}, Ti.prototype.drawFeature = function(t, e) {
			var i = e.getGeometryFunction()(t);
			i && K.
		default.intersects(this.extent_, i.getExtent()) && (this.setStyle(e), this.drawGeometry(i))
		}, Ti.prototype.drawGeometryCollection = function(t, e) {
			var i, n, r = t.getGeometriesArray();
			for (i = 0, n = r.length; i < n; ++i) this.drawGeometry(r[i])
		}, Ti.prototype.drawPoint = function(t, e) {
			var i = this.context_,
				n = new Si(1, this.extent_),
				r = n.getReplay(0, Vt.IMAGE);
			r.setImageStyle(this.imageStyle_), r.drawPoint(t, e), r.finish(i);
			r.replay(this.context_, this.center_, this.resolution_, this.rotation_, this.size_, this.pixelRatio_, 1, {}, void 0, !1), r.getDeleteResourcesFunction(i)(), this.textStyle_ && this.drawText_(n, t)
		}, Ti.prototype.drawMultiPoint = function(t, e) {
			var i = this.context_,
				n = new Si(1, this.extent_),
				r = n.getReplay(0, Vt.IMAGE);
			r.setImageStyle(this.imageStyle_), r.drawMultiPoint(t, e), r.finish(i);
			r.replay(this.context_, this.center_, this.resolution_, this.rotation_, this.size_, this.pixelRatio_, 1, {}, void 0, !1), r.getDeleteResourcesFunction(i)(), this.textStyle_ && this.drawText_(n, t)
		}, Ti.prototype.drawLineString = function(t, e) {
			var i = this.context_,
				n = new Si(1, this.extent_),
				r = n.getReplay(0, Vt.LINE_STRING);
			r.setFillStrokeStyle(null, this.strokeStyle_), r.drawLineString(t, e), r.finish(i);
			r.replay(this.context_, this.center_, this.resolution_, this.rotation_, this.size_, this.pixelRatio_, 1, {}, void 0, !1), r.getDeleteResourcesFunction(i)(), this.textStyle_ && this.drawText_(n, t)
		}, Ti.prototype.drawMultiLineString = function(t, e) {
			var i = this.context_,
				n = new Si(1, this.extent_),
				r = n.getReplay(0, Vt.LINE_STRING);
			r.setFillStrokeStyle(null, this.strokeStyle_), r.drawMultiLineString(t, e), r.finish(i);
			r.replay(this.context_, this.center_, this.resolution_, this.rotation_, this.size_, this.pixelRatio_, 1, {}, void 0, !1), r.getDeleteResourcesFunction(i)(), this.textStyle_ && this.drawText_(n, t)
		}, Ti.prototype.drawPolygon = function(t, e) {
			var i = this.context_,
				n = new Si(1, this.extent_),
				r = n.getReplay(0, Vt.POLYGON);
			r.setFillStrokeStyle(this.fillStyle_, this.strokeStyle_), r.drawPolygon(t, e), r.finish(i);
			r.replay(this.context_, this.center_, this.resolution_, this.rotation_, this.size_, this.pixelRatio_, 1, {}, void 0, !1), r.getDeleteResourcesFunction(i)(), this.textStyle_ && this.drawText_(n, t)
		}, Ti.prototype.drawMultiPolygon = function(t, e) {
			var i = this.context_,
				n = new Si(1, this.extent_),
				r = n.getReplay(0, Vt.POLYGON);
			r.setFillStrokeStyle(this.fillStyle_, this.strokeStyle_), r.drawMultiPolygon(t, e), r.finish(i);
			r.replay(this.context_, this.center_, this.resolution_, this.rotation_, this.size_, this.pixelRatio_, 1, {}, void 0, !1), r.getDeleteResourcesFunction(i)(), this.textStyle_ && this.drawText_(n, t)
		}, Ti.prototype.drawCircle = function(t, e) {
			var i = this.context_,
				n = new Si(1, this.extent_),
				r = n.getReplay(0, Vt.CIRCLE);
			r.setFillStrokeStyle(this.fillStyle_, this.strokeStyle_), r.drawCircle(t, e), r.finish(i);
			r.replay(this.context_, this.center_, this.resolution_, this.rotation_, this.size_, this.pixelRatio_, 1, {}, void 0, !1), r.getDeleteResourcesFunction(i)(), this.textStyle_ && this.drawText_(n, t)
		}, Ti.prototype.setImageStyle = function(t) {
			this.imageStyle_ = t
		}, Ti.prototype.setFillStrokeStyle = function(t, e) {
			this.fillStyle_ = t, this.strokeStyle_ = e
		}, Ti.prototype.setTextStyle = function(t) {
			this.textStyle_ = t
		};
		var Ri = Ti,
			wi = {};
		wi.fragment = new Re(n.
	default.DEBUG_WEBGL ? "precision mediump float;\nvarying vec2 v_texCoord;\n\n\nuniform float u_opacity;\nuniform sampler2D u_texture;\n\nvoid main(void) {\n  vec4 texColor = texture2D(u_texture, v_texCoord);\n  gl_FragColor.rgb = texColor.rgb;\n  gl_FragColor.a = texColor.a * u_opacity;\n}\n":
		"precision mediump float;varying vec2 a;uniform float f;uniform sampler2D g;void main(void){vec4 texColor=texture2D(g,a);gl_FragColor.rgb=texColor.rgb;gl_FragColor.a=texColor.a*f;}"), wi.vertex = new Le(n.
	default.DEBUG_WEBGL ? "varying vec2 v_texCoord;\n\n\nattribute vec2 a_position;\nattribute vec2 a_texCoord;\n\nuniform mat4 u_texCoordMatrix;\nuniform mat4 u_projectionMatrix;\n\nvoid main(void) {\n  gl_Position = u_projectionMatrix * vec4(a_position, 0., 1.);\n  v_texCoord = (u_texCoordMatrix * vec4(a_texCoord, 0., 1.)).st;\n}\n\n\n":
		"varying vec2 a;attribute vec2 b;attribute vec2 c;uniform mat4 d;uniform mat4 e;void main(void){gl_Position=e*vec4(b,0.,1.);a=(d*vec4(c,0.,1.)).st;}");
		var Li = wi,
			Ni = function(t, e) {
				this.u_texCoordMatrix = t.getUniformLocation(e, n.
			default.DEBUG_WEBGL ? "u_texCoordMatrix":
				"d"), this.u_projectionMatrix = t.getUniformLocation(e, n.
			default.DEBUG_WEBGL ? "u_projectionMatrix":
				"e"), this.u_opacity = t.getUniformLocation(e, n.
			default.DEBUG_WEBGL ? "u_opacity":
				"f"), this.u_texture = t.getUniformLocation(e, n.
			default.DEBUG_WEBGL ? "u_texture":
				"g"), this.a_position = t.getAttribLocation(e, n.
			default.DEBUG_WEBGL ? "a_position":
				"b"), this.a_texCoord = t.getAttribLocation(e, n.
			default.DEBUG_WEBGL ? "a_texCoord":
				"c")
			},
			Pi = function(t, e) {
				_t.call(this, e), this.mapRenderer = t, this.arrayBuffer_ = new Be([-1, -1, 0, 0, 1, -1, 1, 0, -1, 1, 0, 1, 1, 1, 1, 1]), this.texture = null, this.framebuffer = null, this.framebufferDimension = void 0, this.texCoordMatrix = ct.a.create(), this.projectionMatrix = ct.a.create(), this.tmpMat4_ = be.create(), this.defaultLocations_ = null
			};
		n.
	default.inherits(Pi, _t), Pi.prototype.bindFramebuffer = function(t, e) {
			var i = this.mapRenderer.getGL();
			if (void 0 === this.framebufferDimension || this.framebufferDimension != e) {
				var n = function(t, e, i) {
						t.isContextLost() || (t.deleteFramebuffer(e), t.deleteTexture(i))
					}.bind(null, i, this.framebuffer, this.texture);
				t.postRenderFunctions.push(n);
				var r = He.createEmptyTexture(i, e, e),
					o = i.createFramebuffer();
				i.bindFramebuffer(Ce.a.FRAMEBUFFER, o), i.framebufferTexture2D(Ce.a.FRAMEBUFFER, Ce.a.COLOR_ATTACHMENT0, Ce.a.TEXTURE_2D, r, 0), this.texture = r, this.framebuffer = o, this.framebufferDimension = e
			} else i.bindFramebuffer(Ce.a.FRAMEBUFFER, this.framebuffer)
		}, Pi.prototype.composeFrame = function(t, e, i) {
			this.dispatchComposeEvent_(nt.a.PRECOMPOSE, i, t), i.bindBuffer(Ce.a.ARRAY_BUFFER, this.arrayBuffer_);
			var n, r = i.getGL(),
				o = Li.fragment,
				s = Li.vertex,
				a = i.getProgram(o, s);
			this.defaultLocations_ ? n = this.defaultLocations_ : (n = new Ni(r, a), this.defaultLocations_ = n), i.useProgram(a) && (r.enableVertexAttribArray(n.a_position), r.vertexAttribPointer(n.a_position, 2, Ce.a.FLOAT, !1, 16, 0), r.enableVertexAttribArray(n.a_texCoord), r.vertexAttribPointer(n.a_texCoord, 2, Ce.a.FLOAT, !1, 16, 8), r.uniform1i(n.u_texture, 0)), r.uniformMatrix4fv(n.u_texCoordMatrix, !1, be.fromTransform(this.tmpMat4_, this.getTexCoordMatrix())), r.uniformMatrix4fv(n.u_projectionMatrix, !1, be.fromTransform(this.tmpMat4_, this.getProjectionMatrix())), r.uniform1f(n.u_opacity, e.opacity), r.bindTexture(Ce.a.TEXTURE_2D, this.getTexture()), r.drawArrays(Ce.a.TRIANGLE_STRIP, 0, 4), this.dispatchComposeEvent_(nt.a.POSTCOMPOSE, i, t)
		}, Pi.prototype.dispatchComposeEvent_ = function(t, e, i) {
			var n = this.getLayer();
			if (n.hasListener(t)) {
				var r = i.viewState,
					o = r.resolution,
					s = i.pixelRatio,
					a = i.extent,
					l = r.center,
					u = r.rotation,
					h = i.size,
					c = new Ri(e, l, o, u, h, a, s),
					d = new it(t, c, i, null, e);
				n.dispatchEvent(d)
			}
		}, Pi.prototype.getTexCoordMatrix = function() {
			return this.texCoordMatrix
		}, Pi.prototype.getTexture = function() {
			return this.texture
		}, Pi.prototype.getProjectionMatrix = function() {
			return this.projectionMatrix
		}, Pi.prototype.handleWebGLContextLost = function() {
			this.texture = null, this.framebuffer = null, this.framebufferDimension = void 0
		}, Pi.prototype.prepareFrame = function(t, e, i) {}, Pi.prototype.forEachLayerAtPixel = function(t, e, i, n) {};
		var Oi = Pi,
			Mi = function(t, e) {
				Oi.call(this, t, e), this.image_ = null, this.hitCanvasContext_ = null, this.hitTransformationMatrix_ = null
			};
		n.
	default.inherits(Mi, Oi), Mi.handles = function(t, e) {
			return t === Q.a.WEBGL && e.getType() === H.a.IMAGE
		}, Mi.create = function(t, e) {
			return new Mi(t, e)
		}, Mi.prototype.createTexture_ = function(t) {
			var e = t.getImage(),
				i = this.mapRenderer.getGL();
			return He.createTexture(i, e, Ce.a.CLAMP_TO_EDGE, Ce.a.CLAMP_TO_EDGE)
		}, Mi.prototype.forEachFeatureAtCoordinate = function(t, e, i, n, r) {
			var o = this.getLayer(),
				s = o.getSource(),
				a = e.viewState.resolution,
				l = e.viewState.rotation,
				u = e.skippedFeatureUids;
			return s.forEachFeatureAtCoordinate(t, a, l, i, u, (function(t) {
				return n.call(r, t, o)
			}))
		}, Mi.prototype.prepareFrame = function(t, e, i) {
			var r = this.mapRenderer.getGL(),
				o = t.pixelRatio,
				s = t.viewState,
				a = s.center,
				l = s.resolution,
				u = s.rotation,
				h = this.image_,
				c = this.texture,
				d = this.getLayer().getSource(),
				f = t.viewHints,
				p = t.extent;
			if (void 0 !== e.extent && (p = K.
		default.getIntersection(p, e.extent)), !f[A.a.ANIMATING] && !f[A.a.INTERACTING] && !K.
		default.isEmpty(p)) {
				var g = s.projection;
				if (!n.
			default.ENABLE_RASTER_REPROJECTION) {
					var m = d.getProjection();
					m && (g = m)
				}
				var v = d.getImage(p, l, o, g);
				if (v) if (this.loadImage(v) && (h = v, c = this.createTexture_(v), this.texture)) {
					var y = function(t, e) {
							t.isContextLost() || t.deleteTexture(e)
						}.bind(null, r, this.texture);
					t.postRenderFunctions.push(y)
				}
			}
			if (h) {
				var _ = this.mapRenderer.getContext().getCanvas();
				this.updateProjectionMatrix_(_.width, _.height, o, a, l, u, h.getExtent()), this.hitTransformationMatrix_ = null;
				var E = this.texCoordMatrix;
				ct.a.reset(E), ct.a.scale(E, 1, -1), ct.a.translate(E, 0, -1), this.image_ = h, this.texture = c, this.updateLogos(t, d)
			}
			return !!h
		}, Mi.prototype.updateProjectionMatrix_ = function(t, e, i, n, r, o, s) {
			var a = t * r,
				l = e * r,
				u = this.projectionMatrix;
			ct.a.reset(u), ct.a.scale(u, 2 * i / a, 2 * i / l), ct.a.rotate(u, -o), ct.a.translate(u, s[0] - n[0], s[1] - n[1]), ct.a.scale(u, (s[2] - s[0]) / 2, (s[3] - s[1]) / 2), ct.a.translate(u, 1, 1)
		}, Mi.prototype.hasFeatureAtCoordinate = function(t, e) {
			return void 0 !== this.forEachFeatureAtCoordinate(t, e, 0, v.a.TRUE, this)
		}, Mi.prototype.forEachLayerAtPixel = function(t, e, i, r) {
			if (this.image_ && this.image_.getImage()) {
				if (this.getLayer().getSource().forEachFeatureAtCoordinate !== n.
			default.nullFunction) {
					var o = ct.a.apply(e.pixelToCoordinateTransform, t.slice());
					return this.forEachFeatureAtCoordinate(o, e, 0, v.a.TRUE, this) ? i.call(r, this.getLayer(), null) : void 0
				}
				var s = [this.image_.getImage().width, this.image_.getImage().height];
				this.hitTransformationMatrix_ || (this.hitTransformationMatrix_ = this.getHitTransformationMatrix_(e.size, s));
				var a = ct.a.apply(this.hitTransformationMatrix_, t.slice());
				if (!(a[0] < 0 || a[0] > s[0] || a[1] < 0 || a[1] > s[1])) {
					this.hitCanvasContext_ || (this.hitCanvasContext_ = $.a.createCanvasContext2D(1, 1)), this.hitCanvasContext_.clearRect(0, 0, 1, 1), this.hitCanvasContext_.drawImage(this.image_.getImage(), a[0], a[1], 1, 1, 0, 0, 1, 1);
					var l = this.hitCanvasContext_.getImageData(0, 0, 1, 1).data;
					return l[3] > 0 ? i.call(r, this.getLayer(), l) : void 0
				}
			}
		}, Mi.prototype.getHitTransformationMatrix_ = function(t, e) {
			var i = ct.a.create();
			ct.a.translate(i, -1, -1), ct.a.scale(i, 2 / t[0], 2 / t[1]), ct.a.translate(i, 0, t[1]), ct.a.scale(i, 1, -1);
			var n = ct.a.invert(this.projectionMatrix.slice()),
				r = ct.a.create();
			return ct.a.translate(r, 0, e[1]), ct.a.scale(r, 1, -1), ct.a.scale(r, e[0] / 2, e[1] / 2), ct.a.translate(r, 1, 1), ct.a.multiply(r, n), ct.a.multiply(r, i), r
		};
		var bi = Mi,
			Fi = i(112),
			Di = i(96),
			Gi = function(t, e) {
				Ot.call(this, t, e), this.canvas_ = document.createElement("CANVAS"), this.canvas_.style.width = "100%", this.canvas_.style.height = "100%", this.canvas_.style.display = "block", this.canvas_.className = Rt.a.CLASS_UNSELECTABLE, t.insertBefore(this.canvas_, t.childNodes[0] || null), this.clipTileCanvasWidth_ = 0, this.clipTileCanvasHeight_ = 0, this.clipTileContext_ = $.a.createCanvasContext2D(), this.renderedVisible_ = !0, this.gl_ = Ce.a.getContext(this.canvas_, {
					antialias: !0,
					depth: !0,
					failIfMajorPerformanceCaveat: !0,
					preserveDrawingBuffer: !1,
					stencil: !0
				}), this.context_ = new He(this.canvas_, this.gl_), mt.a.listen(this.canvas_, We.LOST, this.handleWebGLContextLost, this), mt.a.listen(this.canvas_, We.RESTORED, this.handleWebGLContextRestored, this), this.textureCache_ = new Fi.a, this.focus_ = null, this.tileTextureQueue_ = new Di.a(function(t) {
					var e = t[1],
						i = t[2],
						n = e[0] - this.focus_[0],
						r = e[1] - this.focus_[1];
					return 65536 * Math.log(i) + Math.sqrt(n * n + r * r) / i
				}.bind(this), (function(t) {
					return t[0].getKey()
				})), this.loadNextTileTexture_ = function(t, e) {
					if (!this.tileTextureQueue_.isEmpty()) {
						this.tileTextureQueue_.reprioritize();
						var i = this.tileTextureQueue_.dequeue(),
							n = i[0],
							r = i[3],
							o = i[4];
						this.bindTileTexture(n, r, o, Ce.a.LINEAR, Ce.a.LINEAR)
					}
					return !1
				}.bind(this), this.textureCacheFrameMarkerCount_ = 0, this.initializeGL_()
			};
		n.
	default.inherits(Gi, Ot), Gi.handles = function(t) {
			return O.a.WEBGL && t === Q.a.WEBGL
		}, Gi.create = function(t, e) {
			return new Gi(t, e)
		}, Gi.prototype.bindTileTexture = function(t, e, i, n, r) {
			var o = this.getGL(),
				s = t.getKey();
			if (this.textureCache_.containsKey(s)) {
				var a = this.textureCache_.get(s);
				o.bindTexture(Ce.a.TEXTURE_2D, a.texture), a.magFilter != n && (o.texParameteri(Ce.a.TEXTURE_2D, Ce.a.TEXTURE_MAG_FILTER, n), a.magFilter = n), a.minFilter != r && (o.texParameteri(Ce.a.TEXTURE_2D, Ce.a.TEXTURE_MIN_FILTER, r), a.minFilter = r)
			} else {
				var l = o.createTexture();
				if (o.bindTexture(Ce.a.TEXTURE_2D, l), i > 0) {
					var u = this.clipTileContext_.canvas,
						h = this.clipTileContext_;
					this.clipTileCanvasWidth_ !== e[0] || this.clipTileCanvasHeight_ !== e[1] ? (u.width = e[0], u.height = e[1], this.clipTileCanvasWidth_ = e[0], this.clipTileCanvasHeight_ = e[1]) : h.clearRect(0, 0, e[0], e[1]), h.drawImage(t.getImage(), i, i, e[0], e[1], 0, 0, e[0], e[1]), o.texImage2D(Ce.a.TEXTURE_2D, 0, Ce.a.RGBA, Ce.a.RGBA, Ce.a.UNSIGNED_BYTE, u)
				} else o.texImage2D(Ce.a.TEXTURE_2D, 0, Ce.a.RGBA, Ce.a.RGBA, Ce.a.UNSIGNED_BYTE, t.getImage());
				o.texParameteri(Ce.a.TEXTURE_2D, Ce.a.TEXTURE_MAG_FILTER, n), o.texParameteri(Ce.a.TEXTURE_2D, Ce.a.TEXTURE_MIN_FILTER, r), o.texParameteri(Ce.a.TEXTURE_2D, Ce.a.TEXTURE_WRAP_S, Ce.a.CLAMP_TO_EDGE), o.texParameteri(Ce.a.TEXTURE_2D, Ce.a.TEXTURE_WRAP_T, Ce.a.CLAMP_TO_EDGE), this.textureCache_.set(s, {
					texture: l,
					magFilter: n,
					minFilter: r
				})
			}
		}, Gi.prototype.dispatchComposeEvent_ = function(t, e) {
			var i = this.getMap();
			if (i.hasListener(t)) {
				var n = this.context_,
					r = e.extent,
					o = e.size,
					s = e.viewState,
					a = e.pixelRatio,
					l = s.resolution,
					u = s.center,
					h = s.rotation,
					c = new Ri(n, u, l, h, o, r, a),
					d = new it(t, c, e, null, n);
				i.dispatchEvent(d)
			}
		}, Gi.prototype.disposeInternal = function() {
			var t = this.getGL();
			t.isContextLost() || this.textureCache_.forEach((function(e) {
				e && t.deleteTexture(e.texture)
			})), this.context_.dispose(), Ot.prototype.disposeInternal.call(this)
		}, Gi.prototype.expireCache_ = function(t, e) {
			for (var i, r = this.getGL(); this.textureCache_.getCount() - this.textureCacheFrameMarkerCount_ > n.
		default.WEBGL_TEXTURE_CACHE_HIGH_WATER_MARK;) {
				if (i = this.textureCache_.peekLast()) r.deleteTexture(i.texture);
				else {
					if (+this.textureCache_.peekLastKey() == e.index) break;
					--this.textureCacheFrameMarkerCount_
				}
				this.textureCache_.pop()
			}
		}, Gi.prototype.getContext = function() {
			return this.context_
		}, Gi.prototype.getGL = function() {
			return this.gl_
		}, Gi.prototype.getTileTextureQueue = function() {
			return this.tileTextureQueue_
		}, Gi.prototype.getType = function() {
			return Q.a.WEBGL
		}, Gi.prototype.handleWebGLContextLost = function(t) {
			t.preventDefault(), this.textureCache_.clear(), this.textureCacheFrameMarkerCount_ = 0;
			var e = this.getLayerRenderers();
			for (var i in e) {
				e[i].handleWebGLContextLost()
			}
		}, Gi.prototype.handleWebGLContextRestored = function() {
			this.initializeGL_(), this.getMap().render()
		}, Gi.prototype.initializeGL_ = function() {
			var t = this.gl_;
			t.activeTexture(Ce.a.TEXTURE0), t.blendFuncSeparate(Ce.a.SRC_ALPHA, Ce.a.ONE_MINUS_SRC_ALPHA, Ce.a.ONE, Ce.a.ONE_MINUS_SRC_ALPHA), t.disable(Ce.a.CULL_FACE), t.disable(Ce.a.DEPTH_TEST), t.disable(Ce.a.SCISSOR_TEST), t.disable(Ce.a.STENCIL_TEST)
		}, Gi.prototype.isTileTextureLoaded = function(t) {
			return this.textureCache_.containsKey(t.getKey())
		}, Gi.prototype.renderFrame = function(t) {
			var e = this.getContext(),
				i = this.getGL();
			if (i.isContextLost()) return !1;
			if (!t) return this.renderedVisible_ && (this.canvas_.style.display = "none", this.renderedVisible_ = !1), !1;
			this.focus_ = t.focus, this.textureCache_.set((-t.index).toString(), null), ++this.textureCacheFrameMarkerCount_, this.dispatchComposeEvent_(nt.a.PRECOMPOSE, t);
			var r = [],
				o = t.layerStatesArray;
			Z.a.stableSort(o, Ot.sortByZIndex);
			var s, a, l, u = t.viewState.resolution;
			for (s = 0, a = o.length; s < a; ++s) l = o[s], wt.a.visibleAtResolution(l, u) && l.sourceState == vt.a.READY && this.getLayerRenderer(l.layer).prepareFrame(t, l, e) && r.push(l);
			var h = t.size[0] * t.pixelRatio,
				c = t.size[1] * t.pixelRatio;
			for (this.canvas_.width == h && this.canvas_.height == c || (this.canvas_.width = h, this.canvas_.height = c), i.bindFramebuffer(Ce.a.FRAMEBUFFER, null), i.clearColor(0, 0, 0, 0), i.clear(Ce.a.COLOR_BUFFER_BIT), i.enable(Ce.a.BLEND), i.viewport(0, 0, this.canvas_.width, this.canvas_.height), s = 0, a = r.length; s < a; ++s) l = r[s], this.getLayerRenderer(l.layer).composeFrame(t, l, e);
			this.renderedVisible_ || (this.canvas_.style.display = "", this.renderedVisible_ = !0), this.calculateMatrices2D(t), this.textureCache_.getCount() - this.textureCacheFrameMarkerCount_ > n.
		default.WEBGL_TEXTURE_CACHE_HIGH_WATER_MARK && t.postRenderFunctions.push(this.expireCache_.bind(this)), this.tileTextureQueue_.isEmpty() || (t.postRenderFunctions.push(this.loadNextTileTexture_), t.animate = !0), this.dispatchComposeEvent_(nt.a.POSTCOMPOSE, t), this.scheduleRemoveUnusedLayerRenderers(t), this.scheduleExpireIconCache(t)
		}, Gi.prototype.forEachFeatureAtCoordinate = function(t, e, i, n, r, o, s) {
			var a;
			if (this.getGL().isContextLost()) return !1;
			var l, u = e.viewState,
				h = e.layerStatesArray;
			for (l = h.length - 1; l >= 0; --l) {
				var c = h[l],
					d = c.layer;
				if (wt.a.visibleAtResolution(c, u.resolution) && o.call(s, d)) if (a = this.getLayerRenderer(d).forEachFeatureAtCoordinate(t, e, i, n, r)) return a
			}
		}, Gi.prototype.hasFeatureAtCoordinate = function(t, e, i, n, r) {
			var o = !1;
			if (this.getGL().isContextLost()) return !1;
			var s, a = e.viewState,
				l = e.layerStatesArray;
			for (s = l.length - 1; s >= 0; --s) {
				var u = l[s],
					h = u.layer;
				if (wt.a.visibleAtResolution(u, a.resolution) && n.call(r, h)) if (o = this.getLayerRenderer(h).hasFeatureAtCoordinate(t, e)) return !0
			}
			return o
		}, Gi.prototype.forEachLayerAtPixel = function(t, e, i, n, r, o) {
			if (this.getGL().isContextLost()) return !1;
			var s, a, l = e.viewState,
				u = e.layerStatesArray;
			for (a = u.length - 1; a >= 0; --a) {
				var h = u[a],
					c = h.layer;
				if (wt.a.visibleAtResolution(h, l.resolution) && r.call(n, c)) if (s = this.getLayerRenderer(c).forEachLayerAtPixel(t, e, i, n)) return s
			}
		};
		var ki = Gi,
			Ui = {};
		Ui.fragment = new Re(n.
	default.DEBUG_WEBGL ? "precision mediump float;\nvarying vec2 v_texCoord;\n\n\nuniform sampler2D u_texture;\n\nvoid main(void) {\n  gl_FragColor = texture2D(u_texture, v_texCoord);\n}\n":
		"precision mediump float;varying vec2 a;uniform sampler2D e;void main(void){gl_FragColor=texture2D(e,a);}"), Ui.vertex = new Le(n.
	default.DEBUG_WEBGL ? "varying vec2 v_texCoord;\n\n\nattribute vec2 a_position;\nattribute vec2 a_texCoord;\nuniform vec4 u_tileOffset;\n\nvoid main(void) {\n  gl_Position = vec4(a_position * u_tileOffset.xy + u_tileOffset.zw, 0., 1.);\n  v_texCoord = a_texCoord;\n}\n\n\n":
		"varying vec2 a;attribute vec2 b;attribute vec2 c;uniform vec4 d;void main(void){gl_Position=vec4(b*d.xy+d.zw,0.,1.);a=c;}");
		var Bi = Ui,
			ji = function(t, e) {
				this.u_tileOffset = t.getUniformLocation(e, n.
			default.DEBUG_WEBGL ? "u_tileOffset":
				"d"), this.u_texture = t.getUniformLocation(e, n.
			default.DEBUG_WEBGL ? "u_texture":
				"e"), this.a_position = t.getAttribLocation(e, n.
			default.DEBUG_WEBGL ? "a_position":
				"b"), this.a_texCoord = t.getAttribLocation(e, n.
			default.DEBUG_WEBGL ? "a_texCoord":
				"c")
			},
			Vi = i(48),
			Yi = function(t, e) {
				Oi.call(this, t, e), this.fragmentShader_ = Bi.fragment, this.vertexShader_ = Bi.vertex, this.locations_ = null, this.renderArrayBuffer_ = new Be([0, 0, 0, 1, 1, 0, 1, 1, 0, 1, 0, 0, 1, 1, 1, 0]), this.renderedTileRange_ = null, this.renderedFramebufferExtent_ = null, this.renderedRevision_ = -1, this.tmpSize_ = [0, 0]
			};
		n.
	default.inherits(Yi, Oi), Yi.handles = function(t, e) {
			return t === Q.a.WEBGL && e.getType() === H.a.TILE
		}, Yi.create = function(t, e) {
			return new Yi(t, e)
		}, Yi.prototype.disposeInternal = function() {
			this.mapRenderer.getContext().deleteBuffer(this.renderArrayBuffer_), Oi.prototype.disposeInternal.call(this)
		}, Yi.prototype.createLoadedTileFinder = function(t, e, i) {
			var n = this.mapRenderer;
			return (function(r, o) {
				return t.forEachLoadedTile(e, r, o, (function(t) {
					var e = n.isTileTextureLoaded(t);
					return e && (i[r] || (i[r] = {}), i[r][t.tileCoord.toString()] = t), e
				}))
			})
		}, Yi.prototype.handleWebGLContextLost = function() {
			Oi.prototype.handleWebGLContextLost.call(this), this.locations_ = null
		}, Yi.prototype.prepareFrame = function(t, e, i) {
			var n, r = this.mapRenderer,
				o = i.getGL(),
				s = t.viewState,
				a = s.projection,
				l = this.getLayer(),
				u = l.getSource(),
				h = u.getTileGridForProjection(a),
				c = h.getZForResolution(s.resolution),
				d = h.getResolution(c),
				f = u.getTilePixelSize(c, t.pixelRatio, a),
				A = f[0] / Vi.a.toSize(h.getTileSize(c), this.tmpSize_)[0],
				p = d / A,
				g = u.getTilePixelRatio(A) * u.getGutter(a),
				m = s.center,
				v = t.extent,
				y = h.getTileRangeForExtentAndZ(v, c);
			if (this.renderedTileRange_ && this.renderedTileRange_.equals(y) && this.renderedRevision_ == u.getRevision()) n = this.renderedFramebufferExtent_;
			else {
				var _ = y.getSize(),
					E = Math.max(_[0] * f[0], _[1] * f[1]),
					x = M.a.roundUpToPowerOfTwo(E),
					C = p * x,
					I = h.getOrigin(c),
					S = I[0] + y.minX * f[0] * p,
					T = I[1] + y.minY * f[1] * p;
				n = [S, T, S + C, T + C], this.bindFramebuffer(t, x), o.viewport(0, 0, x, x), o.clearColor(0, 0, 0, 0), o.clear(Ce.a.COLOR_BUFFER_BIT), o.disable(Ce.a.BLEND);
				var R = i.getProgram(this.fragmentShader_, this.vertexShader_);
				i.useProgram(R), this.locations_ || (this.locations_ = new ji(o, R)), i.bindBuffer(Ce.a.ARRAY_BUFFER, this.renderArrayBuffer_), o.enableVertexAttribArray(this.locations_.a_position), o.vertexAttribPointer(this.locations_.a_position, 2, Ce.a.FLOAT, !1, 16, 0), o.enableVertexAttribArray(this.locations_.a_texCoord), o.vertexAttribPointer(this.locations_.a_texCoord, 2, Ce.a.FLOAT, !1, 16, 8), o.uniform1i(this.locations_.u_texture, 0);
				var w = {};
				w[c] = {};
				var L, N, P, O, b, F, D = this.createLoadedTileFinder(u, a, w),
					G = l.getUseInterimTilesOnError(),
					k = !0,
					U = K.
				default.createEmpty(),
					B = new Ft.a(0, 0, 0, 0);
				for (O = y.minX; O <= y.maxX; ++O) for (b = y.minY; b <= y.maxY; ++b) if (N = u.getTile(c, O, b, A, a), void 0 === e.extent || (F = h.getTileCoordExtent(N.tileCoord, U), K.
			default.intersects(F, e.extent))) {
					if ((P = N.getState()) == pt.a.LOADED || P == pt.a.EMPTY || P == pt.a.ERROR && !G || (N = N.getInterimTile()), (P = N.getState()) == pt.a.LOADED) {
						if (r.isTileTextureLoaded(N)) {
							w[c][N.tileCoord.toString()] = N;
							continue
						}
					} else if (P == pt.a.EMPTY || P == pt.a.ERROR && !G) continue;
					k = !1, h.forEachTileCoordParentTileRange(N.tileCoord, D, null, B, U) || (L = h.getTileCoordChildTileRange(N.tileCoord, B, U)) && D(c + 1, L)
				}
				var j = Object.keys(w).map(Number);
				j.sort(Z.a.numberSafeCompareFunction);
				var V, Y, z, X, W = new Float32Array(4);
				for (V = 0, Y = j.length; V < Y; ++V) for (z in X = w[j[V]]) N = X[z], F = h.getTileCoordExtent(N.tileCoord, U), W[0] = 2 * (F[2] - F[0]) / C, W[1] = 2 * (F[3] - F[1]) / C, W[2] = 2 * (F[0] - n[0]) / C - 1, W[3] = 2 * (F[1] - n[1]) / C - 1, o.uniform4fv(this.locations_.u_tileOffset, W), r.bindTileTexture(N, f, g * A, Ce.a.LINEAR, Ce.a.LINEAR), o.drawArrays(Ce.a.TRIANGLE_STRIP, 0, 4);
				k ? (this.renderedTileRange_ = y, this.renderedFramebufferExtent_ = n, this.renderedRevision_ = u.getRevision()):
				(this.renderedTileRange_ = null, this.renderedFramebufferExtent_ = null, this.renderedRevision_ = -1, t.animate = !0)
			}
			this.updateUsedTiles(t.usedTiles, u, c, y);
			var q = r.getTileTextureQueue();
			this.manageTilePyramid(t, u, h, A, a, v, c, l.getPreload(), (function(t) {
				t.getState() != pt.a.LOADED || r.isTileTextureLoaded(t) || q.isKeyQueued(t.getKey()) || q.enqueue([t, h.getTileCoordCenter(t.tileCoord), h.getResolution(t.tileCoord[0]), f, g * A])
			}), this), this.scheduleExpireCache(t, u), this.updateLogos(t, u);
			var H = this.texCoordMatrix;
			return ct.a.reset(H), ct.a.translate(H, (Math.round(m[0] / d) * d - n[0]) / (n[2] - n[0]), (Math.round(m[1] / d) * d - n[1]) / (n[3] - n[1])), 0 !== s.rotation && ct.a.rotate(H, s.rotation), ct.a.scale(H, t.size[0] * s.resolution / (n[2] - n[0]), t.size[1] * s.resolution / (n[3] - n[1])), ct.a.translate(H, -.5, -.5), !0
		}, Yi.prototype.forEachLayerAtPixel = function(t, e, i, n) {
			if (this.framebuffer) {
				var r = [t[0] / e.size[0], (e.size[1] - t[1]) / e.size[1]],
					o = ct.a.apply(this.texCoordMatrix, r.slice()),
					s = [o[0] * this.framebufferDimension, o[1] * this.framebufferDimension],
					a = this.mapRenderer.getContext().getGL();
				a.bindFramebuffer(a.FRAMEBUFFER, this.framebuffer);
				var l = new Uint8Array(4);
				return a.readPixels(s[0], s[1], 1, 1, a.RGBA, a.UNSIGNED_BYTE, l), l[3] > 0 ? i.call(n, this.getLayer(), l) : void 0
			}
		};
		var zi = Yi,
			Xi = function(t, e) {
				Oi.call(this, t, e), this.dirty_ = !1, this.renderedRevision_ = -1, this.renderedResolution_ = NaN, this.renderedExtent_ = K.
			default.createEmpty(), this.renderedRenderOrder_ = null, this.replayGroup_ = null, this.layerState_ = null
			};
		n.
	default.inherits(Xi, Oi), Xi.handles = function(t, e) {
			return t === Q.a.WEBGL && e.getType() === H.a.VECTOR
		}, Xi.create = function(t, e) {
			return new Xi(t, e)
		}, Xi.prototype.composeFrame = function(t, e, i) {
			this.layerState_ = e;
			var n = t.viewState,
				r = this.replayGroup_,
				o = t.size,
				s = t.pixelRatio,
				a = this.mapRenderer.getGL();
			r && !r.isEmpty() && (a.enable(a.SCISSOR_TEST), a.scissor(0, 0, o[0] * s, o[1] * s), r.replay(i, n.center, n.resolution, n.rotation, o, s, e.opacity, e.managed ? t.skippedFeatureUids : {}), a.disable(a.SCISSOR_TEST))
		}, Xi.prototype.disposeInternal = function() {
			var t = this.replayGroup_;
			if (t) {
				var e = this.mapRenderer.getContext();
				t.getDeleteResourcesFunction(e)(), this.replayGroup_ = null
			}
			Oi.prototype.disposeInternal.call(this)
		}, Xi.prototype.forEachFeatureAtCoordinate = function(t, e, i, r, o) {
			if (this.replayGroup_ && this.layerState_) {
				var s = this.mapRenderer.getContext(),
					a = e.viewState,
					l = this.getLayer(),
					u = this.layerState_,
					h = {};
				return this.replayGroup_.forEachFeatureAtCoordinate(t, s, a.center, a.resolution, a.rotation, e.size, e.pixelRatio, u.opacity, {}, (function(t) {
					var e = n.
				default.getUid(t).toString();
					if (!(e in h)) return h[e] = !0, r.call(o, t, l)
				}))
			}
		}, Xi.prototype.hasFeatureAtCoordinate = function(t, e) {
			if (this.replayGroup_ && this.layerState_) {
				var i = this.mapRenderer.getContext(),
					n = e.viewState,
					r = this.layerState_;
				return this.replayGroup_.hasFeatureAtCoordinate(t, i, n.center, n.resolution, n.rotation, e.size, e.pixelRatio, r.opacity, e.skippedFeatureUids)
			}
			return !1
		}, Xi.prototype.forEachLayerAtPixel = function(t, e, i, n) {
			var r = ct.a.apply(e.pixelToCoordinateTransform, t.slice());
			return this.hasFeatureAtCoordinate(r, e) ? i.call(n, this.getLayer(), null) : void 0
		}, Xi.prototype.handleStyleImageChange_ = function(t) {
			this.renderIfReadyAndVisible()
		}, Xi.prototype.prepareFrame = function(t, e, i) {
			var n = this.getLayer(),
				r = n.getSource();
			this.updateLogos(t, r);
			var o = t.viewHints[A.a.ANIMATING],
				s = t.viewHints[A.a.INTERACTING],
				a = n.getUpdateWhileAnimating(),
				l = n.getUpdateWhileInteracting();
			if (!this.dirty_ && !a && o || !l && s) return !0;
			var u = t.extent,
				h = t.viewState,
				c = h.projection,
				d = h.resolution,
				f = t.pixelRatio,
				p = n.getRevision(),
				g = n.getRenderBuffer(),
				m = n.getRenderOrder();
			void 0 === m && (m = pe.defaultOrder);
			var v = K.
		default.buffer(u, g * d);
			if (!this.dirty_ && this.renderedResolution_ == d && this.renderedRevision_ == p && this.renderedRenderOrder_ == m && K.
		default.containsExtent(this.renderedExtent_, v)) return !0;
			this.replayGroup_ && t.postRenderFunctions.push(this.replayGroup_.getDeleteResourcesFunction(i)), this.dirty_ = !1;
			var y = new Si(pe.getTolerance(d, f), v, n.getRenderBuffer());
			r.loadFeatures(v, d, c);
			var _ = function(t) {
					var e, i = t.getStyleFunction();
					if (i ? e = i.call(t, d) : (i = n.getStyleFunction()) && (e = i(t, d)), e) {
						var r = this.renderFeature(t, d, f, e, y);
						this.dirty_ = this.dirty_ || r
					}
				};
			if (m) {
				var E = [];
				r.forEachFeatureInExtent(v, (function(t) {
					E.push(t)
				}), this), E.sort(m), E.forEach(_, this)
			} else r.forEachFeatureInExtent(v, _, this);
			return y.finish(i), this.renderedResolution_ = d, this.renderedRevision_ = p, this.renderedRenderOrder_ = m, this.renderedExtent_ = v, this.replayGroup_ = y, !0
		}, Xi.prototype.renderFeature = function(t, e, i, n, r) {
			if (!n) return !1;
			var o = !1;
			if (Array.isArray(n)) for (var s = n.length - 1; s >= 0; --s) o = pe.renderFeature(r, t, n[s], pe.getSquaredTolerance(e, i), this.handleStyleImageChange_, this) || o;
			else o = pe.renderFeature(r, t, n, pe.getSquaredTolerance(e, i), this.handleStyleImageChange_, this) || o;
			return o
		};
		var Wi = Xi;
		n.
	default.ENABLE_CANVAS && (Y.a.register(o.a.MAP_RENDERER, bt), Y.a.registerMultiple(o.a.LAYER_RENDERER, [Tt, Gt, me, xe])), n.
	default.ENABLE_WEBGL && (Y.a.register(o.a.MAP_RENDERER, ki), Y.a.registerMultiple(o.a.LAYER_RENDERER, [bi, zi, Wi]));
		var qi = function(t) {
				(t = V.a.assign({}, t)).controls || (t.controls = s.
			default.defaults()), t.interactions || (t.interactions = j.defaults()), r.a.call(this, t)
			};
		n.
	default.inherits(qi, r.a);
		e.
	default = qi
	}, function(t, e, i) {
		"use strict";
		var n = {
			cache_: null,
			set: function(t) {
				n.cache_ = t
			},
			get: function() {
				return n.cache_ || window.proj4
			}
		};
		e.a = n
	}, function(t, e, i) {
		"use strict";
		i.r(e);
		var n = i(82),
			r = i(11),
			o = i(75),
			s = function(t) {
				this.html_ = t.html, this.tileRanges_ = t.tileRanges ? t.tileRanges : null
			};
		s.prototype.getHTML = function() {
			return this.html_
		}, s.prototype.intersectsAnyTileRange = function(t, e, i) {
			if (!this.tileRanges_) return !0;
			var s, a, l, u;
			for (u in t) {
				var h;
				if (u in this.tileRanges_) for (l = t[u], s = 0, a = this.tileRanges_[u].length; s < a; ++s) {
					if ((h = this.tileRanges_[u][s]).intersects(l)) return !0;
					var c = e.getTileRangeForExtentAndZ(o.a.extentFromProjection(i), parseInt(u, 10)),
						d = c.getWidth();
					if (l.minX < c.minX || l.maxX > c.maxX) {
						if (h.intersects(new n.a(r.a.modulo(l.minX, d), r.a.modulo(l.maxX, d), l.minY, l.maxY))) return !0;
						if (l.getWidth() > d && h.intersects(c)) return !0
					}
				}
			}
			return !1
		}, e.
	default = s
	}, function(t, e, i) {
		"use strict";
		var n = i(0),
			r = i(15),
			o = i(82),
			s = i(10),
			a = i(1),
			l = i(11),
			u = i(48),
			h = i(49),
			c = function(t) {
				var e;
				if (this.minZoom = void 0 !== t.minZoom ? t.minZoom : 0, this.resolutions_ = t.resolutions, r.a.assert(s.a.isSorted(this.resolutions_, (function(t, e) {
					return e - t
				}), !0), 17), !t.origins) for (var i = 0, l = this.resolutions_.length - 1; i < l; ++i) if (e) {
					if (this.resolutions_[i] / this.resolutions_[i + 1] !== e) {
						e = void 0;
						break
					}
				} else e = this.resolutions_[i] / this.resolutions_[i + 1];
				this.zoomFactor_ = e, this.maxZoom = this.resolutions_.length - 1, this.origin_ = void 0 !== t.origin ? t.origin : null, this.origins_ = null, void 0 !== t.origins && (this.origins_ = t.origins, r.a.assert(this.origins_.length == this.resolutions_.length, 20));
				var u = t.extent;
				void 0 === u || this.origin_ || this.origins_ || (this.origin_ = a.
			default.getTopLeft(u)), r.a.assert(!this.origin_ && this.origins_ || this.origin_ && !this.origins_, 18), this.tileSizes_ = null, void 0 !== t.tileSizes && (this.tileSizes_ = t.tileSizes, r.a.assert(this.tileSizes_.length == this.resolutions_.length, 19)), this.tileSize_ = void 0 !== t.tileSize ? t.tileSize : this.tileSizes_ ? null : n.
			default.DEFAULT_TILE_SIZE, r.a.assert(!this.tileSize_ && this.tileSizes_ || this.tileSize_ && !this.tileSizes_, 22), this.extent_ = void 0 !== u ? u:
				null, this.fullTileRanges_ = null, this.tmpSize_ = [0, 0], void 0 !== t.sizes ? this.fullTileRanges_ = t.sizes.map((function(t, e) {
					return new o.a(Math.min(0, t[0]), Math.max(t[0] - 1, -1), Math.min(0, t[1]), Math.max(t[1] - 1, -1))
				}), this) : u && this.calculateTileRanges_(u)
			};
		c.tmpTileCoord_ = [0, 0, 0], c.prototype.forEachTileCoord = function(t, e, i) {
			for (var n = this.getTileRangeForExtentAndZ(t, e), r = n.minX, o = n.maxX; r <= o; ++r) for (var s = n.minY, a = n.maxY; s <= a; ++s) i([e, r, s])
		}, c.prototype.forEachTileCoordParentTileRange = function(t, e, i, n, r) {
			var s, a, l, u = null,
				h = t[0] - 1;
			for (2 === this.zoomFactor_ ? (a = t[1], l = t[2]) : u = this.getTileCoordExtent(t, r); h >= this.minZoom;) {
				if (2 === this.zoomFactor_ ? (a = Math.floor(a / 2), l = Math.floor(l / 2), s = o.a.createOrUpdate(a, a, l, l, n)) : s = this.getTileRangeForExtentAndZ(u, h, n), e.call(i, h, s)) return !0;
				--h
			}
			return !1
		}, c.prototype.getExtent = function() {
			return this.extent_
		}, c.prototype.getMaxZoom = function() {
			return this.maxZoom
		}, c.prototype.getMinZoom = function() {
			return this.minZoom
		}, c.prototype.getOrigin = function(t) {
			return this.origin_ ? this.origin_ : this.origins_[t]
		}, c.prototype.getResolution = function(t) {
			return this.resolutions_[t]
		}, c.prototype.getResolutions = function() {
			return this.resolutions_
		}, c.prototype.getTileCoordChildTileRange = function(t, e, i) {
			if (t[0] < this.maxZoom) {
				if (2 === this.zoomFactor_) {
					var n = 2 * t[1],
						r = 2 * t[2];
					return o.a.createOrUpdate(n, n + 1, r, r + 1, e)
				}
				var s = this.getTileCoordExtent(t, i);
				return this.getTileRangeForExtentAndZ(s, t[0] + 1, e)
			}
			return null
		}, c.prototype.getTileRangeExtent = function(t, e, i) {
			var n = this.getOrigin(t),
				r = this.getResolution(t),
				o = u.a.toSize(this.getTileSize(t), this.tmpSize_),
				s = n[0] + e.minX * o[0] * r,
				l = n[0] + (e.maxX + 1) * o[0] * r,
				h = n[1] + e.minY * o[1] * r,
				c = n[1] + (e.maxY + 1) * o[1] * r;
			return a.
		default.createOrUpdate(s, h, l, c, i)
		}, c.prototype.getTileRangeForExtentAndZ = function(t, e, i) {
			var n = c.tmpTileCoord_;
			this.getTileCoordForXYAndZ_(t[0], t[1], e, !1, n);
			var r = n[1],
				s = n[2];
			return this.getTileCoordForXYAndZ_(t[2], t[3], e, !0, n), o.a.createOrUpdate(r, n[1], s, n[2], i)
		}, c.prototype.getTileCoordCenter = function(t) {
			var e = this.getOrigin(t[0]),
				i = this.getResolution(t[0]),
				n = u.a.toSize(this.getTileSize(t[0]), this.tmpSize_);
			return [e[0] + (t[1] + .5) * n[0] * i, e[1] + (t[2] + .5) * n[1] * i]
		}, c.prototype.getTileCoordExtent = function(t, e) {
			var i = this.getOrigin(t[0]),
				n = this.getResolution(t[0]),
				r = u.a.toSize(this.getTileSize(t[0]), this.tmpSize_),
				o = i[0] + t[1] * r[0] * n,
				s = i[1] + t[2] * r[1] * n,
				l = o + r[0] * n,
				h = s + r[1] * n;
			return a.
		default.createOrUpdate(o, s, l, h, e)
		}, c.prototype.getTileCoordForCoordAndResolution = function(t, e, i) {
			return this.getTileCoordForXYAndResolution_(t[0], t[1], e, !1, i)
		}, c.prototype.getTileCoordForXYAndResolution_ = function(t, e, i, n, r) {
			var o = this.getZForResolution(i),
				s = i / this.getResolution(o),
				a = this.getOrigin(o),
				l = u.a.toSize(this.getTileSize(o), this.tmpSize_),
				c = n ? .5 : 0,
				d = n ? 0 : .5,
				f = Math.floor((t - a[0]) / i + c),
				A = Math.floor((e - a[1]) / i + d),
				p = s * f / l[0],
				g = s * A / l[1];
			return n ? (p = Math.ceil(p) - 1, g = Math.ceil(g) - 1) : (p = Math.floor(p), g = Math.floor(g)), h.a.createOrUpdate(o, p, g, r)
		}, c.prototype.getTileCoordForXYAndZ_ = function(t, e, i, n, r) {
			var o = this.getOrigin(i),
				s = this.getResolution(i),
				a = u.a.toSize(this.getTileSize(i), this.tmpSize_),
				l = n ? .5 : 0,
				c = n ? 0 : .5,
				d = Math.floor((t - o[0]) / s + l),
				f = Math.floor((e - o[1]) / s + c),
				A = d / a[0],
				p = f / a[1];
			return n ? (A = Math.ceil(A) - 1, p = Math.ceil(p) - 1) : (A = Math.floor(A), p = Math.floor(p)), h.a.createOrUpdate(i, A, p, r)
		}, c.prototype.getTileCoordForCoordAndZ = function(t, e, i) {
			return this.getTileCoordForXYAndZ_(t[0], t[1], e, !1, i)
		}, c.prototype.getTileCoordResolution = function(t) {
			return this.resolutions_[t[0]]
		}, c.prototype.getTileSize = function(t) {
			return this.tileSize_ ? this.tileSize_ : this.tileSizes_[t]
		}, c.prototype.getFullTileRange = function(t) {
			return this.fullTileRanges_ ? this.fullTileRanges_[t] : null
		}, c.prototype.getZForResolution = function(t, e) {
			var i = s.a.linearFindNearest(this.resolutions_, t, e || 0);
			return l.a.clamp(i, this.minZoom, this.maxZoom)
		}, c.prototype.calculateTileRanges_ = function(t) {
			for (var e = this.resolutions_.length, i = new Array(e), n = this.minZoom; n < e; ++n) i[n] = this.getTileRangeForExtentAndZ(t, n);
			this.fullTileRanges_ = i
		}, e.a = c
	}, function(t, e, i) {
		"use strict";
		var n = i(0),
			r = i(14),
			o = i(52),
			s = i(11),
			a = i(8),
			l = function(t) {
				r.a.call(this);
				var e = a.a.assign({}, t);
				e[o.a.OPACITY] = void 0 !== t.opacity ? t.opacity : 1, e[o.a.VISIBLE] = void 0 === t.visible || t.visible, e[o.a.Z_INDEX] = void 0 !== t.zIndex ? t.zIndex : 0, e[o.a.MAX_RESOLUTION] = void 0 !== t.maxResolution ? t.maxResolution : 1 / 0, e[o.a.MIN_RESOLUTION] = void 0 !== t.minResolution ? t.minResolution : 0, this.setProperties(e), this.state_ = {
					layer: this,
					managed: !0
				}, this.type
			};
		n.
	default.inherits(l, r.a), l.prototype.getType = function() {
			return this.type
		}, l.prototype.getLayerState = function() {
			return this.state_.opacity = s.a.clamp(this.getOpacity(), 0, 1), this.state_.sourceState = this.getSourceState(), this.state_.visible = this.getVisible(), this.state_.extent = this.getExtent(), this.state_.zIndex = this.getZIndex(), this.state_.maxResolution = this.getMaxResolution(), this.state_.minResolution = Math.max(this.getMinResolution(), 0), this.state_
		}, l.prototype.getLayersArray = function(t) {}, l.prototype.getLayerStatesArray = function(t) {}, l.prototype.getExtent = function() {
			return this.get(o.a.EXTENT)
		}, l.prototype.getMaxResolution = function() {
			return this.get(o.a.MAX_RESOLUTION)
		}, l.prototype.getMinResolution = function() {
			return this.get(o.a.MIN_RESOLUTION)
		}, l.prototype.getOpacity = function() {
			return this.get(o.a.OPACITY)
		}, l.prototype.getSourceState = function() {}, l.prototype.getVisible = function() {
			return this.get(o.a.VISIBLE)
		}, l.prototype.getZIndex = function() {
			return this.get(o.a.Z_INDEX)
		}, l.prototype.setExtent = function(t) {
			this.set(o.a.EXTENT, t)
		}, l.prototype.setMaxResolution = function(t) {
			this.set(o.a.MAX_RESOLUTION, t)
		}, l.prototype.setMinResolution = function(t) {
			this.set(o.a.MIN_RESOLUTION, t)
		}, l.prototype.setOpacity = function(t) {
			this.set(o.a.OPACITY, t)
		}, l.prototype.setVisible = function(t) {
			this.set(o.a.VISIBLE, t)
		}, l.prototype.setZIndex = function(t) {
			this.set(o.a.Z_INDEX, t)
		}, e.a = l
	}, function(t, e, i) {
		"use strict";
		var n = i(10),
			r = i(11),
			o = {
				lineString: function(t, e, i, o, s, a) {
					var l = NaN,
						u = NaN,
						h = (i - e) / o;
					if (1 === h) l = t[e], u = t[e + 1];
					else if (2 == h) l = (1 - s) * t[e] + s * t[e + o], u = (1 - s) * t[e + 1] + s * t[e + o + 1];
					else if (0 !== h) {
						var c, d = t[e],
							f = t[e + 1],
							A = 0,
							p = [0];
						for (c = e + o; c < i; c += o) {
							var g = t[c],
								m = t[c + 1];
							A += Math.sqrt((g - d) * (g - d) + (m - f) * (m - f)), p.push(A), d = g, f = m
						}
						var v = s * A,
							y = n.a.binarySearch(p, v);
						if (y < 0) {
							var _ = (v - p[-y - 2]) / (p[-y - 1] - p[-y - 2]),
								E = e + (-y - 2) * o;
							l = r.a.lerp(t[E], t[E + o], _), u = r.a.lerp(t[E + 1], t[E + o + 1], _)
						} else l = t[e + y * o], u = t[e + y * o + 1]
					}
					return a ? (a[0] = l, a[1] = u, a) : [l, u]
				},
				lineStringCoordinateAtM: function(t, e, i, n, o, s) {
					if (i == e) return null;
					var a;
					if (o < t[e + n - 1]) return s ? ((a = t.slice(e, e + n))[n - 1] = o, a) : null;
					if (t[i - 1] < o) return s ? ((a = t.slice(i - n, i))[n - 1] = o, a) : null;
					if (o == t[e + n - 1]) return t.slice(e, e + n);
					for (var l = e / n, u = i / n; l < u;) {
						var h = l + u >> 1;
						o < t[(h + 1) * n - 1] ? u = h : l = h + 1
					}
					var c = t[l * n - 1];
					if (o == c) return t.slice((l - 1) * n, (l - 1) * n + n);
					var d, f = (o - c) / (t[(l + 1) * n - 1] - c);
					for (a = [], d = 0; d < n - 1; ++d) a.push(r.a.lerp(t[(l - 1) * n + d], t[l * n + d], f));
					return a.push(o), a
				},
				lineStringsCoordinateAtM: function(t, e, i, n, r, s, a) {
					if (a) return o.lineStringCoordinateAtM(t, e, i[i.length - 1], n, r, s);
					var l, u, h;
					if (r < t[n - 1]) return s ? ((l = t.slice(0, n))[n - 1] = r, l) : null;
					if (t[t.length - 1] < r) return s ? ((l = t.slice(t.length - n))[n - 1] = r, l) : null;
					for (u = 0, h = i.length; u < h; ++u) {
						var c = i[u];
						if (e != c) {
							if (r < t[e + n - 1]) return null;
							if (r <= t[c - 1]) return o.lineStringCoordinateAtM(t, e, c, n, r, !1);
							e = c
						}
					}
					return null
				}
			};
		e.a = o
	}, function(t, e, i) {
		"use strict";
		var n = i(0),
			r = i(10),
			o = i(69),
			s = i(93),
			a = i(2),
			l = function() {
				this.xmlSerializer_ = new XMLSerializer, o.a.call(this)
			};
		n.
	default.inherits(l, o.a), l.prototype.getType = function() {
			return s.a.XML
		}, l.prototype.readFeature = function(t, e) {
			if (a.a.isDocument(t)) return this.readFeatureFromDocument(t, e);
			if (a.a.isNode(t)) return this.readFeatureFromNode(t, e);
			if ("string" == typeof t) {
				var i = a.a.parse(t);
				return this.readFeatureFromDocument(i, e)
			}
			return null
		}, l.prototype.readFeatureFromDocument = function(t, e) {
			var i = this.readFeaturesFromDocument(t, e);
			return i.length > 0 ? i[0] : null
		}, l.prototype.readFeatureFromNode = function(t, e) {
			return null
		}, l.prototype.readFeatures = function(t, e) {
			if (a.a.isDocument(t)) return this.readFeaturesFromDocument(t, e);
			if (a.a.isNode(t)) return this.readFeaturesFromNode(t, e);
			if ("string" == typeof t) {
				var i = a.a.parse(t);
				return this.readFeaturesFromDocument(i, e)
			}
			return []
		}, l.prototype.readFeaturesFromDocument = function(t, e) {
			var i, n = [];
			for (i = t.firstChild; i; i = i.nextSibling) i.nodeType == Node.ELEMENT_NODE && r.a.extend(n, this.readFeaturesFromNode(i, e));
			return n
		}, l.prototype.readFeaturesFromNode = function(t, e) {}, l.prototype.readGeometry = function(t, e) {
			if (a.a.isDocument(t)) return this.readGeometryFromDocument(t, e);
			if (a.a.isNode(t)) return this.readGeometryFromNode(t, e);
			if ("string" == typeof t) {
				var i = a.a.parse(t);
				return this.readGeometryFromDocument(i, e)
			}
			return null
		}, l.prototype.readGeometryFromDocument = function(t, e) {
			return null
		}, l.prototype.readGeometryFromNode = function(t, e) {
			return null
		}, l.prototype.readProjection = function(t) {
			if (a.a.isDocument(t)) return this.readProjectionFromDocument(t);
			if (a.a.isNode(t)) return this.readProjectionFromNode(t);
			if ("string" == typeof t) {
				var e = a.a.parse(t);
				return this.readProjectionFromDocument(e)
			}
			return null
		}, l.prototype.readProjectionFromDocument = function(t) {
			return this.defaultDataProjection
		}, l.prototype.readProjectionFromNode = function(t) {
			return this.defaultDataProjection
		}, l.prototype.writeFeature = function(t, e) {
			var i = this.writeFeatureNode(t, e);
			return this.xmlSerializer_.serializeToString(i)
		}, l.prototype.writeFeatureNode = function(t, e) {
			return null
		}, l.prototype.writeFeatures = function(t, e) {
			var i = this.writeFeaturesNode(t, e);
			return this.xmlSerializer_.serializeToString(i)
		}, l.prototype.writeFeaturesNode = function(t, e) {
			return null
		}, l.prototype.writeGeometry = function(t, e) {
			var i = this.writeGeometryNode(t, e);
			return this.xmlSerializer_.serializeToString(i)
		}, l.prototype.writeGeometryNode = function(t, e) {
			return null
		}, e.a = l
	}, function(t, e, i) {
		"use strict";
		Object.defineProperty(e, "__esModule", {
			value: !0
		}), e.GisUtil = void 0;
		var n = i(63),
			r = function(t) {
				if (t && t.__esModule) return t;
				var e = {};
				if (null != t) for (var i in t) Object.prototype.hasOwnProperty.call(t, i) && (e[i] = t[i]);
				return e.
			default = t, e
			}(i(55));
		var o = {
			factors: {
				miles: 3960,
				nauticalmiles: 3441.145,
				degrees: 57.2957795,
				radians: 1,
				inches: 250905600,
				yards: 6969600,
				meters: 6373e3,
				metres: 6373e3,
				kilometers: 6373,
				kilometres: 6373,
				feet: 20908792.65
			},
			collisionCal: function(t, e, i) {
				e /= 1.3;
				for (var n = [], r = 0; r < t.length; r++) {
					for (var o = !0, s = 0; s < n.length; s++) if (this.distance(t[r], n[s], e, i)) {
						o = !1;
						break
					}
					o && n.push(t[r])
				}
				return n
			},
			distance: function(t, e, i, n) {
				var r = t.label.length * n,
					o = t.width + r,
					s = e.label.length * n,
					a = e.width + s,
					l = t.labOffsetX || 0,
					u = t.labOffsetY || 0,
					h = e.labOffsetX || 0,
					c = e.labOffsetY || 0,
					d = Math.max(t.height, n),
					f = Math.max(e.height, n),
					A = t.coord[0] - i * o / 2 + l * i,
					p = t.coord[1] - i * d / 2 + u * i,
					g = t.coord[0] + i * o / 2 + l * i,
					m = t.coord[1] + i * d / 2 + u * i,
					v = e.coord[0] - i * a / 2 + h * i,
					y = e.coord[1] - i * f / 2 + c * i,
					_ = e.coord[0] + i * a / 2 + h * i,
					E = e.coord[1] + i * f / 2 + c * i;
				return !(A > _ || v > g || p > E || y > m)
			},
			loadJson: function(t, e, i, n) {
				var r = new XMLHttpRequest;
				r.open("GET", t, !0), "arraybuffer" === e && (r.responseType = "arraybuffer"), r.onload = function() {
					var t;
					!r.status || r.status >= 200 && r.status < 300 ? ("json" === e || "text" === e ? t = r.responseText : "arraybuffer" === e && (t = r.response), t ? i && i(t) : n && n()) : n && n()
				}, r.onerror = function() {
					n && n()
				}, r.send()
			},
			judgeQuadrant: function(t, e) {
				var i = t[0],
					n = t[1],
					r = e[0],
					o = e[1];
				return o >= n && r >= i ? 1 : o >= n && r < i ? 2 : o < n && r <= i ? 3 : o < n && r >= i ? 4 : void 0
			},
			inRing: function(t, e, i) {
				var n = !1,
					r = e[0];
				r[0][0] === r[r.length - 1][0] && r[0][1] === r[r.length - 1][1] && (r = r.slice(0, r.length - 1));
				for (var o = 0, s = r.length - 1; o < r.length; s = o++) {
					var a = r[o][0],
						l = r[o][1],
						u = r[s][0],
						h = r[s][1];
					if (t[1] * (a - u) + l * (u - t[0]) + h * (t[0] - a) == 0 && (a - t[0]) * (u - t[0]) <= 0 && (l - t[1]) * (h - t[1]) <= 0) return !i;
					l > t[1] != h > t[1] && t[0] < (u - a) * (t[1] - l) / (h - l) + a && (n = !n)
				}
				return n
			},
			pointsWithinPolygon: function(t, e) {
				for (var i = [], n = 0; n < t.length; n++) {
					this.inRing(t[n].coord, e) && i.push(t[n])
				}
				return i
			},
			lineIntersects: function(t, e, i, n, r, o, s, a) {
				var l, u, h, c, d = {
					x: null,
					y: null,
					onLine1: !1,
					onLine2: !1
				};
				return 0 === (l = (a - o) * (i - t) - (s - r) * (n - e)) ? null !== d.x && null !== d.y && d : (c = (i - t) * (u = e - o) - (n - e) * (h = t - r), u = ((s - r) * u - (a - o) * h) / l, h = c / l, d.x = t + u * (i - t), d.y = e + u * (n - e), u >= 0 && u <= 1 && (d.onLine1 = !0), h >= 0 && h <= 1 && (d.onLine2 = !0), !(!d.onLine1 || !d.onLine2) && [d.x, d.y])
			},
			selfIntersections: function(t) {
				var e = [],
					i = this;
				return t.forEach((function(n) {
					t.forEach((function(t) {
						for (var r = 0; r < n.length - 1; r++) for (var o = r; o < t.length - 1; o++) {
							if (n === t) {
								if (1 === Math.abs(r - o)) continue;
								if (0 === r && o === n.length - 2 && n[r][0] === n[n.length - 1][0] && n[r][1] === n[n.length - 1][1]) continue
							}
							var s = i.lineIntersects(n[r][0], n[r][1], n[r + 1][0], n[r + 1][1], t[o][0], t[o][1], t[o + 1][0], t[o + 1][1]);
							s && e.push(s)
						}
					}))
				})), e
			},
			distanceToRadians: function(t, e, i) {
				var r = Math.PI / 180,
					o = 180 / Math.PI,
					s = r * t[0],
					a = r * t[1],
					l = r * i,
					u = e / n.MapConstant.mapRadius * 1e3,
					h = Math.asin(Math.sin(a) * Math.cos(u) + Math.cos(a) * Math.sin(u) * Math.cos(l));
				return [o * (s + Math.atan2(Math.sin(l) * Math.sin(u) * Math.cos(a), Math.cos(u) - Math.sin(a) * Math.sin(h))), o * h]
			},
			circle: function(t, e, i) {
				if (!t) throw new Error("center is required");
				if (!e) throw new Error("radius is required");
				i = i || 64;
				for (var n = [], r = 0; r < i; r++) n.push(this.distanceToRadians(t, e, 360 * r / i));
				return n.push(n[0]), [n]
			},
			getArrowCoords: function(t, e, i) {
				var n = t[0][0],
					o = t[1][0],
					s = t[0][1],
					a = t[1][1],
					l = r.isDefAndNotNull(e) ? e : .2,
					u = r.isDefAndNotNull(i) ? i : 1,
					h = Math.PI / 6,
					c = o - n >= 0 ? 1 : -1,
					d = n + (o - n) * u,
					f = s + (a - s) * u,
					A = Math.atan((a - s) / (o - n)),
					p = A + Math.PI - h,
					g = A + Math.PI + h;
				return [[d + c * Math.cos(p) * l, f + c * Math.sin(p) * l], [d, f], [d + c * Math.cos(g) * l, f + c * Math.sin(g) * l]]
			},
			getLineAngle: function(t, e) {
				var i = t[0] - e[0],
					n = t[1] - e[1],
					r = 0;
				return i > 0 && n > 0 ? r = Math.PI + Math.atan(i / n) : i > 0 && n < 0 ? r = 2 * Math.PI - Math.atan(i / Math.abs(n)) : i < 0 && n < 0 ? r = Math.atan(Math.abs(i) / Math.abs(n)) : i < 0 && n > 0 ? r = Math.PI - Math.atan(Math.abs(i) / n) : i < 0 && 0 == n ? r = Math.PI / 2 : 0 == i && n > 0 ? r = Math.PI : i > 0 && 0 == n ? r = 3 * Math.PI / 2 : 0 == i && n < 0 && (r = 2 * Math.PI), 180 * r / Math.PI
			},
			calEndPointCoords: function(t, e, i) {
				var n, r, o = i * Math.PI / 180;
				return o > 0 && o < Math.PI / 2 ? (n = t[0] + Math.sin(o) * e, r = t[1] + Math.cos(o) * e) : o === Math.PI / 2 ? (n = t[0] + e, r = t[1]) : o > Math.PI / 2 && o < Math.PI ? (n = t[0] + Math.cos(o - Math.PI / 2) * e, r = t[1] - Math.sin(o - Math.PI / 2) * e) : o === Math.PI ? (n = t[0], r = t[1] - e) : o > Math.PI && o < 3 * Math.PI / 2 ? (n = t[0] - Math.cos(3 * Math.PI / 2 - o) * e, r = t[1] - Math.sin(3 * Math.PI / 2 - o) * e) : o === 3 * Math.PI / 2 ? (n = t[0] - e, r = t[1]) : o > 3 * Math.PI / 2 && o < 2 * Math.PI ? (n = t[0] - Math.cos(o - 3 * Math.PI / 2) * e, r = t[1] + Math.sin(o - 3 * Math.PI / 2) * e) : 0 !== o && o !== 2 * Math.PI || (n = t[0], r = t[1] + e), [n, r]
			},
			getPointInLine: function(t, e, i, n) {
				var r = [],
					o = [];
				if (t[0] < e[0]) for (o = t; o[0] <= e[0];) {
					var s = this.calEndPointCoords(o, n, i);
					o = s, r.push(s)
				} else if (t[0] > e[0]) for (o = t; o[0] >= e[0];) {
					var a = this.calEndPointCoords(o, n, i);
					o = a, r.push(a)
				}
				for (var l = 0; l < r.length; l++) if (t[0] >= e[0]) {
					if (r[l][0] < e[0]) {
						r.splice(l);
						break
					}
				} else if (r[l][0] > e[0]) {
					r.splice(l);
					break
				}
				return r
			},
			extentExtend: function(t, e) {
				return e[0] < t[0] && (t[0] = e[0]), e[2] > t[2] && (t[2] = e[2]), e[1] < t[1] && (t[1] = e[1]), e[3] > t[3] && (t[3] = e[3]), t
			}
		};
		e.GisUtil = o
	}, function(t, e, i) {
		"use strict";
		var n = i(0),
			r = i(98),
			o = function(t, e, i, n, o) {
				r.a.call(this, t, e, o), this.originalEvent = i, this.pixel = e.getEventPixel(i), this.coordinate = e.getCoordinateFromPixel(this.pixel), this.dragging = void 0 !== n && n
			};
		n.
	default.inherits(o, r.a), o.prototype.preventDefault = function() {
			r.a.prototype.preventDefault.call(this), this.originalEvent.preventDefault()
		}, o.prototype.stopPropagation = function() {
			r.a.prototype.stopPropagation.call(this), this.originalEvent.stopPropagation()
		}, e.a = o
	}, function(t, e, i) {
		"use strict";
		var n = i(0),
			r = i(1),
			o = i(18),
			s = i(4),
			a = i(40),
			l = i(102),
			u = i(70),
			h = i(64),
			c = i(65),
			d = i(76),
			f = function(t, e) {
				a.a.call(this), this.maxDelta_ = -1, this.maxDeltaRevision_ = -1, this.setCoordinates(t, e)
			};
		n.
	default.inherits(f, a.a), f.prototype.clone = function() {
			var t = new f(null);
			return t.setFlatCoordinates(this.layout, this.flatCoordinates.slice()), t
		}, f.prototype.closestPointXY = function(t, e, i, n) {
			return n < r.
		default.closestSquaredDistanceXY(this.getExtent(), t, e) ? n:
			(this.maxDeltaRevision_ != this.getRevision() && (this.maxDelta_ = Math.sqrt(u.a.getMaxSquaredDelta(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, 0)), this.maxDeltaRevision_ = this.getRevision()), u.a.getClosestPoint(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, this.maxDelta_, !0, t, e, i, n))
		}, f.prototype.getArea = function() {
			return l.a.linearRing(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride)
		}, f.prototype.getCoordinates = function() {
			return c.a.coordinates(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride)
		}, f.prototype.getSimplifiedGeometryInternal = function(t) {
			var e = [];
			e.length = d.a.douglasPeucker(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, t, e, 0);
			var i = new f(null);
			return i.setFlatCoordinates(o.a.XY, e), i
		}, f.prototype.getType = function() {
			return s.a.LINEAR_RING
		}, f.prototype.intersectsExtent = function(t) {}, f.prototype.setCoordinates = function(t, e) {
			t ? (this.setLayout(e, t, 1), this.flatCoordinates || (this.flatCoordinates = []), this.flatCoordinates.length = h.a.coordinates(this.flatCoordinates, 0, t, this.stride), this.changed()) : this.setFlatCoordinates(o.a.XY, null)
		}, f.prototype.setFlatCoordinates = function(t, e) {
			this.setFlatCoordinatesInternal(t, e), this.changed()
		}, e.a = f
	}, function(t, e, i) {
		"use strict";
		var n = i(0),
			r = i(95),
			o = i(47),
			s = {
				Projection_: function(t, e) {
					r.a.call(this, {
						code: t,
						units: o.a.DEGREES,
						extent: s.EXTENT,
						axisOrientation: e,
						global: !0,
						metersPerUnit: s.METERS_PER_UNIT,
						worldExtent: s.EXTENT
					})
				}
			};
		n.
	default.inherits(s.Projection_, r.a), s.RADIUS = 6378137, s.EXTENT = [-180, -90, 180, 90], s.METERS_PER_UNIT = Math.PI * s.RADIUS / 180, s.PROJECTIONS = [new s.Projection_("CRS:84"), new s.Projection_("EPSG:4326", "neu"), new s.Projection_("urn:ogc:def:crs:EPSG::4326", "neu"), new s.Projection_("urn:ogc:def:crs:EPSG:6.6:4326", "neu"), new s.Projection_("urn:ogc:def:crs:OGC:1.3:CRS84"), new s.Projection_("urn:ogc:def:crs:OGC:2:84"), new s.Projection_("http://www.opengis.net/gml/srs/epsg.xml#4326", "neu"), new s.Projection_("urn:x-ogc:def:crs:EPSG:4326", "neu")], e.a = s
	}, function(t, e, i) {
		"use strict";
		var n = i(0),
			r = i(3),
			o = i(50),
			s = i(35),
			a = i(66),
			l = function(t, e) {
				this.dispatcher = t, this.mapping_ = e
			};
		l.prototype.getEvents = function() {
			return Object.keys(this.mapping_)
		}, l.prototype.getHandlerForEvent = function(t) {
			return this.mapping_[t]
		};
		var u = l,
			h = function(t) {
				var e = {
					mousedown: this.mousedown,
					mousemove: this.mousemove,
					mouseup: this.mouseup,
					mouseover: this.mouseover,
					mouseout: this.mouseout
				};
				u.call(this, t, e), this.pointerMap = t.pointerMap, this.lastTouches = []
			};
		n.
	default.inherits(h, u), h.POINTER_ID = 1, h.POINTER_TYPE = "mouse", h.DEDUP_DIST = 25, h.prototype.isEventSimulatedFromTouch_ = function(t) {
			for (var e, i = this.lastTouches, n = t.clientX, r = t.clientY, o = 0, s = i.length; o < s && (e = i[o]); o++) {
				var a = Math.abs(n - e[0]),
					l = Math.abs(r - e[1]);
				if (a <= h.DEDUP_DIST && l <= h.DEDUP_DIST) return !0
			}
			return !1
		}, h.prepareEvent = function(t, e) {
			var i = e.cloneEvent(t, t),
				n = i.preventDefault;
			return i.preventDefault = function() {
				t.preventDefault(), n()
			}, i.pointerId = h.POINTER_ID, i.isPrimary = !0, i.pointerType = h.POINTER_TYPE, i
		}, h.prototype.mousedown = function(t) {
			if (!this.isEventSimulatedFromTouch_(t)) {
				h.POINTER_ID.toString() in this.pointerMap && this.cancel(t);
				var e = h.prepareEvent(t, this.dispatcher);
				this.pointerMap[h.POINTER_ID.toString()] = t, this.dispatcher.down(e, t)
			}
		}, h.prototype.mousemove = function(t) {
			if (!this.isEventSimulatedFromTouch_(t)) {
				var e = h.prepareEvent(t, this.dispatcher);
				this.dispatcher.move(e, t)
			}
		}, h.prototype.mouseup = function(t) {
			if (!this.isEventSimulatedFromTouch_(t)) {
				var e = this.pointerMap[h.POINTER_ID.toString()];
				if (e && e.button === t.button) {
					var i = h.prepareEvent(t, this.dispatcher);
					this.dispatcher.up(i, t), this.cleanupMouse()
				}
			}
		}, h.prototype.mouseover = function(t) {
			if (!this.isEventSimulatedFromTouch_(t)) {
				var e = h.prepareEvent(t, this.dispatcher);
				this.dispatcher.enterOver(e, t)
			}
		}, h.prototype.mouseout = function(t) {
			if (!this.isEventSimulatedFromTouch_(t)) {
				var e = h.prepareEvent(t, this.dispatcher);
				this.dispatcher.leaveOut(e, t)
			}
		}, h.prototype.cancel = function(t) {
			var e = h.prepareEvent(t, this.dispatcher);
			this.dispatcher.cancel(e, t), this.cleanupMouse()
		}, h.prototype.cleanupMouse = function() {
			delete this.pointerMap[h.POINTER_ID.toString()]
		};
		var c = h,
			d = function(t) {
				var e = {
					MSPointerDown: this.msPointerDown,
					MSPointerMove: this.msPointerMove,
					MSPointerUp: this.msPointerUp,
					MSPointerOut: this.msPointerOut,
					MSPointerOver: this.msPointerOver,
					MSPointerCancel: this.msPointerCancel,
					MSGotPointerCapture: this.msGotPointerCapture,
					MSLostPointerCapture: this.msLostPointerCapture
				};
				u.call(this, t, e), this.pointerMap = t.pointerMap, this.POINTER_TYPES = ["", "unavailable", "touch", "pen", "mouse"]
			};
		n.
	default.inherits(d, u), d.prototype.prepareEvent_ = function(t) {
			var e = t;
			return "number" == typeof t.pointerType && ((e = this.dispatcher.cloneEvent(t, t)).pointerType = this.POINTER_TYPES[t.pointerType]), e
		}, d.prototype.cleanup = function(t) {
			delete this.pointerMap[t.toString()]
		}, d.prototype.msPointerDown = function(t) {
			this.pointerMap[t.pointerId.toString()] = t;
			var e = this.prepareEvent_(t);
			this.dispatcher.down(e, t)
		}, d.prototype.msPointerMove = function(t) {
			var e = this.prepareEvent_(t);
			this.dispatcher.move(e, t)
		}, d.prototype.msPointerUp = function(t) {
			var e = this.prepareEvent_(t);
			this.dispatcher.up(e, t), this.cleanup(t.pointerId)
		}, d.prototype.msPointerOut = function(t) {
			var e = this.prepareEvent_(t);
			this.dispatcher.leaveOut(e, t)
		}, d.prototype.msPointerOver = function(t) {
			var e = this.prepareEvent_(t);
			this.dispatcher.enterOver(e, t)
		}, d.prototype.msPointerCancel = function(t) {
			var e = this.prepareEvent_(t);
			this.dispatcher.cancel(e, t), this.cleanup(t.pointerId)
		}, d.prototype.msLostPointerCapture = function(t) {
			var e = this.dispatcher.makeEvent("lostpointercapture", t, t);
			this.dispatcher.dispatchEvent(e)
		}, d.prototype.msGotPointerCapture = function(t) {
			var e = this.dispatcher.makeEvent("gotpointercapture", t, t);
			this.dispatcher.dispatchEvent(e)
		};
		var f = d,
			A = function(t) {
				var e = {
					pointerdown: this.pointerDown,
					pointermove: this.pointerMove,
					pointerup: this.pointerUp,
					pointerout: this.pointerOut,
					pointerover: this.pointerOver,
					pointercancel: this.pointerCancel,
					gotpointercapture: this.gotPointerCapture,
					lostpointercapture: this.lostPointerCapture
				};
				u.call(this, t, e)
			};
		n.
	default.inherits(A, u), A.prototype.pointerDown = function(t) {
			this.dispatcher.fireNativeEvent(t)
		}, A.prototype.pointerMove = function(t) {
			this.dispatcher.fireNativeEvent(t)
		}, A.prototype.pointerUp = function(t) {
			this.dispatcher.fireNativeEvent(t)
		}, A.prototype.pointerOut = function(t) {
			this.dispatcher.fireNativeEvent(t)
		}, A.prototype.pointerOver = function(t) {
			this.dispatcher.fireNativeEvent(t)
		}, A.prototype.pointerCancel = function(t) {
			this.dispatcher.fireNativeEvent(t)
		}, A.prototype.lostPointerCapture = function(t) {
			this.dispatcher.fireNativeEvent(t)
		}, A.prototype.gotPointerCapture = function(t) {
			this.dispatcher.fireNativeEvent(t)
		};
		var p = A,
			g = i(21),
			m = function(t, e, i) {
				g.a.call(this, t), this.originalEvent = e;
				var n = i || {};
				this.buttons = this.getButtons_(n), this.pressure = this.getPressure_(n, this.buttons), this.bubbles = "bubbles" in n && n.bubbles, this.cancelable = "cancelable" in n && n.cancelable, this.view = "view" in n ? n.view : null, this.detail = "detail" in n ? n.detail : null, this.screenX = "screenX" in n ? n.screenX : 0, this.screenY = "screenY" in n ? n.screenY : 0, this.clientX = "clientX" in n ? n.clientX : 0, this.clientY = "clientY" in n ? n.clientY : 0, this.ctrlKey = "ctrlKey" in n && n.ctrlKey, this.altKey = "altKey" in n && n.altKey, this.shiftKey = "shiftKey" in n && n.shiftKey, this.metaKey = "metaKey" in n && n.metaKey, this.button = "button" in n ? n.button : 0, this.relatedTarget = "relatedTarget" in n ? n.relatedTarget : null, this.pointerId = "pointerId" in n ? n.pointerId : 0, this.width = "width" in n ? n.width : 0, this.height = "height" in n ? n.height : 0, this.tiltX = "tiltX" in n ? n.tiltX : 0, this.tiltY = "tiltY" in n ? n.tiltY : 0, this.pointerType = "pointerType" in n ? n.pointerType : "", this.hwTimestamp = "hwTimestamp" in n ? n.hwTimestamp : 0, this.isPrimary = "isPrimary" in n && n.isPrimary, e.preventDefault && (this.preventDefault = function() {
					e.preventDefault()
				})
			};
		n.
	default.inherits(m, g.a), m.prototype.getButtons_ = function(t) {
			var e;
			if (t.buttons || m.HAS_BUTTONS) e = t.buttons;
			else switch (t.which) {
			case 1:
				e = 1;
				break;
			case 2:
				e = 4;
				break;
			case 3:
				e = 2;
				break;
			default:
				e = 0
			}
			return e
		}, m.prototype.getPressure_ = function(t, e) {
			return t.pressure ? t.pressure : e ? .5 : 0
		}, m.HAS_BUTTONS = !1, function() {
			try {
				var t = new MouseEvent("click", {
					buttons: 1
				});
				m.HAS_BUTTONS = 1 === t.buttons
			} catch (t) {}
		}();
		var v = m,
			y = i(10),
			_ = function(t, e) {
				var i = {
					touchstart: this.touchstart,
					touchmove: this.touchmove,
					touchend: this.touchend,
					touchcancel: this.touchcancel
				};
				u.call(this, t, i), this.pointerMap = t.pointerMap, this.mouseSource = e, this.firstTouchId_ = void 0, this.clickCount_ = 0, this.resetId_ = void 0
			};
		n.
	default.inherits(_, u), _.DEDUP_TIMEOUT = 2500, _.CLICK_COUNT_TIMEOUT = 200, _.POINTER_TYPE = "touch", _.prototype.isPrimaryTouch_ = function(t) {
			return this.firstTouchId_ === t.identifier
		}, _.prototype.setPrimaryTouch_ = function(t) {
			var e = Object.keys(this.pointerMap).length;
			(0 === e || 1 === e && c.POINTER_ID.toString() in this.pointerMap) && (this.firstTouchId_ = t.identifier, this.cancelResetClickCount_())
		}, _.prototype.removePrimaryPointer_ = function(t) {
			t.isPrimary && (this.firstTouchId_ = void 0, this.resetClickCount_())
		}, _.prototype.resetClickCount_ = function() {
			this.resetId_ = setTimeout(this.resetClickCountHandler_.bind(this), _.CLICK_COUNT_TIMEOUT)
		}, _.prototype.resetClickCountHandler_ = function() {
			this.clickCount_ = 0, this.resetId_ = void 0
		}, _.prototype.cancelResetClickCount_ = function() {
			void 0 !== this.resetId_ && clearTimeout(this.resetId_)
		}, _.prototype.touchToPointer_ = function(t, e) {
			var i = this.dispatcher.cloneEvent(t, e);
			return i.pointerId = e.identifier + 2, i.bubbles = !0, i.cancelable = !0, i.detail = this.clickCount_, i.button = 0, i.buttons = 1, i.width = e.webkitRadiusX || e.radiusX || 0, i.height = e.webkitRadiusY || e.radiusY || 0, i.pressure = e.webkitForce || e.force || .5, i.isPrimary = this.isPrimaryTouch_(e), i.pointerType = _.POINTER_TYPE, i.clientX = e.clientX, i.clientY = e.clientY, i.screenX = e.screenX, i.screenY = e.screenY, i
		}, _.prototype.processTouches_ = function(t, e) {
			var i, n, r = Array.prototype.slice.call(t.changedTouches),
				o = r.length;

			function s() {
				t.preventDefault()
			}
			for (i = 0; i < o; ++i)(n = this.touchToPointer_(t, r[i])).preventDefault = s, e.call(this, t, n)
		}, _.prototype.findTouch_ = function(t, e) {
			for (var i = t.length, n = 0; n < i; n++) if (t[n].identifier === e) return !0;
			return !1
		}, _.prototype.vacuumTouches_ = function(t) {
			var e = t.touches,
				i = Object.keys(this.pointerMap),
				n = i.length;
			if (n >= e.length) {
				var r, o, s, a = [];
				for (r = 0; r < n; ++r) o = i[r], s = this.pointerMap[o], o == c.POINTER_ID || this.findTouch_(e, o - 2) || a.push(s.out);
				for (r = 0; r < a.length; ++r) this.cancelOut_(t, a[r])
			}
		}, _.prototype.touchstart = function(t) {
			this.vacuumTouches_(t), this.setPrimaryTouch_(t.changedTouches[0]), this.dedupSynthMouse_(t), this.clickCount_++, this.processTouches_(t, this.overDown_)
		}, _.prototype.overDown_ = function(t, e) {
			this.pointerMap[e.pointerId] = {
				target: e.target,
				out: e,
				outTarget: e.target
			}, this.dispatcher.over(e, t), this.dispatcher.enter(e, t), this.dispatcher.down(e, t)
		}, _.prototype.touchmove = function(t) {
			t.preventDefault(), this.processTouches_(t, this.moveOverOut_)
		}, _.prototype.moveOverOut_ = function(t, e) {
			var i = e,
				n = this.pointerMap[i.pointerId];
			if (n) {
				var r = n.out,
					o = n.outTarget;
				this.dispatcher.move(i, t), r && o !== i.target && (r.relatedTarget = i.target, i.relatedTarget = o, r.target = o, i.target ? (this.dispatcher.leaveOut(r, t), this.dispatcher.enterOver(i, t)) : (i.target = o, i.relatedTarget = null, this.cancelOut_(t, i))), n.out = i, n.outTarget = i.target
			}
		}, _.prototype.touchend = function(t) {
			this.dedupSynthMouse_(t), this.processTouches_(t, this.upOut_)
		}, _.prototype.upOut_ = function(t, e) {
			this.dispatcher.up(e, t), this.dispatcher.out(e, t), this.dispatcher.leave(e, t), this.cleanUpPointer_(e)
		}, _.prototype.touchcancel = function(t) {
			this.processTouches_(t, this.cancelOut_)
		}, _.prototype.cancelOut_ = function(t, e) {
			this.dispatcher.cancel(e, t), this.dispatcher.out(e, t), this.dispatcher.leave(e, t), this.cleanUpPointer_(e)
		}, _.prototype.cleanUpPointer_ = function(t) {
			delete this.pointerMap[t.pointerId], this.removePrimaryPointer_(t)
		}, _.prototype.dedupSynthMouse_ = function(t) {
			var e = this.mouseSource.lastTouches,
				i = t.changedTouches[0];
			if (this.isPrimaryTouch_(i)) {
				var n = [i.clientX, i.clientY];
				e.push(n), setTimeout((function() {
					y.a.remove(e, n)
				}), _.DEDUP_TIMEOUT)
			}
		};
		var E = _,
			x = function(t) {
				o.a.call(this), this.element_ = t, this.pointerMap = {}, this.eventMap_ = {}, this.eventSourceList_ = [], this.registerSources()
			};
		n.
	default.inherits(x, o.a), x.prototype.registerSources = function() {
			if (s.a.POINTER) this.registerSource("native", new p(this));
			else if (s.a.MSPOINTER) this.registerSource("ms", new f(this));
			else {
				var t = new c(this);
				this.registerSource("mouse", t), s.a.TOUCH && this.registerSource("touch", new E(this, t))
			}
			this.register_()
		}, x.prototype.registerSource = function(t, e) {
			var i = e,
				n = i.getEvents();
			n && (n.forEach((function(t) {
				var e = i.getHandlerForEvent(t);
				e && (this.eventMap_[t] = e.bind(i))
			}), this), this.eventSourceList_.push(i))
		}, x.prototype.register_ = function() {
			for (var t, e = this.eventSourceList_.length, i = 0; i < e; i++) t = this.eventSourceList_[i], this.addEvents_(t.getEvents())
		}, x.prototype.unregister_ = function() {
			for (var t, e = this.eventSourceList_.length, i = 0; i < e; i++) t = this.eventSourceList_[i], this.removeEvents_(t.getEvents())
		}, x.prototype.eventHandler_ = function(t) {
			var e = t.type,
				i = this.eventMap_[e];
			i && i(t)
		}, x.prototype.addEvents_ = function(t) {
			t.forEach((function(t) {
				r.a.listen(this.element_, t, this.eventHandler_, this)
			}), this)
		}, x.prototype.removeEvents_ = function(t) {
			t.forEach((function(t) {
				r.a.unlisten(this.element_, t, this.eventHandler_, this)
			}), this)
		}, x.prototype.cloneEvent = function(t, e) {
			for (var i, n = {}, r = 0, o = x.CLONE_PROPS.length; r < o; r++) n[i = x.CLONE_PROPS[r][0]] = t[i] || e[i] || x.CLONE_PROPS[r][1];
			return n
		}, x.prototype.down = function(t, e) {
			this.fireEvent(a.a.POINTERDOWN, t, e)
		}, x.prototype.move = function(t, e) {
			this.fireEvent(a.a.POINTERMOVE, t, e)
		}, x.prototype.up = function(t, e) {
			this.fireEvent(a.a.POINTERUP, t, e)
		}, x.prototype.enter = function(t, e) {
			t.bubbles = !1, this.fireEvent(a.a.POINTERENTER, t, e)
		}, x.prototype.leave = function(t, e) {
			t.bubbles = !1, this.fireEvent(a.a.POINTERLEAVE, t, e)
		}, x.prototype.over = function(t, e) {
			t.bubbles = !0, this.fireEvent(a.a.POINTEROVER, t, e)
		}, x.prototype.out = function(t, e) {
			t.bubbles = !0, this.fireEvent(a.a.POINTEROUT, t, e)
		}, x.prototype.cancel = function(t, e) {
			this.fireEvent(a.a.POINTERCANCEL, t, e)
		}, x.prototype.leaveOut = function(t, e) {
			this.out(t, e), this.contains_(t.target, t.relatedTarget) || this.leave(t, e)
		}, x.prototype.enterOver = function(t, e) {
			this.over(t, e), this.contains_(t.target, t.relatedTarget) || this.enter(t, e)
		}, x.prototype.contains_ = function(t, e) {
			return !(!t || !e) && t.contains(e)
		}, x.prototype.makeEvent = function(t, e, i) {
			return new v(t, i, e)
		}, x.prototype.fireEvent = function(t, e, i) {
			var n = this.makeEvent(t, e, i);
			this.dispatchEvent(n)
		}, x.prototype.fireNativeEvent = function(t) {
			var e = this.makeEvent(t.type, t, t);
			this.dispatchEvent(e)
		}, x.prototype.wrapMouseEvent = function(t, e) {
			return this.makeEvent(t, c.prepareEvent(e, this), e)
		}, x.prototype.disposeInternal = function() {
			this.unregister_(), o.a.prototype.disposeInternal.call(this)
		}, x.CLONE_PROPS = [
			["bubbles", !1],
			["cancelable", !1],
			["view", null],
			["detail", null],
			["screenX", 0],
			["screenY", 0],
			["clientX", 0],
			["clientY", 0],
			["ctrlKey", !1],
			["altKey", !1],
			["shiftKey", !1],
			["metaKey", !1],
			["button", 0],
			["relatedTarget", null],
			["buttons", 0],
			["pointerId", 0],
			["width", 0],
			["height", 0],
			["pressure", 0],
			["tiltX", 0],
			["tiltY", 0],
			["pointerType", ""],
			["hwTimestamp", 0],
			["isPrimary", !1],
			["type", ""],
			["target", null],
			["currentTarget", null],
			["which", 0]
		];
		e.a = x
	}, function(t, e, i) {
		"use strict";
		var n = i(0),
			r = i(27),
			o = i(42),
			s = i(125),
			a = i(35),
			l = i(24),
			u = i(78),
			h = i(3),
			c = i(50),
			d = i(66),
			f = i(128),
			A = function(t, e) {
				c.a.call(this), this.map_ = t, this.clickTimeoutId_ = 0, this.dragging_ = !1, this.dragListenerKeys_ = [], this.moveTolerance_ = e ? e * a.a.DEVICE_PIXEL_RATIO : a.a.DEVICE_PIXEL_RATIO, this.down_ = null;
				var i = this.map_.getViewport();
				this.activePointers_ = 0, this.trackedTouches_ = {}, this.pointerEventHandler_ = new f.a(i), this.documentPointerEventHandler_ = null, this.pointerdownListenerKey_ = h.a.listen(this.pointerEventHandler_, d.a.POINTERDOWN, this.handlePointerDown_, this), this.relayedListenerKey_ = h.a.listen(this.pointerEventHandler_, d.a.POINTERMOVE, this.relayEvent_, this)
			};
		n.
	default.inherits(A, c.a), A.prototype.emulateClick_ = function(t) {
			var e = new u.a(l.a.CLICK, this.map_, t);
			this.dispatchEvent(e), 0 !== this.clickTimeoutId_ ? (clearTimeout(this.clickTimeoutId_), this.clickTimeoutId_ = 0, e = new u.a(l.a.DBLCLICK, this.map_, t), this.dispatchEvent(e)) : this.clickTimeoutId_ = setTimeout(function() {
				this.clickTimeoutId_ = 0;
				var e = new u.a(l.a.SINGLECLICK, this.map_, t);
				this.dispatchEvent(e)
			}.bind(this), 250)
		}, A.prototype.updateActivePointers_ = function(t) {
			var e = t;
			e.type == l.a.POINTERUP || e.type == l.a.POINTERCANCEL ? delete this.trackedTouches_[e.pointerId] : e.type == l.a.POINTERDOWN && (this.trackedTouches_[e.pointerId] = !0), this.activePointers_ = Object.keys(this.trackedTouches_).length
		}, A.prototype.handlePointerUp_ = function(t) {
			this.updateActivePointers_(t);
			var e = new u.a(l.a.POINTERUP, this.map_, t);
			this.dispatchEvent(e), e.propagationStopped || this.dragging_ || !this.isMouseActionButton_(t) || this.emulateClick_(this.down_), 0 === this.activePointers_ && (this.dragListenerKeys_.forEach(h.a.unlistenByKey), this.dragListenerKeys_.length = 0, this.dragging_ = !1, this.down_ = null, this.documentPointerEventHandler_.dispose(), this.documentPointerEventHandler_ = null)
		}, A.prototype.isMouseActionButton_ = function(t) {
			return 0 === t.button
		}, A.prototype.handlePointerDown_ = function(t) {
			this.updateActivePointers_(t);
			var e = new u.a(l.a.POINTERDOWN, this.map_, t);
			this.dispatchEvent(e), this.down_ = t, 0 === this.dragListenerKeys_.length && (this.documentPointerEventHandler_ = new f.a(document), this.dragListenerKeys_.push(h.a.listen(this.documentPointerEventHandler_, l.a.POINTERMOVE, this.handlePointerMove_, this), h.a.listen(this.documentPointerEventHandler_, l.a.POINTERUP, this.handlePointerUp_, this), h.a.listen(this.pointerEventHandler_, l.a.POINTERCANCEL, this.handlePointerUp_, this)))
		}, A.prototype.handlePointerMove_ = function(t) {
			if (this.isMoving_(t)) {
				this.dragging_ = !0;
				var e = new u.a(l.a.POINTERDRAG, this.map_, t, this.dragging_);
				this.dispatchEvent(e)
			}
			t.preventDefault()
		}, A.prototype.relayEvent_ = function(t) {
			var e = !(!this.down_ || !this.isMoving_(t));
			this.dispatchEvent(new u.a(t.type, this.map_, t, e))
		}, A.prototype.isMoving_ = function(t) {
			return Math.abs(t.clientX - this.down_.clientX) > this.moveTolerance_ || Math.abs(t.clientY - this.down_.clientY) > this.moveTolerance_
		}, A.prototype.disposeInternal = function() {
			this.relayedListenerKey_ && (h.a.unlistenByKey(this.relayedListenerKey_), this.relayedListenerKey_ = null), this.pointerdownListenerKey_ && (h.a.unlistenByKey(this.pointerdownListenerKey_), this.pointerdownListenerKey_ = null), this.dragListenerKeys_.forEach(h.a.unlistenByKey), this.dragListenerKeys_.length = 0, this.documentPointerEventHandler_ && (this.documentPointerEventHandler_.dispose(), this.documentPointerEventHandler_ = null), this.pointerEventHandler_ && (this.pointerEventHandler_.dispose(), this.pointerEventHandler_ = null), c.a.prototype.disposeInternal.call(this)
		};
		var p = A,
			g = i(98),
			m = i(89),
			v = i(61),
			y = i(14),
			_ = i(77),
			E = i(13),
			x = i(5),
			C = i(96),
			I = function(t, e) {
				C.a.call(this, (function(e) {
					return t.apply(null, e)
				}), (function(t) {
					return t[0].getKey()
				})), this.tileChangeCallback_ = e, this.tilesLoading_ = 0, this.tilesLoadingKeys_ = {}
			};
		n.
	default.inherits(I, C.a), I.prototype.enqueue = function(t) {
			var e = C.a.prototype.enqueue.call(this, t);
			if (e) {
				var i = t[0];
				h.a.listen(i, x.a.CHANGE, this.handleTileChange, this)
			}
			return e
		}, I.prototype.getTilesLoading = function() {
			return this.tilesLoading_
		}, I.prototype.handleTileChange = function(t) {
			var e = t.target,
				i = e.getState();
			if (i === E.a.LOADED || i === E.a.ERROR || i === E.a.EMPTY || i === E.a.ABORT) {
				h.a.unlisten(e, x.a.CHANGE, this.handleTileChange, this);
				var n = e.getKey();
				n in this.tilesLoadingKeys_ && (delete this.tilesLoadingKeys_[n], --this.tilesLoading_), this.tileChangeCallback_()
			}
		}, I.prototype.loadMoreTiles = function(t, e) {
			for (var i, n, r, o = 0, s = !1; this.tilesLoading_ < t && o < e && this.getCount() > 0;) r = (n = this.dequeue()[0]).getKey(), (i = n.getState()) === E.a.ABORT ? s = !0 : i !== E.a.IDLE || r in this.tilesLoadingKeys_ || (this.tilesLoadingKeys_[r] = !0, ++this.tilesLoading_, ++o, n.load());
			0 === o && s && this.tileChangeCallback_()
		};
		var S = I,
			T = i(150),
			R = i(22),
			w = i(15),
			L = i(16),
			N = i(21),
			P = i(1),
			O = i(20),
			M = i(121),
			b = i(8),
			F = i(59),
			D = function(t) {
				var e = t || {},
					i = b.a.assign({}, e);
				delete i.layers;
				var n = e.layers;
				M.a.call(this, i), this.layersListenerKeys_ = [], this.listenerKeys_ = {}, h.a.listen(this, y.a.getChangeEventType(D.Property_.LAYERS), this.handleLayersChanged_, this), n ? Array.isArray(n) ? n = new r.
			default (n.slice(), {
					unique: !0
				}):
				(w.a.assert(n instanceof r.
			default, 43), n = n) : n = new r.
			default (void 0, {
					unique: !0
				}), this.setLayers(n)
			};
		n.
	default.inherits(D, M.a), D.prototype.handleLayerChange_ = function() {
			this.changed()
		}, D.prototype.handleLayersChanged_ = function(t) {
			this.layersListenerKeys_.forEach(h.a.unlistenByKey), this.layersListenerKeys_.length = 0;
			var e = this.getLayers();
			for (var i in this.layersListenerKeys_.push(h.a.listen(e, o.a.ADD, this.handleLayersAdd_, this), h.a.listen(e, o.a.REMOVE, this.handleLayersRemove_, this)), this.listenerKeys_) this.listenerKeys_[i].forEach(h.a.unlistenByKey);
			b.a.clear(this.listenerKeys_);
			var r, s, a, l = e.getArray();
			for (r = 0, s = l.length; r < s; r++) a = l[r], this.listenerKeys_[n.
		default.getUid(a).toString()] = [h.a.listen(a, _.a.PROPERTYCHANGE, this.handleLayerChange_, this), h.a.listen(a, x.a.CHANGE, this.handleLayerChange_, this)];
			this.changed()
		}, D.prototype.handleLayersAdd_ = function(t) {
			var e = t.element,
				i = n.
			default.getUid(e).toString();
			this.listenerKeys_[i] = [h.a.listen(e, _.a.PROPERTYCHANGE, this.handleLayerChange_, this), h.a.listen(e, x.a.CHANGE, this.handleLayerChange_, this)], this.changed()
		}, D.prototype.handleLayersRemove_ = function(t) {
			var e = t.element,
				i = n.
			default.getUid(e).toString();
			this.listenerKeys_[i].forEach(h.a.unlistenByKey), delete this.listenerKeys_[i], this.changed()
		}, D.prototype.getLayers = function() {
			return this.get(D.Property_.LAYERS)
		}, D.prototype.setLayers = function(t) {
			this.set(D.Property_.LAYERS, t)
		}, D.prototype.getLayersArray = function(t) {
			var e = void 0 !== t ? t : [];
			return this.getLayers().forEach((function(t) {
				t.getLayersArray(e)
			})), e
		}, D.prototype.getLayerStatesArray = function(t) {
			var e = void 0 !== t ? t : [],
				i = e.length;
			this.getLayers().forEach((function(t) {
				t.getLayerStatesArray(e)
			}));
			var n, r, o, s = this.getLayerState();
			for (n = i, r = e.length; n < r; n++)(o = e[n]).opacity *= s.opacity, o.visible = o.visible && s.visible, o.maxResolution = Math.min(o.maxResolution, s.maxResolution), o.minResolution = Math.max(o.minResolution, s.minResolution), void 0 !== s.extent && (void 0 !== o.extent ? o.extent = P.
		default.getIntersection(o.extent, s.extent):
			o.extent = s.extent);
			return e
		}, D.prototype.getSourceState = function() {
			return F.a.READY
		}, D.Property_ = {
			LAYERS: "layers"
		};
		var G = D,
			k = i(83),
			U = i(46),
			B = i(48),
			j = i(6),
			V = function(t) {
				y.a.call(this);
				var e = V.createOptionsInternal(t);
				this.loadTilesWhileAnimating_ = void 0 !== t.loadTilesWhileAnimating && t.loadTilesWhileAnimating, this.loadTilesWhileInteracting_ = void 0 !== t.loadTilesWhileInteracting && t.loadTilesWhileInteracting, this.pixelRatio_ = void 0 !== t.pixelRatio ? t.pixelRatio : a.a.DEVICE_PIXEL_RATIO, this.logos_ = e.logos, this.animationDelayKey_, this.animationDelay_ = function() {
					this.animationDelayKey_ = void 0, this.renderFrame_.call(this, Date.now())
				}.bind(this), this.coordinateToPixelTransform_ = j.a.create(), this.pixelToCoordinateTransform_ = j.a.create(), this.frameIndex_ = 0, this.frameState_ = null, this.previousExtent_ = null, this.viewPropertyListenerKey_ = null, this.viewChangeListenerKey_ = null, this.layerGroupPropertyListenerKeys_ = null, this.viewport_ = document.createElement("DIV"), this.viewport_.className = "ol-viewport" + (a.a.TOUCH ? " ol-touch" : ""), this.viewport_.style.position = "relative", this.viewport_.style.overflow = "hidden", this.viewport_.style.width = "100%", this.viewport_.style.height = "100%", this.viewport_.style.msTouchAction = "none", this.viewport_.style.touchAction = "none", this.overlayContainer_ = document.createElement("DIV"), this.overlayContainer_.className = "ol-overlaycontainer", this.viewport_.appendChild(this.overlayContainer_), this.overlayContainerStopEvent_ = document.createElement("DIV"), this.overlayContainerStopEvent_.className = "ol-overlaycontainer-stopevent";
				for (var i = [x.a.CLICK, x.a.DBLCLICK, x.a.MOUSEDOWN, x.a.TOUCHSTART, x.a.MSPOINTERDOWN, l.a.POINTERDOWN, x.a.MOUSEWHEEL, x.a.WHEEL], n = 0, s = i.length; n < s; ++n) h.a.listen(this.overlayContainerStopEvent_, i[n], N.a.stopPropagation);
				for (var u in this.viewport_.appendChild(this.overlayContainerStopEvent_), this.mapBrowserEventHandler_ = new p(this, t.moveTolerance), l.a) h.a.listen(this.mapBrowserEventHandler_, l.a[u], this.handleMapBrowserEvent, this);
				this.keyboardEventTarget_ = e.keyboardEventTarget, this.keyHandlerKeys_ = null, h.a.listen(this.viewport_, x.a.WHEEL, this.handleBrowserEvent, this), h.a.listen(this.viewport_, x.a.MOUSEWHEEL, this.handleBrowserEvent, this), this.controls = e.controls || new r.
			default, this.interactions = e.interactions || new r.
			default, this.overlays_ = e.overlays, this.overlayIdIndex_ = {}, this.renderer_ = e.mapRendererPlugin.create(this.viewport_, this), this.handleResize_, this.focus_ = null, this.postRenderFunctions_ = [], this.tileQueue_ = new S(this.getTilePriority.bind(this), this.handleTileChange_.bind(this)), this.skippedFeatureUids_ = {}, h.a.listen(this, y.a.getChangeEventType(v.a.LAYERGROUP), this.handleLayerGroupChanged_, this), h.a.listen(this, y.a.getChangeEventType(v.a.VIEW), this.handleViewChanged_, this), h.a.listen(this, y.a.getChangeEventType(v.a.SIZE), this.handleSizeChanged_, this), h.a.listen(this, y.a.getChangeEventType(v.a.TARGET), this.handleTargetChanged_, this), this.setProperties(e.values), this.controls.forEach((function(t) {
					t.setMap(this)
				}), this), h.a.listen(this.controls, o.a.ADD, (function(t) {
					t.element.setMap(this)
				}), this), h.a.listen(this.controls, o.a.REMOVE, (function(t) {
					t.element.setMap(null)
				}), this), this.interactions.forEach((function(t) {
					t.setMap(this)
				}), this), h.a.listen(this.interactions, o.a.ADD, (function(t) {
					t.element.setMap(this)
				}), this), h.a.listen(this.interactions, o.a.REMOVE, (function(t) {
					t.element.setMap(null)
				}), this), this.overlays_.forEach(this.addOverlayInternal_, this), h.a.listen(this.overlays_, o.a.ADD, (function(t) {
					this.addOverlayInternal_(t.element)
				}), this), h.a.listen(this.overlays_, o.a.REMOVE, (function(t) {
					var e = t.element.getId();
					void 0 !== e && delete this.overlayIdIndex_[e.toString()], t.element.setMap(null)
				}), this)
			};
		n.
	default.inherits(V, y.a), V.prototype.addControl = function(t) {
			this.getControls().push(t)
		}, V.prototype.addInteraction = function(t) {
			this.getInteractions().push(t)
		}, V.prototype.addLayer = function(t) {
			this.getLayerGroup().getLayers().push(t)
		}, V.prototype.addOverlay = function(t) {
			this.getOverlays().push(t)
		}, V.prototype.addOverlayInternal_ = function(t) {
			var e = t.getId();
			void 0 !== e && (this.overlayIdIndex_[e.toString()] = t), t.setMap(this)
		}, V.prototype.disposeInternal = function() {
			this.mapBrowserEventHandler_.dispose(), h.a.unlisten(this.viewport_, x.a.WHEEL, this.handleBrowserEvent, this), h.a.unlisten(this.viewport_, x.a.MOUSEWHEEL, this.handleBrowserEvent, this), void 0 !== this.handleResize_ && (window.removeEventListener(x.a.RESIZE, this.handleResize_, !1), this.handleResize_ = void 0), this.animationDelayKey_ && (cancelAnimationFrame(this.animationDelayKey_), this.animationDelayKey_ = void 0), this.setTarget(null), y.a.prototype.disposeInternal.call(this)
		}, V.prototype.forEachFeatureAtPixel = function(t, e, i) {
			if (this.frameState_) {
				var n = this.getCoordinateFromPixel(t),
					r = void 0 !== (i = void 0 !== i ? i : {}).hitTolerance ? i.hitTolerance * this.frameState_.pixelRatio : 0,
					o = void 0 !== i.layerFilter ? i.layerFilter : O.a.TRUE;
				return this.renderer_.forEachFeatureAtCoordinate(n, this.frameState_, r, e, null, o, null)
			}
		}, V.prototype.getFeaturesAtPixel = function(t, e) {
			var i = null;
			return this.forEachFeatureAtPixel(t, (function(t) {
				i || (i = []), i.push(t)
			}), e), i
		}, V.prototype.forEachLayerAtPixel = function(t, e, i, n, r) {
			if (this.frameState_) {
				var o = void 0 !== i ? i : null,
					s = void 0 !== n ? n : O.a.TRUE,
					a = void 0 !== r ? r : null;
				return this.renderer_.forEachLayerAtPixel(t, this.frameState_, e, o, s, a)
			}
		}, V.prototype.hasFeatureAtPixel = function(t, e) {
			if (!this.frameState_) return !1;
			var i = this.getCoordinateFromPixel(t),
				n = void 0 !== (e = void 0 !== e ? e : {}).layerFilter ? e.layerFilter : O.a.TRUE,
				r = void 0 !== e.hitTolerance ? e.hitTolerance * this.frameState_.pixelRatio : 0;
			return this.renderer_.hasFeatureAtCoordinate(i, this.frameState_, r, n, null)
		}, V.prototype.getEventCoordinate = function(t) {
			return this.getCoordinateFromPixel(this.getEventPixel(t))
		}, V.prototype.getEventPixel = function(t) {
			var e = this.viewport_.getBoundingClientRect(),
				i = t.changedTouches ? t.changedTouches[0] : t;
			return [i.clientX - e.left, i.clientY - e.top]
		}, V.prototype.getTarget = function() {
			return this.get(v.a.TARGET)
		}, V.prototype.getTargetElement = function() {
			var t = this.getTarget();
			return void 0 !== t ? "string" == typeof t ? document.getElementById(t) : t : null
		}, V.prototype.getCoordinateFromPixel = function(t) {
			var e = this.frameState_;
			return e ? j.a.apply(e.pixelToCoordinateTransform, t.slice()) : null
		}, V.prototype.getControls = function() {
			return this.controls
		}, V.prototype.getOverlays = function() {
			return this.overlays_
		}, V.prototype.getOverlayById = function(t) {
			var e = this.overlayIdIndex_[t.toString()];
			return void 0 !== e ? e : null
		}, V.prototype.getInteractions = function() {
			return this.interactions
		}, V.prototype.getLayerGroup = function() {
			return this.get(v.a.LAYERGROUP)
		}, V.prototype.getLayers = function() {
			return this.getLayerGroup().getLayers()
		}, V.prototype.getPixelFromCoordinate = function(t) {
			var e = this.frameState_;
			return e ? j.a.apply(e.coordinateToPixelTransform, t.slice(0, 2)) : null
		}, V.prototype.getRenderer = function() {
			return this.renderer_
		}, V.prototype.getSize = function() {
			return this.get(v.a.SIZE)
		}, V.prototype.getView = function() {
			return this.get(v.a.VIEW)
		}, V.prototype.getViewport = function() {
			return this.viewport_
		}, V.prototype.getOverlayContainer = function() {
			return this.overlayContainer_
		}, V.prototype.getOverlayContainerStopEvent = function() {
			return this.overlayContainerStopEvent_
		}, V.prototype.getTilePriority = function(t, e, i, n) {
			var r = this.frameState_;
			if (!(r && e in r.wantedTiles)) return C.a.DROP;
			if (!r.wantedTiles[e][t.getKey()]) return C.a.DROP;
			var o = i[0] - r.focus[0],
				s = i[1] - r.focus[1];
			return 65536 * Math.log(n) + Math.sqrt(o * o + s * s) / n
		}, V.prototype.handleBrowserEvent = function(t, e) {
			var i = e || t.type,
				n = new s.a(i, this, t);
			this.handleMapBrowserEvent(n)
		}, V.prototype.handleMapBrowserEvent = function(t) {
			if (this.frameState_) {
				this.focus_ = t.coordinate, t.frameState = this.frameState_;
				var e, i = this.getInteractions().getArray();
				if (!1 !== this.dispatchEvent(t)) for (e = i.length - 1; e >= 0; e--) {
					var n = i[e];
					if (n.getActive()) if (!n.handleEvent(t)) break
				}
			}
		}, V.prototype.handlePostRender = function() {
			var t = this.frameState_,
				e = this.tileQueue_;
			if (!e.isEmpty()) {
				var i = 16,
					n = i;
				if (t) {
					var r = t.viewHints;
					r[R.a.ANIMATING] && (i = this.loadTilesWhileAnimating_ ? 8 : 0, n = 2), r[R.a.INTERACTING] && (i = this.loadTilesWhileInteracting_ ? 8 : 0, n = 2)
				}
				e.getTilesLoading() < i && (e.reprioritize(), e.loadMoreTiles(i, n))
			}
			var o, s, a = this.postRenderFunctions_;
			for (o = 0, s = a.length; o < s; ++o) a[o](this, t);
			a.length = 0
		}, V.prototype.handleSizeChanged_ = function() {
			this.render()
		}, V.prototype.handleTargetChanged_ = function() {
			var t;
			if (this.getTarget() && (t = this.getTargetElement()), this.keyHandlerKeys_) {
				for (var e = 0, i = this.keyHandlerKeys_.length; e < i; ++e) h.a.unlistenByKey(this.keyHandlerKeys_[e]);
				this.keyHandlerKeys_ = null
			}
			if (t) {
				t.appendChild(this.viewport_);
				var n = this.keyboardEventTarget_ ? this.keyboardEventTarget_ : t;
				this.keyHandlerKeys_ = [h.a.listen(n, x.a.KEYDOWN, this.handleBrowserEvent, this), h.a.listen(n, x.a.KEYPRESS, this.handleBrowserEvent, this)], this.handleResize_ || (this.handleResize_ = this.updateSize.bind(this), window.addEventListener(x.a.RESIZE, this.handleResize_, !1))
			} else this.renderer_.removeLayerRenderers(), L.a.removeNode(this.viewport_), void 0 !== this.handleResize_ && (window.removeEventListener(x.a.RESIZE, this.handleResize_, !1), this.handleResize_ = void 0);
			this.updateSize()
		}, V.prototype.handleTileChange_ = function() {
			this.render()
		}, V.prototype.handleViewPropertyChanged_ = function() {
			this.render()
		}, V.prototype.handleViewChanged_ = function() {
			this.viewPropertyListenerKey_ && (h.a.unlistenByKey(this.viewPropertyListenerKey_), this.viewPropertyListenerKey_ = null), this.viewChangeListenerKey_ && (h.a.unlistenByKey(this.viewChangeListenerKey_), this.viewChangeListenerKey_ = null);
			var t = this.getView();
			t && (this.viewport_.setAttribute("data-view", n.
		default.getUid(t)), this.viewPropertyListenerKey_ = h.a.listen(t, _.a.PROPERTYCHANGE, this.handleViewPropertyChanged_, this), this.viewChangeListenerKey_ = h.a.listen(t, x.a.CHANGE, this.handleViewPropertyChanged_, this)), this.render()
		}, V.prototype.handleLayerGroupChanged_ = function() {
			this.layerGroupPropertyListenerKeys_ && (this.layerGroupPropertyListenerKeys_.forEach(h.a.unlistenByKey), this.layerGroupPropertyListenerKeys_ = null);
			var t = this.getLayerGroup();
			t && (this.layerGroupPropertyListenerKeys_ = [h.a.listen(t, _.a.PROPERTYCHANGE, this.render, this), h.a.listen(t, x.a.CHANGE, this.render, this)]), this.render()
		}, V.prototype.isRendered = function() {
			return !!this.frameState_
		}, V.prototype.renderSync = function() {
			this.animationDelayKey_ && cancelAnimationFrame(this.animationDelayKey_), this.animationDelay_()
		}, V.prototype.render = function() {
			void 0 === this.animationDelayKey_ && (this.animationDelayKey_ = requestAnimationFrame(this.animationDelay_))
		}, V.prototype.removeControl = function(t) {
			return this.getControls().remove(t)
		}, V.prototype.removeInteraction = function(t) {
			return this.getInteractions().remove(t)
		}, V.prototype.removeLayer = function(t) {
			return this.getLayerGroup().getLayers().remove(t)
		}, V.prototype.removeOverlay = function(t) {
			return this.getOverlays().remove(t)
		}, V.prototype.renderFrame_ = function(t) {
			var e, i, r, o = this.getSize(),
				s = this.getView(),
				a = P.
			default.createEmpty(),
				l = this.frameState_,
				u = null;
			if (void 0 !== o && B.a.hasArea(o) && s && s.isDef()) {
				var h = s.getHints(this.frameState_ ? this.frameState_.viewHints : void 0),
					c = this.getLayerGroup().getLayerStatesArray(),
					d = {};
				for (e = 0, i = c.length; e < i; ++e) d[n.
			default.getUid(c[e].layer)] = c[e];
				var f = (r = s.getState()).center,
					A = r.resolution / this.pixelRatio_;
				f[0] = Math.round(f[0] / A) * A, f[1] = Math.round(f[1] / A) * A, u = {
					animate: !1,
					coordinateToPixelTransform: this.coordinateToPixelTransform_,
					extent: a,
					focus: this.focus_ ? this.focus_ : f,
					index: this.frameIndex_++,
					layerStates: d,
					layerStatesArray: c,
					logos: b.a.assign({}, this.logos_),
					pixelRatio: this.pixelRatio_,
					pixelToCoordinateTransform: this.pixelToCoordinateTransform_,
					postRenderFunctions: [],
					size: o,
					skippedFeatureUids: this.skippedFeatureUids_,
					tileQueue: this.tileQueue_,
					time: t,
					usedTiles: {},
					viewState: r,
					viewHints: h,
					wantedTiles: {}
				}
			}
			if (u && (u.extent = P.
		default.getForViewAndSize(r.center, r.resolution, r.rotation, u.size, a)), this.frameState_ = u, this.renderer_.renderFrame(u), u) {
				if (u.animate && this.render(), Array.prototype.push.apply(this.postRenderFunctions_, u.postRenderFunctions), l)(!this.previousExtent_ || !P.
			default.isEmpty(this.previousExtent_) && !P.
			default.equals(u.extent, this.previousExtent_)) && (this.dispatchEvent(new g.a(m.a.MOVESTART, this, l)), this.previousExtent_ = P.
			default.createOrUpdateEmpty(this.previousExtent_));
				this.previousExtent_ && !u.viewHints[R.a.ANIMATING] && !u.viewHints[R.a.INTERACTING] && !P.
			default.equals(u.extent, this.previousExtent_) && (this.dispatchEvent(new g.a(m.a.MOVEEND, this, u)), P.
			default.clone(u.extent, this.previousExtent_))
			}
			this.dispatchEvent(new g.a(m.a.POSTRENDER, this, u)), setTimeout(this.handlePostRender.bind(this), 0)
		}, V.prototype.setLayerGroup = function(t) {
			this.set(v.a.LAYERGROUP, t)
		}, V.prototype.setSize = function(t) {
			this.set(v.a.SIZE, t)
		}, V.prototype.setTarget = function(t) {
			this.set(v.a.TARGET, t)
		}, V.prototype.setView = function(t) {
			this.set(v.a.VIEW, t)
		}, V.prototype.skipFeature = function(t) {
			var e = n.
		default.getUid(t).toString();
			this.skippedFeatureUids_[e] = !0, this.render()
		}, V.prototype.updateSize = function() {
			var t = this.getTargetElement();
			if (t) {
				var e = getComputedStyle(t);
				this.setSize([t.offsetWidth - parseFloat(e.borderLeftWidth) - parseFloat(e.paddingLeft) - parseFloat(e.paddingRight) - parseFloat(e.borderRightWidth), t.offsetHeight - parseFloat(e.borderTopWidth) - parseFloat(e.paddingTop) - parseFloat(e.paddingBottom) - parseFloat(e.borderBottomWidth)])
			} else this.setSize(void 0)
		}, V.prototype.unskipFeature = function(t) {
			var e = n.
		default.getUid(t).toString();
			delete this.skippedFeatureUids_[e], this.render()
		}, V.DEFAULT_RENDERER_TYPES = [U.a.CANVAS, U.a.WEBGL], V.LOGO_URL = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAMAAABEpIrGAAAAA3NCSVQICAjb4U/gAAAACXBIWXMAAAHGAAABxgEXwfpGAAAAGXRFWHRTb2Z0d2FyZQB3d3cuaW5rc2NhcGUub3Jnm+48GgAAAhNQTFRF////AP//AICAgP//AFVVQECA////K1VVSbbbYL/fJ05idsTYJFtbbcjbJllmZszWWMTOIFhoHlNiZszTa9DdUcHNHlNlV8XRIVdiasrUHlZjIVZjaMnVH1RlIFRkH1RkH1ZlasvYasvXVsPQH1VkacnVa8vWIVZjIFRjVMPQa8rXIVVkXsXRsNveIFVkIFZlIVVj3eDeh6GmbMvXH1ZkIFRka8rWbMvXIFVkIFVjIFVkbMvWH1VjbMvWIFVlbcvWIFVla8vVIFVkbMvWbMvVH1VkbMvWIFVlbcvWIFVkbcvVbMvWjNPbIFVkU8LPwMzNIFVkbczWIFVkbsvWbMvXIFVkRnB8bcvW2+TkW8XRIFVkIlZlJVloJlpoKlxrLl9tMmJwOWd0Omh1RXF8TneCT3iDUHiDU8LPVMLPVcLPVcPQVsPPVsPQV8PQWMTQWsTQW8TQXMXSXsXRX4SNX8bSYMfTYcfTYsfTY8jUZcfSZsnUaIqTacrVasrVa8jTa8rWbI2VbMvWbcvWdJObdcvUdszUd8vVeJaee87Yfc3WgJyjhqGnitDYjaarldPZnrK2oNbborW5o9bbo9fbpLa6q9ndrL3ArtndscDDutzfu8fJwN7gwt7gxc/QyuHhy+HizeHi0NfX0+Pj19zb1+Tj2uXk29/e3uLg3+Lh3+bl4uXj4ufl4+fl5Ofl5ufl5ujm5+jmySDnBAAAAFp0Uk5TAAECAgMEBAYHCA0NDg4UGRogIiMmKSssLzU7PkJJT1JTVFliY2hrdHZ3foSFhYeJjY2QkpugqbG1tre5w8zQ09XY3uXn6+zx8vT09vf4+Pj5+fr6/P39/f3+gz7SsAAAAVVJREFUOMtjYKA7EBDnwCPLrObS1BRiLoJLnte6CQy8FLHLCzs2QUG4FjZ5GbcmBDDjxJBXDWxCBrb8aM4zbkIDzpLYnAcE9VXlJSWlZRU13koIeW57mGx5XjoMZEUqwxWYQaQbSzLSkYGfKFSe0QMsX5WbjgY0YS4MBplemI4BdGBW+DQ11eZiymfqQuXZIjqwyadPNoSZ4L+0FVM6e+oGI6g8a9iKNT3o8kVzNkzRg5lgl7p4wyRUL9Yt2jAxVh6mQCogae6GmflI8p0r13VFWTHBQ0rWPW7ahgWVcPm+9cuLoyy4kCJDzCm6d8PSFoh0zvQNC5OjDJhQopPPJqph1doJBUD5tnkbZiUEqaCnB3bTqLTFG1bPn71kw4b+GFdpLElKIzRxxgYgWNYc5SCENVHKeUaltHdXx0dZ8uBI1hJ2UUDgq82CM2MwKeibqAvSO7MCABq0wXEPiqWEAAAAAElFTkSuQmCC", V.createOptionsInternal = function(t) {
			var e = null;
			void 0 !== t.keyboardEventTarget && (e = "string" == typeof t.keyboardEventTarget ? document.getElementById(t.keyboardEventTarget) : t.keyboardEventTarget);
			var i = {},
				o = {};
			if (void 0 === t.logo || "boolean" == typeof t.logo && t.logo) o[V.LOGO_URL] = "https://openlayers.org/";
			else {
				var s = t.logo;
				"string" == typeof s ? o[s] = "" : s instanceof HTMLElement ? o[n.
			default.getUid(s).toString()] = s : s && (w.a.assert("string" == typeof s.href, 44), w.a.assert("string" == typeof s.src, 45), o[s.src] = s.href)
			}
			var a, l, u = t.layers instanceof G ? t.layers : new G({
				layers: t.layers
			});
			i[v.a.LAYERGROUP] = u, i[v.a.TARGET] = t.target, i[v.a.VIEW] = void 0 !== t.view ? t.view : new T.
		default, void 0 !== t.renderer ? (Array.isArray(t.renderer) ? a = t.renderer : "string" == typeof t.renderer ? a = [t.renderer] : w.a.assert(!1, 46), a.indexOf("dom") >= 0 && (a = a.concat(V.DEFAULT_RENDERER_TYPES))):
			a = V.DEFAULT_RENDERER_TYPES;
			var h, c, d, f = k.a.getMapRendererPlugins();
			t : for (var A = 0, p = a.length; A < p; ++A) for (var g = a[A], m = 0, y = f.length; m < y; ++m) {
				var _ = f[m];
				if (_.handles(g)) {
					l = _;
					break t
				}
			}
			if (!l) throw new Error("Unable to create a map renderer for types: " + a.join(", "));
			return void 0 !== t.controls && (Array.isArray(t.controls) ? h = new r.
		default (t.controls.slice()):
			(w.a.assert(t.controls instanceof r.
		default, 47), h = t.controls)), void 0 !== t.interactions && (Array.isArray(t.interactions) ? c = new r.
		default (t.interactions.slice()):
			(w.a.assert(t.interactions instanceof r.
		default, 48), c = t.interactions)), void 0 !== t.overlays ? Array.isArray(t.overlays) ? d = new r.
		default (t.overlays.slice()):
			(w.a.assert(t.overlays instanceof r.
		default, 49), d = t.overlays) : d = new r.
		default, {
				controls: h,
				interactions: c,
				keyboardEventTarget: e,
				logos: o,
				overlays: d,
				mapRendererPlugin: l,
				values: i
			}
		};
		e.a = V
	}, function(t, e, i) {
		"use strict";
		Object.defineProperty(e, "__esModule", {
			value: !0
		});
		e.
	default = function() {
			var t = 0,
				e = new Object;
			this.isEmpty = function() {
				return 0 == t
			}, this.containsKey = function(t) {
				return t in e
			}, this.containsValue = function(t) {
				for (var i in e) if (e[i] == t) return !0;
				return !1
			}, this.put = function(i, n) {
				this.containsKey(i) || t++, e[i] = n
			}, this.get = function(t) {
				return this.containsKey(t) ? e[t] : null
			}, this.remove = function(i) {
				this.containsKey(i) && delete e[i] && t--
			}, this.values = function() {
				var t = new Array;
				for (var i in e) t.push(e[i]);
				return t
			}, this.keySet = function() {
				var t = new Array;
				for (var i in e) t.push(i);
				return t
			}, this.size = function() {
				return t
			}, this.clear = function() {
				t = 0, e = new Object
			}
		}
	}, function(t, e, i) {
		"use strict";
		i.r(e);
		var n = i(0),
			r = i(26),
			o = i(24),
			s = i(14),
			a = i(19),
			l = i(3),
			u = i(21),
			h = i(28),
			c = i(1),
			d = i(20),
			f = i(105),
			A = i(4),
			p = i(58),
			g = i(94),
			m = i(104),
			v = i(106),
			y = i(25),
			_ = i(31),
			E = {
				DRAWSTART: "drawstart",
				DRAWEND: "drawend"
			},
			x = i(23),
			C = i(111),
			I = i(33),
			S = i(30),
			T = i(34),
			R = function(t) {
				x.a.call(this, {
					handleDownEvent: R.handleDownEvent_,
					handleEvent: R.handleEvent,
					handleUpEvent: R.handleUpEvent_
				}), this.shouldHandle_ = !1, this.downPx_ = null, this.freehand_ = !1, this.source_ = t.source ? t.source : null, this.features_ = t.features ? t.features : null, this.snapTolerance_ = t.snapTolerance ? t.snapTolerance : 12, this.type_ = t.type, this.mode_ = R.getMode_(this.type_), this.stopClick_ = !! t.stopClick, this.minPoints_ = t.minPoints ? t.minPoints : this.mode_ === R.Mode_.POLYGON ? 3 : 2, this.maxPoints_ = t.maxPoints ? t.maxPoints : 1 / 0, this.finishCondition_ = t.finishCondition ? t.finishCondition : d.a.TRUE;
				var e = t.geometryFunction;
				if (!e) if (this.type_ === A.a.CIRCLE) e = function(t, e) {
					var i = e || new f.
				default ([NaN, NaN]),
						n = a.
					default.squaredDistance(t[0], t[1]);
					return i.setCenterAndRadius(t[0], Math.sqrt(n)), i
				};
				else {
					var i, n = this.mode_;
					n === R.Mode_.POINT ? i = y.
				default:
					n === R.Mode_.LINE_STRING ? i = p.
				default:
					n === R.Mode_.POLYGON && (i = _.
				default), e = function(t, e) {
						var r = e;
						return r ? n === R.Mode_.POLYGON ? t[0].length ? r.setCoordinates([t[0].concat([t[0][0]])]) : r.setCoordinates([]) : r.setCoordinates(t) : r = new i(t), r
					}
				}
				this.geometryFunction_ = e, this.finishCoordinate_ = null, this.sketchFeature_ = null, this.sketchPoint_ = null, this.sketchCoords_ = null, this.sketchLine_ = null, this.sketchLineCoords_ = null, this.squaredClickTolerance_ = t.clickTolerance ? t.clickTolerance * t.clickTolerance : 36, this.overlay_ = new I.
			default ({
					source: new S.
				default ({
						useSpatialIndex: !1,
						wrapX: !! t.wrapX && t.wrapX
					}),
					style:
					t.style ? t.style : R.getDefaultStyleFunction()
				}), this.geometryName_ = t.geometryName, this.condition_ = t.condition ? t.condition:
				h.
			default.noModifierKeys, this.freehandCondition_, t.freehand ? this.freehandCondition_ = h.
			default.always:
				this.freehandCondition_ = t.freehandCondition ? t.freehandCondition : h.
			default.shiftKeyOnly, l.a.listen(this, s.a.getChangeEventType(C.a.ACTIVE), this.updateState_, this)
			};
		n.
	default.inherits(R, x.a), R.getDefaultStyleFunction = function() {
			var t = T.
		default.createDefaultEditing();
			return function(e, i) {
				return t[e.getGeometry().getType()]
			}
		}, R.prototype.setMap = function(t) {
			x.a.prototype.setMap.call(this, t), this.updateState_()
		}, R.handleEvent = function(t) {
			this.freehand_ = this.mode_ !== R.Mode_.POINT && this.freehandCondition_(t);
			var e = !0;
			return this.freehand_ && t.type === o.a.POINTERDRAG && null !== this.sketchFeature_ ? (this.addToDrawing_(t), e = !1) : this.freehand_ && t.type === o.a.POINTERDOWN ? e = !1 : t.type === o.a.POINTERMOVE ? e = this.handlePointerMove_(t) : t.type === o.a.DBLCLICK && (e = !1), x.a.handleEvent.call(this, t) && e
		}, R.handleDownEvent_ = function(t) {
			return this.shouldHandle_ = !this.freehand_, this.freehand_ ? (this.downPx_ = t.pixel, this.finishCoordinate_ || this.startDrawing_(t), !0) : !! this.condition_(t) && (this.downPx_ = t.pixel, !0)
		}, R.handleUpEvent_ = function(t) {
			var e = !0;
			this.handlePointerMove_(t);
			var i = this.mode_ === R.Mode_.CIRCLE;
			return this.shouldHandle_ ? (this.finishCoordinate_ ? this.freehand_ || i ? this.finishDrawing() : this.atFinish_(t) ? this.finishCondition_(t) && this.finishDrawing() : this.addToDrawing_(t) : (this.startDrawing_(t), this.mode_ === R.Mode_.POINT && this.finishDrawing()), e = !1) : this.freehand_ && (this.finishCoordinate_ = null, this.abortDrawing_()), !e && this.stopClick_ && t.stopPropagation(), e
		}, R.prototype.handlePointerMove_ = function(t) {
			if (this.downPx_ && (!this.freehand_ && this.shouldHandle_ || this.freehand_ && !this.shouldHandle_)) {
				var e = this.downPx_,
					i = t.pixel,
					n = e[0] - i[0],
					r = e[1] - i[1],
					o = n * n + r * r;
				this.shouldHandle_ = this.freehand_ ? o > this.squaredClickTolerance_ : o <= this.squaredClickTolerance_
			}
			return this.finishCoordinate_ ? this.modifyDrawing_(t) : this.createOrUpdateSketchPoint_(t), !0
		}, R.prototype.atFinish_ = function(t) {
			var e = !1;
			if (this.sketchFeature_) {
				var i = !1,
					n = [this.finishCoordinate_];
				if (this.mode_ === R.Mode_.LINE_STRING ? i = this.sketchCoords_.length > this.minPoints_ : this.mode_ === R.Mode_.POLYGON && (i = this.sketchCoords_[0].length > this.minPoints_, n = [this.sketchCoords_[0][0], this.sketchCoords_[0][this.sketchCoords_[0].length - 2]]), i) for (var r = t.map, o = 0, s = n.length; o < s; o++) {
					var a = n[o],
						l = r.getPixelFromCoordinate(a),
						u = t.pixel,
						h = u[0] - l[0],
						c = u[1] - l[1],
						d = this.freehand_ ? 1 : this.snapTolerance_;
					if (e = Math.sqrt(h * h + c * c) <= d) {
						this.finishCoordinate_ = a;
						break
					}
				}
			}
			return e
		}, R.prototype.createOrUpdateSketchPoint_ = function(t) {
			var e = t.coordinate.slice();
			this.sketchPoint_ ? this.sketchPoint_.getGeometry().setCoordinates(e) : (this.sketchPoint_ = new r.
		default (new y.
		default (e)), this.updateSketchFeatures_())
		}, R.prototype.startDrawing_ = function(t) {
			var e = t.coordinate;
			this.finishCoordinate_ = e, this.mode_ === R.Mode_.POINT ? this.sketchCoords_ = e.slice() : this.mode_ === R.Mode_.POLYGON ? (this.sketchCoords_ = [
				[e.slice(), e.slice()]
			], this.sketchLineCoords_ = this.sketchCoords_[0]) : (this.sketchCoords_ = [e.slice(), e.slice()], this.mode_ === R.Mode_.CIRCLE && (this.sketchLineCoords_ = this.sketchCoords_)), this.sketchLineCoords_ && (this.sketchLine_ = new r.
		default (new p.
		default (this.sketchLineCoords_)));
			var i = this.geometryFunction_(this.sketchCoords_);
			this.sketchFeature_ = new r.
		default, this.geometryName_ && this.sketchFeature_.setGeometryName(this.geometryName_), this.sketchFeature_.setGeometry(i), this.updateSketchFeatures_(), this.dispatchEvent(new R.Event(E.DRAWSTART, this.sketchFeature_))
		}, R.prototype.modifyDrawing_ = function(t) {
			var e, i, n = t.coordinate,
				o = this.sketchFeature_.getGeometry();
			(this.mode_ === R.Mode_.POINT ? i = this.sketchCoords_ : this.mode_ === R.Mode_.POLYGON ? (i = (e = this.sketchCoords_[0])[e.length - 1], this.atFinish_(t) && (n = this.finishCoordinate_.slice())) : i = (e = this.sketchCoords_)[e.length - 1], i[0] = n[0], i[1] = n[1], this.geometryFunction_(this.sketchCoords_, o), this.sketchPoint_) && this.sketchPoint_.getGeometry().setCoordinates(n);
			if (o instanceof _.
		default &&this.mode_ !== R.Mode_.POLYGON) {
				this.sketchLine_ || (this.sketchLine_ = new r.
			default (new p.
			default (null)));
				var s = o.getLinearRing(0);
				this.sketchLine_.getGeometry().setFlatCoordinates(s.getLayout(), s.getFlatCoordinates())
			} else this.sketchLineCoords_ && this.sketchLine_.getGeometry().setCoordinates(this.sketchLineCoords_);
			this.updateSketchFeatures_()
		}, R.prototype.addToDrawing_ = function(t) {
			var e, i, n = t.coordinate,
				r = this.sketchFeature_.getGeometry();
			this.mode_ === R.Mode_.LINE_STRING ? (this.finishCoordinate_ = n.slice(), (i = this.sketchCoords_).length >= this.maxPoints_ && (this.freehand_ ? i.pop() : e = !0), i.push(n.slice()), this.geometryFunction_(i, r)) : this.mode_ === R.Mode_.POLYGON && ((i = this.sketchCoords_[0]).length >= this.maxPoints_ && (this.freehand_ ? i.pop() : e = !0), i.push(n.slice()), e && (this.finishCoordinate_ = i[0]), this.geometryFunction_(this.sketchCoords_, r)), this.updateSketchFeatures_(), e && this.finishDrawing()
		}, R.prototype.removeLastPoint = function() {
			if (this.sketchFeature_) {
				var t, e = this.sketchFeature_.getGeometry();
				this.mode_ === R.Mode_.LINE_STRING ? ((t = this.sketchCoords_).splice(-2, 1), this.geometryFunction_(t, e), t.length >= 2 && (this.finishCoordinate_ = t[t.length - 2].slice())) : this.mode_ === R.Mode_.POLYGON && ((t = this.sketchCoords_[0]).splice(-2, 1), this.sketchLine_.getGeometry().setCoordinates(t), this.geometryFunction_(this.sketchCoords_, e)), 0 === t.length && (this.finishCoordinate_ = null), this.updateSketchFeatures_()
			}
		}, R.prototype.finishDrawing = function() {
			var t = this.abortDrawing_(),
				e = this.sketchCoords_,
				i = t.getGeometry();
			this.mode_ === R.Mode_.LINE_STRING ? (e.pop(), this.geometryFunction_(e, i)) : this.mode_ === R.Mode_.POLYGON && (e[0].pop(), this.geometryFunction_(e, i), e = i.getCoordinates()), this.type_ === A.a.MULTI_POINT ? t.setGeometry(new m.a([e])) : this.type_ === A.a.MULTI_LINE_STRING ? t.setGeometry(new g.
		default ([e])) : this.type_ === A.a.MULTI_POLYGON && t.setGeometry(new v.a([e])), this.dispatchEvent(new R.Event(E.DRAWEND, t)), this.features_ && this.features_.push(t), this.source_ && this.source_.addFeature(t)
		}, R.prototype.abortDrawing_ = function() {
			this.finishCoordinate_ = null;
			var t = this.sketchFeature_;
			return t && (this.sketchFeature_ = null, this.sketchPoint_ = null, this.sketchLine_ = null, this.overlay_.getSource().clear(!0)), t
		}, R.prototype.extend = function(t) {
			var e = t.getGeometry();
			this.sketchFeature_ = t, this.sketchCoords_ = e.getCoordinates();
			var i = this.sketchCoords_[this.sketchCoords_.length - 1];
			this.finishCoordinate_ = i.slice(), this.sketchCoords_.push(i.slice()), this.updateSketchFeatures_(), this.dispatchEvent(new R.Event(E.DRAWSTART, this.sketchFeature_))
		}, R.prototype.shouldStopEvent = d.a.FALSE, R.prototype.updateSketchFeatures_ = function() {
			var t = [];
			this.sketchFeature_ && t.push(this.sketchFeature_), this.sketchLine_ && t.push(this.sketchLine_), this.sketchPoint_ && t.push(this.sketchPoint_);
			var e = this.overlay_.getSource();
			e.clear(!0), e.addFeatures(t)
		}, R.prototype.updateState_ = function() {
			var t = this.getMap(),
				e = this.getActive();
			t && e || this.abortDrawing_(), this.overlay_.setMap(e ? t : null)
		}, R.createRegularPolygon = function(t, e) {
			return function(i, n) {
				var r = i[0],
					o = i[1],
					s = Math.sqrt(a.
				default.squaredDistance(r, o)),
					l = n || _.
				default.fromCircle(new f.
				default (r), t),
					u = e || Math.atan((o[1] - r[1]) / (o[0] - r[0]));
				return _.
			default.makeRegular(l, r, s, u), l
			}
		}, R.createBox = function() {
			return function(t, e) {
				var i = c.
			default.boundingExtent(t),
					n = e || new _.
				default (null);
				return n.setCoordinates([
					[c.
				default.getBottomLeft(i), c.
				default.getBottomRight(i), c.
				default.getTopRight(i), c.
				default.getTopLeft(i), c.
				default.getBottomLeft(i)]
				]), n
			}
		}, R.getMode_ = function(t) {
			var e;
			return t === A.a.POINT || t === A.a.MULTI_POINT ? e = R.Mode_.POINT : t === A.a.LINE_STRING || t === A.a.MULTI_LINE_STRING ? e = R.Mode_.LINE_STRING : t === A.a.POLYGON || t === A.a.MULTI_POLYGON ? e = R.Mode_.POLYGON : t === A.a.CIRCLE && (e = R.Mode_.CIRCLE), e
		}, R.Mode_ = {
			POINT: "Point",
			LINE_STRING: "LineString",
			POLYGON: "Polygon",
			CIRCLE: "Circle"
		}, R.Event = function(t, e) {
			u.a.call(this, t), this.feature = e
		}, n.
	default.inherits(R.Event, u.a);
		e.
	default = R
	}, function(t, e, i) {
		"use strict";
		var n = i(0),
			r = function(t) {
				var e = n.
			default.VERSION ? n.
			default.VERSION.split("-")[0]:
				"latest";
				this.message = "Assertion failed. See https://openlayers.org/en/" + e + "/doc/errors/#" + t + " for details.", this.code = t, this.name = "AssertionError"
			};
		n.
	default.inherits(r, Error), e.a = r
	}, function(t, e, i) {
		"use strict";
		var n = i(10),
			r = i(72),
			o = {
				linearRings: function(t, e, i, o, s, a, l) {
					for (var u, h, c, d, f, A, p, g = s[a + 1], m = [], v = 0, y = i.length; v < y; ++v) {
						var _ = i[v];
						for (d = t[_ - o], A = t[_ - o + 1], u = e; u < _; u += o) f = t[u], p = t[u + 1], (g <= A && p <= g || A <= g && g <= p) && (c = (g - A) / (p - A) * (f - d) + d, m.push(c)), d = f, A = p
					}
					var E = NaN,
						x = -1 / 0;
					for (m.sort(n.a.numberSafeCompareFunction), d = m[0], u = 1, h = m.length; u < h; ++u) {
						f = m[u];
						var C = Math.abs(f - d);
						C > x && (c = (d + f) / 2, r.a.linearRingsContainsXY(t, e, i, o, c, g) && (E = c, x = C)), d = f
					}
					return isNaN(E) && (E = s[a]), l ? (l.push(E, g, x), l) : [E, g, x]
				},
				linearRingss: function(t, e, i, n, r) {
					var s, a, l = [];
					for (s = 0, a = i.length; s < a; ++s) {
						var u = i[s];
						l = o.linearRings(t, e, u, n, r, 2 * s, l), e = u[u.length - 1]
					}
					return l
				}
			};
		e.a = o
	}, function(t, e, i) {
		"use strict";
		var n = {
			forEach: function(t, e, i, n, r, o) {
				for (var s, a = [t[e], t[e + 1]], l = []; e + n < i; e += n) {
					if (l[0] = t[e + n], l[1] = t[e + n + 1], s = r.call(o, a, l)) return s;
					a[0] = l[0], a[1] = l[1]
				}
				return !1
			}
		};
		e.a = n
	}, function(t, e, i) {
		"use strict";
		e.a = {
			IMAGE: "image",
			VECTOR: "vector"
		}
	}, function(t, e, i) {
		"use strict";
		var n = {
			lineString: function(t, e, i, n) {
				var r, o = t[e],
					s = t[e + 1],
					a = 0;
				for (r = e + n; r < i; r += n) {
					var l = t[r],
						u = t[r + 1];
					a += Math.sqrt((l - o) * (l - o) + (u - s) * (u - s)), o = l, s = u
				}
				return a
			},
			linearRing: function(t, e, i, r) {
				var o = n.lineString(t, e, i, r),
					s = t[i - r] - t[e],
					a = t[i - r + 1] - t[e + 1];
				return o += Math.sqrt(s * s + a * a)
			}
		};
		e.a = n
	}, function(t, e, i) {
		"use strict";
		e.a = {
			POINT: "point",
			LINE: "line"
		}
	}, function(t, e, i) {
		"use strict";
		i.r(e);
		var n = i(0),
			r = i(71),
			o = i(75),
			s = function(t) {
				var e = t || {},
					i = void 0 !== e.projection ? e.projection : "EPSG:3857",
					n = void 0 !== e.tileGrid ? e.tileGrid : o.a.createXYZ({
						extent: o.a.extentFromProjection(i),
						maxZoom: e.maxZoom,
						minZoom: e.minZoom,
						tileSize: e.tileSize
					});
				r.a.call(this, {
					attributions: e.attributions,
					cacheSize: e.cacheSize,
					crossOrigin: e.crossOrigin,
					logo: e.logo,
					opaque: e.opaque,
					projection: i,
					reprojectionErrorThreshold: e.reprojectionErrorThreshold,
					tileGrid: n,
					tileLoadFunction: e.tileLoadFunction,
					tilePixelRatio: e.tilePixelRatio,
					tileUrlFunction: e.tileUrlFunction,
					url: e.url,
					urls: e.urls,
					wrapX: void 0 === e.wrapX || e.wrapX,
					transition: e.transition
				})
			};
		n.
	default.inherits(s, r.a), e.
	default = s
	}, function(t, e, i) {
		"use strict";
		var n = i(0),
			r = i(1),
			o = i(11),
			s = i(9),
			a = function(t, e, i, o, a) {
				this.sourceProj_ = t, this.targetProj_ = e;
				var l = {},
					u = s.
				default.getTransform(this.targetProj_, this.sourceProj_);
				this.transformInv_ = function(t) {
					var e = t[0] + "/" + t[1];
					return l[e] || (l[e] = u(t)), l[e]
				}, this.maxSourceExtent_ = o, this.errorThresholdSquared_ = a * a, this.triangles_ = [], this.wrapsXInSource_ = !1, this.canWrapXInSource_ = this.sourceProj_.canWrapX() && !! o && !! this.sourceProj_.getExtent() && r.
			default.getWidth(o) == r.
			default.getWidth(this.sourceProj_.getExtent()), this.sourceWorldWidth_ = this.sourceProj_.getExtent() ? r.
			default.getWidth(this.sourceProj_.getExtent()):
				null, this.targetWorldWidth_ = this.targetProj_.getExtent() ? r.
			default.getWidth(this.targetProj_.getExtent()):
				null;
				var h = r.
			default.getTopLeft(i),
					c = r.
				default.getTopRight(i),
					d = r.
				default.getBottomRight(i),
					f = r.
				default.getBottomLeft(i),
					A = this.transformInv_(h),
					p = this.transformInv_(c),
					g = this.transformInv_(d),
					m = this.transformInv_(f);
				if (this.addQuad_(h, c, d, f, A, p, g, m, n.
			default.RASTER_REPROJECTION_MAX_SUBDIVISION), this.wrapsXInSource_) {
					var v = 1 / 0;
					this.triangles_.forEach((function(t, e, i) {
						v = Math.min(v, t.source[0][0], t.source[1][0], t.source[2][0])
					})), this.triangles_.forEach((function(t) {
						if (Math.max(t.source[0][0], t.source[1][0], t.source[2][0]) - v > this.sourceWorldWidth_ / 2) {
							var e = [
								[t.source[0][0], t.source[0][1]],
								[t.source[1][0], t.source[1][1]],
								[t.source[2][0], t.source[2][1]]
							];
							e[0][0] - v > this.sourceWorldWidth_ / 2 && (e[0][0] -= this.sourceWorldWidth_), e[1][0] - v > this.sourceWorldWidth_ / 2 && (e[1][0] -= this.sourceWorldWidth_), e[2][0] - v > this.sourceWorldWidth_ / 2 && (e[2][0] -= this.sourceWorldWidth_);
							var i = Math.min(e[0][0], e[1][0], e[2][0]);
							Math.max(e[0][0], e[1][0], e[2][0]) - i < this.sourceWorldWidth_ / 2 && (t.source = e)
						}
					}), this)
				}
				l = {}
			};
		a.prototype.addTriangle_ = function(t, e, i, n, r, o) {
			this.triangles_.push({
				source: [n, r, o],
				target: [t, e, i]
			})
		}, a.prototype.addQuad_ = function(t, e, i, s, a, l, u, h, c) {
			var d = r.
		default.boundingExtent([a, l, u, h]),
				f = this.sourceWorldWidth_ ? r.
			default.getWidth(d) / this.sourceWorldWidth_:
				null,
				A = this.sourceWorldWidth_,
				p = this.sourceProj_.canWrapX() && f > .5 && f < 1,
				g = !1;
			if (c > 0) {
				if (this.targetProj_.isGlobal() && this.targetWorldWidth_) {
					var m = r.
				default.boundingExtent([t, e, i, s]);
					g |= r.
				default.getWidth(m) / this.targetWorldWidth_ > n.
				default.RASTER_REPROJECTION_MAX_TRIANGLE_WIDTH
				}!p && this.sourceProj_.isGlobal() && f && (g |= f > n.
			default.RASTER_REPROJECTION_MAX_TRIANGLE_WIDTH)
			}
			if (g || !this.maxSourceExtent_ || r.
		default.intersects(d, this.maxSourceExtent_)) {
				if (!(g || isFinite(a[0]) && isFinite(a[1]) && isFinite(l[0]) && isFinite(l[1]) && isFinite(u[0]) && isFinite(u[1]) && isFinite(h[0]) && isFinite(h[1]))) {
					if (!(c > 0)) return;
					g = !0
				}
				if (c > 0) {
					if (!g) {
						var v, y = [(t[0] + i[0]) / 2, (t[1] + i[1]) / 2],
							_ = this.transformInv_(y);
						if (p) v = (o.a.modulo(a[0], A) + o.a.modulo(u[0], A)) / 2 - o.a.modulo(_[0], A);
						else v = (a[0] + u[0]) / 2 - _[0];
						var E = (a[1] + u[1]) / 2 - _[1];
						g = v * v + E * E > this.errorThresholdSquared_
					}
					if (g) {
						if (Math.abs(t[0] - i[0]) <= Math.abs(t[1] - i[1])) {
							var x = [(e[0] + i[0]) / 2, (e[1] + i[1]) / 2],
								C = this.transformInv_(x),
								I = [(s[0] + t[0]) / 2, (s[1] + t[1]) / 2],
								S = this.transformInv_(I);
							this.addQuad_(t, e, x, I, a, l, C, S, c - 1), this.addQuad_(I, x, i, s, S, C, u, h, c - 1)
						} else {
							var T = [(t[0] + e[0]) / 2, (t[1] + e[1]) / 2],
								R = this.transformInv_(T),
								w = [(i[0] + s[0]) / 2, (i[1] + s[1]) / 2],
								L = this.transformInv_(w);
							this.addQuad_(t, T, w, s, a, R, L, h, c - 1), this.addQuad_(T, e, i, w, R, l, u, L, c - 1)
						}
						return
					}
				}
				if (p) {
					if (!this.canWrapXInSource_) return;
					this.wrapsXInSource_ = !0
				}
				this.addTriangle_(t, i, s, a, u, h), this.addTriangle_(t, e, i, a, l, u)
			}
		}, a.prototype.calculateSourceExtent = function() {
			var t = r.
		default.createEmpty();
			return this.triangles_.forEach((function(e, i, n) {
				var o = e.source;
				r.
			default.extendCoordinate(t, o[0]), r.
			default.extendCoordinate(t, o[1]), r.
			default.extendCoordinate(t, o[2])
			})), t
		}, a.prototype.getTriangles = function() {
			return this.triangles_
		}, e.a = a
	}, function(t, e, i) {
		"use strict";
		i.r(e);
		var n = i(21),
			r = i(0),
			o = i(28),
			s = i(23),
			a = i(88),
			l = i(31),
			u = function(t) {
				this.geometry_ = null, this.element_ = document.createElement("div"), this.element_.style.position = "absolute", this.element_.className = "ol-box " + t, this.map_ = null, this.startPixel_ = null, this.endPixel_ = null
			};
		r.
	default.inherits(u, a.a), u.prototype.disposeInternal = function() {
			this.setMap(null)
		}, u.prototype.render_ = function() {
			var t = this.startPixel_,
				e = this.endPixel_,
				i = this.element_.style;
			i.left = Math.min(t[0], e[0]) + "px", i.top = Math.min(t[1], e[1]) + "px", i.width = Math.abs(e[0] - t[0]) + "px", i.height = Math.abs(e[1] - t[1]) + "px"
		}, u.prototype.setMap = function(t) {
			if (this.map_) {
				this.map_.getOverlayContainer().removeChild(this.element_);
				var e = this.element_.style;
				e.left = e.top = e.width = e.height = "inherit"
			}
			this.map_ = t, this.map_ && this.map_.getOverlayContainer().appendChild(this.element_)
		}, u.prototype.setPixels = function(t, e) {
			this.startPixel_ = t, this.endPixel_ = e, this.createOrUpdateGeometry(), this.render_()
		}, u.prototype.createOrUpdateGeometry = function() {
			var t = this.startPixel_,
				e = this.endPixel_,
				i = [t, [t[0], e[1]], e, [e[0], t[1]]].map(this.map_.getCoordinateFromPixel, this.map_);
			i[4] = i[0].slice(), this.geometry_ ? this.geometry_.setCoordinates([i]) : this.geometry_ = new l.
		default ([i])
		}, u.prototype.getGeometry = function() {
			return this.geometry_
		};
		var h = u,
			c = function(t) {
				s.a.call(this, {
					handleDownEvent: c.handleDownEvent_,
					handleDragEvent: c.handleDragEvent_,
					handleUpEvent: c.handleUpEvent_
				});
				var e = t || {};
				this.box_ = new h(e.className || "ol-dragbox"), this.minArea_ = void 0 !== e.minArea ? e.minArea : 64, this.startPixel_ = null, this.condition_ = e.condition ? e.condition : o.
			default.always, this.boxEndCondition_ = e.boxEndCondition ? e.boxEndCondition:
				c.defaultBoxEndCondition
			};
		r.
	default.inherits(c, s.a), c.defaultBoxEndCondition = function(t, e, i) {
			var n = i[0] - e[0],
				r = i[1] - e[1];
			return n * n + r * r >= this.minArea_
		}, c.handleDragEvent_ = function(t) {
			o.
		default.mouseOnly(t) && (this.box_.setPixels(this.startPixel_, t.pixel), this.dispatchEvent(new c.Event(c.EventType_.BOXDRAG, t.coordinate, t)))
		}, c.prototype.getGeometry = function() {
			return this.box_.getGeometry()
		}, c.prototype.onBoxEnd = r.
	default.nullFunction, c.handleUpEvent_ = function(t) {
			return !o.
		default.mouseOnly(t) || (this.box_.setMap(null), this.boxEndCondition_(t, this.startPixel_, t.pixel) && (this.onBoxEnd(t), this.dispatchEvent(new c.Event(c.EventType_.BOXEND, t.coordinate, t))), !1)
		}, c.handleDownEvent_ = function(t) {
			return !!o.
		default.mouseOnly(t) && (!(!o.
		default.mouseActionButton(t) || !this.condition_(t)) && (this.startPixel_ = t.pixel, this.box_.setMap(t.map), this.box_.setPixels(this.startPixel_, this.startPixel_), this.dispatchEvent(new c.Event(c.EventType_.BOXSTART, t.coordinate, t)), !0))
		}, c.EventType_ = {
			BOXSTART: "boxstart",
			BOXDRAG: "boxdrag",
			BOXEND: "boxend"
		}, c.Event = function(t, e, i) {
			n.a.call(this, t), this.coordinate = e, this.mapBrowserEvent = i
		}, r.
	default.inherits(c.Event, n.a);
		e.
	default = c
	}, function(t, e, i) {
		"use strict";
		var n = i(44),
			r = function() {
				this.cache_ = {}, this.cacheSize_ = 0, this.maxCacheSize_ = 32
			};
		r.getKey = function(t, e, i) {
			return e + ":" + t + ":" + (i ? n.a.asString(i) : "null")
		}, r.prototype.clear = function() {
			this.cache_ = {}, this.cacheSize_ = 0
		}, r.prototype.expire = function() {
			if (this.cacheSize_ > this.maxCacheSize_) {
				var t, e, i = 0;
				for (t in this.cache_) e = this.cache_[t], 0 != (3 & i++) || e.hasListener() || (delete this.cache_[t], --this.cacheSize_)
			}
		}, r.prototype.get = function(t, e, i) {
			var n = r.getKey(t, e, i);
			return n in this.cache_ ? this.cache_[n] : null
		}, r.prototype.set = function(t, e, i, n) {
			var o = r.getKey(t, e, i);
			this.cache_[o] = n, ++this.cacheSize_
		}, r.prototype.setSize = function(t) {
			this.maxCacheSize_ = t, this.expire()
		};
		var o = r,
			s = {};
		s.iconImageCache = new o;
		e.a = s
	}, function(t, e, i) {
		"use strict";
		Object.defineProperty(e, "__esModule", {
			value: !0
		}), e.switchSelFea = e.selStyle = e.selFeaObj = void 0;
		var n = h(i(34)),
			r = h(i(38)),
			o = h(i(36)),
			s = h(i(86)),
			a = h(i(100)),
			l = h(i(68)),
			u = i(87);

		function h(t) {
			return t && t.__esModule ? t : {
			default:
				t
			}
		}
		var c = {},
			d = function() {
				var t = new r.
			default ({
					color: u.DefaultStyle.selFillColor
				}),
					e = new o.
				default ({
						color: u.DefaultStyle.selStrokeColor,
						width: u.DefaultStyle.selStrokeWidth
					});
				return [new n.
			default ({
					image: new l.
				default ({
						fill: t,
						stroke: e,
						radius: 5
					}),
					fill:
					t,
					stroke: e
				})]
			},
			f = {
				CIRCLE: function(t) {
					return new n.
				default ({
						image: new l.
					default ({
							radius: t.radius,
							stroke: new o.
						default ({
								color: t.selStrokeColor
							}),
							fill:
							new r.
						default ({
								color: t.selFillColor
							})
						}),
						stroke:
						new o.
					default ({
							color: t.selStrokeColor
						}),
						fill:
						new r.
					default ({
							color: t.selFillColor
						}),
						text:
						new s.
					default ({
							text: t.label,
							fill: new r.
						default ({
								color: t.selLabFillColor
							}),
							stroke:
							new o.
						default ({
								color: t.selLabStrokeColor,
								width: t.selLabStrokeWidth
							})
						})
					})
				},
				ICON: function(t) {
					if (t.isBox) {
						var e = document.createElement("img");
						e.src = t.src;
						var i = [e.width, e.height],
							l = i[0] > i[1] ? i[0] : i[1],
							u = function(t) {
								var e = t.xaxis || 0,
									i = t.yaxis || 0,
									n = t.width,
									r = t.height,
									o = t.radius,
									s = document.createElement("canvas");
								s.width = n, s.height = r;
								var a = s.getContext("2d");
								return n < 4 * o && (o = n / 4), r < 4 * o && (o = r / 4), a.beginPath(), a.moveTo(e + o, i), a.arcTo(e + n, i, e + n, i + r, o), a.arcTo(e + n, i + r, e, i + r, o), a.arcTo(e, i + r, e, i, o), a.arcTo(e, i, e + n, i, o), a.closePath(), a.fillStyle = t.fillColor, a.fill(), s
							}({
								xaxis: 0,
								yaxis: 0,
								width: (l = parseInt(l) * t.scale) + 2,
								height: l + 2,
								radius: l / 2 + 1,
								fillColor: t.selFillColor
							});
						return [new n.
					default ({
							image: new a.
						default ({
								img: u,
								imgSize: [u.width, u.height]
							}),
							zIndex:
							-1
						}), new n.
					default ({
							image: new a.
						default ({
								anchor: t.anchor,
								anchorXUnits: "pixels",
								anchorYUnits: "pixels",
								src: t.src,
								scale: t.scale
							}),
							text:
							new s.
						default ({
								font: t.lalFontSize + " " + t.labFontFamily,
								text: t.label,
								fill: new r.
							default ({
									color: t.selLabFillColor
								}),
								stroke:
								new o.
							default ({
									color: t.selLabStrokeColor,
									width: t.selLabStrokeWidth
								}),
								offsetX:
								t.labOffsetX,
								offsetY: t.labOffsetY
							})
						})]
					}
					var h;
					if (t.isCanvas) {
						var c = new Image(t.width, t.height);
						c.crossOrigin = "anonymous", c.src = t.selSrc;
						var d = document.createElement("canvas");
						d.width = t.width, d.height = t.height;
						var f = d.getContext("2d");
						c.onload = function() {
							f.drawImage(c, 0, 0, t.width, t.height)
						}, h = new a.
					default ({
							img: d,
							imgSize: [t.width, t.height]
						})
					} else h = new a.
				default ({
						anchor: t.anchor,
						src: t.selSrc,
						scale: t.scale,
						anchorXUnits: "pixels",
						anchorYUnits: "pixels",
						rotation: Math.PI / 180 * t.IconRotation
					});
					return new n.
				default ({
						image: h,
						text: new s.
					default ({
							font: t.lalFontSize + " " + t.labFontFamily,
							text: t.label,
							fill: new r.
						default ({
								color: t.selLabFillColor
							}),
							stroke:
							new o.
						default ({
								color: t.selLabStrokeColor,
								width: t.selLabStrokeWidth
							}),
							offsetX:
							t.labOffsetX,
							offsetY: t.labOffsetY
						})
					})
				},
				LINE: function(t) {
					return new n.
				default ({
						stroke: new o.
					default ({
							color: t.selStrokeColor
						}),
						fill:
						new r.
					default ({
							color: t.selFillColor
						}),
						text:
						new s.
					default ({
							text: t.label,
							fill: new r.
						default ({
								color: t.selLabFillColor
							}),
							stroke:
							new o.
						default ({
								color: t.selLabStrokeColor,
								width: t.selLabStrokeWidth
							})
						})
					})
				},
				POLYGON: function(t) {
					return new n.
				default ({
						stroke: new o.
					default ({
							color: t.selStrokeColor
						}),
						fill:
						new r.
					default ({
							color: t.selFillColor
						}),
						text:
						new s.
					default ({
							text: t.label,
							fill: new r.
						default ({
								color: t.selLabFillColor
							}),
							stroke:
							new o.
						default ({
								color: t.selLabStrokeColor,
								width: t.selLabStrokeWidth
							})
						})
					})
				},
				DATASERVER: function(t) {
					return "ICON" == t.type ? this.ICON(t) : "POLYGON" == t.type ? this.POLYGON(t) : void 0
				}
			};
		e.selFeaObj = c, e.selStyle = f, e.switchSelFea = function(t) {
			for (var e in c) if (e.indexOf(t.mapId) >= 0) {
				var i = c[e];
				e.indexOf(t.mapId + t.selType) >= 0 && (c[e].setStyle(null), delete c[e])
			}
			if (t.hasOwnProperty("featureArr")) if (t.featureArr instanceof Array) for (var n = 0; n < t.featureArr.length; n++) {
				i = t.featureArr[n];
				c[t.mapId + t.selType + t.layerType + i.get("id")] = i, i.setStyle(f[t.layerType](i.get("property")))
			} else {
				for (var e in c) {
					if (e.indexOf(t.mapId) >= 0) if ((i = c[e]) == t.featureArr) return
				}
				c[t.mapId + t.selType + t.layerType + t.featureArr.get("id")] = t.featureArr, t.featureArr.get("property") ? t.featureArr.setStyle(f[t.layerType](t.featureArr.get("property"))) : t.featureArr.setStyle(d)
			}
		}
	}, function(t, e, i) {
		!
		function(t) {
			"use strict";

			function e(t, e) {
				for (var i in e) e.hasOwnProperty(i) && (t[i] = e[i])
			}
			function i() {}
			function n() {}
			function r() {}
			function o() {}
			function s() {}
			function a() {}
			function l() {}
			function u(t) {
				this.message = t
			}
			function h(t, e) {
				t.prototype = Object.create(e.prototype), t.prototype.constructor = t
			}
			function c() {
				if (0 === arguments.length) u.call(this);
				else if (1 === arguments.length) {
					var t = arguments[0];
					u.call(this, t)
				}
			}
			function d() {}
			function f() {
				if (this.x = null, this.y = null, this.z = null, 0 === arguments.length) f.call(this, 0, 0);
				else if (1 === arguments.length) {
					var t = arguments[0];
					f.call(this, t.x, t.y, t.z)
				} else if (2 === arguments.length) {
					var e = arguments[0],
						i = arguments[1];
					f.call(this, e, i, f.NULL_ORDINATE)
				} else if (3 === arguments.length) {
					var n = arguments[0],
						r = arguments[1],
						o = arguments[2];
					this.x = n, this.y = r, this.z = o
				}
			}
			function A() {
				if (this.dimensionsToTest = 2, 0 === arguments.length) A.call(this, 2);
				else if (1 === arguments.length) {
					var t = arguments[0];
					if (2 !== t && 3 !== t) throw new n("only 2 or 3 dimensions may be specified");
					this.dimensionsToTest = t
				}
			}
			function p() {}
			function g() {}
			function m(t) {
				this.message = t || ""
			}
			function v() {}
			function y(t) {
				this.message = t || ""
			}
			function _(t) {
				this.message = t || ""
			}
			function E() {
				this.array_ = [], arguments[0] instanceof g && this.addAll(arguments[0])
			}
			function x() {
				if (E.apply(this), 0 === arguments.length);
				else if (1 === arguments.length) {
					var t = arguments[0];
					this.ensureCapacity(t.length), this.add(t, !0)
				} else if (2 === arguments.length) {
					var e = arguments[0],
						i = arguments[1];
					this.ensureCapacity(e.length), this.add(e, i)
				}
			}
			function C() {
				if (this.minx = null, this.maxx = null, this.miny = null, this.maxy = null, 0 === arguments.length) this.init();
				else if (1 === arguments.length) {
					if (arguments[0] instanceof f) {
						var t = arguments[0];
						this.init(t.x, t.x, t.y, t.y)
					} else if (arguments[0] instanceof C) {
						var e = arguments[0];
						this.init(e)
					}
				} else if (2 === arguments.length) {
					var i = arguments[0],
						n = arguments[1];
					this.init(i.x, n.x, i.y, n.y)
				} else if (4 === arguments.length) {
					var r = arguments[0],
						o = arguments[1],
						s = arguments[2],
						a = arguments[3];
					this.init(r, o, s, a)
				}
			}
			function I() {}
			function S() {
				I.call(this, "Projective point not representable on the Cartesian plane.")
			}
			function T() {}
			function R(t, e) {
				return t.interfaces_ && t.interfaces_().indexOf(e) > -1
			}
			function w() {}
			function L(t) {
				this.str = t
			}
			function N(t) {
				this.value = t
			}
			function P() {}
			function O() {
				if (this.hi = 0, this.lo = 0, 0 === arguments.length) this.init(0);
				else if (1 === arguments.length) {
					if ("number" == typeof arguments[0]) {
						var t = arguments[0];
						this.init(t)
					} else if (arguments[0] instanceof O) {
						var e = arguments[0];
						this.init(e)
					} else if ("string" == typeof arguments[0]) {
						var i = arguments[0];
						O.call(this, O.parse(i))
					}
				} else if (2 === arguments.length) {
					var n = arguments[0],
						r = arguments[1];
					this.init(n, r)
				}
			}
			function M() {}
			function b() {}
			function F() {}
			function D() {
				if (this.x = null, this.y = null, this.w = null, 0 === arguments.length) this.x = 0, this.y = 0, this.w = 1;
				else if (1 === arguments.length) {
					var t = arguments[0];
					this.x = t.x, this.y = t.y, this.w = 1
				} else if (2 === arguments.length) {
					if ("number" == typeof arguments[0] && "number" == typeof arguments[1]) {
						var e = arguments[0],
							i = arguments[1];
						this.x = e, this.y = i, this.w = 1
					} else if (arguments[0] instanceof D && arguments[1] instanceof D) {
						var n = arguments[0],
							r = arguments[1];
						this.x = n.y * r.w - r.y * n.w, this.y = r.x * n.w - n.x * r.w, this.w = n.x * r.y - r.x * n.y
					} else if (arguments[0] instanceof f && arguments[1] instanceof f) {
						var o = arguments[0],
							s = arguments[1];
						this.x = o.y - s.y, this.y = s.x - o.x, this.w = o.x * s.y - s.x * o.y
					}
				} else if (3 === arguments.length) {
					var a = arguments[0],
						l = arguments[1],
						u = arguments[2];
					this.x = a, this.y = l, this.w = u
				} else if (4 === arguments.length) {
					var h = arguments[0],
						c = arguments[1],
						d = arguments[2],
						A = arguments[3],
						p = h.y - c.y,
						g = c.x - h.x,
						m = h.x * c.y - c.x * h.y,
						v = d.y - A.y,
						y = A.x - d.x,
						_ = d.x * A.y - A.x * d.y;
					this.x = g * _ - y * m, this.y = v * m - p * _, this.w = p * y - v * g
				}
			}
			function G() {}
			function k() {}
			function U() {
				this.envelope = null, this.factory = null, this.SRID = null, this.userData = null;
				var t = arguments[0];
				this.factory = t, this.SRID = t.getSRID()
			}
			function B() {}
			function j() {}
			function V() {}
			function Y() {}
			function z() {}
			function X() {}
			function W() {}
			function q() {}
			function H() {}
			function Z() {}
			function K() {}
			function J() {}
			function Q() {
				this.array_ = [], arguments[0] instanceof g && this.addAll(arguments[0])
			}
			function $(t) {
				return null == t ? jo : t.color
			}
			function tt(t) {
				return null == t ? null : t.parent
			}
			function et(t, e) {
				null !== t && (t.color = e)
			}
			function it(t) {
				return null == t ? null : t.left
			}
			function nt(t) {
				return null == t ? null : t.right
			}
			function rt() {
				this.root_ = null, this.size_ = 0
			}
			function ot() {}
			function st() {}
			function at() {
				this.array_ = [], arguments[0] instanceof g && this.addAll(arguments[0])
			}
			function lt() {}
			function ut() {}
			function ht() {}
			function ct() {}
			function dt() {
				this.geometries = null;
				var t = arguments[0],
					e = arguments[1];
				if (U.call(this, e), null === t && (t = []), U.hasNullElements(t)) throw new n("geometries must not contain null elements");
				this.geometries = t
			}
			function ft() {
				var t = arguments[0],
					e = arguments[1];
				dt.call(this, t, e)
			}
			function At() {
				if (this.geom = null, this.geomFact = null, this.bnRule = null, this.endpointMap = null, 1 === arguments.length) {
					var t = arguments[0];
					At.call(this, t, j.MOD2_BOUNDARY_RULE)
				} else if (2 === arguments.length) {
					var e = arguments[0],
						i = arguments[1];
					this.geom = e, this.geomFact = e.getFactory(), this.bnRule = i
				}
			}
			function pt() {
				this.count = null
			}
			function gt() {}
			function mt() {}
			function vt() {}
			function yt() {}
			function _t() {}
			function Et() {}
			function xt() {}
			function Ct() {
				this.points = null;
				var t = arguments[0],
					e = arguments[1];
				U.call(this, e), this.init(t)
			}
			function It() {}
			function St() {
				this.coordinates = null;
				var t = arguments[0],
					e = arguments[1];
				U.call(this, e), this.init(t)
			}
			function Tt() {}
			function Rt() {
				this.shell = null, this.holes = null;
				var t = arguments[0],
					e = arguments[1],
					i = arguments[2];
				if (U.call(this, i), null === t && (t = this.getFactory().createLinearRing()), null === e && (e = []), U.hasNullElements(e)) throw new n("holes must not contain null elements");
				if (t.isEmpty() && U.hasNonEmptyElements(e)) throw new n("shell is empty but holes are not");
				this.shell = t, this.holes = e
			}
			function wt() {
				var t = arguments[0],
					e = arguments[1];
				dt.call(this, t, e)
			}
			function Lt() {
				if (arguments[0] instanceof f && arguments[1] instanceof Wt) {
					var t = arguments[0],
						e = arguments[1];
					Lt.call(this, e.getCoordinateSequenceFactory().create(t), e)
				} else if (R(arguments[0], b) && arguments[1] instanceof Wt) {
					var i = arguments[0],
						n = arguments[1];
					Ct.call(this, i, n), this.validateConstruction()
				}
			}
			function Nt() {
				var t = arguments[0],
					e = arguments[1];
				dt.call(this, t, e)
			}
			function Pt() {
				if (this.factory = null, this.isUserDataCopied = !1, 0 === arguments.length);
				else if (1 === arguments.length) {
					var t = arguments[0];
					this.factory = t
				}
			}
			function Ot() {}
			function Mt() {}
			function bt() {}
			function Ft() {}
			function Dt() {
				if (this.dimension = 3, this.coordinates = null, 1 === arguments.length) {
					if (arguments[0] instanceof Array) {
						var t = arguments[0];
						Dt.call(this, t, 3)
					} else if (Number.isInteger(arguments[0])) {
						var e = arguments[0];
						this.coordinates = new Array(e).fill(null);
						for (var i = 0; e > i; i++) this.coordinates[i] = new f
					} else if (R(arguments[0], b)) {
						var n = arguments[0];
						if (null === n) return this.coordinates = new Array(0).fill(null), null;
						for (this.dimension = n.getDimension(), this.coordinates = new Array(n.size()).fill(null), i = 0; i < this.coordinates.length; i++) this.coordinates[i] = n.getCoordinateCopy(i)
					}
				} else if (2 === arguments.length) if (arguments[0] instanceof Array && Number.isInteger(arguments[1])) {
					var r = arguments[0],
						o = arguments[1];
					this.coordinates = r, this.dimension = o, null === r && (this.coordinates = new Array(0).fill(null))
				} else if (Number.isInteger(arguments[0]) && Number.isInteger(arguments[1])) {
					var s = arguments[0],
						a = arguments[1];
					for (this.coordinates = new Array(s).fill(null), this.dimension = a, i = 0; s > i; i++) this.coordinates[i] = new f
				}
			}
			function Gt() {}
			function kt(t, e) {
				return t === e || t != t && e != e
			}
			function Ut(t) {
				this.add ? t.forEach(this.add, this) : t.forEach((function(t) {
					this.set(t[0], t[1])
				}), this)
			}
			function Bt(t, e) {
				if (this.objectOnly && e !== Object(e)) throw new TypeError("Invalid value used as weak collection key");
				if (e != e || 0 === e) for (Yo = t.length; Yo-- && !kt(t[Yo], e););
				else Yo = t.indexOf(e);
				return Yo > -1
			}
			function jt(t, e, i) {
				var n = [0],
					r = !1;
				return t.push(n), {
					next: function() {
						var o, s = n[0];
						return !r && s < e.length ? (o = i ? [e[s], i[s]] : e[s], n[0]++) : (r = !0, t.splice(t.indexOf(n), 1)), {
							done: r,
							value: o
						}
					}
				}
			}
			function Vt() {
				return this._values.length
			}
			function Yt() {
				this.map_ = new Wo
			}
			function zt() {
				if (this.modelType = null, this.scale = null, 0 === arguments.length) this.modelType = zt.FLOATING;
				else if (1 === arguments.length) if (arguments[0] instanceof Xt) {
					var t = arguments[0];
					this.modelType = t, t === zt.FIXED && this.setScale(1)
				} else if ("number" == typeof arguments[0]) {
					var e = arguments[0];
					this.modelType = zt.FIXED, this.setScale(e)
				} else if (arguments[0] instanceof zt) {
					var i = arguments[0];
					this.modelType = i.modelType, this.scale = i.scale
				}
			}
			function Xt() {
				this.name = null;
				var t = arguments[0];
				this.name = t, Xt.nameToTypeMap.put(t, this)
			}
			function Wt() {
				if (this.precisionModel = null, this.coordinateSequenceFactory = null, this.SRID = null, 0 === arguments.length) Wt.call(this, new zt, 0);
				else if (1 === arguments.length) {
					if (R(arguments[0], G)) {
						var t = arguments[0];
						Wt.call(this, new zt, 0, t)
					} else if (arguments[0] instanceof zt) {
						var e = arguments[0];
						Wt.call(this, e, 0, Wt.getDefaultCoordinateSequenceFactory())
					}
				} else if (2 === arguments.length) {
					var i = arguments[0],
						n = arguments[1];
					Wt.call(this, i, n, Wt.getDefaultCoordinateSequenceFactory())
				} else if (3 === arguments.length) {
					var r = arguments[0],
						o = arguments[1],
						s = arguments[2];
					this.precisionModel = r, this.coordinateSequenceFactory = s, this.SRID = o
				}
			}
			function qt(t) {
				this.geometryFactory = t || new Wt
			}
			function Ht(t) {
				this.parser = new qt(t)
			}
			function Zt() {
				this.result = null, this.inputLines = Array(2).fill().map((function() {
					return Array(2)
				})), this.intPt = new Array(2).fill(null), this.intLineIndex = null, this._isProper = null, this.pa = null, this.pb = null, this.precisionModel = null, this.intPt[0] = new f, this.intPt[1] = new f, this.pa = this.intPt[0], this.pb = this.intPt[1], this.result = 0
			}
			function Kt() {
				Zt.apply(this)
			}
			function Jt() {}
			function Qt() {
				this.p = null, this.crossingCount = 0, this.isPointOnSegment = !1;
				var t = arguments[0];
				this.p = t
			}
			function $t() {}
			function te() {
				if (this.p0 = null, this.p1 = null, 0 === arguments.length) te.call(this, new f, new f);
				else if (1 === arguments.length) {
					var t = arguments[0];
					te.call(this, t.p0, t.p1)
				} else if (2 === arguments.length) {
					var e = arguments[0],
						i = arguments[1];
					this.p0 = e, this.p1 = i
				} else if (4 === arguments.length) {
					var n = arguments[0],
						r = arguments[1],
						o = arguments[2],
						s = arguments[3];
					te.call(this, new f(n, r), new f(o, s))
				}
			}
			function ee() {
				if (this.matrix = null, 0 === arguments.length) this.matrix = Array(3).fill().map((function() {
					return Array(3)
				})), this.setAll(ut.FALSE);
				else if (1 === arguments.length) if ("string" == typeof arguments[0]) {
					var t = arguments[0];
					ee.call(this), this.set(t)
				} else if (arguments[0] instanceof ee) {
					var e = arguments[0];
					ee.call(this), this.matrix[T.INTERIOR][T.INTERIOR] = e.matrix[T.INTERIOR][T.INTERIOR], this.matrix[T.INTERIOR][T.BOUNDARY] = e.matrix[T.INTERIOR][T.BOUNDARY], this.matrix[T.INTERIOR][T.EXTERIOR] = e.matrix[T.INTERIOR][T.EXTERIOR], this.matrix[T.BOUNDARY][T.INTERIOR] = e.matrix[T.BOUNDARY][T.INTERIOR], this.matrix[T.BOUNDARY][T.BOUNDARY] = e.matrix[T.BOUNDARY][T.BOUNDARY], this.matrix[T.BOUNDARY][T.EXTERIOR] = e.matrix[T.BOUNDARY][T.EXTERIOR], this.matrix[T.EXTERIOR][T.INTERIOR] = e.matrix[T.EXTERIOR][T.INTERIOR], this.matrix[T.EXTERIOR][T.BOUNDARY] = e.matrix[T.EXTERIOR][T.BOUNDARY], this.matrix[T.EXTERIOR][T.EXTERIOR] = e.matrix[T.EXTERIOR][T.EXTERIOR]
				}
			}
			function ie() {
				this.areaBasePt = null, this.triangleCent3 = new f, this.areasum2 = 0, this.cg3 = new f, this.lineCentSum = new f, this.totalLength = 0, this.ptCount = 0, this.ptCentSum = new f;
				var t = arguments[0];
				this.areaBasePt = null, this.add(t)
			}
			function ne(t) {
				this.message = t || ""
			}
			function re() {
				this.array_ = []
			}
			function oe() {
				this.treeSet = new at, this.list = new E
			}
			function se() {
				if (this.geomFactory = null, this.inputPts = null, 1 === arguments.length) {
					var t = arguments[0];
					se.call(this, se.extractCoordinates(t), t.getFactory())
				} else if (2 === arguments.length) {
					var e = arguments[0],
						i = arguments[1];
					this.inputPts = oe.filterCoordinates(e), this.geomFactory = i
				}
			}
			function ae() {
				this.origin = null;
				var t = arguments[0];
				this.origin = t
			}
			function le() {
				this.inputGeom = null, this.factory = null, this.pruneEmptyGeometry = !0, this.preserveGeometryCollectionType = !0, this.preserveCollections = !1, this.preserveType = !1
			}
			function ue() {
				if (this.snapTolerance = 0, this.srcPts = null, this.seg = new te, this.allowSnappingToSourceVertices = !1, this._isClosed = !1, arguments[0] instanceof Ct && "number" == typeof arguments[1]) {
					var t = arguments[0],
						e = arguments[1];
					ue.call(this, t.getCoordinates(), e)
				} else if (arguments[0] instanceof Array && "number" == typeof arguments[1]) {
					var i = arguments[0],
						n = arguments[1];
					this.srcPts = i, this._isClosed = ue.isClosed(i), this.snapTolerance = n
				}
			}
			function he() {
				this.srcGeom = null;
				var t = arguments[0];
				this.srcGeom = t
			}
			function ce() {
				if (le.apply(this), this.snapTolerance = null, this.snapPts = null, this.isSelfSnap = !1, 2 === arguments.length) {
					var t = arguments[0],
						e = arguments[1];
					this.snapTolerance = t, this.snapPts = e
				} else if (3 === arguments.length) {
					var i = arguments[0],
						n = arguments[1],
						r = arguments[2];
					this.snapTolerance = i, this.snapPts = n, this.isSelfSnap = r
				}
			}
			function de() {
				this.isFirst = !0, this.commonMantissaBitsCount = 53, this.commonBits = 0, this.commonSignExp = null
			}
			function fe() {
				this.commonCoord = null, this.ccFilter = new Ae
			}
			function Ae() {
				this.commonBitsX = new de, this.commonBitsY = new de
			}
			function pe() {
				this.trans = null;
				var t = arguments[0];
				this.trans = t
			}
			function ge() {
				this.parent = null, this.atStart = null, this.max = null, this.index = null, this.subcollectionIterator = null;
				var t = arguments[0];
				this.parent = t, this.atStart = !0, this.index = 0, this.max = t.getNumGeometries()
			}
			function me() {
				if (this.boundaryRule = j.OGC_SFS_BOUNDARY_RULE, this.isIn = null, this.numBoundaries = null, 0 === arguments.length);
				else if (1 === arguments.length) {
					var t = arguments[0];
					if (null === t) throw new n("Rule must be non-null");
					this.boundaryRule = t
				}
			}
			function ve() {}
			function ye() {}
			function _e() {
				this.pts = null, this.data = null;
				var t = arguments[0],
					e = arguments[1];
				this.pts = t, this.data = e
			}
			function Ee() {}
			function xe() {
				this.bounds = null, this.item = null;
				var t = arguments[0],
					e = arguments[1];
				this.bounds = t, this.item = e
			}
			function Ce() {
				this._size = null, this.items = null, this._size = 0, this.items = new E, this.items.add(null)
			}
			function Ie() {}
			function Se() {}
			function Te() {
				if (this.childBoundables = new E, this.bounds = null, this.level = null, 0 === arguments.length);
				else if (1 === arguments.length) {
					var t = arguments[0];
					this.level = t
				}
			}
			function Re() {
				this.boundable1 = null, this.boundable2 = null, this._distance = null, this.itemDistance = null;
				var t = arguments[0],
					e = arguments[1],
					i = arguments[2];
				this.boundable1 = t, this.boundable2 = e, this.itemDistance = i, this._distance = this.distance()
			}
			function we() {
				if (this.root = null, this.built = !1, this.itemBoundables = new E, this.nodeCapacity = null, 0 === arguments.length) we.call(this, we.DEFAULT_NODE_CAPACITY);
				else if (1 === arguments.length) {
					var t = arguments[0];
					d.isTrue(t > 1, "Node capacity must be greater than 1"), this.nodeCapacity = t
				}
			}
			function Le() {}
			function Ne() {
				if (0 === arguments.length) Ne.call(this, Ne.DEFAULT_NODE_CAPACITY);
				else if (1 === arguments.length) {
					var t = arguments[0];
					we.call(this, t)
				}
			}
			function Pe() {
				var t = arguments[0];
				Te.call(this, t)
			}
			function Oe() {}
			function Me() {
				this.segString = null, this.coord = null, this.segmentIndex = null, this.segmentOctant = null, this._isInterior = null;
				var t = arguments[0],
					e = arguments[1],
					i = arguments[2],
					n = arguments[3];
				this.segString = t, this.coord = new f(e), this.segmentIndex = i, this.segmentOctant = n, this._isInterior = !e.equals2D(t.getCoordinate(i))
			}
			function be() {
				this.nodeMap = new rt, this.edge = null;
				var t = arguments[0];
				this.edge = t
			}
			function Fe() {
				this.nodeList = null, this.edge = null, this.nodeIt = null, this.currNode = null, this.nextNode = null, this.currSegIndex = 0;
				var t = arguments[0];
				this.nodeList = t, this.edge = t.getEdge(), this.nodeIt = t.iterator(), this.readNextNode()
			}
			function De() {}
			function Ge() {
				this.nodeList = new be(this), this.pts = null, this.data = null;
				var t = arguments[0],
					e = arguments[1];
				this.pts = t, this.data = e
			}
			function ke() {
				this.tempEnv1 = new C, this.tempEnv2 = new C, this.overlapSeg1 = new te, this.overlapSeg2 = new te
			}
			function Ue() {
				this.pts = null, this.start = null, this.end = null, this.env = null, this.context = null, this.id = null;
				var t = arguments[0],
					e = arguments[1],
					i = arguments[2],
					n = arguments[3];
				this.pts = t, this.start = e, this.end = i, this.context = n
			}
			function Be() {}
			function je() {}
			function Ve() {}
			function Ye() {
				if (this.segInt = null, 0 === arguments.length);
				else if (1 === arguments.length) {
					var t = arguments[0];
					this.setSegmentIntersector(t)
				}
			}
			function ze() {
				if (this.monoChains = new E, this.index = new Ne, this.idCounter = 0, this.nodedSegStrings = null, this.nOverlaps = 0, 0 === arguments.length);
				else if (1 === arguments.length) {
					var t = arguments[0];
					Ye.call(this, t)
				}
			}
			function Xe() {
				ke.apply(this), this.si = null;
				var t = arguments[0];
				this.si = t
			}
			function We() {
				if (this.pt = null, 1 === arguments.length) {
					var t = arguments[0];
					u.call(this, t)
				} else if (2 === arguments.length) {
					var e = arguments[0],
						i = arguments[1];
					u.call(this, We.msgWithCoord(e, i)), this.pt = new f(i)
				}
			}
			function qe() {}
			function He() {
				this.findAllIntersections = !1, this.isCheckEndSegmentsOnly = !1, this.li = null, this.interiorIntersection = null, this.intSegments = null, this.intersections = new E, this.intersectionCount = 0, this.keepIntersections = !0;
				var t = arguments[0];
				this.li = t, this.interiorIntersection = null
			}
			function Ze() {
				this.li = new Kt, this.segStrings = null, this.findAllIntersections = !1, this.segInt = null, this._isValid = !0;
				var t = arguments[0];
				this.segStrings = t
			}
			function Ke() {
				this.nv = null;
				var t = arguments[0];
				this.nv = new Ze(Ke.toSegmentStrings(t))
			}
			function Je() {
				this.mapOp = null;
				var t = arguments[0];
				this.mapOp = t
			}
			function Qe() {}
			function $e() {
				if (this.location = null, 1 === arguments.length) {
					if (arguments[0] instanceof Array) {
						var t = arguments[0];
						this.init(t.length)
					} else if (Number.isInteger(arguments[0])) {
						var e = arguments[0];
						this.init(1), this.location[Qe.ON] = e
					} else if (arguments[0] instanceof $e) {
						var i = arguments[0];
						if (this.init(i.location.length), null !== i) for (var n = 0; n < this.location.length; n++) this.location[n] = i.location[n]
					}
				} else if (3 === arguments.length) {
					var r = arguments[0],
						o = arguments[1],
						s = arguments[2];
					this.init(3), this.location[Qe.ON] = r, this.location[Qe.LEFT] = o, this.location[Qe.RIGHT] = s
				}
			}
			function ti() {
				if (this.elt = new Array(2).fill(null), 1 === arguments.length) {
					if (Number.isInteger(arguments[0])) {
						var t = arguments[0];
						this.elt[0] = new $e(t), this.elt[1] = new $e(t)
					} else if (arguments[0] instanceof ti) {
						var e = arguments[0];
						this.elt[0] = new $e(e.elt[0]), this.elt[1] = new $e(e.elt[1])
					}
				} else if (2 === arguments.length) {
					var i = arguments[0],
						n = arguments[1];
					this.elt[0] = new $e(T.NONE), this.elt[1] = new $e(T.NONE), this.elt[i].setLocation(n)
				} else if (3 === arguments.length) {
					var r = arguments[0],
						o = arguments[1],
						s = arguments[2];
					this.elt[0] = new $e(r, o, s), this.elt[1] = new $e(r, o, s)
				} else if (4 === arguments.length) {
					var a = arguments[0],
						l = arguments[1],
						u = arguments[2],
						h = arguments[3];
					this.elt[0] = new $e(T.NONE, T.NONE, T.NONE), this.elt[1] = new $e(T.NONE, T.NONE, T.NONE), this.elt[a].setLocations(l, u, h)
				}
			}
			function ei() {
				this.startDe = null, this.maxNodeDegree = -1, this.edges = new E, this.pts = new E, this.label = new ti(T.NONE), this.ring = null, this._isHole = null, this.shell = null, this.holes = new E, this.geometryFactory = null;
				var t = arguments[0],
					e = arguments[1];
				this.geometryFactory = e, this.computePoints(t), this.computeRing()
			}
			function ii() {
				var t = arguments[0],
					e = arguments[1];
				ei.call(this, t, e)
			}
			function ni() {
				var t = arguments[0],
					e = arguments[1];
				ei.call(this, t, e)
			}
			function ri() {
				if (this.label = null, this._isInResult = !1, this._isCovered = !1, this._isCoveredSet = !1, this._isVisited = !1, 0 === arguments.length);
				else if (1 === arguments.length) {
					var t = arguments[0];
					this.label = t
				}
			}
			function oi() {
				ri.apply(this), this.coord = null, this.edges = null;
				var t = arguments[0],
					e = arguments[1];
				this.coord = t, this.edges = e, this.label = new ti(0, T.NONE)
			}
			function si() {
				this.nodeMap = new rt, this.nodeFact = null;
				var t = arguments[0];
				this.nodeFact = t
			}
			function ai() {
				if (this.edge = null, this.label = null, this.node = null, this.p0 = null, this.p1 = null, this.dx = null, this.dy = null, this.quadrant = null, 1 === arguments.length) {
					var t = arguments[0];
					this.edge = t
				} else if (3 === arguments.length) {
					var e = arguments[0],
						i = arguments[1],
						n = arguments[2];
					ai.call(this, e, i, n, null)
				} else if (4 === arguments.length) {
					var r = arguments[0],
						o = arguments[1],
						s = arguments[2],
						a = arguments[3];
					ai.call(this, r), this.init(o, s), this.label = a
				}
			}
			function li() {
				this._isForward = null, this._isInResult = !1, this._isVisited = !1, this.sym = null, this.next = null, this.nextMin = null, this.edgeRing = null, this.minEdgeRing = null, this.depth = [0, -999, -999];
				var t = arguments[0],
					e = arguments[1];
				if (ai.call(this, t), this._isForward = e, e) this.init(t.getCoordinate(0), t.getCoordinate(1));
				else {
					var i = t.getNumPoints() - 1;
					this.init(t.getCoordinate(i), t.getCoordinate(i - 1))
				}
				this.computeDirectedLabel()
			}
			function ui() {}
			function hi() {
				if (this.edges = new E, this.nodes = null, this.edgeEndList = new E, 0 === arguments.length) this.nodes = new si(new ui);
				else if (1 === arguments.length) {
					var t = arguments[0];
					this.nodes = new si(t)
				}
			}
			function ci() {
				this.geometryFactory = null, this.shellList = new E;
				var t = arguments[0];
				this.geometryFactory = t
			}
			function di() {
				this.op = null, this.geometryFactory = null, this.ptLocator = null, this.lineEdgesList = new E, this.resultLineList = new E;
				var t = arguments[0],
					e = arguments[1],
					i = arguments[2];
				this.op = t, this.geometryFactory = e, this.ptLocator = i
			}
			function fi() {
				this.op = null, this.geometryFactory = null, this.resultPointList = new E;
				var t = arguments[0],
					e = arguments[1];
				arguments[2], this.op = t, this.geometryFactory = e
			}
			function Ai() {}
			function pi() {
				this.geom = null;
				var t = arguments[0];
				this.geom = t
			}
			function gi() {
				this.edgeMap = new rt, this.edgeList = null, this.ptInAreaLocation = [T.NONE, T.NONE]
			}
			function mi() {
				gi.apply(this), this.resultAreaEdgeList = null, this.label = null, this.SCANNING_FOR_INCOMING = 1, this.LINKING_TO_OUTGOING = 2
			}
			function vi() {
				ui.apply(this)
			}
			function yi() {
				this.mce = null, this.chainIndex = null;
				var t = arguments[0],
					e = arguments[1];
				this.mce = t, this.chainIndex = e
			}
			function _i() {
				if (this.label = null, this.xValue = null, this.eventType = null, this.insertEvent = null, this.deleteEventIndex = null, this.obj = null, 2 === arguments.length) {
					var t = arguments[0],
						e = arguments[1];
					this.eventType = _i.DELETE, this.xValue = t, this.insertEvent = e
				} else if (3 === arguments.length) {
					var i = arguments[0],
						n = arguments[1],
						r = arguments[2];
					this.eventType = _i.INSERT, this.label = i, this.xValue = n, this.obj = r
				}
			}
			function Ei() {}
			function xi() {
				this._hasIntersection = !1, this.hasProper = !1, this.hasProperInterior = !1, this.properIntersectionPoint = null, this.li = null, this.includeProper = null, this.recordIsolated = null, this.isSelfIntersection = null, this.numIntersections = 0, this.numTests = 0, this.bdyNodes = null, this._isDone = !1, this.isDoneWhenProperInt = !1;
				var t = arguments[0],
					e = arguments[1],
					i = arguments[2];
				this.li = t, this.includeProper = e, this.recordIsolated = i
			}
			function Ci() {
				Ei.apply(this), this.events = new E, this.nOverlaps = null
			}
			function Ii() {
				this.min = r.POSITIVE_INFINITY, this.max = r.NEGATIVE_INFINITY
			}
			function Si() {}
			function Ti() {
				Ii.apply(this), this.item = null;
				var t = arguments[0],
					e = arguments[1],
					i = arguments[2];
				this.min = t, this.max = e, this.item = i
			}
			function Ri() {
				Ii.apply(this), this.node1 = null, this.node2 = null;
				var t = arguments[0],
					e = arguments[1];
				this.node1 = t, this.node2 = e, this.buildExtent(this.node1, this.node2)
			}
			function wi() {
				this.leaves = new E, this.root = null, this.level = 0
			}
			function Li() {
				if (this.lines = null, this.isForcedToLineString = !1, 1 === arguments.length) {
					var t = arguments[0];
					this.lines = t
				} else if (2 === arguments.length) {
					var e = arguments[0],
						i = arguments[1];
					this.lines = e, this.isForcedToLineString = i
				}
			}
			function Ni() {
				this.items = new E
			}
			function Pi() {
				this.index = null;
				var t = arguments[0];
				if (!R(t, Tt)) throw new n("Argument must be Polygonal");
				this.index = new Mi(t)
			}
			function Oi() {
				this.counter = null;
				var t = arguments[0];
				this.counter = t
			}
			function Mi() {
				this.index = new wi;
				var t = arguments[0];
				this.init(t)
			}
			function bi() {
				this.coord = null, this.segmentIndex = null, this.dist = null;
				var t = arguments[0],
					e = arguments[1],
					i = arguments[2];
				this.coord = new f(t), this.segmentIndex = e, this.dist = i
			}
			function Fi() {
				this.nodeMap = new rt, this.edge = null;
				var t = arguments[0];
				this.edge = t
			}
			function Di() {}
			function Gi() {
				this.e = null, this.pts = null, this.startIndex = null, this.env1 = new C, this.env2 = new C;
				var t = arguments[0];
				this.e = t, this.pts = t.getCoordinates();
				var e = new Di;
				this.startIndex = e.getChainStartIndices(this.pts)
			}
			function ki() {
				this.depth = Array(2).fill().map((function() {
					return Array(3)
				}));
				for (var t = 0; 2 > t; t++) for (var e = 0; 3 > e; e++) this.depth[t][e] = ki.NULL_VALUE
			}
			function Ui() {
				if (ri.apply(this), this.pts = null, this.env = null, this.eiList = new Fi(this), this.name = null, this.mce = null, this._isIsolated = !0, this.depth = new ki, this.depthDelta = 0, 1 === arguments.length) {
					var t = arguments[0];
					Ui.call(this, t, null)
				} else if (2 === arguments.length) {
					var e = arguments[0],
						i = arguments[1];
					this.pts = e, this.label = i
				}
			}
			function Bi() {
				if (hi.apply(this), this.parentGeom = null, this.lineEdgeMap = new Yt, this.boundaryNodeRule = null, this.useBoundaryDeterminationRule = !0, this.argIndex = null, this.boundaryNodes = null, this._hasTooFewPoints = !1, this.invalidPoint = null, this.areaPtLocator = null, this.ptLocator = new me, 2 === arguments.length) {
					var t = arguments[0],
						e = arguments[1];
					Bi.call(this, t, e, j.OGC_SFS_BOUNDARY_RULE)
				} else if (3 === arguments.length) {
					var i = arguments[0],
						n = arguments[1],
						r = arguments[2];
					this.argIndex = i, this.parentGeom = n, this.boundaryNodeRule = r, null !== n && this.add(n)
				}
			}
			function ji() {
				if (this.li = new Kt, this.resultPrecisionModel = null, this.arg = null, 1 === arguments.length) {
					var t = arguments[0];
					this.setComputationPrecision(t.getPrecisionModel()), this.arg = new Array(1).fill(null), this.arg[0] = new Bi(0, t)
				} else if (2 === arguments.length) {
					var e = arguments[0],
						i = arguments[1];
					ji.call(this, e, i, j.OGC_SFS_BOUNDARY_RULE)
				} else if (3 === arguments.length) {
					var n = arguments[0],
						r = arguments[1],
						o = arguments[2];
					n.getPrecisionModel().compareTo(r.getPrecisionModel()) >= 0 ? this.setComputationPrecision(n.getPrecisionModel()) : this.setComputationPrecision(r.getPrecisionModel()), this.arg = new Array(2).fill(null), this.arg[0] = new Bi(0, n, o), this.arg[1] = new Bi(1, r, o)
				}
			}
			function Vi() {
				this.pts = null, this._orientation = null;
				var t = arguments[0];
				this.pts = t, this._orientation = Vi.orientation(t)
			}
			function Yi() {
				this.edges = new E, this.ocaMap = new rt
			}
			function zi() {
				this.ptLocator = new me, this.geomFact = null, this.resultGeom = null, this.graph = null, this.edgeList = new Yi, this.resultPolyList = new E, this.resultLineList = new E, this.resultPointList = new E;
				var t = arguments[0],
					e = arguments[1];
				ji.call(this, t, e), this.graph = new hi(new vi), this.geomFact = t.getFactory()
			}
			function Xi() {
				this.geom = new Array(2).fill(null), this.snapTolerance = null, this.cbr = null;
				var t = arguments[0],
					e = arguments[1];
				this.geom[0] = t, this.geom[1] = e, this.computeSnapTolerance()
			}
			function Wi() {
				this.geom = new Array(2).fill(null);
				var t = arguments[0],
					e = arguments[1];
				this.geom[0] = t, this.geom[1] = e
			}
			function qi() {
				this.factory = null, this.interiorPoint = null, this.maxWidth = 0;
				var t = arguments[0];
				this.factory = t.getFactory(), this.add(t)
			}
			function Hi() {
				this.poly = null, this.centreY = null, this.hiY = r.MAX_VALUE, this.loY = -r.MAX_VALUE;
				var t = arguments[0];
				this.poly = t, this.hiY = t.getEnvelopeInternal().getMaxY(), this.loY = t.getEnvelopeInternal().getMinY(), this.centreY = qi.avg(this.loY, this.hiY)
			}
			function Zi() {
				this.centroid = null, this.minDistance = r.MAX_VALUE, this.interiorPoint = null;
				var t = arguments[0];
				this.centroid = t.getCentroid().getCoordinate(), this.addInterior(t), null === this.interiorPoint && this.addEndpoints(t)
			}
			function Ki() {
				this.centroid = null, this.minDistance = r.MAX_VALUE, this.interiorPoint = null;
				var t = arguments[0];
				this.centroid = t.getCentroid().getCoordinate(), this.add(t)
			}
			function Ji() {}
			function Qi() {
				this.p0 = null, this.p1 = null, this.p2 = null;
				var t = arguments[0],
					e = arguments[1],
					i = arguments[2];
				this.p0 = t, this.p1 = e, this.p2 = i
			}
			function $i() {
				this.input = null, this.extremalPts = null, this.centre = null, this.radius = 0;
				var t = arguments[0];
				this.input = t
			}
			function tn() {
				if (this.inputGeom = null, this.isConvex = null, this.convexHullPts = null, this.minBaseSeg = new te, this.minWidthPt = null, this.minPtIndex = null, this.minWidth = 0, 1 === arguments.length) {
					var t = arguments[0];
					tn.call(this, t, !1)
				} else if (2 === arguments.length) {
					var e = arguments[0],
						i = arguments[1];
					this.inputGeom = e, this.isConvex = i
				}
			}
			function en() {
				this.inputGeom = null, this.distanceTolerance = null;
				var t = arguments[0];
				this.inputGeom = t
			}
			function nn() {
				le.apply(this), this.distanceTolerance = null;
				var t = arguments[0];
				this.distanceTolerance = t
			}
			function rn() {
				this._orig = null, this._sym = null, this._next = null;
				var t = arguments[0];
				this._orig = t
			}
			function on() {
				this._isMarked = !1;
				var t = arguments[0];
				rn.call(this, t)
			}
			function sn() {
				this.vertexMap = new Yt
			}
			function an() {
				this._isStart = !1;
				var t = arguments[0];
				on.call(this, t)
			}
			function ln() {
				sn.apply(this)
			}
			function un() {
				this.result = null, this.factory = null, this.graph = null, this.lines = new E, this.nodeEdgeStack = new re, this.ringStartEdge = null, this.graph = new ln
			}
			function hn() {
				this.items = new E, this.subnode = new Array(4).fill(null)
			}
			function cn() {}
			function dn() {
				this.pt = new f, this.level = 0, this.env = null;
				var t = arguments[0];
				this.computeKey(t)
			}
			function fn() {
				hn.apply(this), this.env = null, this.centrex = null, this.centrey = null, this.level = null;
				var t = arguments[0],
					e = arguments[1];
				this.env = t, this.level = e, this.centrex = (t.getMinX() + t.getMaxX()) / 2, this.centrey = (t.getMinY() + t.getMaxY()) / 2
			}
			function An() {}
			function pn() {
				hn.apply(this)
			}
			function gn() {
				this.root = null, this.minExtent = 1, this.root = new pn
			}
			function mn(t) {
				this.geometryFactory = t || new Wt
			}
			function vn(t) {
				this.geometryFactory = t || new Wt, this.precisionModel = this.geometryFactory.getPrecisionModel(), this.parser = new mn(this.geometryFactory)
			}
			function yn() {
				this.parser = new mn(this.geometryFactory)
			}
			function _n(t) {
				this.geometryFactory = t || new Wt, this.precisionModel = this.geometryFactory.getPrecisionModel(), this.parser = new qt(this.geometryFactory)
			}
			function En(t) {
				return [t.x, t.y]
			}
			function xn(t) {
				this.geometryFactory = t || new Wt
			}
			function Cn() {
				if (this.noder = null, this.scaleFactor = null, this.offsetX = null, this.offsetY = null, this.isScaled = !1, 2 === arguments.length) {
					var t = arguments[0],
						e = arguments[1];
					Cn.call(this, t, e, 0, 0)
				} else if (4 === arguments.length) {
					var i = arguments[0],
						n = arguments[1];
					arguments[2], arguments[3], this.noder = i, this.scaleFactor = n, this.isScaled = !this.isIntegerPrecision()
				}
			}
			function In() {
				if (this.inputGeom = null, this.isClosedEndpointsInInterior = !0, this.nonSimpleLocation = null, 1 === arguments.length) {
					var t = arguments[0];
					this.inputGeom = t
				} else if (2 === arguments.length) {
					var e = arguments[0],
						i = arguments[1];
					this.inputGeom = e, this.isClosedEndpointsInInterior = !i.isInBoundary(2)
				}
			}
			function Sn() {
				this.pt = null, this.isClosed = null, this.degree = null;
				var t = arguments[0];
				this.pt = t, this.isClosed = !1, this.degree = 0
			}
			function Tn() {
				if (this.quadrantSegments = Tn.DEFAULT_QUADRANT_SEGMENTS, this.endCapStyle = Tn.CAP_ROUND, this.joinStyle = Tn.JOIN_ROUND, this.mitreLimit = Tn.DEFAULT_MITRE_LIMIT, this._isSingleSided = !1, this.simplifyFactor = Tn.DEFAULT_SIMPLIFY_FACTOR, 0 === arguments.length);
				else if (1 === arguments.length) {
					var t = arguments[0];
					this.setQuadrantSegments(t)
				} else if (2 === arguments.length) {
					var e = arguments[0],
						i = arguments[1];
					this.setQuadrantSegments(e), this.setEndCapStyle(i)
				} else if (4 === arguments.length) {
					var n = arguments[0],
						r = arguments[1],
						o = arguments[2],
						s = arguments[3];
					this.setQuadrantSegments(n), this.setEndCapStyle(r), this.setJoinStyle(o), this.setMitreLimit(s)
				}
			}
			function Rn() {
				this.minIndex = -1, this.minCoord = null, this.minDe = null, this.orientedDe = null
			}
			function wn() {
				this.array_ = []
			}
			function Ln() {
				this.finder = null, this.dirEdgeList = new E, this.nodes = new E, this.rightMostCoord = null, this.env = null, this.finder = new Rn
			}
			function Nn() {
				this.inputLine = null, this.distanceTol = null, this.isDeleted = null, this.angleOrientation = $t.COUNTERCLOCKWISE;
				var t = arguments[0];
				this.inputLine = t
			}
			function Pn() {
				this.ptList = null, this.precisionModel = null, this.minimimVertexDistance = 0, this.ptList = new E
			}
			function On() {
				this.maxCurveSegmentError = 0, this.filletAngleQuantum = null, this.closingSegLengthFactor = 1, this.segList = null, this.distance = 0, this.precisionModel = null, this.bufParams = null, this.li = null, this.s0 = null, this.s1 = null, this.s2 = null, this.seg0 = new te, this.seg1 = new te, this.offset0 = new te, this.offset1 = new te, this.side = 0, this._hasNarrowConcaveAngle = !1;
				var t = arguments[0],
					e = arguments[1],
					i = arguments[2];
				this.precisionModel = t, this.bufParams = e, this.li = new Kt, this.filletAngleQuantum = Math.PI / 2 / e.getQuadrantSegments(), e.getQuadrantSegments() >= 8 && e.getJoinStyle() === Tn.JOIN_ROUND && (this.closingSegLengthFactor = On.MAX_CLOSING_SEG_LEN_FACTOR), this.init(i)
			}
			function Mn() {
				this.distance = 0, this.precisionModel = null, this.bufParams = null;
				var t = arguments[0],
					e = arguments[1];
				this.precisionModel = t, this.bufParams = e
			}
			function bn() {
				this.subgraphs = null, this.seg = new te, this.cga = new $t;
				var t = arguments[0];
				this.subgraphs = t
			}
			function Fn() {
				this.upwardSeg = null, this.leftDepth = null;
				var t = arguments[0],
					e = arguments[1];
				this.upwardSeg = new te(t), this.leftDepth = e
			}
			function Dn() {
				this.inputGeom = null, this.distance = null, this.curveBuilder = null, this.curveList = new E;
				var t = arguments[0],
					e = arguments[1],
					i = arguments[2];
				this.inputGeom = t, this.distance = e, this.curveBuilder = i
			}
			function Gn() {
				this._hasIntersection = !1, this.hasProper = !1, this.hasProperInterior = !1, this.hasInterior = !1, this.properIntersectionPoint = null, this.li = null, this.isSelfIntersection = null, this.numIntersections = 0, this.numInteriorIntersections = 0, this.numProperIntersections = 0, this.numTests = 0;
				var t = arguments[0];
				this.li = t
			}
			function kn() {
				this.bufParams = null, this.workingPrecisionModel = null, this.workingNoder = null, this.geomFact = null, this.graph = null, this.edgeList = new Yi;
				var t = arguments[0];
				this.bufParams = t
			}
			function Un() {
				this.li = new Kt, this.segStrings = null;
				var t = arguments[0];
				this.segStrings = t
			}
			function Bn() {
				this.li = null, this.pt = null, this.originalPt = null, this.ptScaled = null, this.p0Scaled = null, this.p1Scaled = null, this.scaleFactor = null, this.minx = null, this.maxx = null, this.miny = null, this.maxy = null, this.corner = new Array(4).fill(null), this.safeEnv = null;
				var t = arguments[0],
					e = arguments[1],
					i = arguments[2];
				if (this.originalPt = t, this.pt = t, this.scaleFactor = e, this.li = i, 0 >= e) throw new n("Scale factor must be non-zero");
				1 !== e && (this.pt = new f(this.scale(t.x), this.scale(t.y)), this.p0Scaled = new f, this.p1Scaled = new f), this.initCorners(this.pt)
			}
			function jn() {
				this.tempEnv1 = new C, this.selectedSegment = new te
			}
			function Vn() {
				this.index = null;
				var t = arguments[0];
				this.index = t
			}
			function Yn() {
				jn.apply(this), this.hotPixel = null, this.parentEdge = null, this.hotPixelVertexIndex = null, this._isNodeAdded = !1;
				var t = arguments[0],
					e = arguments[1],
					i = arguments[2];
				this.hotPixel = t, this.parentEdge = e, this.hotPixelVertexIndex = i
			}
			function zn() {
				this.li = null, this.interiorIntersections = null;
				var t = arguments[0];
				this.li = t, this.interiorIntersections = new E
			}
			function Xn() {
				this.pm = null, this.li = null, this.scaleFactor = null, this.noder = null, this.pointSnapper = null, this.nodedSegStrings = null;
				var t = arguments[0];
				this.pm = t, this.li = new Kt, this.li.setPrecisionModel(t), this.scaleFactor = t.getScale()
			}
			function Wn() {
				if (this.argGeom = null, this.distance = null, this.bufParams = new Tn, this.resultGeometry = null, this.saveException = null, 1 === arguments.length) {
					var t = arguments[0];
					this.argGeom = t
				} else if (2 === arguments.length) {
					var e = arguments[0],
						i = arguments[1];
					this.argGeom = e, this.bufParams = i
				}
			}
			function qn() {
				this.comps = null;
				var t = arguments[0];
				this.comps = t
			}
			function Hn() {
				if (this.component = null, this.segIndex = null, this.pt = null, 2 === arguments.length) {
					var t = arguments[0],
						e = arguments[1];
					Hn.call(this, t, Hn.INSIDE_AREA, e)
				} else if (3 === arguments.length) {
					var i = arguments[0],
						n = arguments[1],
						r = arguments[2];
					this.component = i, this.segIndex = n, this.pt = r
				}
			}
			function Zn() {
				this.pts = null;
				var t = arguments[0];
				this.pts = t
			}
			function Kn() {
				this.locations = null;
				var t = arguments[0];
				this.locations = t
			}
			function Jn() {
				if (this.geom = null, this.terminateDistance = 0, this.ptLocator = new me, this.minDistanceLocation = null, this.minDistance = r.MAX_VALUE, 2 === arguments.length) {
					var t = arguments[0],
						e = arguments[1];
					Jn.call(this, t, e, 0)
				} else if (3 === arguments.length) {
					var i = arguments[0],
						n = arguments[1],
						o = arguments[2];
					this.geom = new Array(2).fill(null), this.geom[0] = i, this.geom[1] = n, this.terminateDistance = o
				}
			}
			function Qn() {
				this.factory = null, this.directedEdges = new E, this.coordinates = null;
				var t = arguments[0];
				this.factory = t
			}
			function $n() {
				this._isMarked = !1, this._isVisited = !1, this.data = null
			}
			function tr() {
				$n.apply(this), this.parentEdge = null, this.from = null, this.to = null, this.p0 = null, this.p1 = null, this.sym = null, this.edgeDirection = null, this.quadrant = null, this.angle = null;
				var t = arguments[0],
					e = arguments[1],
					i = arguments[2],
					n = arguments[3];
				this.from = t, this.to = e, this.edgeDirection = n, this.p0 = t.getCoordinate(), this.p1 = i;
				var r = this.p1.x - this.p0.x,
					o = this.p1.y - this.p0.y;
				this.quadrant = Be.quadrant(r, o), this.angle = Math.atan2(o, r)
			}
			function er() {
				var t = arguments[0],
					e = arguments[1],
					i = arguments[2],
					n = arguments[3];
				tr.call(this, t, e, i, n)
			}
			function ir() {
				if ($n.apply(this), this.dirEdge = null, 0 === arguments.length);
				else if (2 === arguments.length) {
					var t = arguments[0],
						e = arguments[1];
					this.setDirectedEdges(t, e)
				}
			}
			function nr() {
				this.outEdges = new E, this.sorted = !1
			}
			function rr() {
				if ($n.apply(this), this.pt = null, this.deStar = null, 1 === arguments.length) {
					var t = arguments[0];
					rr.call(this, t, new nr)
				} else if (2 === arguments.length) {
					var e = arguments[0],
						i = arguments[1];
					this.pt = e, this.deStar = i
				}
			}
			function or() {
				ir.apply(this), this.line = null;
				var t = arguments[0];
				this.line = t
			}
			function sr() {
				this.nodeMap = new rt
			}
			function ar() {
				this.edges = new Q, this.dirEdges = new Q, this.nodeMap = new sr
			}
			function lr() {
				ar.apply(this)
			}
			function ur() {
				this.graph = new lr, this.mergedLineStrings = null, this.factory = null, this.edgeStrings = null
			}
			function hr() {
				this.edgeRing = null, this.next = null, this.label = -1;
				var t = arguments[0],
					e = arguments[1],
					i = arguments[2],
					n = arguments[3];
				tr.call(this, t, e, i, n)
			}
			function cr() {
				ir.apply(this), this.line = null;
				var t = arguments[0];
				this.line = t
			}
			function dr() {
				this.factory = null, this.deList = new E, this.lowestEdge = null, this.ring = null, this.ringPts = null, this.holes = null, this.shell = null, this._isHole = null, this._isProcessed = !1, this._isIncludedSet = !1, this._isIncluded = !1;
				var t = arguments[0];
				this.factory = t
			}
			function fr() {}
			function Ar() {
				ar.apply(this), this.factory = null;
				var t = arguments[0];
				this.factory = t
			}
			function pr() {
				if (this.lineStringAdder = new gr(this), this.graph = null, this.dangles = new E, this.cutEdges = new E, this.invalidRingLines = new E, this.holeList = null, this.shellList = null, this.polyList = null, this.isCheckingRingsValid = !0, this.extractOnlyPolygonal = null, this.geomFactory = null, 0 === arguments.length) pr.call(this, !1);
				else if (1 === arguments.length) {
					var t = arguments[0];
					this.extractOnlyPolygonal = t
				}
			}
			function gr() {
				this.p = null;
				var t = arguments[0];
				this.p = t
			}
			function mr() {}
			function vr() {
				if (this.edgeEnds = new E, 1 === arguments.length) {
					var t = arguments[0];
					vr.call(this, null, t)
				} else if (2 === arguments.length) {
					var e = (arguments[0], arguments[1]);
					ai.call(this, e.getEdge(), e.getCoordinate(), e.getDirectedCoordinate(), new ti(e.getLabel())), this.insert(e)
				}
			}
			function yr() {
				gi.apply(this)
			}
			function _r() {
				var t = arguments[0],
					e = arguments[1];
				oi.call(this, t, e)
			}
			function Er() {
				ui.apply(this)
			}
			function xr() {
				this.li = new Kt, this.ptLocator = new me, this.arg = null, this.nodes = new si(new Er), this.im = null, this.isolatedEdges = new E, this.invalidPoint = null;
				var t = arguments[0];
				this.arg = t
			}
			function Cr() {
				this.rectEnv = null;
				var t = arguments[0];
				this.rectEnv = t.getEnvelopeInternal()
			}
			function Ir() {
				this.li = new Kt, this.rectEnv = null, this.diagUp0 = null, this.diagUp1 = null, this.diagDown0 = null, this.diagDown1 = null;
				var t = arguments[0];
				this.rectEnv = t, this.diagUp0 = new f(t.getMinX(), t.getMinY()), this.diagUp1 = new f(t.getMaxX(), t.getMaxY()), this.diagDown0 = new f(t.getMinX(), t.getMaxY()), this.diagDown1 = new f(t.getMaxX(), t.getMinY())
			}
			function Sr() {
				this._isDone = !1
			}
			function Tr() {
				this.rectangle = null, this.rectEnv = null;
				var t = arguments[0];
				this.rectangle = t, this.rectEnv = t.getEnvelopeInternal()
			}
			function Rr() {
				Sr.apply(this), this.rectEnv = null, this._intersects = !1;
				var t = arguments[0];
				this.rectEnv = t
			}
			function wr() {
				Sr.apply(this), this.rectSeq = null, this.rectEnv = null, this._containsPoint = !1;
				var t = arguments[0];
				this.rectSeq = t.getExteriorRing().getCoordinateSequence(), this.rectEnv = t.getEnvelopeInternal()
			}
			function Lr() {
				Sr.apply(this), this.rectEnv = null, this.rectIntersector = null, this.hasIntersection = !1, this.p0 = new f, this.p1 = new f;
				var t = arguments[0];
				this.rectEnv = t.getEnvelopeInternal(), this.rectIntersector = new Ir(this.rectEnv)
			}
			function Nr() {
				if (this._relate = null, 2 === arguments.length) {
					var t = arguments[0],
						e = arguments[1];
					ji.call(this, t, e), this._relate = new xr(this.arg)
				} else if (3 === arguments.length) {
					var i = arguments[0],
						n = arguments[1],
						r = arguments[2];
					ji.call(this, i, n, r), this._relate = new xr(this.arg)
				}
			}
			function Pr() {
				this.geomFactory = null, this.skipEmpty = !1, this.inputGeoms = null;
				var t = arguments[0];
				this.geomFactory = Pr.extractFactory(t), this.inputGeoms = t
			}
			function Or() {
				this.pointGeom = null, this.otherGeom = null, this.geomFact = null;
				var t = arguments[0],
					e = arguments[1];
				this.pointGeom = t, this.otherGeom = e, this.geomFact = e.getFactory()
			}
			function Mr() {
				this.sortIndex = -1, this.comps = null;
				var t = arguments[0],
					e = arguments[1];
				this.sortIndex = t, this.comps = e
			}
			function br() {
				this.inputPolys = null, this.geomFactory = null;
				var t = arguments[0];
				this.inputPolys = t, null === this.inputPolys && (this.inputPolys = new E)
			}
			function Fr() {
				if (this.polygons = new E, this.lines = new E, this.points = new E, this.geomFact = null, 1 === arguments.length) {
					if (R(arguments[0], g)) {
						var t = arguments[0];
						this.extract(t)
					} else if (arguments[0] instanceof U) {
						var e = arguments[0];
						this.extract(e)
					}
				} else if (2 === arguments.length) {
					var i = arguments[0],
						n = arguments[1];
					this.geomFact = n, this.extract(i)
				}
			}
			function Dr() {
				this.geometryFactory = new Wt, this.geomGraph = null, this.disconnectedRingcoord = null;
				var t = arguments[0];
				this.geomGraph = t
			}
			function Gr() {
				this.items = new E, this.subnode = [null, null]
			}
			function kr() {
				if (this.min = null, this.max = null, 0 === arguments.length) this.min = 0, this.max = 0;
				else if (1 === arguments.length) {
					var t = arguments[0];
					this.init(t.min, t.max)
				} else if (2 === arguments.length) {
					var e = arguments[0],
						i = arguments[1];
					this.init(e, i)
				}
			}
			function Ur() {
				this.pt = 0, this.level = 0, this.interval = null;
				var t = arguments[0];
				this.computeKey(t)
			}
			function Br() {
				Gr.apply(this), this.interval = null, this.centre = null, this.level = null;
				var t = arguments[0],
					e = arguments[1];
				this.interval = t, this.level = e, this.centre = (t.getMin() + t.getMax()) / 2
			}
			function jr() {
				Gr.apply(this)
			}
			function Vr() {
				this.root = null, this.minExtent = 1, this.root = new jr
			}
			function Yr() {}
			function zr() {
				this.ring = null, this.tree = null, this.crossings = 0, this.interval = new kr;
				var t = arguments[0];
				this.ring = t, this.buildIndex()
			}
			function Xr() {
				jn.apply(this), this.mcp = null, this.p = null;
				var t = arguments[0],
					e = arguments[1];
				this.mcp = t, this.p = e
			}
			function Wr() {
				this.nodes = new si(new Er)
			}
			function qr() {
				this.li = new Kt, this.geomGraph = null, this.nodeGraph = new Wr, this.invalidPoint = null;
				var t = arguments[0];
				this.geomGraph = t
			}
			function Hr() {
				this.graph = null, this.rings = new E, this.totalEnv = new C, this.index = null, this.nestedPt = null;
				var t = arguments[0];
				this.graph = t
			}
			function Zr() {
				if (this.errorType = null, this.pt = null, 1 === arguments.length) {
					var t = arguments[0];
					Zr.call(this, t, null)
				} else if (2 === arguments.length) {
					var e = arguments[0],
						i = arguments[1];
					this.errorType = e, null !== i && (this.pt = i.copy())
				}
			}
			function Kr() {
				this.parentGeometry = null, this.isSelfTouchingRingFormingHoleValid = !1, this.validErr = null;
				var t = arguments[0];
				this.parentGeometry = t
			}
			function Jr() {
				Pt.CoordinateOperation.apply(this), this.targetPM = null, this.removeCollapsed = !0;
				var t = arguments[0],
					e = arguments[1];
				this.targetPM = t, this.removeCollapsed = e
			}
			function Qr() {
				this.targetPM = null, this.removeCollapsed = !0, this.changePrecisionModel = !1, this.isPointwise = !1;
				var t = arguments[0];
				this.targetPM = t
			}
			function $r() {
				this.pts = null, this.usePt = null, this.distanceTolerance = null, this.seg = new te;
				var t = arguments[0];
				this.pts = t
			}
			function to() {
				this.inputGeom = null, this.distanceTolerance = null, this.isEnsureValidTopology = !0;
				var t = arguments[0];
				this.inputGeom = t
			}
			function eo() {
				le.apply(this), this.isEnsureValidTopology = !0, this.distanceTolerance = null;
				var t = arguments[0],
					e = arguments[1];
				this.isEnsureValidTopology = t, this.distanceTolerance = e
			}
			function io() {
				if (this.parent = null, this.index = null, 2 === arguments.length) {
					var t = arguments[0],
						e = arguments[1];
					io.call(this, t, e, null, -1)
				} else if (4 === arguments.length) {
					var i = arguments[0],
						n = arguments[1],
						r = arguments[2],
						o = arguments[3];
					te.call(this, i, n), this.parent = r, this.index = o
				}
			}
			function no() {
				if (this.parentLine = null, this.segs = null, this.resultSegs = new E, this.minimumSize = null, 1 === arguments.length) {
					var t = arguments[0];
					no.call(this, t, 2)
				} else if (2 === arguments.length) {
					var e = arguments[0],
						i = arguments[1];
					this.parentLine = e, this.minimumSize = i, this.init()
				}
			}
			function ro() {
				this.index = new gn
			}
			function oo() {
				this.querySeg = null, this.items = new E;
				var t = arguments[0];
				this.querySeg = t
			}
			function so() {
				this.li = new Kt, this.inputIndex = new ro, this.outputIndex = new ro, this.line = null, this.linePts = null, this.distanceTolerance = 0;
				var t = arguments[0],
					e = arguments[1];
				this.inputIndex = t, this.outputIndex = e
			}
			function ao() {
				this.inputIndex = new ro, this.outputIndex = new ro, this.distanceTolerance = 0
			}
			function lo() {
				this.inputGeom = null, this.lineSimplifier = new ao, this.linestringMap = null;
				var t = arguments[0];
				this.inputGeom = t
			}
			function uo() {
				le.apply(this), this.linestringMap = null;
				var t = arguments[0];
				this.linestringMap = t
			}
			function ho() {
				this.tps = null;
				var t = arguments[0];
				this.tps = t
			}
			function co() {
				this.seg = null, this.segLen = null, this.splitPt = null, this.minimumLen = 0;
				var t = arguments[0];
				this.seg = t, this.segLen = t.getLength()
			}
			function fo() {}
			function Ao() {}
			function po() {}
			function go() {
				if (this.p = null, 1 === arguments.length) {
					var t = arguments[0];
					this.p = new f(t)
				} else if (2 === arguments.length) {
					var e = arguments[0],
						i = arguments[1];
					this.p = new f(e, i)
				} else if (3 === arguments.length) {
					var n = arguments[0],
						r = arguments[1],
						o = arguments[2];
					this.p = new f(n, r, o)
				}
			}
			function mo() {
				this._isOnConstraint = null, this.constraint = null;
				var t = arguments[0];
				go.call(this, t)
			}
			function vo() {
				this._rot = null, this.vertex = null, this.next = null, this.data = null
			}
			function yo() {
				this.subdiv = null, this.isUsingTolerance = !1;
				var t = arguments[0];
				this.subdiv = t, this.isUsingTolerance = t.getTolerance() > 0
			}
			function _o() {}
			function Eo() {
				this.subdiv = null, this.lastEdge = null;
				var t = arguments[0];
				this.subdiv = t, this.init()
			}
			function xo() {
				if (this.seg = null, 1 === arguments.length) {
					if ("string" == typeof arguments[0]) {
						var t = arguments[0];
						u.call(this, t)
					} else if (arguments[0] instanceof te) {
						var e = arguments[0];
						u.call(this, "Locate failed to converge (at edge: " + e + ").  Possible causes include invalid Subdivision topology or very close sites"), this.seg = new te(e)
					}
				} else if (2 === arguments.length) {
					var i = arguments[0],
						n = arguments[1];
					u.call(this, xo.msgWithSpatial(i, n)), this.seg = new te(n)
				}
			}
			function Co() {}
			function Io() {
				this.visitedKey = 0, this.quadEdges = new E, this.startingEdge = null, this.tolerance = null, this.edgeCoincidenceTolerance = null, this.frameVertex = new Array(3).fill(null), this.frameEnv = null, this.locator = null, this.seg = new te, this.triEdges = new Array(3).fill(null);
				var t = arguments[0],
					e = arguments[1];
				this.tolerance = e, this.edgeCoincidenceTolerance = e / Io.EDGE_COINCIDENCE_TOL_FACTOR, this.createFrame(t), this.startingEdge = this.initSubdiv(), this.locator = new Eo(this)
			}
			function So() {}
			function To() {
				this.triList = new E
			}
			function Ro() {
				this.triList = new E
			}
			function wo() {
				this.coordList = new x, this.triCoords = new E
			}
			function Lo() {
				if (this.ls = null, this.data = null, 2 === arguments.length) {
					var t = arguments[0],
						e = arguments[1];
					this.ls = new te(t, e)
				} else if (3 === arguments.length) {
					var i = arguments[0],
						n = arguments[1],
						r = arguments[2];
					this.ls = new te(i, n), this.data = r
				} else if (6 === arguments.length) {
					var o = arguments[0],
						s = arguments[1],
						a = arguments[2],
						l = arguments[3],
						u = arguments[4],
						h = arguments[5];
					Lo.call(this, new f(o, s, a), new f(l, u, h))
				} else if (7 === arguments.length) {
					var c = arguments[0],
						d = arguments[1],
						A = arguments[2],
						p = arguments[3],
						g = arguments[4],
						m = arguments[5],
						v = arguments[6];
					Lo.call(this, new f(c, d, A), new f(p, g, m), v)
				}
			}
			function No() {}
			function Po() {
				if (this.p = null, this.data = null, this.left = null, this.right = null, this.count = null, 2 === arguments.length) {
					var t = arguments[0],
						e = arguments[1];
					this.p = new f(t), this.left = null, this.right = null, this.count = 1, this.data = e
				} else if (3 === arguments.length) {
					var i = arguments[0],
						n = arguments[1],
						r = arguments[2];
					this.p = new f(i, n), this.left = null, this.right = null, this.count = 1, this.data = r
				}
			}
			function Oo() {
				if (this.root = null, this.numberOfNodes = null, this.tolerance = null, 0 === arguments.length) Oo.call(this, 0);
				else if (1 === arguments.length) {
					var t = arguments[0];
					this.tolerance = t
				}
			}
			function Mo() {
				this.tolerance = null, this.matchNode = null, this.matchDist = 0, this.p = null;
				var t = arguments[0],
					e = arguments[1];
				this.p = t, this.tolerance = e
			}
			function bo() {
				this.initialVertices = null, this.segVertices = null, this.segments = new E, this.subdiv = null, this.incDel = null, this.convexHull = null, this.splitFinder = new Ao, this.kdt = null, this.vertexFactory = null, this.computeAreaEnv = null, this.splitPt = null, this.tolerance = null;
				var t = arguments[0],
					e = arguments[1];
				this.initialVertices = new E(t), this.tolerance = e, this.kdt = new Oo(e)
			}
			function Fo() {
				this.siteCoords = null, this.tolerance = 0, this.subdiv = null
			}
			function Do() {
				this.siteCoords = null, this.constraintLines = null, this.tolerance = 0, this.subdiv = null, this.constraintVertexMap = new rt
			}
			function Go() {
				this.siteCoords = null, this.tolerance = 0, this.subdiv = null, this.clipEnv = null, this.diagramEnv = null
			}
			function ko() {}
			Array.prototype.fill || (Array.prototype.fill = function(t) {
				for (var e = Object(this), i = parseInt(e.length, 10), n = arguments[1], r = parseInt(n, 10) || 0, o = 0 > r ? Math.max(i + r, 0) : Math.min(r, i), s = arguments[2], a = void 0 === s ? i : parseInt(s, 10) || 0, l = 0 > a ? Math.max(i + a, 0) : Math.min(a, i); l > o; o++) e[o] = t;
				return e
			}), Number.isFinite = Number.isFinite ||
			function(t) {
				return "number" == typeof t && isFinite(t)
			}, Number.isInteger = Number.isInteger ||
			function(t) {
				return "number" == typeof t && isFinite(t) && Math.floor(t) === t
			}, Number.parseFloat = Number.parseFloat || parseFloat, Number.isNaN = Number.isNaN ||
			function(t) {
				return t != t
			}, Math.trunc = Math.trunc ||
			function(t) {
				return 0 > t ? Math.ceil(t) : Math.floor(t)
			}, e(i.prototype, {
				interfaces_: function() {
					return []
				},
				getClass: function() {
					return i
				}
			}), i.equalsWithTolerance = function(t, e, i) {
				return Math.abs(t - e) <= i
			}, r.isNaN = function(t) {
				return Number.isNaN(t)
			}, r.doubleToLongBits = function(t) {
				return t
			}, r.longBitsToDouble = function(t) {
				return t
			}, r.isInfinite = function(t) {
				return !Number.isFinite(t)
			}, r.MAX_VALUE = Number.MAX_VALUE, h(c, u), e(c.prototype, {
				interfaces_: function() {
					return []
				},
				getClass: function() {
					return c
				}
			}), e(d.prototype, {
				interfaces_: function() {
					return []
				},
				getClass: function() {
					return d
				}
			}), d.shouldNeverReachHere = function() {
				if (0 === arguments.length) d.shouldNeverReachHere(null);
				else if (1 === arguments.length) {
					var t = arguments[0];
					throw new c("Should never reach here" + (null !== t ? ": " + t : ""))
				}
			}, d.isTrue = function() {
				if (1 === arguments.length) {
					var t = arguments[0];
					d.isTrue(t, null)
				} else if (2 === arguments.length) {
					var e = arguments[0],
						i = arguments[1];
					if (!e) throw null === i ? new c : new c(i)
				}
			}, d.equals = function() {
				if (2 === arguments.length) {
					var t = arguments[0],
						e = arguments[1];
					d.equals(t, e, null)
				} else if (3 === arguments.length) {
					var i = arguments[0],
						n = arguments[1],
						r = arguments[2];
					if (!n.equals(i)) throw new c("Expected " + i + " but encountered " + n + (null !== r ? ": " + r : ""))
				}
			}, e(f.prototype, {
				setOrdinate: function(t, e) {
					switch (t) {
					case f.X:
						this.x = e;
						break;
					case f.Y:
						this.y = e;
						break;
					case f.Z:
						this.z = e;
						break;
					default:
						throw new n("Invalid ordinate index: " + t)
					}
				},
				equals2D: function() {
					if (1 === arguments.length) {
						var t = arguments[0];
						return this.x === t.x && this.y === t.y
					}
					if (2 === arguments.length) {
						var e = arguments[0],
							n = arguments[1];
						return !!i.equalsWithTolerance(this.x, e.x, n) && !! i.equalsWithTolerance(this.y, e.y, n)
					}
				},
				getOrdinate: function(t) {
					switch (t) {
					case f.X:
						return this.x;
					case f.Y:
						return this.y;
					case f.Z:
						return this.z
					}
					throw new n("Invalid ordinate index: " + t)
				},
				equals3D: function(t) {
					return this.x === t.x && this.y === t.y && (this.z === t.z || r.isNaN(this.z) && r.isNaN(t.z))
				},
				equals: function(t) {
					return t instanceof f && this.equals2D(t)
				},
				equalInZ: function(t, e) {
					return i.equalsWithTolerance(this.z, t.z, e)
				},
				compareTo: function(t) {
					var e = t;
					return this.x < e.x ? -1 : this.x > e.x ? 1 : this.y < e.y ? -1 : this.y > e.y ? 1 : 0
				},
				clone: function() {
					try {
						var t = null;
						return null
					} catch (t) {
						if (t instanceof CloneNotSupportedException) return d.shouldNeverReachHere("this shouldn't happen because this class is Cloneable"), null;
						throw t
					}
				},
				copy: function() {
					return new f(this)
				},
				toString: function() {
					return "(" + this.x + ", " + this.y + ", " + this.z + ")"
				},
				distance3D: function(t) {
					var e = this.x - t.x,
						i = this.y - t.y,
						n = this.z - t.z;
					return Math.sqrt(e * e + i * i + n * n)
				},
				distance: function(t) {
					var e = this.x - t.x,
						i = this.y - t.y;
					return Math.sqrt(e * e + i * i)
				},
				hashCode: function() {
					var t = 17;
					return 37 * (t = 37 * t + f.hashCode(this.x)) + f.hashCode(this.y)
				},
				setCoordinate: function(t) {
					this.x = t.x, this.y = t.y, this.z = t.z
				},
				interfaces_: function() {
					return [o, s, l]
				},
				getClass: function() {
					return f
				}
			}), f.hashCode = function() {
				if (1 === arguments.length) {
					var t = arguments[0],
						e = r.doubleToLongBits(t);
					return Math.trunc(e ^ e >>> 32)
				}
			}, e(A.prototype, {
				compare: function(t, e) {
					var i = t,
						n = e,
						r = A.compare(i.x, n.x);
					if (0 !== r) return r;
					var o = A.compare(i.y, n.y);
					return 0 !== o ? o : this.dimensionsToTest <= 2 ? 0 : A.compare(i.z, n.z)
				},
				interfaces_: function() {
					return [a]
				},
				getClass: function() {
					return A
				}
			}), A.compare = function(t, e) {
				return e > t ? -1 : t > e ? 1 : r.isNaN(t) ? r.isNaN(e) ? 0 : -1 : r.isNaN(e) ? 1 : 0
			}, f.DimensionalComparator = A, f.serialVersionUID = 0x5cbf2c235c7e5800, f.NULL_ORDINATE = r.NaN, f.X = 0, f.Y = 1, f.Z = 2, p.prototype.hasNext = function() {}, p.prototype.next = function() {}, p.prototype.remove = function() {}, g.prototype.add = function() {}, g.prototype.addAll = function() {}, g.prototype.isEmpty = function() {}, g.prototype.iterator = function() {}, g.prototype.size = function() {}, g.prototype.toArray = function() {}, g.prototype.remove = function() {}, m.prototype = new Error, m.prototype.name = "IndexOutOfBoundsException", v.prototype = Object.create(g.prototype), v.prototype.constructor = v, v.prototype.get = function() {}, v.prototype.set = function() {}, v.prototype.isEmpty = function() {}, y.prototype = new Error, y.prototype.name = "NoSuchElementException", _.prototype = new Error, _.prototype.name = "OperationNotSupported", E.prototype = Object.create(v.prototype), E.prototype.constructor = E, E.prototype.ensureCapacity = function() {}, E.prototype.interfaces_ = function() {
				return [v, g]
			}, E.prototype.add = function(t) {
				return this.array_.push(t), !0
			}, E.prototype.clear = function() {
				this.array_ = []
			}, E.prototype.addAll = function(t) {
				for (var e = t.iterator(); e.hasNext();) this.add(e.next());
				return !0
			}, E.prototype.set = function(t, e) {
				var i = this.array_[t];
				return this.array_[t] = e, i
			}, E.prototype.iterator = function() {
				return new Uo(this)
			}, E.prototype.get = function(t) {
				if (0 > t || t >= this.size()) throw new m;
				return this.array_[t]
			}, E.prototype.isEmpty = function() {
				return 0 === this.array_.length
			}, E.prototype.size = function() {
				return this.array_.length
			}, E.prototype.toArray = function() {
				for (var t = [], e = 0, i = this.array_.length; i > e; e++) t.push(this.array_[e]);
				return t
			}, E.prototype.remove = function(t) {
				for (var e = !1, i = 0, n = this.array_.length; n > i; i++) if (this.array_[i] === t) {
					this.array_.splice(i, 1), e = !0;
					break
				}
				return e
			};
			var Uo = function(t) {
					this.arrayList_ = t, this.position_ = 0
				};
			Uo.prototype.next = function() {
				if (this.position_ === this.arrayList_.size()) throw new y;
				return this.arrayList_.get(this.position_++)
			}, Uo.prototype.hasNext = function() {
				return this.position_ < this.arrayList_.size()
			}, Uo.prototype.set = function(t) {
				return this.arrayList_.set(this.position_ - 1, t)
			}, Uo.prototype.remove = function() {
				throw new _
			}, h(x, E), e(x.prototype, {
				getCoordinate: function(t) {
					return this.get(t)
				},
				addAll: function() {
					if (2 === arguments.length) {
						for (var t = arguments[0], e = arguments[1], i = !1, n = t.iterator(); n.hasNext();) this.add(n.next(), e), i = !0;
						return i
					}
					return E.prototype.addAll.apply(this, arguments)
				},
				clone: function() {
					for (var t = E.prototype.clone.call(this), e = 0; e < this.size(); e++) t.add(e, this.get(e).copy());
					return t
				},
				toCoordinateArray: function() {
					return this.toArray(x.coordArrayType)
				},
				add: function() {
					if (1 === arguments.length) {
						var t = arguments[0];
						E.prototype.add.call(this, t)
					} else if (2 === arguments.length) {
						if (arguments[0] instanceof Array && "boolean" == typeof arguments[1]) {
							var e = arguments[0],
								i = arguments[1];
							return this.add(e, i, !0), !0
						}
						if (arguments[0] instanceof f && "boolean" == typeof arguments[1]) {
							var n = arguments[0],
								r = arguments[1];
							if (!r && this.size() >= 1) {
								var o = this.get(this.size() - 1);
								if (o.equals2D(n)) return null
							}
							E.prototype.add.call(this, n)
						} else if (arguments[0] instanceof Object && "boolean" == typeof arguments[1]) {
							var s = arguments[0],
								a = arguments[1];
							return this.add(s, a), !0
						}
					} else if (3 === arguments.length) {
						if ("boolean" == typeof arguments[2] && arguments[0] instanceof Array && "boolean" == typeof arguments[1]) {
							var l = arguments[0],
								u = arguments[1],
								h = arguments[2];
							if (h) for (var c = 0; c < l.length; c++) this.add(l[c], u);
							else for (c = l.length - 1; c >= 0; c--) this.add(l[c], u);
							return !0
						}
						if ("boolean" == typeof arguments[2] && Number.isInteger(arguments[0]) && arguments[1] instanceof f) {
							var d = arguments[0],
								A = arguments[1],
								p = arguments[2];
							if (!p) {
								var g = this.size();
								if (g > 0) {
									if (d > 0) {
										var m = this.get(d - 1);
										if (m.equals2D(A)) return null
									}
									if (g > d) {
										var v = this.get(d);
										if (v.equals2D(A)) return null
									}
								}
							}
							E.prototype.add.call(this, d, A)
						}
					} else if (4 === arguments.length) {
						var y = arguments[0],
							_ = arguments[1],
							x = arguments[2],
							C = arguments[3],
							I = 1;
						for (x > C && (I = -1), c = x; c !== C; c += I) this.add(y[c], _);
						return !0
					}
				},
				closeRing: function() {
					this.size() > 0 && this.add(new f(this.get(0)), !1)
				},
				interfaces_: function() {
					return []
				},
				getClass: function() {
					return x
				}
			}), x.coordArrayType = new Array(0).fill(null), e(C.prototype, {
				getArea: function() {
					return this.getWidth() * this.getHeight()
				},
				equals: function(t) {
					if (!(t instanceof C)) return !1;
					var e = t;
					return this.isNull() ? e.isNull() : this.maxx === e.getMaxX() && this.maxy === e.getMaxY() && this.minx === e.getMinX() && this.miny === e.getMinY()
				},
				intersection: function(t) {
					if (this.isNull() || t.isNull() || !this.intersects(t)) return new C;
					var e = this.minx > t.minx ? this.minx : t.minx,
						i = this.miny > t.miny ? this.miny : t.miny;
					return new C(e, this.maxx < t.maxx ? this.maxx : t.maxx, i, this.maxy < t.maxy ? this.maxy : t.maxy)
				},
				isNull: function() {
					return this.maxx < this.minx
				},
				getMaxX: function() {
					return this.maxx
				},
				covers: function() {
					if (1 === arguments.length) {
						if (arguments[0] instanceof f) {
							var t = arguments[0];
							return this.covers(t.x, t.y)
						}
						if (arguments[0] instanceof C) {
							var e = arguments[0];
							return !this.isNull() && !e.isNull() && e.getMinX() >= this.minx && e.getMaxX() <= this.maxx && e.getMinY() >= this.miny && e.getMaxY() <= this.maxy
						}
					} else if (2 === arguments.length) {
						var i = arguments[0],
							n = arguments[1];
						return !this.isNull() && i >= this.minx && i <= this.maxx && n >= this.miny && n <= this.maxy
					}
				},
				intersects: function() {
					if (1 === arguments.length) {
						if (arguments[0] instanceof C) {
							var t = arguments[0];
							return !this.isNull() && !t.isNull() && !(t.minx > this.maxx || t.maxx < this.minx || t.miny > this.maxy || t.maxy < this.miny)
						}
						if (arguments[0] instanceof f) {
							var e = arguments[0];
							return this.intersects(e.x, e.y)
						}
					} else if (2 === arguments.length) {
						var i = arguments[0],
							n = arguments[1];
						return !this.isNull() && !(i > this.maxx || i < this.minx || n > this.maxy || n < this.miny)
					}
				},
				getMinY: function() {
					return this.miny
				},
				getMinX: function() {
					return this.minx
				},
				expandToInclude: function() {
					if (1 === arguments.length) {
						if (arguments[0] instanceof f) {
							var t = arguments[0];
							this.expandToInclude(t.x, t.y)
						} else if (arguments[0] instanceof C) {
							var e = arguments[0];
							if (e.isNull()) return null;
							this.isNull() ? (this.minx = e.getMinX(), this.maxx = e.getMaxX(), this.miny = e.getMinY(), this.maxy = e.getMaxY()) : (e.minx < this.minx && (this.minx = e.minx), e.maxx > this.maxx && (this.maxx = e.maxx), e.miny < this.miny && (this.miny = e.miny), e.maxy > this.maxy && (this.maxy = e.maxy))
						}
					} else if (2 === arguments.length) {
						var i = arguments[0],
							n = arguments[1];
						this.isNull() ? (this.minx = i, this.maxx = i, this.miny = n, this.maxy = n) : (i < this.minx && (this.minx = i), i > this.maxx && (this.maxx = i), n < this.miny && (this.miny = n), n > this.maxy && (this.maxy = n))
					}
				},
				minExtent: function() {
					if (this.isNull()) return 0;
					var t = this.getWidth(),
						e = this.getHeight();
					return e > t ? t : e
				},
				getWidth: function() {
					return this.isNull() ? 0 : this.maxx - this.minx
				},
				compareTo: function(t) {
					var e = t;
					return this.isNull() ? e.isNull() ? 0 : -1 : e.isNull() ? 1 : this.minx < e.minx ? -1 : this.minx > e.minx ? 1 : this.miny < e.miny ? -1 : this.miny > e.miny ? 1 : this.maxx < e.maxx ? -1 : this.maxx > e.maxx ? 1 : this.maxy < e.maxy ? -1 : this.maxy > e.maxy ? 1 : 0
				},
				translate: function(t, e) {
					return this.isNull() ? null : void this.init(this.getMinX() + t, this.getMaxX() + t, this.getMinY() + e, this.getMaxY() + e)
				},
				toString: function() {
					return "Env[" + this.minx + " : " + this.maxx + ", " + this.miny + " : " + this.maxy + "]"
				},
				setToNull: function() {
					this.minx = 0, this.maxx = -1, this.miny = 0, this.maxy = -1
				},
				getHeight: function() {
					return this.isNull() ? 0 : this.maxy - this.miny
				},
				maxExtent: function() {
					if (this.isNull()) return 0;
					var t = this.getWidth(),
						e = this.getHeight();
					return t > e ? t : e
				},
				expandBy: function() {
					if (1 === arguments.length) {
						var t = arguments[0];
						this.expandBy(t, t)
					} else if (2 === arguments.length) {
						var e = arguments[0],
							i = arguments[1];
						if (this.isNull()) return null;
						this.minx -= e, this.maxx += e, this.miny -= i, this.maxy += i, (this.minx > this.maxx || this.miny > this.maxy) && this.setToNull()
					}
				},
				contains: function() {
					if (1 === arguments.length) {
						if (arguments[0] instanceof C) {
							var t = arguments[0];
							return this.covers(t)
						}
						if (arguments[0] instanceof f) {
							var e = arguments[0];
							return this.covers(e)
						}
					} else if (2 === arguments.length) {
						var i = arguments[0],
							n = arguments[1];
						return this.covers(i, n)
					}
				},
				centre: function() {
					return this.isNull() ? null : new f((this.getMinX() + this.getMaxX()) / 2, (this.getMinY() + this.getMaxY()) / 2)
				},
				init: function() {
					if (0 === arguments.length) this.setToNull();
					else if (1 === arguments.length) {
						if (arguments[0] instanceof f) {
							var t = arguments[0];
							this.init(t.x, t.x, t.y, t.y)
						} else if (arguments[0] instanceof C) {
							var e = arguments[0];
							this.minx = e.minx, this.maxx = e.maxx, this.miny = e.miny, this.maxy = e.maxy
						}
					} else if (2 === arguments.length) {
						var i = arguments[0],
							n = arguments[1];
						this.init(i.x, n.x, i.y, n.y)
					} else if (4 === arguments.length) {
						var r = arguments[0],
							o = arguments[1],
							s = arguments[2],
							a = arguments[3];
						o > r ? (this.minx = r, this.maxx = o) : (this.minx = o, this.maxx = r), a > s ? (this.miny = s, this.maxy = a) : (this.miny = a, this.maxy = s)
					}
				},
				getMaxY: function() {
					return this.maxy
				},
				distance: function(t) {
					if (this.intersects(t)) return 0;
					var e = 0;
					this.maxx < t.minx ? e = t.minx - this.maxx : this.minx > t.maxx && (e = this.minx - t.maxx);
					var i = 0;
					return this.maxy < t.miny ? i = t.miny - this.maxy : this.miny > t.maxy && (i = this.miny - t.maxy), 0 === e ? i : 0 === i ? e : Math.sqrt(e * e + i * i)
				},
				hashCode: function() {
					var t = 17;
					return 37 * (t = 37 * (t = 37 * (t = 37 * t + f.hashCode(this.minx)) + f.hashCode(this.maxx)) + f.hashCode(this.miny)) + f.hashCode(this.maxy)
				},
				interfaces_: function() {
					return [o, l]
				},
				getClass: function() {
					return C
				}
			}), C.intersects = function() {
				if (3 === arguments.length) {
					var t = arguments[0],
						e = arguments[1],
						i = arguments[2];
					return i.x >= (t.x < e.x ? t.x : e.x) && i.x <= (t.x > e.x ? t.x : e.x) && i.y >= (t.y < e.y ? t.y : e.y) && i.y <= (t.y > e.y ? t.y : e.y)
				}
				if (4 === arguments.length) {
					var n = arguments[0],
						r = arguments[1],
						o = arguments[2],
						s = arguments[3],
						a = Math.min(o.x, s.x),
						l = Math.max(o.x, s.x),
						u = Math.min(n.x, r.x),
						h = Math.max(n.x, r.x);
					return !(u > l || a > h || (a = Math.min(o.y, s.y), l = Math.max(o.y, s.y), u = Math.min(n.y, r.y), h = Math.max(n.y, r.y), u > l || a > h))
				}
			}, C.serialVersionUID = 0x51845cd552189800, h(S, I), e(S.prototype, {
				interfaces_: function() {
					return []
				},
				getClass: function() {
					return S
				}
			}), e(T.prototype, {
				interfaces_: function() {
					return []
				},
				getClass: function() {
					return T
				}
			}), T.toLocationSymbol = function(t) {
				switch (t) {
				case T.EXTERIOR:
					return "e";
				case T.BOUNDARY:
					return "b";
				case T.INTERIOR:
					return "i";
				case T.NONE:
					return "-"
				}
				throw new n("Unknown location value: " + t)
			}, T.INTERIOR = 0, T.BOUNDARY = 1, T.EXTERIOR = 2, T.NONE = -1, e(w.prototype, {
				interfaces_: function() {
					return []
				},
				getClass: function() {
					return w
				}
			}), w.log10 = function(t) {
				var e = Math.log(t);
				return r.isInfinite(e) ? e : r.isNaN(e) ? e : e / w.LOG_10
			}, w.min = function(t, e, i, n) {
				var r = t;
				return r > e && (r = e), r > i && (r = i), r > n && (r = n), r
			}, w.clamp = function() {
				if ("number" == typeof arguments[2] && "number" == typeof arguments[0] && "number" == typeof arguments[1]) {
					var t = arguments[0],
						e = arguments[1],
						i = arguments[2];
					return e > t ? e : t > i ? i : t
				}
				if (Number.isInteger(arguments[2]) && Number.isInteger(arguments[0]) && Number.isInteger(arguments[1])) {
					var n = arguments[0],
						r = arguments[1],
						o = arguments[2];
					return r > n ? r : n > o ? o : n
				}
			}, w.wrap = function(t, e) {
				return 0 > t ? e - -t % e : t % e
			}, w.max = function() {
				if (3 === arguments.length) {
					var t = arguments[0],
						e = arguments[1],
						i = arguments[2];
					return e > (n = t) && (n = e), i > n && (n = i), n
				}
				if (4 === arguments.length) {
					var n, r = arguments[0],
						o = arguments[1],
						s = arguments[2],
						a = arguments[3];
					return o > (n = r) && (n = o), s > n && (n = s), a > n && (n = a), n
				}
			}, w.average = function(t, e) {
				return (t + e) / 2
			}, w.LOG_10 = Math.log(10), L.prototype.append = function(t) {
				this.str += t
			}, L.prototype.setCharAt = function(t, e) {
				return this.str.substr(0, t) + e + this.str.substr(t + 1)
			}, L.prototype.toString = function(t) {
				return this.str
			}, N.prototype.intValue = function() {
				return this.value
			}, N.prototype.compareTo = function(t) {
				return this.value < t ? -1 : this.value > t ? 1 : 0
			}, N.isNaN = function(t) {
				return Number.isNaN(t)
			}, P.isWhitespace = function(t) {
				return 32 >= t && t >= 0 || 127 == t
			}, P.toUpperCase = function(t) {
				return t.toUpperCase()
			}, e(O.prototype, {
				le: function(t) {
					return this.hi < t.hi || this.hi === t.hi && this.lo <= t.lo
				},
				extractSignificantDigits: function(t, e) {
					var i = this.abs(),
						n = O.magnitude(i.hi),
						r = O.TEN.pow(n);
					(i = i.divide(r)).gt(O.TEN) ? (i = i.divide(O.TEN), n += 1) : i.lt(O.ONE) && (i = i.multiply(O.TEN), n -= 1);
					for (var o = n + 1, s = new L, a = O.MAX_PRINT_DIGITS - 1, l = 0; a >= l; l++) {
						t && l === o && s.append(".");
						var u = Math.trunc(i.hi);
						if (0 > u) break;
						var h = !1,
							c = 0;
						u > 9 ? (h = !0, c = "9") : c = "0" + u, s.append(c), i = i.subtract(O.valueOf(u)).multiply(O.TEN), h && i.selfAdd(O.TEN);
						var d = !0,
							f = O.magnitude(i.hi);
						if (0 > f && Math.abs(f) >= a - l && (d = !1), !d) break
					}
					return e[0] = n, s.toString()
				},
				sqr: function() {
					return this.multiply(this)
				},
				doubleValue: function() {
					return this.hi + this.lo
				},
				subtract: function() {
					if (arguments[0] instanceof O) {
						var t = arguments[0];
						return this.add(t.negate())
					}
					if ("number" == typeof arguments[0]) {
						var e = arguments[0];
						return this.add(-e)
					}
				},
				equals: function() {
					if (1 === arguments.length) {
						var t = arguments[0];
						return this.hi === t.hi && this.lo === t.lo
					}
				},
				isZero: function() {
					return 0 === this.hi && 0 === this.lo
				},
				selfSubtract: function() {
					if (arguments[0] instanceof O) {
						var t = arguments[0];
						return this.isNaN() ? this : this.selfAdd(-t.hi, -t.lo)
					}
					if ("number" == typeof arguments[0]) {
						var e = arguments[0];
						return this.isNaN() ? this : this.selfAdd(-e, 0)
					}
				},
				getSpecialNumberString: function() {
					return this.isZero() ? "0.0" : this.isNaN() ? "NaN " : null
				},
				min: function(t) {
					return this.le(t) ? this : t
				},
				selfDivide: function() {
					if (1 === arguments.length) {
						if (arguments[0] instanceof O) {
							var t = arguments[0];
							return this.selfDivide(t.hi, t.lo)
						}
						if ("number" == typeof arguments[0]) {
							var e = arguments[0];
							return this.selfDivide(e, 0)
						}
					} else if (2 === arguments.length) {
						var i = arguments[0],
							n = arguments[1],
							r = null,
							o = null,
							s = null,
							a = null,
							l = null,
							u = null,
							h = null,
							c = null;
						return l = this.hi / i, c = (r = (u = O.SPLIT * l) - (r = u - l)) * (s = (c = O.SPLIT * i) - (s = c - i)) - (h = l * i) + r * (a = i - s) + (o = l - r) * s + o * a, c = l + (u = (this.hi - h - c + this.lo - l * n) / i), this.hi = c, this.lo = l - c + u, this
					}
				},
				dump: function() {
					return "DD<" + this.hi + ", " + this.lo + ">"
				},
				divide: function() {
					if (arguments[0] instanceof O) {
						var t = arguments[0],
							e = null,
							i = null,
							n = null,
							o = null,
							s = null,
							a = null,
							l = null,
							u = null;
						i = (s = this.hi / t.hi) - (e = (a = O.SPLIT * s) - (e = a - s)), u = e * (n = (u = O.SPLIT * t.hi) - (n = u - t.hi)) - (l = s * t.hi) + e * (o = t.hi - n) + i * n + i * o;
						var h = u = s + (a = (this.hi - l - u + this.lo - s * t.lo) / t.hi),
							c = s - u + a;
						return new O(h, c)
					}
					if ("number" == typeof arguments[0]) {
						var d = arguments[0];
						return r.isNaN(d) ? O.createNaN() : O.copy(this).selfDivide(d, 0)
					}
				},
				ge: function(t) {
					return this.hi > t.hi || this.hi === t.hi && this.lo >= t.lo
				},
				pow: function(t) {
					if (0 === t) return O.valueOf(1);
					var e = new O(this),
						i = O.valueOf(1),
						n = Math.abs(t);
					if (n > 1) for (; n > 0;) n % 2 == 1 && i.selfMultiply(e), (n /= 2) > 0 && (e = e.sqr());
					else i = e;
					return 0 > t ? i.reciprocal() : i
				},
				ceil: function() {
					if (this.isNaN()) return O.NaN;
					var t = Math.ceil(this.hi),
						e = 0;
					return t === this.hi && (e = Math.ceil(this.lo)), new O(t, e)
				},
				compareTo: function(t) {
					var e = t;
					return this.hi < e.hi ? -1 : this.hi > e.hi ? 1 : this.lo < e.lo ? -1 : this.lo > e.lo ? 1 : 0
				},
				rint: function() {
					return this.isNaN() ? this : this.add(.5).floor()
				},
				setValue: function() {
					if (arguments[0] instanceof O) {
						var t = arguments[0];
						return this.init(t), this
					}
					if ("number" == typeof arguments[0]) {
						var e = arguments[0];
						return this.init(e), this
					}
				},
				max: function(t) {
					return this.ge(t) ? this : t
				},
				sqrt: function() {
					if (this.isZero()) return O.valueOf(0);
					if (this.isNegative()) return O.NaN;
					var t = 1 / Math.sqrt(this.hi),
						e = this.hi * t,
						i = O.valueOf(e),
						n = this.subtract(i.sqr()).hi * (.5 * t);
					return i.add(n)
				},
				selfAdd: function() {
					if (1 === arguments.length) {
						if (arguments[0] instanceof O) {
							var t = arguments[0];
							return this.selfAdd(t.hi, t.lo)
						}
						if ("number" == typeof arguments[0]) {
							var e = arguments[0],
								i = null,
								n = null,
								r = null,
								o = null,
								s = null,
								a = null;
							return o = (r = this.hi + e) - (s = r - this.hi), n = (a = (o = e - s + (this.hi - o)) + this.lo) + (r - (i = r + a)), this.hi = i + n, this.lo = n + (i - this.hi), this
						}
					} else if (2 === arguments.length) {
						var l = arguments[0],
							u = arguments[1],
							h = (i = null, n = null, null),
							c = null;
						r = null, o = null, s = null, a = null, r = this.hi + l, h = this.lo + u, o = r - (s = r - this.hi), c = h - (a = h - this.lo);
						var d = (i = r + (s = (o = l - s + (this.hi - o)) + h)) + (s = (c = u - a + (this.lo - c)) + (n = s + (r - i))),
							f = s + (i - d);
						return this.hi = d, this.lo = f, this
					}
				},
				selfMultiply: function() {
					if (1 === arguments.length) {
						if (arguments[0] instanceof O) {
							var t = arguments[0];
							return this.selfMultiply(t.hi, t.lo)
						}
						if ("number" == typeof arguments[0]) {
							var e = arguments[0];
							return this.selfMultiply(e, 0)
						}
					} else if (2 === arguments.length) {
						var i = arguments[0],
							n = arguments[1],
							r = null,
							o = null,
							s = null,
							a = null,
							l = null,
							u = null;
						r = (l = O.SPLIT * this.hi) - this.hi, u = O.SPLIT * i, r = l - r, o = this.hi - r, s = u - i;
						var h = (l = this.hi * i) + (u = r * (s = u - s) - l + r * (a = i - s) + o * s + o * a + (this.hi * n + this.lo * i)),
							c = u + (r = l - h);
						return this.hi = h, this.lo = c, this
					}
				},
				selfSqr: function() {
					return this.selfMultiply(this)
				},
				floor: function() {
					if (this.isNaN()) return O.NaN;
					var t = Math.floor(this.hi),
						e = 0;
					return t === this.hi && (e = Math.floor(this.lo)), new O(t, e)
				},
				negate: function() {
					return this.isNaN() ? this : new O(-this.hi, -this.lo)
				},
				clone: function() {
					try {
						return null
					} catch (t) {
						if (t instanceof CloneNotSupportedException) return null;
						throw t
					}
				},
				multiply: function() {
					if (arguments[0] instanceof O) {
						var t = arguments[0];
						return t.isNaN() ? O.createNaN() : O.copy(this).selfMultiply(t)
					}
					if ("number" == typeof arguments[0]) {
						var e = arguments[0];
						return r.isNaN(e) ? O.createNaN() : O.copy(this).selfMultiply(e, 0)
					}
				},
				isNaN: function() {
					return r.isNaN(this.hi)
				},
				intValue: function() {
					return Math.trunc(this.hi)
				},
				toString: function() {
					var t = O.magnitude(this.hi);
					return t >= -3 && 20 >= t ? this.toStandardNotation() : this.toSciNotation()
				},
				toStandardNotation: function() {
					var t = this.getSpecialNumberString();
					if (null !== t) return t;
					var e = new Array(1).fill(null),
						i = this.extractSignificantDigits(!0, e),
						n = e[0] + 1,
						r = i;
					if ("." === i.charAt(0)) r = "0" + i;
					else if (0 > n) r = "0." + O.stringOfChar("0", -n) + i;
					else if (-1 === i.indexOf(".")) {
						var o = n - i.length;
						r = i + O.stringOfChar("0", o) + ".0"
					}
					return this.isNegative() ? "-" + r : r
				},
				reciprocal: function() {
					var t, e, i, n, r = null,
						o = null,
						s = null,
						a = null;
					t = (i = 1 / this.hi) - (r = (s = O.SPLIT * i) - (r = s - i)), o = (a = O.SPLIT * this.hi) - this.hi;
					var l = i + (s = (1 - (n = i * this.hi) - (a = r * (o = a - o) - n + r * (e = this.hi - o) + t * o + t * e) - i * this.lo) / this.hi);
					return new O(l, i - l + s)
				},
				toSciNotation: function() {
					if (this.isZero()) return O.SCI_NOT_ZERO;
					var t = this.getSpecialNumberString();
					if (null !== t) return t;
					var e = new Array(1).fill(null),
						i = this.extractSignificantDigits(!1, e),
						n = O.SCI_NOT_EXPONENT_CHAR + e[0];
					if ("0" === i.charAt(0)) throw new IllegalStateException("Found leading zero: " + i);
					var r = "";
					i.length > 1 && (r = i.substring(1));
					var o = i.charAt(0) + "." + r;
					return this.isNegative() ? "-" + o + n : o + n
				},
				abs: function() {
					return this.isNaN() ? O.NaN : this.isNegative() ? this.negate() : new O(this)
				},
				isPositive: function() {
					return this.hi > 0 || 0 === this.hi && this.lo > 0
				},
				lt: function(t) {
					return this.hi < t.hi || this.hi === t.hi && this.lo < t.lo
				},
				add: function() {
					if (arguments[0] instanceof O) {
						var t = arguments[0];
						return O.copy(this).selfAdd(t)
					}
					if ("number" == typeof arguments[0]) {
						var e = arguments[0];
						return O.copy(this).selfAdd(e)
					}
				},
				init: function() {
					if (1 === arguments.length) {
						if ("number" == typeof arguments[0]) {
							var t = arguments[0];
							this.hi = t, this.lo = 0
						} else if (arguments[0] instanceof O) {
							var e = arguments[0];
							this.hi = e.hi, this.lo = e.lo
						}
					} else if (2 === arguments.length) {
						var i = arguments[0],
							n = arguments[1];
						this.hi = i, this.lo = n
					}
				},
				gt: function(t) {
					return this.hi > t.hi || this.hi === t.hi && this.lo > t.lo
				},
				isNegative: function() {
					return this.hi < 0 || 0 === this.hi && this.lo < 0
				},
				trunc: function() {
					return this.isNaN() ? O.NaN : this.isPositive() ? this.floor() : this.ceil()
				},
				signum: function() {
					return this.hi > 0 ? 1 : this.hi < 0 ? -1 : this.lo > 0 ? 1 : this.lo < 0 ? -1 : 0
				},
				interfaces_: function() {
					return [l, o, s]
				},
				getClass: function() {
					return O
				}
			}), O.sqr = function(t) {
				return O.valueOf(t).selfMultiply(t)
			}, O.valueOf = function() {
				if ("string" == typeof arguments[0]) {
					var t = arguments[0];
					return O.parse(t)
				}
				if ("number" == typeof arguments[0]) {
					var e = arguments[0];
					return new O(e)
				}
			}, O.sqrt = function(t) {
				return O.valueOf(t).sqrt()
			}, O.parse = function(t) {
				for (var e = 0, i = t.length; P.isWhitespace(t.charAt(e));) e++;
				var n = !1;
				if (i > e) {
					var r = t.charAt(e);
					"-" !== r && "+" !== r || (e++, "-" === r && (n = !0))
				}
				for (var o = new O, s = 0, a = 0, l = 0; !(e >= i);) {
					var u = t.charAt(e);
					if (e++, P.isDigit(u)) {
						var h = u - "0";
						o.selfMultiply(O.TEN), o.selfAdd(h), s++
					} else {
						if ("." !== u) {
							if ("e" === u || "E" === u) {
								var c = t.substring(e);
								try {
									l = N.parseInt(c)
								} catch (e) {
									throw e instanceof NumberFormatException ? new NumberFormatException("Invalid exponent " + c + " in string " + t) : e
								}
								break
							}
							throw new NumberFormatException("Unexpected character '" + u + "' at position " + e + " in string " + t)
						}
						a = s
					}
				}
				var d = o,
					f = s - a - l;
				if (0 === f) d = o;
				else if (f > 0) {
					var A = O.TEN.pow(f);
					d = o.divide(A)
				} else 0 > f && (A = O.TEN.pow(-f), d = o.multiply(A));
				return n ? d.negate() : d
			}, O.createNaN = function() {
				return new O(r.NaN, r.NaN)
			}, O.copy = function(t) {
				return new O(t)
			}, O.magnitude = function(t) {
				var e = Math.abs(t),
					i = Math.log(e) / Math.log(10),
					n = Math.trunc(Math.floor(i));
				return e >= 10 * Math.pow(10, n) && (n += 1), n
			}, O.stringOfChar = function(t, e) {
				for (var i = new L, n = 0; e > n; n++) i.append(t);
				return i.toString()
			}, O.PI = new O(3.141592653589793, 12246467991473532e-32), O.TWO_PI = new O(6.283185307179586, 24492935982947064e-32), O.PI_2 = new O(1.5707963267948966, 6123233995736766e-32), O.E = new O(2.718281828459045, 14456468917292502e-32), O.NaN = new O(r.NaN, r.NaN), O.EPS = 123259516440783e-46, O.SPLIT = 134217729, O.MAX_PRINT_DIGITS = 32, O.TEN = O.valueOf(10), O.ONE = O.valueOf(1), O.SCI_NOT_EXPONENT_CHAR = "E", O.SCI_NOT_ZERO = "0.0E0", e(M.prototype, {
				interfaces_: function() {
					return []
				},
				getClass: function() {
					return M
				}
			}), M.orientationIndex = function(t, e, i) {
				var n = M.orientationIndexFilter(t, e, i);
				if (1 >= n) return n;
				var r = O.valueOf(e.x).selfAdd(-t.x),
					o = O.valueOf(e.y).selfAdd(-t.y),
					s = O.valueOf(i.x).selfAdd(-e.x),
					a = O.valueOf(i.y).selfAdd(-e.y);
				return r.selfMultiply(a).selfSubtract(o.selfMultiply(s)).signum()
			}, M.signOfDet2x2 = function(t, e, i, n) {
				return t.multiply(n).selfSubtract(e.multiply(i)).signum()
			}, M.intersection = function(t, e, i, n) {
				var r = O.valueOf(n.y).selfSubtract(i.y).selfMultiply(O.valueOf(e.x).selfSubtract(t.x)),
					o = O.valueOf(n.x).selfSubtract(i.x).selfMultiply(O.valueOf(e.y).selfSubtract(t.y)),
					s = r.subtract(o),
					a = O.valueOf(n.x).selfSubtract(i.x).selfMultiply(O.valueOf(t.y).selfSubtract(i.y)),
					l = O.valueOf(n.y).selfSubtract(i.y).selfMultiply(O.valueOf(t.x).selfSubtract(i.x)),
					u = a.subtract(l).selfDivide(s).doubleValue(),
					h = O.valueOf(t.x).selfAdd(O.valueOf(e.x).selfSubtract(t.x).selfMultiply(u)).doubleValue(),
					c = O.valueOf(e.x).selfSubtract(t.x).selfMultiply(O.valueOf(t.y).selfSubtract(i.y)),
					d = O.valueOf(e.y).selfSubtract(t.y).selfMultiply(O.valueOf(t.x).selfSubtract(i.x)),
					A = c.subtract(d).selfDivide(s).doubleValue();
				return new f(h, O.valueOf(i.y).selfAdd(O.valueOf(n.y).selfSubtract(i.y).selfMultiply(A)).doubleValue())
			}, M.orientationIndexFilter = function(t, e, i) {
				var n = null,
					r = (t.x - i.x) * (e.y - i.y),
					o = (t.y - i.y) * (e.x - i.x),
					s = r - o;
				if (r > 0) {
					if (0 >= o) return M.signum(s);
					n = r + o
				} else {
					if (!(0 > r)) return M.signum(s);
					if (o >= 0) return M.signum(s);
					n = -r - o
				}
				var a = M.DP_SAFE_EPSILON * n;
				return s >= a || -s >= a ? M.signum(s) : 2
			}, M.signum = function(t) {
				return t > 0 ? 1 : 0 > t ? -1 : 0
			}, M.DP_SAFE_EPSILON = 1e-15, e(b.prototype, {
				setOrdinate: function(t, e, i) {},
				size: function() {},
				getOrdinate: function(t, e) {},
				getCoordinate: function() {
					1 === arguments.length ? arguments[0] : 2 === arguments.length && (arguments[0], arguments[1])
				},
				getCoordinateCopy: function(t) {},
				getDimension: function() {},
				getX: function(t) {},
				clone: function() {},
				expandEnvelope: function(t) {},
				copy: function() {},
				getY: function(t) {},
				toCoordinateArray: function() {},
				interfaces_: function() {
					return [s]
				},
				getClass: function() {
					return b
				}
			}), b.X = 0, b.Y = 1, b.Z = 2, b.M = 3, F.arraycopy = function(t, e, i, n, r) {
				for (var o = 0, s = e; e + r > s; s++) i[n + o] = t[s], o++
			}, F.getProperty = function(t) {
				return {
					"line.separator": "\n"
				}[t]
			}, e(D.prototype, {
				getY: function() {
					var t = this.y / this.w;
					if (r.isNaN(t) || r.isInfinite(t)) throw new S;
					return t
				},
				getX: function() {
					var t = this.x / this.w;
					if (r.isNaN(t) || r.isInfinite(t)) throw new S;
					return t
				},
				getCoordinate: function() {
					var t = new f;
					return t.x = this.getX(), t.y = this.getY(), t
				},
				interfaces_: function() {
					return []
				},
				getClass: function() {
					return D
				}
			}), D.intersection = function(t, e, i, n) {
				var o = t.y - e.y,
					s = e.x - t.x,
					a = t.x * e.y - e.x * t.y,
					l = i.y - n.y,
					u = n.x - i.x,
					h = i.x * n.y - n.x * i.y,
					c = o * u - l * s,
					d = (s * h - u * a) / c,
					A = (l * a - o * h) / c;
				if (r.isNaN(d) || r.isInfinite(d) || r.isNaN(A) || r.isInfinite(A)) throw new S;
				return new f(d, A)
			}, e(G.prototype, {
				create: function() {
					1 === arguments.length ? arguments[0] instanceof Array ? arguments[0] : R(arguments[0], b) && arguments[0] : 2 === arguments.length && (arguments[0], arguments[1])
				},
				interfaces_: function() {
					return []
				},
				getClass: function() {
					return G
				}
			}), e(k.prototype, {
				filter: function(t) {},
				interfaces_: function() {
					return []
				},
				getClass: function() {
					return k
				}
			}), e(U.prototype, {
				isGeometryCollection: function() {
					return this.getSortIndex() === U.SORTINDEX_GEOMETRYCOLLECTION
				},
				getFactory: function() {
					return this.factory
				},
				getGeometryN: function(t) {
					return this
				},
				getArea: function() {
					return 0
				},
				isRectangle: function() {
					return !1
				},
				equals: function() {
					if (1 === arguments.length) {
						if (arguments[0] instanceof U) {
							var t = arguments[0];
							return null !== t && this.equalsTopo(t)
						}
						if (arguments[0] instanceof Object) {
							var e = arguments[0];
							if (!(e instanceof U)) return !1;
							var i = e;
							return this.equalsExact(i)
						}
					}
				},
				equalsExact: function(t) {
					return this === t || this.equalsExact(t, 0)
				},
				geometryChanged: function() {
					this.apply(U.geometryChangedFilter)
				},
				geometryChangedAction: function() {
					this.envelope = null
				},
				equalsNorm: function(t) {
					return null !== t && this.norm().equalsExact(t.norm())
				},
				getLength: function() {
					return 0
				},
				getNumGeometries: function() {
					return 1
				},
				compareTo: function() {
					if (1 === arguments.length) {
						var t = arguments[0],
							e = t;
						return this.getSortIndex() !== e.getSortIndex() ? this.getSortIndex() - e.getSortIndex() : this.isEmpty() && e.isEmpty() ? 0 : this.isEmpty() ? -1 : e.isEmpty() ? 1 : this.compareToSameClass(t)
					}
					if (2 === arguments.length) {
						var i = arguments[0],
							n = arguments[1];
						return e = i, this.getSortIndex() !== e.getSortIndex() ? this.getSortIndex() - e.getSortIndex() : this.isEmpty() && e.isEmpty() ? 0 : this.isEmpty() ? -1 : e.isEmpty() ? 1 : this.compareToSameClass(i, n)
					}
				},
				getUserData: function() {
					return this.userData
				},
				getSRID: function() {
					return this.SRID
				},
				getEnvelope: function() {
					return this.getFactory().toGeometry(this.getEnvelopeInternal())
				},
				checkNotGeometryCollection: function(t) {
					if (t.getSortIndex() === U.SORTINDEX_GEOMETRYCOLLECTION) throw new n("This method does not support GeometryCollection arguments")
				},
				equal: function(t, e, i) {
					return 0 === i ? t.equals(e) : t.distance(e) <= i
				},
				norm: function() {
					var t = this.copy();
					return t.normalize(), t
				},
				getPrecisionModel: function() {
					return this.factory.getPrecisionModel()
				},
				getEnvelopeInternal: function() {
					return null === this.envelope && (this.envelope = this.computeEnvelopeInternal()), new C(this.envelope)
				},
				setSRID: function(t) {
					this.SRID = t
				},
				setUserData: function(t) {
					this.userData = t
				},
				compare: function(t, e) {
					for (var i = t.iterator(), n = e.iterator(); i.hasNext() && n.hasNext();) {
						var r = i.next(),
							o = n.next(),
							s = r.compareTo(o);
						if (0 !== s) return s
					}
					return i.hasNext() ? 1 : n.hasNext() ? -1 : 0
				},
				hashCode: function() {
					return this.getEnvelopeInternal().hashCode()
				},
				isGeometryCollectionOrDerived: function() {
					return this.getSortIndex() === U.SORTINDEX_GEOMETRYCOLLECTION || this.getSortIndex() === U.SORTINDEX_MULTIPOINT || this.getSortIndex() === U.SORTINDEX_MULTILINESTRING || this.getSortIndex() === U.SORTINDEX_MULTIPOLYGON
				},
				interfaces_: function() {
					return [s, o, l]
				},
				getClass: function() {
					return U
				}
			}), U.hasNonEmptyElements = function(t) {
				for (var e = 0; e < t.length; e++) if (!t[e].isEmpty()) return !0;
				return !1
			}, U.hasNullElements = function(t) {
				for (var e = 0; e < t.length; e++) if (null === t[e]) return !0;
				return !1
			}, U.serialVersionUID = 0x799ea46522854c00, U.SORTINDEX_POINT = 0, U.SORTINDEX_MULTIPOINT = 1, U.SORTINDEX_LINESTRING = 2, U.SORTINDEX_LINEARRING = 3, U.SORTINDEX_MULTILINESTRING = 4, U.SORTINDEX_POLYGON = 5, U.SORTINDEX_MULTIPOLYGON = 6, U.SORTINDEX_GEOMETRYCOLLECTION = 7, U.geometryChangedFilter = {
				interfaces_: function() {
					return [k]
				},
				filter: function(t) {
					t.geometryChangedAction()
				}
			}, e(B.prototype, {
				filter: function(t) {},
				interfaces_: function() {
					return []
				},
				getClass: function() {
					return B
				}
			}), e(j.prototype, {
				isInBoundary: function(t) {},
				interfaces_: function() {
					return []
				},
				getClass: function() {
					return j
				}
			}), e(V.prototype, {
				isInBoundary: function(t) {
					return t % 2 == 1
				},
				interfaces_: function() {
					return [j]
				},
				getClass: function() {
					return V
				}
			}), e(Y.prototype, {
				isInBoundary: function(t) {
					return t > 0
				},
				interfaces_: function() {
					return [j]
				},
				getClass: function() {
					return Y
				}
			}), e(z.prototype, {
				isInBoundary: function(t) {
					return t > 1
				},
				interfaces_: function() {
					return [j]
				},
				getClass: function() {
					return z
				}
			}), e(X.prototype, {
				isInBoundary: function(t) {
					return 1 === t
				},
				interfaces_: function() {
					return [j]
				},
				getClass: function() {
					return X
				}
			}), j.Mod2BoundaryNodeRule = V, j.EndPointBoundaryNodeRule = Y, j.MultiValentEndPointBoundaryNodeRule = z, j.MonoValentEndPointBoundaryNodeRule = X, j.MOD2_BOUNDARY_RULE = new V, j.ENDPOINT_BOUNDARY_RULE = new Y, j.MULTIVALENT_ENDPOINT_BOUNDARY_RULE = new z, j.MONOVALENT_ENDPOINT_BOUNDARY_RULE = new X, j.OGC_SFS_BOUNDARY_RULE = j.MOD2_BOUNDARY_RULE, e(W.prototype, {
				interfaces_: function() {
					return []
				},
				getClass: function() {
					return W
				}
			}), W.isRing = function(t) {
				return !(t.length < 4 || !t[0].equals2D(t[t.length - 1]))
			}, W.ptNotInList = function(t, e) {
				for (var i = 0; i < t.length; i++) {
					var n = t[i];
					if (W.indexOf(n, e) < 0) return n
				}
				return null
			}, W.scroll = function(t, e) {
				var i = W.indexOf(e, t);
				if (0 > i) return null;
				var n = new Array(t.length).fill(null);
				F.arraycopy(t, i, n, 0, t.length - i), F.arraycopy(t, 0, n, t.length - i, i), F.arraycopy(n, 0, t, 0, t.length)
			}, W.equals = function() {
				if (2 === arguments.length) {
					var t = arguments[0],
						e = arguments[1];
					if (t === e) return !0;
					if (null === t || null === e) return !1;
					if (t.length !== e.length) return !1;
					for (var i = 0; i < t.length; i++) if (!t[i].equals(e[i])) return !1;
					return !0
				}
				if (3 === arguments.length) {
					var n = arguments[0],
						r = arguments[1],
						o = arguments[2];
					if (n === r) return !0;
					if (null === n || null === r) return !1;
					if (n.length !== r.length) return !1;
					for (i = 0; i < n.length; i++) if (0 !== o.compare(n[i], r[i])) return !1;
					return !0
				}
			}, W.intersection = function(t, e) {
				for (var i = new x, n = 0; n < t.length; n++) e.intersects(t[n]) && i.add(t[n], !0);
				return i.toCoordinateArray()
			}, W.hasRepeatedPoints = function(t) {
				for (var e = 1; e < t.length; e++) if (t[e - 1].equals(t[e])) return !0;
				return !1
			}, W.removeRepeatedPoints = function(t) {
				return W.hasRepeatedPoints(t) ? new x(t, !1).toCoordinateArray() : t
			}, W.reverse = function(t) {
				for (var e = t.length - 1, i = Math.trunc(e / 2), n = 0; i >= n; n++) {
					var r = t[n];
					t[n] = t[e - n], t[e - n] = r
				}
			}, W.removeNull = function(t) {
				for (var e = 0, i = 0; i < t.length; i++) null !== t[i] && e++;
				var n = new Array(e).fill(null);
				if (0 === e) return n;
				var r = 0;
				for (i = 0; i < t.length; i++) null !== t[i] && (n[r++] = t[i]);
				return n
			}, W.copyDeep = function() {
				if (1 === arguments.length) {
					for (var t = arguments[0], e = new Array(t.length).fill(null), i = 0; i < t.length; i++) e[i] = new f(t[i]);
					return e
				}
				if (5 === arguments.length) {
					var n = arguments[0],
						r = arguments[1],
						o = arguments[2],
						s = arguments[3],
						a = arguments[4];
					for (i = 0; a > i; i++) o[s + i] = new f(n[r + i])
				}
			}, W.isEqualReversed = function(t, e) {
				for (var i = 0; i < t.length; i++) {
					var n = t[i],
						r = e[t.length - i - 1];
					if (0 !== n.compareTo(r)) return !1
				}
				return !0
			}, W.envelope = function(t) {
				for (var e = new C, i = 0; i < t.length; i++) e.expandToInclude(t[i]);
				return e
			}, W.toCoordinateArray = function(t) {
				return t.toArray(W.coordArrayType)
			}, W.atLeastNCoordinatesOrNothing = function(t, e) {
				return e.length >= t ? e : []
			}, W.indexOf = function(t, e) {
				for (var i = 0; i < e.length; i++) if (t.equals(e[i])) return i;
				return -1
			}, W.increasingDirection = function(t) {
				for (var e = 0; e < Math.trunc(t.length / 2); e++) {
					var i = t.length - 1 - e,
						n = t[e].compareTo(t[i]);
					if (0 !== n) return n
				}
				return 1
			}, W.compare = function(t, e) {
				for (var i = 0; i < t.length && i < e.length;) {
					var n = t[i].compareTo(e[i]);
					if (0 !== n) return n;
					i++
				}
				return i < e.length ? -1 : i < t.length ? 1 : 0
			}, W.minCoordinate = function(t) {
				for (var e = null, i = 0; i < t.length; i++)(null === e || e.compareTo(t[i]) > 0) && (e = t[i]);
				return e
			}, W.extract = function(t, e, i) {
				e = w.clamp(e, 0, t.length);
				var n = (i = w.clamp(i, -1, t.length)) - e + 1;
				0 > i && (n = 0), e >= t.length && (n = 0), e > i && (n = 0);
				var r = new Array(n).fill(null);
				if (0 === n) return r;
				for (var o = 0, s = e; i >= s; s++) r[o++] = t[s];
				return r
			}, e(q.prototype, {
				compare: function(t, e) {
					var i = t,
						n = e;
					return W.compare(i, n)
				},
				interfaces_: function() {
					return [a]
				},
				getClass: function() {
					return q
				}
			}), e(H.prototype, {
				compare: function(t, e) {
					var i = t,
						n = e;
					if (i.length < n.length) return -1;
					if (i.length > n.length) return 1;
					if (0 === i.length) return 0;
					var r = W.compare(i, n);
					return W.isEqualReversed(i, n) ? 0 : r
				},
				OLDcompare: function(t, e) {
					var i = t,
						n = e;
					if (i.length < n.length) return -1;
					if (i.length > n.length) return 1;
					if (0 === i.length) return 0;
					for (var r = W.increasingDirection(i), o = W.increasingDirection(n), s = r > 0 ? 0 : i.length - 1, a = o > 0 ? 0 : i.length - 1, l = 0; l < i.length; l++) {
						var u = i[s].compareTo(n[a]);
						if (0 !== u) return u;
						s += r, a += o
					}
					return 0
				},
				interfaces_: function() {
					return [a]
				},
				getClass: function() {
					return H
				}
			}), W.ForwardComparator = q, W.BidirectionalComparator = H, W.coordArrayType = new Array(0).fill(null), Z.prototype.get = function() {}, Z.prototype.put = function() {}, Z.prototype.size = function() {}, Z.prototype.values = function() {}, Z.prototype.entrySet = function() {}, K.prototype = new Z, J.prototype = new g, J.prototype.contains = function() {}, Q.prototype = new J, Q.prototype.contains = function(t) {
				for (var e = 0, i = this.array_.length; i > e; e++) if (this.array_[e] === t) return !0;
				return !1
			}, Q.prototype.add = function(t) {
				return !this.contains(t) && (this.array_.push(t), !0)
			}, Q.prototype.addAll = function(t) {
				for (var e = t.iterator(); e.hasNext();) this.add(e.next());
				return !0
			}, Q.prototype.remove = function(t) {
				throw new javascript.util.OperationNotSupported
			}, Q.prototype.size = function() {
				return this.array_.length
			}, Q.prototype.isEmpty = function() {
				return 0 === this.array_.length
			}, Q.prototype.toArray = function() {
				for (var t = [], e = 0, i = this.array_.length; i > e; e++) t.push(this.array_[e]);
				return t
			}, Q.prototype.iterator = function() {
				return new Bo(this)
			};
			var Bo = function(t) {
					this.hashSet_ = t, this.position_ = 0
				};
			Bo.prototype.next = function() {
				if (this.position_ === this.hashSet_.size()) throw new y;
				return this.hashSet_.array_[this.position_++]
			}, Bo.prototype.hasNext = function() {
				return this.position_ < this.hashSet_.size()
			}, Bo.prototype.remove = function() {
				throw new _
			};
			var jo = 0;
			rt.prototype = new K, rt.prototype.get = function(t) {
				for (var e = this.root_; null !== e;) {
					var i = t.compareTo(e.key);
					if (0 > i) e = e.left;
					else {
						if (!(i > 0)) return e.value;
						e = e.right
					}
				}
				return null
			}, rt.prototype.put = function(t, e) {
				if (null === this.root_) return this.root_ = {
					key: t,
					value: e,
					left: null,
					right: null,
					parent: null,
					color: jo,
					getValue: function() {
						return this.value
					},
					getKey: function() {
						return this.key
					}
				}, this.size_ = 1, null;
				var i, n, r = this.root_;
				do {
					if (i = r, 0 > (n = t.compareTo(r.key))) r = r.left;
					else {
						if (!(n > 0)) {
							var o = r.value;
							return r.value = e, o
						}
						r = r.right
					}
				} while (null !== r);
				var s = {
					key: t,
					left: null,
					right: null,
					value: e,
					parent: i,
					color: jo,
					getValue: function() {
						return this.value
					},
					getKey: function() {
						return this.key
					}
				};
				return 0 > n ? i.left = s : i.right = s, this.fixAfterInsertion(s), this.size_++, null
			}, rt.prototype.fixAfterInsertion = function(t) {
				for (t.color = 1; null != t && t != this.root_ && 1 == t.parent.color;) if (tt(t) == it(tt(tt(t)))) 1 == $(e = nt(tt(tt(t)))) ? (et(tt(t), jo), et(e, jo), et(tt(tt(t)), 1), t = tt(tt(t))) : (t == nt(tt(t)) && (t = tt(t), this.rotateLeft(t)), et(tt(t), jo), et(tt(tt(t)), 1), this.rotateRight(tt(tt(t))));
				else {
					var e;
					1 == $(e = it(tt(tt(t)))) ? (et(tt(t), jo), et(e, jo), et(tt(tt(t)), 1), t = tt(tt(t))) : (t == it(tt(t)) && (t = tt(t), this.rotateRight(t)), et(tt(t), jo), et(tt(tt(t)), 1), this.rotateLeft(tt(tt(t))))
				}
				this.root_.color = jo
			}, rt.prototype.values = function() {
				var t = new E,
					e = this.getFirstEntry();
				if (null !== e) for (t.add(e.value); null !== (e = rt.successor(e));) t.add(e.value);
				return t
			}, rt.prototype.entrySet = function() {
				var t = new Q,
					e = this.getFirstEntry();
				if (null !== e) for (t.add(e); null !== (e = rt.successor(e));) t.add(e);
				return t
			}, rt.prototype.rotateLeft = function(t) {
				if (null != t) {
					var e = t.right;
					t.right = e.left, null != e.left && (e.left.parent = t), e.parent = t.parent, null == t.parent ? this.root_ = e : t.parent.left == t ? t.parent.left = e : t.parent.right = e, e.left = t, t.parent = e
				}
			}, rt.prototype.rotateRight = function(t) {
				if (null != t) {
					var e = t.left;
					t.left = e.right, null != e.right && (e.right.parent = t), e.parent = t.parent, null == t.parent ? this.root_ = e : t.parent.right == t ? t.parent.right = e : t.parent.left = e, e.right = t, t.parent = e
				}
			}, rt.prototype.getFirstEntry = function() {
				var t = this.root_;
				if (null != t) for (; null != t.left;) t = t.left;
				return t
			}, rt.successor = function(t) {
				if (null === t) return null;
				if (null !== t.right) {
					for (var e = t.right; null !== e.left;) e = e.left;
					return e
				}
				e = t.parent;
				for (var i = t; null !== e && i === e.right;) i = e, e = e.parent;
				return e
			}, rt.prototype.size = function() {
				return this.size_
			}, e(ot.prototype, {
				interfaces_: function() {
					return []
				},
				getClass: function() {
					return ot
				}
			}), st.prototype = new J, at.prototype = new st, at.prototype.contains = function(t) {
				for (var e = 0, i = this.array_.length; i > e; e++) if (0 === this.array_[e].compareTo(t)) return !0;
				return !1
			}, at.prototype.add = function(t) {
				if (this.contains(t)) return !1;
				for (var e = 0, i = this.array_.length; i > e; e++) if (1 === this.array_[e].compareTo(t)) return this.array_.splice(e, 0, t), !0;
				return this.array_.push(t), !0
			}, at.prototype.addAll = function(t) {
				for (var e = t.iterator(); e.hasNext();) this.add(e.next());
				return !0
			}, at.prototype.remove = function(t) {
				throw new _
			}, at.prototype.size = function() {
				return this.array_.length
			}, at.prototype.isEmpty = function() {
				return 0 === this.array_.length
			}, at.prototype.toArray = function() {
				for (var t = [], e = 0, i = this.array_.length; i > e; e++) t.push(this.array_[e]);
				return t
			}, at.prototype.iterator = function() {
				return new Vo(this)
			};
			var Vo = function(t) {
					this.treeSet_ = t, this.position_ = 0
				};
			Vo.prototype.next = function() {
				if (this.position_ === this.treeSet_.size()) throw new y;
				return this.treeSet_.array_[this.position_++]
			}, Vo.prototype.hasNext = function() {
				return this.position_ < this.treeSet_.size()
			}, Vo.prototype.remove = function() {
				throw new _
			}, lt.sort = function() {
				var t, e, i, n, r = arguments[0];
				if (1 === arguments.length) return n = function(t, e) {
					return t.compareTo(e)
				}, void r.sort(n);
				if (2 === arguments.length) i = arguments[1], n = function(t, e) {
					return i.compare(t, e)
				}, r.sort(n);
				else {
					if (3 === arguments.length) {
						(e = r.slice(arguments[1], arguments[2])).sort();
						var o = r.slice(0, arguments[1]).concat(e, r.slice(arguments[2], r.length));
						for (r.splice(0, r.length), t = 0; t < o.length; t++) r.push(o[t]);
						return
					}
					if (4 === arguments.length) {
						for (e = r.slice(arguments[1], arguments[2]), i = arguments[3], n = function(t, e) {
							return i.compare(t, e)
						}, e.sort(n), o = r.slice(0, arguments[1]).concat(e, r.slice(arguments[2], r.length)), r.splice(0, r.length), t = 0; t < o.length; t++) r.push(o[t]);
						return
					}
				}
			}, lt.asList = function(t) {
				for (var e = new E, i = 0, n = t.length; n > i; i++) e.add(t[i]);
				return e
			}, e(ut.prototype, {
				interfaces_: function() {
					return []
				},
				getClass: function() {
					return ut
				}
			}), ut.toDimensionSymbol = function(t) {
				switch (t) {
				case ut.FALSE:
					return ut.SYM_FALSE;
				case ut.TRUE:
					return ut.SYM_TRUE;
				case ut.DONTCARE:
					return ut.SYM_DONTCARE;
				case ut.P:
					return ut.SYM_P;
				case ut.L:
					return ut.SYM_L;
				case ut.A:
					return ut.SYM_A
				}
				throw new n("Unknown dimension value: " + t)
			}, ut.toDimensionValue = function(t) {
				switch (P.toUpperCase(t)) {
				case ut.SYM_FALSE:
					return ut.FALSE;
				case ut.SYM_TRUE:
					return ut.TRUE;
				case ut.SYM_DONTCARE:
					return ut.DONTCARE;
				case ut.SYM_P:
					return ut.P;
				case ut.SYM_L:
					return ut.L;
				case ut.SYM_A:
					return ut.A
				}
				throw new n("Unknown dimension symbol: " + t)
			}, ut.P = 0, ut.L = 1, ut.A = 2, ut.FALSE = -1, ut.TRUE = -2, ut.DONTCARE = -3, ut.SYM_FALSE = "F", ut.SYM_TRUE = "T", ut.SYM_DONTCARE = "*", ut.SYM_P = "0", ut.SYM_L = "1", ut.SYM_A = "2", e(ht.prototype, {
				filter: function(t) {},
				interfaces_: function() {
					return []
				},
				getClass: function() {
					return ht
				}
			}), e(ct.prototype, {
				filter: function(t, e) {},
				isDone: function() {},
				isGeometryChanged: function() {},
				interfaces_: function() {
					return []
				},
				getClass: function() {
					return ct
				}
			}), h(dt, U), e(dt.prototype, {
				computeEnvelopeInternal: function() {
					for (var t = new C, e = 0; e < this.geometries.length; e++) t.expandToInclude(this.geometries[e].getEnvelopeInternal());
					return t
				},
				getGeometryN: function(t) {
					return this.geometries[t]
				},
				getSortIndex: function() {
					return U.SORTINDEX_GEOMETRYCOLLECTION
				},
				getCoordinates: function() {
					for (var t = new Array(this.getNumPoints()).fill(null), e = -1, i = 0; i < this.geometries.length; i++) for (var n = this.geometries[i].getCoordinates(), r = 0; r < n.length; r++) t[++e] = n[r];
					return t
				},
				getArea: function() {
					for (var t = 0, e = 0; e < this.geometries.length; e++) t += this.geometries[e].getArea();
					return t
				},
				equalsExact: function() {
					if (2 === arguments.length) {
						var t = arguments[0],
							e = arguments[1];
						if (!this.isEquivalentClass(t)) return !1;
						var i = t;
						if (this.geometries.length !== i.geometries.length) return !1;
						for (var n = 0; n < this.geometries.length; n++) if (!this.geometries[n].equalsExact(i.geometries[n], e)) return !1;
						return !0
					}
					return U.prototype.equalsExact.apply(this, arguments)
				},
				normalize: function() {
					for (var t = 0; t < this.geometries.length; t++) this.geometries[t].normalize();
					lt.sort(this.geometries)
				},
				getCoordinate: function() {
					return this.isEmpty() ? null : this.geometries[0].getCoordinate()
				},
				getBoundaryDimension: function() {
					for (var t = ut.FALSE, e = 0; e < this.geometries.length; e++) t = Math.max(t, this.geometries[e].getBoundaryDimension());
					return t
				},
				getDimension: function() {
					for (var t = ut.FALSE, e = 0; e < this.geometries.length; e++) t = Math.max(t, this.geometries[e].getDimension());
					return t
				},
				getLength: function() {
					for (var t = 0, e = 0; e < this.geometries.length; e++) t += this.geometries[e].getLength();
					return t
				},
				getNumPoints: function() {
					for (var t = 0, e = 0; e < this.geometries.length; e++) t += this.geometries[e].getNumPoints();
					return t
				},
				getNumGeometries: function() {
					return this.geometries.length
				},
				reverse: function() {
					for (var t = this.geometries.length, e = new Array(t).fill(null), i = 0; i < this.geometries.length; i++) e[i] = this.geometries[i].reverse();
					return this.getFactory().createGeometryCollection(e)
				},
				compareToSameClass: function() {
					if (1 === arguments.length) {
						var t = arguments[0],
							e = new at(lt.asList(this.geometries)),
							i = new at(lt.asList(t.geometries));
						return this.compare(e, i)
					}
					if (2 === arguments.length) {
						for (var n = arguments[0], r = arguments[1], o = n, s = this.getNumGeometries(), a = o.getNumGeometries(), l = 0; s > l && a > l;) {
							var u = this.getGeometryN(l),
								h = o.getGeometryN(l),
								c = u.compareToSameClass(h, r);
							if (0 !== c) return c;
							l++
						}
						return s > l ? 1 : a > l ? -1 : 0
					}
				},
				apply: function() {
					if (R(arguments[0], B)) for (var t = arguments[0], e = 0; e < this.geometries.length; e++) this.geometries[e].apply(t);
					else if (R(arguments[0], ct)) {
						var i = arguments[0];
						if (0 === this.geometries.length) return null;
						for (e = 0; e < this.geometries.length && (this.geometries[e].apply(i), !i.isDone()); e++);
						i.isGeometryChanged() && this.geometryChanged()
					} else if (R(arguments[0], ht)) {
						var n = arguments[0];
						for (n.filter(this), e = 0; e < this.geometries.length; e++) this.geometries[e].apply(n)
					} else if (R(arguments[0], k)) {
						var r = arguments[0];
						for (r.filter(this), e = 0; e < this.geometries.length; e++) this.geometries[e].apply(r)
					}
				},
				getBoundary: function() {
					return this.checkNotGeometryCollection(this), d.shouldNeverReachHere(), null
				},
				clone: function() {
					var t = U.prototype.clone.call(this);
					t.geometries = new Array(this.geometries.length).fill(null);
					for (var e = 0; e < this.geometries.length; e++) t.geometries[e] = this.geometries[e].clone();
					return t
				},
				getGeometryType: function() {
					return "GeometryCollection"
				},
				copy: function() {
					for (var t = new Array(this.geometries.length).fill(null), e = 0; e < t.length; e++) t[e] = this.geometries[e].copy();
					return new dt(t, this.factory)
				},
				isEmpty: function() {
					for (var t = 0; t < this.geometries.length; t++) if (!this.geometries[t].isEmpty()) return !1;
					return !0
				},
				interfaces_: function() {
					return []
				},
				getClass: function() {
					return dt
				}
			}), dt.serialVersionUID = -0x4f07bcb1f857d800, h(ft, dt), e(ft.prototype, {
				getSortIndex: function() {
					return U.SORTINDEX_MULTILINESTRING
				},
				equalsExact: function() {
					if (2 === arguments.length) {
						var t = arguments[0],
							e = arguments[1];
						return !!this.isEquivalentClass(t) && dt.prototype.equalsExact.call(this, t, e)
					}
					return dt.prototype.equalsExact.apply(this, arguments)
				},
				getBoundaryDimension: function() {
					return this.isClosed() ? ut.FALSE : 0
				},
				isClosed: function() {
					if (this.isEmpty()) return !1;
					for (var t = 0; t < this.geometries.length; t++) if (!this.geometries[t].isClosed()) return !1;
					return !0
				},
				getDimension: function() {
					return 1
				},
				reverse: function() {
					for (var t = this.geometries.length, e = new Array(t).fill(null), i = 0; i < this.geometries.length; i++) e[t - 1 - i] = this.geometries[i].reverse();
					return this.getFactory().createMultiLineString(e)
				},
				getBoundary: function() {
					return new At(this).getBoundary()
				},
				getGeometryType: function() {
					return "MultiLineString"
				},
				copy: function() {
					for (var t = new Array(this.geometries.length).fill(null), e = 0; e < t.length; e++) t[e] = this.geometries[e].copy();
					return new ft(t, this.factory)
				},
				interfaces_: function() {
					return [ot]
				},
				getClass: function() {
					return ft
				}
			}), ft.serialVersionUID = 0x7155d2ab4afa8000, e(At.prototype, {
				boundaryMultiLineString: function(t) {
					if (this.geom.isEmpty()) return this.getEmptyMultiPoint();
					var e = this.computeBoundaryCoordinates(t);
					return 1 === e.length ? this.geomFact.createPoint(e[0]) : this.geomFact.createMultiPointFromCoords(e)
				},
				getBoundary: function() {
					return this.geom instanceof Ct ? this.boundaryLineString(this.geom) : this.geom instanceof ft ? this.boundaryMultiLineString(this.geom) : this.geom.getBoundary()
				},
				boundaryLineString: function(t) {
					return this.geom.isEmpty() ? this.getEmptyMultiPoint() : t.isClosed() ? this.bnRule.isInBoundary(2) ? t.getStartPoint() : this.geomFact.createMultiPoint() : this.geomFact.createMultiPoint([t.getStartPoint(), t.getEndPoint()])
				},
				getEmptyMultiPoint: function() {
					return this.geomFact.createMultiPoint()
				},
				computeBoundaryCoordinates: function(t) {
					var e = new E;
					this.endpointMap = new rt;
					for (var i = 0; i < t.getNumGeometries(); i++) {
						var n = t.getGeometryN(i);
						0 !== n.getNumPoints() && (this.addEndpoint(n.getCoordinateN(0)), this.addEndpoint(n.getCoordinateN(n.getNumPoints() - 1)))
					}
					for (var r = this.endpointMap.entrySet().iterator(); r.hasNext();) {
						var o = r.next(),
							s = o.getValue().count;
						this.bnRule.isInBoundary(s) && e.add(o.getKey())
					}
					return W.toCoordinateArray(e)
				},
				addEndpoint: function(t) {
					var e = this.endpointMap.get(t);
					null === e && (e = new pt, this.endpointMap.put(t, e)), e.count++
				},
				interfaces_: function() {
					return []
				},
				getClass: function() {
					return At
				}
			}), At.getBoundary = function() {
				if (1 === arguments.length) {
					var t = arguments[0];
					return new At(t).getBoundary()
				}
				if (2 === arguments.length) {
					var e = arguments[0],
						i = arguments[1];
					return new At(e, i).getBoundary()
				}
			}, e(pt.prototype, {
				interfaces_: function() {
					return []
				},
				getClass: function() {
					return pt
				}
			}), e(Et.prototype, {
				interfaces_: function() {
					return []
				},
				getClass: function() {
					return Et
				}
			}), Et.chars = function(t, e) {
				for (var i = new Array(e).fill(null), n = 0; e > n; n++) i[n] = t;
				return new String(i)
			}, Et.getStackTrace = function() {
				if (1 === arguments.length) {
					var t = arguments[0],
						e = new vt,
						i = new gt(e);
					return t.printStackTrace(i), e.toString()
				}
				if (2 === arguments.length) {
					for (var n = arguments[0], r = arguments[1], o = "", s = new mt(Et.getStackTrace(n)), a = new _t(s), l = 0; r > l; l++) try {
						o += a.readLine() + Et.NEWLINE
					} catch (t) {
						if (!(t instanceof yt)) throw t;
						d.shouldNeverReachHere()
					}
					return o
				}
			}, Et.split = function(t, e) {
				for (var i = e.length, n = new E, r = "" + t, o = r.indexOf(e); o >= 0;) {
					var s = r.substring(0, o);
					n.add(s), o = (r = r.substring(o + i)).indexOf(e)
				}
				r.length > 0 && n.add(r);
				for (var a = new Array(n.size()).fill(null), l = 0; l < a.length; l++) a[l] = n.get(l);
				return a
			}, Et.toString = function() {
				if (1 === arguments.length) {
					var t = arguments[0];
					return Et.SIMPLE_ORDINATE_FORMAT.format(t)
				}
			}, Et.spaces = function(t) {
				return Et.chars(" ", t)
			}, Et.NEWLINE = F.getProperty("line.separator"), Et.SIMPLE_ORDINATE_FORMAT = new function() {}("0.#"), e(xt.prototype, {
				interfaces_: function() {
					return []
				},
				getClass: function() {
					return xt
				}
			}), xt.copyCoord = function(t, e, i, n) {
				for (var r = Math.min(t.getDimension(), i.getDimension()), o = 0; r > o; o++) i.setOrdinate(n, o, t.getOrdinate(e, o))
			}, xt.isRing = function(t) {
				var e = t.size();
				return 0 === e || !(3 >= e) && t.getOrdinate(0, b.X) === t.getOrdinate(e - 1, b.X) && t.getOrdinate(0, b.Y) === t.getOrdinate(e - 1, b.Y)
			}, xt.isEqual = function(t, e) {
				var i = t.size();
				if (i !== e.size()) return !1;
				for (var n = Math.min(t.getDimension(), e.getDimension()), o = 0; i > o; o++) for (var s = 0; n > s; s++) {
					var a = t.getOrdinate(o, s),
						l = e.getOrdinate(o, s);
					if (!(t.getOrdinate(o, s) === e.getOrdinate(o, s) || r.isNaN(a) && r.isNaN(l))) return !1
				}
				return !0
			}, xt.extend = function(t, e, i) {
				var n = t.create(i, e.getDimension()),
					r = e.size();
				if (xt.copy(e, 0, n, 0, r), r > 0) for (var o = r; i > o; o++) xt.copy(e, r - 1, n, o, 1);
				return n
			}, xt.reverse = function(t) {
				for (var e = t.size() - 1, i = Math.trunc(e / 2), n = 0; i >= n; n++) xt.swap(t, n, e - n)
			}, xt.swap = function(t, e, i) {
				if (e === i) return null;
				for (var n = 0; n < t.getDimension(); n++) {
					var r = t.getOrdinate(e, n);
					t.setOrdinate(e, n, t.getOrdinate(i, n)), t.setOrdinate(i, n, r)
				}
			}, xt.copy = function(t, e, i, n, r) {
				for (var o = 0; r > o; o++) xt.copyCoord(t, e + o, i, n + o)
			}, xt.toString = function() {
				if (1 === arguments.length) {
					var t = arguments[0],
						e = t.size();
					if (0 === e) return "()";
					var i = t.getDimension(),
						n = new L;
					n.append("(");
					for (var r = 0; e > r; r++) {
						r > 0 && n.append(" ");
						for (var o = 0; i > o; o++) o > 0 && n.append(","), n.append(Et.toString(t.getOrdinate(r, o)))
					}
					return n.append(")"), n.toString()
				}
			}, xt.ensureValidRing = function(t, e) {
				var i = e.size();
				return 0 === i ? e : 3 >= i ? xt.createClosedRing(t, e, 4) : e.getOrdinate(0, b.X) === e.getOrdinate(i - 1, b.X) && e.getOrdinate(0, b.Y) === e.getOrdinate(i - 1, b.Y) ? e : xt.createClosedRing(t, e, i + 1)
			}, xt.createClosedRing = function(t, e, i) {
				var n = t.create(i, e.getDimension()),
					r = e.size();
				xt.copy(e, 0, n, 0, r);
				for (var o = r; i > o; o++) xt.copy(e, 0, n, o, 1);
				return n
			}, h(Ct, U), e(Ct.prototype, {
				computeEnvelopeInternal: function() {
					return this.isEmpty() ? new C : this.points.expandEnvelope(new C)
				},
				isRing: function() {
					return this.isClosed() && this.isSimple()
				},
				getSortIndex: function() {
					return U.SORTINDEX_LINESTRING
				},
				getCoordinates: function() {
					return this.points.toCoordinateArray()
				},
				equalsExact: function() {
					if (2 === arguments.length) {
						var t = arguments[0],
							e = arguments[1];
						if (!this.isEquivalentClass(t)) return !1;
						var i = t;
						if (this.points.size() !== i.points.size()) return !1;
						for (var n = 0; n < this.points.size(); n++) if (!this.equal(this.points.getCoordinate(n), i.points.getCoordinate(n), e)) return !1;
						return !0
					}
					return U.prototype.equalsExact.apply(this, arguments)
				},
				normalize: function() {
					for (var t = 0; t < Math.trunc(this.points.size() / 2); t++) {
						var e = this.points.size() - 1 - t;
						if (!this.points.getCoordinate(t).equals(this.points.getCoordinate(e))) return this.points.getCoordinate(t).compareTo(this.points.getCoordinate(e)) > 0 && xt.reverse(this.points), null
					}
				},
				getCoordinate: function() {
					return this.isEmpty() ? null : this.points.getCoordinate(0)
				},
				getBoundaryDimension: function() {
					return this.isClosed() ? ut.FALSE : 0
				},
				isClosed: function() {
					return !this.isEmpty() && this.getCoordinateN(0).equals2D(this.getCoordinateN(this.getNumPoints() - 1))
				},
				getEndPoint: function() {
					return this.isEmpty() ? null : this.getPointN(this.getNumPoints() - 1)
				},
				getDimension: function() {
					return 1
				},
				getLength: function() {
					return $t.computeLength(this.points)
				},
				getNumPoints: function() {
					return this.points.size()
				},
				reverse: function() {
					var t = this.points.copy();
					return xt.reverse(t), this.getFactory().createLineString(t)
				},
				compareToSameClass: function() {
					if (1 === arguments.length) {
						for (var t = arguments[0], e = t, i = 0, n = 0; i < this.points.size() && n < e.points.size();) {
							var r = this.points.getCoordinate(i).compareTo(e.points.getCoordinate(n));
							if (0 !== r) return r;
							i++, n++
						}
						return i < this.points.size() ? 1 : n < e.points.size() ? -1 : 0
					}
					if (2 === arguments.length) {
						var o = arguments[0],
							s = arguments[1];
						return e = o, s.compare(this.points, e.points)
					}
				},
				apply: function() {
					if (R(arguments[0], B)) for (var t = arguments[0], e = 0; e < this.points.size(); e++) t.filter(this.points.getCoordinate(e));
					else if (R(arguments[0], ct)) {
						var i = arguments[0];
						if (0 === this.points.size()) return null;
						for (e = 0; e < this.points.size() && (i.filter(this.points, e), !i.isDone()); e++);
						i.isGeometryChanged() && this.geometryChanged()
					} else if (R(arguments[0], ht)) {
						var n = arguments[0];
						n.filter(this)
					} else if (R(arguments[0], k)) {
						var r = arguments[0];
						r.filter(this)
					}
				},
				getBoundary: function() {
					return new At(this).getBoundary()
				},
				isEquivalentClass: function(t) {
					return t instanceof Ct
				},
				clone: function() {
					var t = U.prototype.clone.call(this);
					return t.points = this.points.clone(), t
				},
				getCoordinateN: function(t) {
					return this.points.getCoordinate(t)
				},
				getGeometryType: function() {
					return "LineString"
				},
				copy: function() {
					return new Ct(this.points.copy(), this.factory)
				},
				getCoordinateSequence: function() {
					return this.points
				},
				isEmpty: function() {
					return 0 === this.points.size()
				},
				init: function(t) {
					if (null === t && (t = this.getFactory().getCoordinateSequenceFactory().create([])), 1 === t.size()) throw new n("Invalid number of points in LineString (found " + t.size() + " - must be 0 or >= 2)");
					this.points = t
				},
				isCoordinate: function(t) {
					for (var e = 0; e < this.points.size(); e++) if (this.points.getCoordinate(e).equals(t)) return !0;
					return !1
				},
				getStartPoint: function() {
					return this.isEmpty() ? null : this.getPointN(0)
				},
				getPointN: function(t) {
					return this.getFactory().createPoint(this.points.getCoordinate(t))
				},
				interfaces_: function() {
					return [ot]
				},
				getClass: function() {
					return Ct
				}
			}), Ct.serialVersionUID = 0x2b2b51ba435c8e00, e(It.prototype, {
				interfaces_: function() {
					return []
				},
				getClass: function() {
					return It
				}
			}), h(St, U), e(St.prototype, {
				computeEnvelopeInternal: function() {
					if (this.isEmpty()) return new C;
					var t = new C;
					return t.expandToInclude(this.coordinates.getX(0), this.coordinates.getY(0)), t
				},
				getSortIndex: function() {
					return U.SORTINDEX_POINT
				},
				getCoordinates: function() {
					return this.isEmpty() ? [] : [this.getCoordinate()]
				},
				equalsExact: function() {
					if (2 === arguments.length) {
						var t = arguments[0],
							e = arguments[1];
						return !!this.isEquivalentClass(t) && (!(!this.isEmpty() || !t.isEmpty()) || this.isEmpty() === t.isEmpty() && this.equal(t.getCoordinate(), this.getCoordinate(), e))
					}
					return U.prototype.equalsExact.apply(this, arguments)
				},
				normalize: function() {},
				getCoordinate: function() {
					return 0 !== this.coordinates.size() ? this.coordinates.getCoordinate(0) : null
				},
				getBoundaryDimension: function() {
					return ut.FALSE
				},
				getDimension: function() {
					return 0
				},
				getNumPoints: function() {
					return this.isEmpty() ? 0 : 1
				},
				reverse: function() {
					return this.copy()
				},
				getX: function() {
					if (null === this.getCoordinate()) throw new IllegalStateException("getX called on empty Point");
					return this.getCoordinate().x
				},
				compareToSameClass: function() {
					if (1 === arguments.length) {
						var t = arguments[0],
							e = t;
						return this.getCoordinate().compareTo(e.getCoordinate())
					}
					if (2 === arguments.length) {
						var i = arguments[0],
							n = arguments[1];
						return e = i, n.compare(this.coordinates, e.coordinates)
					}
				},
				apply: function() {
					if (R(arguments[0], B)) {
						var t = arguments[0];
						if (this.isEmpty()) return null;
						t.filter(this.getCoordinate())
					} else if (R(arguments[0], ct)) {
						var e = arguments[0];
						if (this.isEmpty()) return null;
						e.filter(this.coordinates, 0), e.isGeometryChanged() && this.geometryChanged()
					} else if (R(arguments[0], ht)) {
						var i = arguments[0];
						i.filter(this)
					} else if (R(arguments[0], k)) {
						var n = arguments[0];
						n.filter(this)
					}
				},
				getBoundary: function() {
					return this.getFactory().createGeometryCollection(null)
				},
				clone: function() {
					var t = U.prototype.clone.call(this);
					return t.coordinates = this.coordinates.clone(), t
				},
				getGeometryType: function() {
					return "Point"
				},
				copy: function() {
					return new St(this.coordinates.copy(), this.factory)
				},
				getCoordinateSequence: function() {
					return this.coordinates
				},
				getY: function() {
					if (null === this.getCoordinate()) throw new IllegalStateException("getY called on empty Point");
					return this.getCoordinate().y
				},
				isEmpty: function() {
					return 0 === this.coordinates.size()
				},
				init: function(t) {
					null === t && (t = this.getFactory().getCoordinateSequenceFactory().create([])), d.isTrue(t.size() <= 1), this.coordinates = t
				},
				isSimple: function() {
					return !0
				},
				interfaces_: function() {
					return [It]
				},
				getClass: function() {
					return St
				}
			}), St.serialVersionUID = 0x44077bad161cbc00, e(Tt.prototype, {
				interfaces_: function() {
					return []
				},
				getClass: function() {
					return Tt
				}
			}), h(Rt, U), e(Rt.prototype, {
				computeEnvelopeInternal: function() {
					return this.shell.getEnvelopeInternal()
				},
				getSortIndex: function() {
					return U.SORTINDEX_POLYGON
				},
				getCoordinates: function() {
					if (this.isEmpty()) return [];
					for (var t = new Array(this.getNumPoints()).fill(null), e = -1, i = this.shell.getCoordinates(), n = 0; n < i.length; n++) t[++e] = i[n];
					for (var r = 0; r < this.holes.length; r++) for (var o = this.holes[r].getCoordinates(), s = 0; s < o.length; s++) t[++e] = o[s];
					return t
				},
				getArea: function() {
					var t = 0;
					t += Math.abs($t.signedArea(this.shell.getCoordinateSequence()));
					for (var e = 0; e < this.holes.length; e++) t -= Math.abs($t.signedArea(this.holes[e].getCoordinateSequence()));
					return t
				},
				isRectangle: function() {
					if (0 !== this.getNumInteriorRing()) return !1;
					if (null === this.shell) return !1;
					if (5 !== this.shell.getNumPoints()) return !1;
					for (var t = this.shell.getCoordinateSequence(), e = this.getEnvelopeInternal(), i = 0; 5 > i; i++) {
						if ((o = t.getX(i)) !== e.getMinX() && o !== e.getMaxX()) return !1;
						if ((s = t.getY(i)) !== e.getMinY() && s !== e.getMaxY()) return !1
					}
					var n = t.getX(0),
						r = t.getY(0);
					for (i = 1; 4 >= i; i++) {
						var o, s;
						if ((o = t.getX(i)) !== n == ((s = t.getY(i)) !== r)) return !1;
						n = o, r = s
					}
					return !0
				},
				equalsExact: function() {
					if (2 === arguments.length) {
						var t = arguments[0],
							e = arguments[1];
						if (!this.isEquivalentClass(t)) return !1;
						var i = t,
							n = this.shell,
							r = i.shell;
						if (!n.equalsExact(r, e)) return !1;
						if (this.holes.length !== i.holes.length) return !1;
						for (var o = 0; o < this.holes.length; o++) if (!this.holes[o].equalsExact(i.holes[o], e)) return !1;
						return !0
					}
					return U.prototype.equalsExact.apply(this, arguments)
				},
				normalize: function() {
					if (0 === arguments.length) {
						this.normalize(this.shell, !0);
						for (var t = 0; t < this.holes.length; t++) this.normalize(this.holes[t], !1);
						lt.sort(this.holes)
					} else if (2 === arguments.length) {
						var e = arguments[0],
							i = arguments[1];
						if (e.isEmpty()) return null;
						var n = new Array(e.getCoordinates().length - 1).fill(null);
						F.arraycopy(e.getCoordinates(), 0, n, 0, n.length);
						var r = W.minCoordinate(e.getCoordinates());
						W.scroll(n, r), F.arraycopy(n, 0, e.getCoordinates(), 0, n.length), e.getCoordinates()[n.length] = n[0], $t.isCCW(e.getCoordinates()) === i && W.reverse(e.getCoordinates())
					}
				},
				getCoordinate: function() {
					return this.shell.getCoordinate()
				},
				getNumInteriorRing: function() {
					return this.holes.length
				},
				getBoundaryDimension: function() {
					return 1
				},
				getDimension: function() {
					return 2
				},
				getLength: function() {
					var t = 0;
					t += this.shell.getLength();
					for (var e = 0; e < this.holes.length; e++) t += this.holes[e].getLength();
					return t
				},
				getNumPoints: function() {
					for (var t = this.shell.getNumPoints(), e = 0; e < this.holes.length; e++) t += this.holes[e].getNumPoints();
					return t
				},
				reverse: function() {
					var t = this.copy();
					t.shell = this.shell.copy().reverse(), t.holes = new Array(this.holes.length).fill(null);
					for (var e = 0; e < this.holes.length; e++) t.holes[e] = this.holes[e].copy().reverse();
					return t
				},
				convexHull: function() {
					return this.getExteriorRing().convexHull()
				},
				compareToSameClass: function() {
					if (1 === arguments.length) {
						var t = arguments[0],
							e = this.shell,
							i = t.shell;
						return e.compareToSameClass(i)
					}
					if (2 === arguments.length) {
						var n = arguments[0],
							r = arguments[1],
							o = n,
							s = (e = this.shell, i = o.shell, e.compareToSameClass(i, r));
						if (0 !== s) return s;
						for (var a = this.getNumInteriorRing(), l = o.getNumInteriorRing(), u = 0; a > u && l > u;) {
							var h = this.getInteriorRingN(u),
								c = o.getInteriorRingN(u),
								d = h.compareToSameClass(c, r);
							if (0 !== d) return d;
							u++
						}
						return a > u ? 1 : l > u ? -1 : 0
					}
				},
				apply: function() {
					if (R(arguments[0], B)) {
						var t = arguments[0];
						this.shell.apply(t);
						for (var e = 0; e < this.holes.length; e++) this.holes[e].apply(t)
					} else if (R(arguments[0], ct)) {
						var i = arguments[0];
						if (this.shell.apply(i), !i.isDone()) for (e = 0; e < this.holes.length && (this.holes[e].apply(i), !i.isDone()); e++);
						i.isGeometryChanged() && this.geometryChanged()
					} else if (R(arguments[0], ht)) {
						var n = arguments[0];
						n.filter(this)
					} else if (R(arguments[0], k)) {
						var r = arguments[0];
						for (r.filter(this), this.shell.apply(r), e = 0; e < this.holes.length; e++) this.holes[e].apply(r)
					}
				},
				getBoundary: function() {
					if (this.isEmpty()) return this.getFactory().createMultiLineString();
					var t = new Array(this.holes.length + 1).fill(null);
					t[0] = this.shell;
					for (var e = 0; e < this.holes.length; e++) t[e + 1] = this.holes[e];
					return t.length <= 1 ? this.getFactory().createLinearRing(t[0].getCoordinateSequence()) : this.getFactory().createMultiLineString(t)
				},
				clone: function() {
					var t = U.prototype.clone.call(this);
					t.shell = this.shell.clone(), t.holes = new Array(this.holes.length).fill(null);
					for (var e = 0; e < this.holes.length; e++) t.holes[e] = this.holes[e].clone();
					return t
				},
				getGeometryType: function() {
					return "Polygon"
				},
				copy: function() {
					for (var t = this.shell.copy(), e = new Array(this.holes.length).fill(null), i = 0; i < e.length; i++) e[i] = this.holes[i].copy();
					return new Rt(t, e, this.factory)
				},
				getExteriorRing: function() {
					return this.shell
				},
				isEmpty: function() {
					return this.shell.isEmpty()
				},
				getInteriorRingN: function(t) {
					return this.holes[t]
				},
				interfaces_: function() {
					return [Tt]
				},
				getClass: function() {
					return Rt
				}
			}), Rt.serialVersionUID = -0x307ffefd8dc97200, h(wt, dt), e(wt.prototype, {
				getSortIndex: function() {
					return U.SORTINDEX_MULTIPOINT
				},
				isValid: function() {
					return !0
				},
				equalsExact: function() {
					if (2 === arguments.length) {
						var t = arguments[0],
							e = arguments[1];
						return !!this.isEquivalentClass(t) && dt.prototype.equalsExact.call(this, t, e)
					}
					return dt.prototype.equalsExact.apply(this, arguments)
				},
				getCoordinate: function() {
					if (1 === arguments.length) {
						var t = arguments[0];
						return this.geometries[t].getCoordinate()
					}
					return dt.prototype.getCoordinate.apply(this, arguments)
				},
				getBoundaryDimension: function() {
					return ut.FALSE
				},
				getDimension: function() {
					return 0
				},
				getBoundary: function() {
					return this.getFactory().createGeometryCollection(null)
				},
				getGeometryType: function() {
					return "MultiPoint"
				},
				copy: function() {
					for (var t = new Array(this.geometries.length).fill(null), e = 0; e < t.length; e++) t[e] = this.geometries[e].copy();
					return new wt(t, this.factory)
				},
				interfaces_: function() {
					return [It]
				},
				getClass: function() {
					return wt
				}
			}), wt.serialVersionUID = -0x6fb1ed4162e0fc00, h(Lt, Ct), e(Lt.prototype, {
				getSortIndex: function() {
					return U.SORTINDEX_LINEARRING
				},
				getBoundaryDimension: function() {
					return ut.FALSE
				},
				isClosed: function() {
					return !!this.isEmpty() || Ct.prototype.isClosed.call(this)
				},
				reverse: function() {
					var t = this.points.copy();
					return xt.reverse(t), this.getFactory().createLinearRing(t)
				},
				validateConstruction: function() {
					if (!this.isEmpty() && !Ct.prototype.isClosed.call(this)) throw new n("Points of LinearRing do not form a closed linestring");
					if (this.getCoordinateSequence().size() >= 1 && this.getCoordinateSequence().size() < Lt.MINIMUM_VALID_SIZE) throw new n("Invalid number of points in LinearRing (found " + this.getCoordinateSequence().size() + " - must be 0 or >= 4)")
				},
				getGeometryType: function() {
					return "LinearRing"
				},
				copy: function() {
					return new Lt(this.points.copy(), this.factory)
				},
				interfaces_: function() {
					return []
				},
				getClass: function() {
					return Lt
				}
			}), Lt.MINIMUM_VALID_SIZE = 4, Lt.serialVersionUID = -0x3b229e262367a600, h(Nt, dt), e(Nt.prototype, {
				getSortIndex: function() {
					return U.SORTINDEX_MULTIPOLYGON
				},
				equalsExact: function() {
					if (2 === arguments.length) {
						var t = arguments[0],
							e = arguments[1];
						return !!this.isEquivalentClass(t) && dt.prototype.equalsExact.call(this, t, e)
					}
					return dt.prototype.equalsExact.apply(this, arguments)
				},
				getBoundaryDimension: function() {
					return 1
				},
				getDimension: function() {
					return 2
				},
				reverse: function() {
					for (var t = this.geometries.length, e = new Array(t).fill(null), i = 0; i < this.geometries.length; i++) e[i] = this.geometries[i].reverse();
					return this.getFactory().createMultiPolygon(e)
				},
				getBoundary: function() {
					if (this.isEmpty()) return this.getFactory().createMultiLineString();
					for (var t = new E, e = 0; e < this.geometries.length; e++) for (var i = this.geometries[e].getBoundary(), n = 0; n < i.getNumGeometries(); n++) t.add(i.getGeometryN(n));
					var r = new Array(t.size()).fill(null);
					return this.getFactory().createMultiLineString(t.toArray(r))
				},
				getGeometryType: function() {
					return "MultiPolygon"
				},
				copy: function() {
					for (var t = new Array(this.geometries.length).fill(null), e = 0; e < t.length; e++) t[e] = this.geometries[e].copy();
					return new Nt(t, this.factory)
				},
				interfaces_: function() {
					return [Tt]
				},
				getClass: function() {
					return Nt
				}
			}), Nt.serialVersionUID = -0x7a5aa1369171980, e(Pt.prototype, {
				setCopyUserData: function(t) {
					this.isUserDataCopied = t
				},
				edit: function(t, e) {
					if (null === t) return null;
					var i = this.editInternal(t, e);
					return this.isUserDataCopied && i.setUserData(t.getUserData()), i
				},
				editInternal: function(t, e) {
					return null === this.factory && (this.factory = t.getFactory()), t instanceof dt ? this.editGeometryCollection(t, e) : t instanceof Rt ? this.editPolygon(t, e) : t instanceof St ? e.edit(t, this.factory) : t instanceof Ct ? e.edit(t, this.factory) : (d.shouldNeverReachHere("Unsupported Geometry class: " + t.getClass().getName()), null)
				},
				editGeometryCollection: function(t, e) {
					for (var i = e.edit(t, this.factory), n = new E, r = 0; r < i.getNumGeometries(); r++) {
						var o = this.edit(i.getGeometryN(r), e);
						null === o || o.isEmpty() || n.add(o)
					}
					return i.getClass() === wt ? this.factory.createMultiPoint(n.toArray([])) : i.getClass() === ft ? this.factory.createMultiLineString(n.toArray([])) : i.getClass() === Nt ? this.factory.createMultiPolygon(n.toArray([])) : this.factory.createGeometryCollection(n.toArray([]))
				},
				editPolygon: function(t, e) {
					var i = e.edit(t, this.factory);
					if (null === i && (i = this.factory.createPolygon(null)), i.isEmpty()) return i;
					var n = this.edit(i.getExteriorRing(), e);
					if (null === n || n.isEmpty()) return this.factory.createPolygon();
					for (var r = new E, o = 0; o < i.getNumInteriorRing(); o++) {
						var s = this.edit(i.getInteriorRingN(o), e);
						null === s || s.isEmpty() || r.add(s)
					}
					return this.factory.createPolygon(n, r.toArray([]))
				},
				interfaces_: function() {
					return []
				},
				getClass: function() {
					return Pt
				}
			}), Pt.GeometryEditorOperation = Ot, e(Mt.prototype, {
				edit: function(t, e) {
					return t
				},
				interfaces_: function() {
					return [Ot]
				},
				getClass: function() {
					return Mt
				}
			}), e(bt.prototype, {
				edit: function(t, e) {
					if (t instanceof Lt) return e.createLinearRing(this.editCoordinates(t.getCoordinates(), t));
					if (t instanceof Ct) return e.createLineString(this.editCoordinates(t.getCoordinates(), t));
					if (t instanceof St) {
						var i = this.editCoordinates(t.getCoordinates(), t);
						return i.length > 0 ? e.createPoint(i[0]) : e.createPoint()
					}
					return t
				},
				interfaces_: function() {
					return [Ot]
				},
				getClass: function() {
					return bt
				}
			}), e(Ft.prototype, {
				edit: function(t, e) {
					return t instanceof Lt ? e.createLinearRing(this.edit(t.getCoordinateSequence(), t)) : t instanceof Ct ? e.createLineString(this.edit(t.getCoordinateSequence(), t)) : t instanceof St ? e.createPoint(this.edit(t.getCoordinateSequence(), t)) : t
				},
				interfaces_: function() {
					return [Ot]
				},
				getClass: function() {
					return Ft
				}
			}), Pt.NoOpGeometryOperation = Mt, Pt.CoordinateOperation = bt, Pt.CoordinateSequenceOperation = Ft, e(Dt.prototype, {
				setOrdinate: function(t, e, i) {
					switch (e) {
					case b.X:
						this.coordinates[t].x = i;
						break;
					case b.Y:
						this.coordinates[t].y = i;
						break;
					case b.Z:
						this.coordinates[t].z = i;
						break;
					default:
						throw new n("invalid ordinateIndex")
					}
				},
				size: function() {
					return this.coordinates.length
				},
				getOrdinate: function(t, e) {
					switch (e) {
					case b.X:
						return this.coordinates[t].x;
					case b.Y:
						return this.coordinates[t].y;
					case b.Z:
						return this.coordinates[t].z
					}
					return r.NaN
				},
				getCoordinate: function() {
					if (1 === arguments.length) {
						var t = arguments[0];
						return this.coordinates[t]
					}
					if (2 === arguments.length) {
						var e = arguments[0],
							i = arguments[1];
						i.x = this.coordinates[e].x, i.y = this.coordinates[e].y, i.z = this.coordinates[e].z
					}
				},
				getCoordinateCopy: function(t) {
					return new f(this.coordinates[t])
				},
				getDimension: function() {
					return this.dimension
				},
				getX: function(t) {
					return this.coordinates[t].x
				},
				clone: function() {
					for (var t = new Array(this.size()).fill(null), e = 0; e < this.coordinates.length; e++) t[e] = this.coordinates[e].clone();
					return new Dt(t, this.dimension)
				},
				expandEnvelope: function(t) {
					for (var e = 0; e < this.coordinates.length; e++) t.expandToInclude(this.coordinates[e]);
					return t
				},
				copy: function() {
					for (var t = new Array(this.size()).fill(null), e = 0; e < this.coordinates.length; e++) t[e] = this.coordinates[e].copy();
					return new Dt(t, this.dimension)
				},
				toString: function() {
					if (this.coordinates.length > 0) {
						var t = new L(17 * this.coordinates.length);
						t.append("("), t.append(this.coordinates[0]);
						for (var e = 1; e < this.coordinates.length; e++) t.append(", "), t.append(this.coordinates[e]);
						return t.append(")"), t.toString()
					}
					return "()"
				},
				getY: function(t) {
					return this.coordinates[t].y
				},
				toCoordinateArray: function() {
					return this.coordinates
				},
				interfaces_: function() {
					return [b, l]
				},
				getClass: function() {
					return Dt
				}
			}), Dt.serialVersionUID = -0xcb44a778db18e00, e(Gt.prototype, {
				readResolve: function() {
					return Gt.instance()
				},
				create: function() {
					if (1 === arguments.length) {
						if (arguments[0] instanceof Array) {
							var t = arguments[0];
							return new Dt(t)
						}
						if (R(arguments[0], b)) {
							var e = arguments[0];
							return new Dt(e)
						}
					} else if (2 === arguments.length) {
						var i = arguments[0],
							n = arguments[1];
						return n > 3 && (n = 3), 2 > n ? new Dt(i) : new Dt(i, n)
					}
				},
				interfaces_: function() {
					return [G, l]
				},
				getClass: function() {
					return Gt
				}
			}), Gt.instance = function() {
				return Gt.instanceObject
			}, Gt.serialVersionUID = -0x38e49fa6cf6f2e00, Gt.instanceObject = new Gt;
			var Yo, zo = Object.defineProperty,
				Xo = function(t, e) {
					function i(t) {
						return this && this.constructor === i ? (this._keys = [], this._values = [], this._itp = [], this.objectOnly = e, void(t && Ut.call(this, t))) : new i(t)
					}
					return e || zo(t, "size", {
						get: Vt
					}), t.constructor = i, i.prototype = t, i
				}({
					delete: function(t) {
						return this.has(t) && (this._keys.splice(Yo, 1), this._values.splice(Yo, 1), this._itp.forEach((function(t) {
							Yo < t[0] && t[0]--
						}))), Yo > -1
					},
					has: function(t) {
						return Bt.call(this, this._keys, t)
					},
					get: function(t) {
						return this.has(t) ? this._values[Yo] : void 0
					},
					set: function(t, e) {
						return this.has(t) ? this._values[Yo] = e : this._values[this._keys.push(t) - 1] = e, this
					},
					keys: function() {
						return jt(this._itp, this._keys)
					},
					values: function() {
						return jt(this._itp, this._values)
					},
					entries: function() {
						return jt(this._itp, this._keys, this._values)
					},
					forEach: function(t, e) {
						for (var i = this.entries();;) {
							var n = i.next();
							if (n.done) break;
							t.call(e, n.value[1], n.value[0], this)
						}
					},
					clear: function() {
						(this._keys || 0).length = this._values.length = 0
					}
				}),
				Wo = "undefined" != typeof Map && Map.prototype.values ? Map : Xo;
			Yt.prototype = new Z, Yt.prototype.get = function(t) {
				return this.map_.get(t) || null
			}, Yt.prototype.put = function(t, e) {
				return this.map_.set(t, e), e
			}, Yt.prototype.values = function() {
				for (var t = new E, e = this.map_.values(), i = e.next(); !i.done;) t.add(i.value), i = e.next();
				return t
			}, Yt.prototype.entrySet = function() {
				var t = new Q;
				return this.map_.entries().forEach((function(e) {
					return t.add(e)
				})), t
			}, Yt.prototype.size = function() {
				return this.map_.size()
			}, e(zt.prototype, {
				equals: function(t) {
					if (!(t instanceof zt)) return !1;
					var e = t;
					return this.modelType === e.modelType && this.scale === e.scale
				},
				compareTo: function(t) {
					var e = t,
						i = this.getMaximumSignificantDigits(),
						n = e.getMaximumSignificantDigits();
					return new N(i).compareTo(new N(n))
				},
				getScale: function() {
					return this.scale
				},
				isFloating: function() {
					return this.modelType === zt.FLOATING || this.modelType === zt.FLOATING_SINGLE
				},
				getType: function() {
					return this.modelType
				},
				toString: function() {
					var t = "UNKNOWN";
					return this.modelType === zt.FLOATING ? t = "Floating" : this.modelType === zt.FLOATING_SINGLE ? t = "Floating-Single" : this.modelType === zt.FIXED && (t = "Fixed (Scale=" + this.getScale() + ")"), t
				},
				makePrecise: function() {
					if ("number" == typeof arguments[0]) {
						var t = arguments[0];
						return r.isNaN(t) ? t : this.modelType === zt.FLOATING_SINGLE ? t : this.modelType === zt.FIXED ? Math.round(t * this.scale) / this.scale : t
					}
					if (arguments[0] instanceof f) {
						var e = arguments[0];
						if (this.modelType === zt.FLOATING) return null;
						e.x = this.makePrecise(e.x), e.y = this.makePrecise(e.y)
					}
				},
				getMaximumSignificantDigits: function() {
					var t = 16;
					return this.modelType === zt.FLOATING ? t = 16 : this.modelType === zt.FLOATING_SINGLE ? t = 6 : this.modelType === zt.FIXED && (t = 1 + Math.trunc(Math.ceil(Math.log(this.getScale()) / Math.log(10)))), t
				},
				setScale: function(t) {
					this.scale = Math.abs(t)
				},
				interfaces_: function() {
					return [l, o]
				},
				getClass: function() {
					return zt
				}
			}), zt.mostPrecise = function(t, e) {
				return t.compareTo(e) >= 0 ? t : e
			}, e(Xt.prototype, {
				readResolve: function() {
					return Xt.nameToTypeMap.get(this.name)
				},
				toString: function() {
					return this.name
				},
				interfaces_: function() {
					return [l]
				},
				getClass: function() {
					return Xt
				}
			}), Xt.serialVersionUID = -552860263173159e4, Xt.nameToTypeMap = new Yt, zt.Type = Xt, zt.serialVersionUID = 0x6bee6404e9a25c00, zt.FIXED = new Xt("FIXED"), zt.FLOATING = new Xt("FLOATING"), zt.FLOATING_SINGLE = new Xt("FLOATING SINGLE"), zt.maximumPreciseValue = 9007199254740992, e(Wt.prototype, {
				toGeometry: function(t) {
					return t.isNull() ? this.createPoint(null) : t.getMinX() === t.getMaxX() && t.getMinY() === t.getMaxY() ? this.createPoint(new f(t.getMinX(), t.getMinY())) : t.getMinX() === t.getMaxX() || t.getMinY() === t.getMaxY() ? this.createLineString([new f(t.getMinX(), t.getMinY()), new f(t.getMaxX(), t.getMaxY())]) : this.createPolygon(this.createLinearRing([new f(t.getMinX(), t.getMinY()), new f(t.getMinX(), t.getMaxY()), new f(t.getMaxX(), t.getMaxY()), new f(t.getMaxX(), t.getMinY()), new f(t.getMinX(), t.getMinY())]), null)
				},
				createLineString: function() {
					if (0 === arguments.length) return this.createLineString(this.getCoordinateSequenceFactory().create([]));
					if (1 === arguments.length) {
						if (arguments[0] instanceof Array) {
							var t = arguments[0];
							return this.createLineString(null !== t ? this.getCoordinateSequenceFactory().create(t) : null)
						}
						if (R(arguments[0], b)) {
							var e = arguments[0];
							return new Ct(e, this)
						}
					}
				},
				createMultiLineString: function() {
					if (0 === arguments.length) return new ft(null, this);
					if (1 === arguments.length) {
						var t = arguments[0];
						return new ft(t, this)
					}
				},
				buildGeometry: function(t) {
					for (var e = null, i = !1, n = !1, r = t.iterator(); r.hasNext();) {
						var o = r.next(),
							s = o.getClass();
						null === e && (e = s), s !== e && (i = !0), o.isGeometryCollectionOrDerived() && (n = !0)
					}
					if (null === e) return this.createGeometryCollection();
					if (i || n) return this.createGeometryCollection(Wt.toGeometryArray(t));
					var a = t.iterator().next();
					if (t.size() > 1) {
						if (a instanceof Rt) return this.createMultiPolygon(Wt.toPolygonArray(t));
						if (a instanceof Ct) return this.createMultiLineString(Wt.toLineStringArray(t));
						if (a instanceof St) return this.createMultiPoint(Wt.toPointArray(t));
						d.shouldNeverReachHere("Unhandled class: " + a.getClass().getName())
					}
					return a
				},
				createMultiPointFromCoords: function(t) {
					return this.createMultiPoint(null !== t ? this.getCoordinateSequenceFactory().create(t) : null)
				},
				createPoint: function() {
					if (0 === arguments.length) return this.createPoint(this.getCoordinateSequenceFactory().create([]));
					if (1 === arguments.length) {
						if (arguments[0] instanceof f) {
							var t = arguments[0];
							return this.createPoint(null !== t ? this.getCoordinateSequenceFactory().create([t]) : null)
						}
						if (R(arguments[0], b)) {
							var e = arguments[0];
							return new St(e, this)
						}
					}
				},
				getCoordinateSequenceFactory: function() {
					return this.coordinateSequenceFactory
				},
				createPolygon: function() {
					if (0 === arguments.length) return new Rt(null, null, this);
					if (1 === arguments.length) {
						if (R(arguments[0], b)) {
							var t = arguments[0];
							return this.createPolygon(this.createLinearRing(t))
						}
						if (arguments[0] instanceof Array) {
							var e = arguments[0];
							return this.createPolygon(this.createLinearRing(e))
						}
						if (arguments[0] instanceof Lt) {
							var i = arguments[0];
							return this.createPolygon(i, null)
						}
					} else if (2 === arguments.length) {
						var n = arguments[0],
							r = arguments[1];
						return new Rt(n, r, this)
					}
				},
				getSRID: function() {
					return this.SRID
				},
				createGeometryCollection: function() {
					if (0 === arguments.length) return new dt(null, this);
					if (1 === arguments.length) {
						var t = arguments[0];
						return new dt(t, this)
					}
				},
				createGeometry: function(t) {
					return new Pt(this).edit(t, {
						edit: function() {
							if (2 === arguments.length) {
								var t = arguments[0];
								return arguments[1], this.coordinateSequenceFactory.create(t)
							}
						}
					})
				},
				getPrecisionModel: function() {
					return this.precisionModel
				},
				createLinearRing: function() {
					if (0 === arguments.length) return this.createLinearRing(this.getCoordinateSequenceFactory().create([]));
					if (1 === arguments.length) {
						if (arguments[0] instanceof Array) {
							var t = arguments[0];
							return this.createLinearRing(null !== t ? this.getCoordinateSequenceFactory().create(t) : null)
						}
						if (R(arguments[0], b)) {
							var e = arguments[0];
							return new Lt(e, this)
						}
					}
				},
				createMultiPolygon: function() {
					if (0 === arguments.length) return new Nt(null, this);
					if (1 === arguments.length) {
						var t = arguments[0];
						return new Nt(t, this)
					}
				},
				createMultiPoint: function() {
					if (0 === arguments.length) return new wt(null, this);
					if (1 === arguments.length) {
						if (arguments[0] instanceof Array) {
							var t = arguments[0];
							return new wt(t, this)
						}
						if (arguments[0] instanceof Array) {
							var e = arguments[0];
							return this.createMultiPoint(null !== e ? this.getCoordinateSequenceFactory().create(e) : null)
						}
						if (R(arguments[0], b)) {
							var i = arguments[0];
							if (null === i) return this.createMultiPoint(new Array(0).fill(null));
							for (var n = new Array(i.size()).fill(null), r = 0; r < i.size(); r++) {
								var o = this.getCoordinateSequenceFactory().create(1, i.getDimension());
								xt.copy(i, r, o, 0, 1), n[r] = this.createPoint(o)
							}
							return this.createMultiPoint(n)
						}
					}
				},
				interfaces_: function() {
					return [l]
				},
				getClass: function() {
					return Wt
				}
			}), Wt.toMultiPolygonArray = function(t) {
				var e = new Array(t.size()).fill(null);
				return t.toArray(e)
			}, Wt.toGeometryArray = function(t) {
				if (null === t) return null;
				var e = new Array(t.size()).fill(null);
				return t.toArray(e)
			}, Wt.getDefaultCoordinateSequenceFactory = function() {
				return Gt.instance()
			}, Wt.toMultiLineStringArray = function(t) {
				var e = new Array(t.size()).fill(null);
				return t.toArray(e)
			}, Wt.toLineStringArray = function(t) {
				var e = new Array(t.size()).fill(null);
				return t.toArray(e)
			}, Wt.toMultiPointArray = function(t) {
				var e = new Array(t.size()).fill(null);
				return t.toArray(e)
			}, Wt.toLinearRingArray = function(t) {
				var e = new Array(t.size()).fill(null);
				return t.toArray(e)
			}, Wt.toPointArray = function(t) {
				var e = new Array(t.size()).fill(null);
				return t.toArray(e)
			}, Wt.toPolygonArray = function(t) {
				var e = new Array(t.size()).fill(null);
				return t.toArray(e)
			}, Wt.createPointFromInternalCoord = function(t, e) {
				return e.getPrecisionModel().makePrecise(t), e.getFactory().createPoint(t)
			}, Wt.serialVersionUID = -0x5ea75f2051eeb400;
			var qo = {
				typeStr: /^\s*(\w+)\s*\(\s*(.*)\s*\)\s*$/,
				emptyTypeStr: /^\s*(\w+)\s*EMPTY\s*$/,
				spaces: /\s+/,
				parenComma: /\)\s*,\s*\(/,
				doubleParenComma: /\)\s*\)\s*,\s*\(\s*\(/,
				trimParens: /^\s*\(?(.*?)\)?\s*$/
			};
			e(qt.prototype, {
				read: function(t) {
					var e, i, n;
					t = t.replace(/[\n\r]/g, " ");
					var r = qo.typeStr.exec(t);
					if (-1 !== t.search("EMPTY") && ((r = qo.emptyTypeStr.exec(t))[2] = void 0), r && (i = r[1].toLowerCase(), n = r[2], Zo[i] && (e = Zo[i].apply(this, [n]))), void 0 === e) throw new Error("Could not parse WKT " + t);
					return e
				},
				write: function(t) {
					return this.extractGeometry(t)
				},
				extractGeometry: function(t) {
					var e = t.getGeometryType().toLowerCase();
					if (!Ho[e]) return null;
					var i = e.toUpperCase();
					return t.isEmpty() ? i + " EMPTY" : i + "(" + Ho[e].apply(this, [t]) + ")"
				}
			});
			var Ho = {
				coordinate: function(t) {
					return t.x + " " + t.y
				},
				point: function(t) {
					return Ho.coordinate.call(this, t.coordinates.coordinates[0])
				},
				multipoint: function(t) {
					for (var e = [], i = 0, n = t.geometries.length; n > i; ++i) e.push("(" + Ho.point.apply(this, [t.geometries[i]]) + ")");
					return e.join(",")
				},
				linestring: function(t) {
					for (var e = [], i = 0, n = t.points.coordinates.length; n > i; ++i) e.push(Ho.coordinate.apply(this, [t.points.coordinates[i]]));
					return e.join(",")
				},
				linearring: function(t) {
					for (var e = [], i = 0, n = t.points.coordinates.length; n > i; ++i) e.push(Ho.coordinate.apply(this, [t.points.coordinates[i]]));
					return e.join(",")
				},
				multilinestring: function(t) {
					for (var e = [], i = 0, n = t.geometries.length; n > i; ++i) e.push("(" + Ho.linestring.apply(this, [t.geometries[i]]) + ")");
					return e.join(",")
				},
				polygon: function(t) {
					var e = [];
					e.push("(" + Ho.linestring.apply(this, [t.shell]) + ")");
					for (var i = 0, n = t.holes.length; n > i; ++i) e.push("(" + Ho.linestring.apply(this, [t.holes[i]]) + ")");
					return e.join(",")
				},
				multipolygon: function(t) {
					for (var e = [], i = 0, n = t.geometries.length; n > i; ++i) e.push("(" + Ho.polygon.apply(this, [t.geometries[i]]) + ")");
					return e.join(",")
				},
				geometrycollection: function(t) {
					for (var e = [], i = 0, n = t.geometries.length; n > i; ++i) e.push(this.extractGeometry(t.geometries[i]));
					return e.join(",")
				}
			},
				Zo = {
					point: function(t) {
						if (void 0 === t) return this.geometryFactory.createPoint();
						var e = t.trim().split(qo.spaces);
						return this.geometryFactory.createPoint(new f(Number.parseFloat(e[0]), Number.parseFloat(e[1])))
					},
					multipoint: function(t) {
						if (void 0 === t) return this.geometryFactory.createMultiPoint();
						for (var e, i = t.trim().split(","), n = [], r = 0, o = i.length; o > r; ++r) e = i[r].replace(qo.trimParens, "$1"), n.push(Zo.point.apply(this, [e]));
						return this.geometryFactory.createMultiPoint(n)
					},
					linestring: function(t) {
						if (void 0 === t) return this.geometryFactory.createLineString();
						for (var e, i = t.trim().split(","), n = [], r = 0, o = i.length; o > r; ++r) e = i[r].trim().split(qo.spaces), n.push(new f(Number.parseFloat(e[0]), Number.parseFloat(e[1])));
						return this.geometryFactory.createLineString(n)
					},
					linearring: function(t) {
						if (void 0 === t) return this.geometryFactory.createLinearRing();
						for (var e, i = t.trim().split(","), n = [], r = 0, o = i.length; o > r; ++r) e = i[r].trim().split(qo.spaces), n.push(new f(Number.parseFloat(e[0]), Number.parseFloat(e[1])));
						return this.geometryFactory.createLinearRing(n)
					},
					multilinestring: function(t) {
						if (void 0 === t) return this.geometryFactory.createMultiLineString();
						for (var e, i = t.trim().split(qo.parenComma), n = [], r = 0, o = i.length; o > r; ++r) e = i[r].replace(qo.trimParens, "$1"), n.push(Zo.linestring.apply(this, [e]));
						return this.geometryFactory.createMultiLineString(n)
					},
					polygon: function(t) {
						if (void 0 === t) return this.geometryFactory.createPolygon();
						for (var e, i, n, r, o = t.trim().split(qo.parenComma), s = [], a = 0, l = o.length; l > a; ++a) e = o[a].replace(qo.trimParens, "$1"), i = Zo.linestring.apply(this, [e]), n = this.geometryFactory.createLinearRing(i.points), 0 === a ? r = n : s.push(n);
						return this.geometryFactory.createPolygon(r, s)
					},
					multipolygon: function(t) {
						if (void 0 === t) return this.geometryFactory.createMultiPolygon();
						for (var e, i = t.trim().split(qo.doubleParenComma), n = [], r = 0, o = i.length; o > r; ++r) e = i[r].replace(qo.trimParens, "$1"), n.push(Zo.polygon.apply(this, [e]));
						return this.geometryFactory.createMultiPolygon(n)
					},
					geometrycollection: function(t) {
						if (void 0 === t) return this.geometryFactory.createGeometryCollection();
						for (var e = (t = t.replace(/,\s*([A-Za-z])/g, "|$1")).trim().split("|"), i = [], n = 0, r = e.length; r > n; ++n) i.push(this.read(e[n]));
						return this.geometryFactory.createGeometryCollection(i)
					}
				};
			e(Ht.prototype, {
				write: function(t) {
					return this.parser.write(t)
				}
			}), e(Ht, {
				toLineString: function(t, e) {
					if (2 !== arguments.length) throw new Error("Not implemented");
					return "LINESTRING ( " + t.x + " " + t.y + ", " + e.x + " " + e.y + " )"
				}
			}), e(Zt.prototype, {
				getIndexAlongSegment: function(t, e) {
					return this.computeIntLineIndex(), this.intLineIndex[t][e]
				},
				getTopologySummary: function() {
					var t = new L;
					return this.isEndPoint() && t.append(" endpoint"), this._isProper && t.append(" proper"), this.isCollinear() && t.append(" collinear"), t.toString()
				},
				computeIntersection: function(t, e, i, n) {
					this.inputLines[0][0] = t, this.inputLines[0][1] = e, this.inputLines[1][0] = i, this.inputLines[1][1] = n, this.result = this.computeIntersect(t, e, i, n)
				},
				getIntersectionNum: function() {
					return this.result
				},
				computeIntLineIndex: function() {
					if (0 === arguments.length) null === this.intLineIndex && (this.intLineIndex = Array(2).fill().map((function() {
						return Array(2)
					})), this.computeIntLineIndex(0), this.computeIntLineIndex(1));
					else if (1 === arguments.length) {
						var t = arguments[0],
							e = this.getEdgeDistance(t, 0),
							i = this.getEdgeDistance(t, 1);
						e > i ? (this.intLineIndex[t][0] = 0, this.intLineIndex[t][1] = 1) : (this.intLineIndex[t][0] = 1, this.intLineIndex[t][1] = 0)
					}
				},
				isProper: function() {
					return this.hasIntersection() && this._isProper
				},
				setPrecisionModel: function(t) {
					this.precisionModel = t
				},
				isInteriorIntersection: function() {
					if (0 === arguments.length) return !!this.isInteriorIntersection(0) || !! this.isInteriorIntersection(1);
					if (1 === arguments.length) {
						for (var t = arguments[0], e = 0; e < this.result; e++) if (!this.intPt[e].equals2D(this.inputLines[t][0]) && !this.intPt[e].equals2D(this.inputLines[t][1])) return !0;
						return !1
					}
				},
				getIntersection: function(t) {
					return this.intPt[t]
				},
				isEndPoint: function() {
					return this.hasIntersection() && !this._isProper
				},
				hasIntersection: function() {
					return this.result !== Zt.NO_INTERSECTION
				},
				getEdgeDistance: function(t, e) {
					return Zt.computeEdgeDistance(this.intPt[e], this.inputLines[t][0], this.inputLines[t][1])
				},
				isCollinear: function() {
					return this.result === Zt.COLLINEAR_INTERSECTION
				},
				toString: function() {
					return Ht.toLineString(this.inputLines[0][0], this.inputLines[0][1]) + " - " + Ht.toLineString(this.inputLines[1][0], this.inputLines[1][1]) + this.getTopologySummary()
				},
				getEndpoint: function(t, e) {
					return this.inputLines[t][e]
				},
				isIntersection: function(t) {
					for (var e = 0; e < this.result; e++) if (this.intPt[e].equals2D(t)) return !0;
					return !1
				},
				getIntersectionAlongSegment: function(t, e) {
					return this.computeIntLineIndex(), this.intPt[this.intLineIndex[t][e]]
				},
				interfaces_: function() {
					return []
				},
				getClass: function() {
					return Zt
				}
			}), Zt.computeEdgeDistance = function(t, e, i) {
				var n = Math.abs(i.x - e.x),
					r = Math.abs(i.y - e.y),
					o = -1;
				if (t.equals(e)) o = 0;
				else if (t.equals(i)) o = n > r ? n : r;
				else {
					var s = Math.abs(t.x - e.x),
						a = Math.abs(t.y - e.y);
					0 !== (o = n > r ? s : a) || t.equals(e) || (o = Math.max(s, a))
				}
				return d.isTrue(!(0 === o && !t.equals(e)), "Bad distance calculation"), o
			}, Zt.nonRobustComputeEdgeDistance = function(t, e, i) {
				var n = t.x - e.x,
					r = t.y - e.y,
					o = Math.sqrt(n * n + r * r);
				return d.isTrue(!(0 === o && !t.equals(e)), "Invalid distance calculation"), o
			}, Zt.DONT_INTERSECT = 0, Zt.DO_INTERSECT = 1, Zt.COLLINEAR = 2, Zt.NO_INTERSECTION = 0, Zt.POINT_INTERSECTION = 1, Zt.COLLINEAR_INTERSECTION = 2, h(Kt, Zt), e(Kt.prototype, {
				isInSegmentEnvelopes: function(t) {
					var e = new C(this.inputLines[0][0], this.inputLines[0][1]),
						i = new C(this.inputLines[1][0], this.inputLines[1][1]);
					return e.contains(t) && i.contains(t)
				},
				computeIntersection: function() {
					if (3 !== arguments.length) return Zt.prototype.computeIntersection.apply(this, arguments);
					var t = arguments[0],
						e = arguments[1],
						i = arguments[2];
					return this._isProper = !1, C.intersects(e, i, t) && 0 === $t.orientationIndex(e, i, t) && 0 === $t.orientationIndex(i, e, t) ? (this._isProper = !0, (t.equals(e) || t.equals(i)) && (this._isProper = !1), this.result = Zt.POINT_INTERSECTION, null) : void(this.result = Zt.NO_INTERSECTION)
				},
				normalizeToMinimum: function(t, e, i, n, r) {
					r.x = this.smallestInAbsValue(t.x, e.x, i.x, n.x), r.y = this.smallestInAbsValue(t.y, e.y, i.y, n.y), t.x -= r.x, t.y -= r.y, e.x -= r.x, e.y -= r.y, i.x -= r.x, i.y -= r.y, n.x -= r.x, n.y -= r.y
				},
				safeHCoordinateIntersection: function(t, e, i, n) {
					var r = null;
					try {
						r = D.intersection(t, e, i, n)
					} catch (o) {
						if (!(o instanceof S)) throw o;
						r = Kt.nearestEndpoint(t, e, i, n)
					}
					return r
				},
				intersection: function(t, e, i, n) {
					var r = this.intersectionWithNormalization(t, e, i, n);
					return this.isInSegmentEnvelopes(r) || (r = new f(Kt.nearestEndpoint(t, e, i, n))), null !== this.precisionModel && this.precisionModel.makePrecise(r), r
				},
				smallestInAbsValue: function(t, e, i, n) {
					var r = t,
						o = Math.abs(r);
					return Math.abs(e) < o && (r = e, o = Math.abs(e)), Math.abs(i) < o && (r = i, o = Math.abs(i)), Math.abs(n) < o && (r = n), r
				},
				checkDD: function(t, e, i, n, r) {
					var o = M.intersection(t, e, i, n),
						s = this.isInSegmentEnvelopes(o);
					F.out.println("DD in env = " + s + "  --------------------- " + o), r.distance(o) > 1e-4 && F.out.println("Distance = " + r.distance(o))
				},
				intersectionWithNormalization: function(t, e, i, n) {
					var r = new f(t),
						o = new f(e),
						s = new f(i),
						a = new f(n),
						l = new f;
					this.normalizeToEnvCentre(r, o, s, a, l);
					var u = this.safeHCoordinateIntersection(r, o, s, a);
					return u.x += l.x, u.y += l.y, u
				},
				computeCollinearIntersection: function(t, e, i, n) {
					var r = C.intersects(t, e, i),
						o = C.intersects(t, e, n),
						s = C.intersects(i, n, t),
						a = C.intersects(i, n, e);
					return r && o ? (this.intPt[0] = i, this.intPt[1] = n, Zt.COLLINEAR_INTERSECTION) : s && a ? (this.intPt[0] = t, this.intPt[1] = e, Zt.COLLINEAR_INTERSECTION) : r && s ? (this.intPt[0] = i, this.intPt[1] = t, !i.equals(t) || o || a ? Zt.COLLINEAR_INTERSECTION : Zt.POINT_INTERSECTION) : r && a ? (this.intPt[0] = i, this.intPt[1] = e, !i.equals(e) || o || s ? Zt.COLLINEAR_INTERSECTION : Zt.POINT_INTERSECTION) : o && s ? (this.intPt[0] = n, this.intPt[1] = t, !n.equals(t) || r || a ? Zt.COLLINEAR_INTERSECTION : Zt.POINT_INTERSECTION) : o && a ? (this.intPt[0] = n, this.intPt[1] = e, !n.equals(e) || r || s ? Zt.COLLINEAR_INTERSECTION : Zt.POINT_INTERSECTION) : Zt.NO_INTERSECTION
				},
				normalizeToEnvCentre: function(t, e, i, n, r) {
					var o = t.x < e.x ? t.x : e.x,
						s = t.y < e.y ? t.y : e.y,
						a = t.x > e.x ? t.x : e.x,
						l = t.y > e.y ? t.y : e.y,
						u = i.x < n.x ? i.x : n.x,
						h = i.y < n.y ? i.y : n.y,
						c = i.x > n.x ? i.x : n.x,
						d = i.y > n.y ? i.y : n.y,
						f = ((o > u ? o : u) + (c > a ? a : c)) / 2,
						A = ((s > h ? s : h) + (d > l ? l : d)) / 2;
					r.x = f, r.y = A, t.x -= r.x, t.y -= r.y, e.x -= r.x, e.y -= r.y, i.x -= r.x, i.y -= r.y, n.x -= r.x, n.y -= r.y
				},
				computeIntersect: function(t, e, i, n) {
					if (this._isProper = !1, !C.intersects(t, e, i, n)) return Zt.NO_INTERSECTION;
					var r = $t.orientationIndex(t, e, i),
						o = $t.orientationIndex(t, e, n);
					if (r > 0 && o > 0 || 0 > r && 0 > o) return Zt.NO_INTERSECTION;
					var s = $t.orientationIndex(i, n, t),
						a = $t.orientationIndex(i, n, e);
					return s > 0 && a > 0 || 0 > s && 0 > a ? Zt.NO_INTERSECTION : 0 === r && 0 === o && 0 === s && 0 === a ? this.computeCollinearIntersection(t, e, i, n) : (0 === r || 0 === o || 0 === s || 0 === a ? (this._isProper = !1, t.equals2D(i) || t.equals2D(n) ? this.intPt[0] = t : e.equals2D(i) || e.equals2D(n) ? this.intPt[0] = e : 0 === r ? this.intPt[0] = new f(i) : 0 === o ? this.intPt[0] = new f(n) : 0 === s ? this.intPt[0] = new f(t) : 0 === a && (this.intPt[0] = new f(e))) : (this._isProper = !0, this.intPt[0] = this.intersection(t, e, i, n)), Zt.POINT_INTERSECTION)
				},
				interfaces_: function() {
					return []
				},
				getClass: function() {
					return Kt
				}
			}), Kt.nearestEndpoint = function(t, e, i, n) {
				var r = t,
					o = $t.distancePointLine(t, i, n),
					s = $t.distancePointLine(e, i, n);
				return o > s && (o = s, r = e), o > (s = $t.distancePointLine(i, t, e)) && (o = s, r = i), o > (s = $t.distancePointLine(n, t, e)) && (o = s, r = n), r
			}, e(Jt.prototype, {
				interfaces_: function() {
					return []
				},
				getClass: function() {
					return Jt
				}
			}), Jt.orientationIndex = function(t, e, i) {
				var n = e.x - t.x,
					r = e.y - t.y,
					o = i.x - e.x,
					s = i.y - e.y;
				return Jt.signOfDet2x2(n, r, o, s)
			}, Jt.signOfDet2x2 = function(t, e, i, n) {
				var r = null,
					o = null,
					s = null;
				if (r = 1, 0 === t || 0 === n) return 0 === e || 0 === i ? 0 : e > 0 ? i > 0 ? -r : r : i > 0 ? r : -r;
				if (0 === e || 0 === i) return n > 0 ? t > 0 ? r : -r : t > 0 ? -r : r;
				if (e > 0 ? n > 0 ? n >= e || (r = -r, o = t, t = i, i = o, o = e, e = n, n = o) : -n >= e ? (r = -r, i = -i, n = -n) : (o = t, t = -i, i = o, o = e, e = -n, n = o) : n > 0 ? n >= -e ? (r = -r, t = -t, e = -e) : (o = -t, t = i, i = o, o = -e, e = n, n = o) : e >= n ? (t = -t, e = -e, i = -i, n = -n) : (r = -r, o = -t, t = -i, i = o, o = -e, e = -n, n = o), t > 0) {
					if (!(i > 0)) return r;
					if (!(i >= t)) return r
				} else {
					if (i > 0) return -r;
					if (!(t >= i)) return -r;
					r = -r, t = -t, i = -i
				}
				for (;;) {
					if (0 > (n -= (s = Math.floor(i / t)) * e)) return -r;
					if (n > e) return r;
					if (t > (i -= s * t) + i) {
						if (n + n > e) return r
					} else {
						if (e > n + n) return -r;
						i = t - i, n = e - n, r = -r
					}
					if (0 === n) return 0 === i ? 0 : -r;
					if (0 === i) return r;
					if (0 > (e -= (s = Math.floor(t / i)) * n)) return r;
					if (e > n) return -r;
					if (i > (t -= s * i) + t) {
						if (e + e > n) return -r
					} else {
						if (n > e + e) return r;
						t = i - t, e = n - e, r = -r
					}
					if (0 === e) return 0 === t ? 0 : r;
					if (0 === t) return -r
				}
			}, e(Qt.prototype, {
				countSegment: function(t, e) {
					if (t.x < this.p.x && e.x < this.p.x) return null;
					if (this.p.x === e.x && this.p.y === e.y) return this.isPointOnSegment = !0, null;
					if (t.y === this.p.y && e.y === this.p.y) {
						var i = t.x,
							n = e.x;
						return i > n && (i = e.x, n = t.x), this.p.x >= i && this.p.x <= n && (this.isPointOnSegment = !0), null
					}
					if (t.y > this.p.y && e.y <= this.p.y || e.y > this.p.y && t.y <= this.p.y) {
						var r = t.x - this.p.x,
							o = t.y - this.p.y,
							s = e.x - this.p.x,
							a = e.y - this.p.y,
							l = Jt.signOfDet2x2(r, o, s, a);
						if (0 === l) return this.isPointOnSegment = !0, null;
						o > a && (l = -l), l > 0 && this.crossingCount++
					}
				},
				isPointInPolygon: function() {
					return this.getLocation() !== T.EXTERIOR
				},
				getLocation: function() {
					return this.isPointOnSegment ? T.BOUNDARY : this.crossingCount % 2 == 1 ? T.INTERIOR : T.EXTERIOR
				},
				isOnSegment: function() {
					return this.isPointOnSegment
				},
				interfaces_: function() {
					return []
				},
				getClass: function() {
					return Qt
				}
			}), Qt.locatePointInRing = function() {
				if (arguments[0] instanceof f && R(arguments[1], b)) {
					for (var t = arguments[0], e = arguments[1], i = new Qt(t), n = new f, r = new f, o = 1; o < e.size(); o++) if (e.getCoordinate(o, n), e.getCoordinate(o - 1, r), i.countSegment(n, r), i.isOnSegment()) return i.getLocation();
					return i.getLocation()
				}
				if (arguments[0] instanceof f && arguments[1] instanceof Array) {
					var s = arguments[0],
						a = arguments[1];
					for (i = new Qt(s), o = 1; o < a.length; o++) if (n = a[o], r = a[o - 1], i.countSegment(n, r), i.isOnSegment()) return i.getLocation();
					return i.getLocation()
				}
			}, e($t.prototype, {
				interfaces_: function() {
					return []
				},
				getClass: function() {
					return $t
				}
			}), $t.orientationIndex = function(t, e, i) {
				return M.orientationIndex(t, e, i)
			}, $t.signedArea = function() {
				if (arguments[0] instanceof Array) {
					var t = arguments[0];
					if (t.length < 3) return 0;
					for (var e = 0, i = t[0].x, n = 1; n < t.length - 1; n++) {
						var r = t[n].x - i,
							o = t[n + 1].y,
							s = t[n - 1].y;
						e += r * (s - o)
					}
					return e / 2
				}
				if (R(arguments[0], b)) {
					var a = arguments[0],
						l = a.size();
					if (3 > l) return 0;
					var u = new f,
						h = new f,
						c = new f;
					for (a.getCoordinate(0, h), a.getCoordinate(1, c), i = h.x, c.x -= i, e = 0, n = 1; l - 1 > n; n++) u.y = h.y, h.x = c.x, h.y = c.y, a.getCoordinate(n + 1, c), c.x -= i, e += h.x * (u.y - c.y);
					return e / 2
				}
			}, $t.distanceLineLine = function(t, e, i, n) {
				if (t.equals(e)) return $t.distancePointLine(t, i, n);
				if (i.equals(n)) return $t.distancePointLine(n, t, e);
				var r = !1;
				if (C.intersects(t, e, i, n)) {
					var o = (e.x - t.x) * (n.y - i.y) - (e.y - t.y) * (n.x - i.x);
					if (0 === o) r = !0;
					else {
						var s = (t.y - i.y) * (n.x - i.x) - (t.x - i.x) * (n.y - i.y),
							a = ((t.y - i.y) * (e.x - t.x) - (t.x - i.x) * (e.y - t.y)) / o,
							l = s / o;
						(0 > l || l > 1 || 0 > a || a > 1) && (r = !0)
					}
				} else r = !0;
				return r ? w.min($t.distancePointLine(t, i, n), $t.distancePointLine(e, i, n), $t.distancePointLine(i, t, e), $t.distancePointLine(n, t, e)) : 0
			}, $t.isPointInRing = function(t, e) {
				return $t.locatePointInRing(t, e) !== T.EXTERIOR
			}, $t.computeLength = function(t) {
				var e = t.size();
				if (1 >= e) return 0;
				var i = 0,
					n = new f;
				t.getCoordinate(0, n);
				for (var r = n.x, o = n.y, s = 1; e > s; s++) {
					t.getCoordinate(s, n);
					var a = n.x,
						l = n.y,
						u = a - r,
						h = l - o;
					i += Math.sqrt(u * u + h * h), r = a, o = l
				}
				return i
			}, $t.isCCW = function(t) {
				var e = t.length - 1;
				if (3 > e) throw new n("Ring has fewer than 4 points, so orientation cannot be determined");
				for (var i = t[0], r = 0, o = 1; e >= o; o++) {
					var s = t[o];
					s.y > i.y && (i = s, r = o)
				}
				var a = r;
				do {
					0 > (a -= 1) && (a = e)
				} while (t[a].equals2D(i) && a !== r);
				var l = r;
				do {
					l = (l + 1) % e
				} while (t[l].equals2D(i) && l !== r);
				var u = t[a],
					h = t[l];
				if (u.equals2D(i) || h.equals2D(i) || u.equals2D(h)) return !1;
				var c = $t.computeOrientation(u, i, h);
				return 0 === c ? u.x > h.x : c > 0
			}, $t.locatePointInRing = function(t, e) {
				return Qt.locatePointInRing(t, e)
			}, $t.distancePointLinePerpendicular = function(t, e, i) {
				var n = (i.x - e.x) * (i.x - e.x) + (i.y - e.y) * (i.y - e.y),
					r = ((e.y - t.y) * (i.x - e.x) - (e.x - t.x) * (i.y - e.y)) / n;
				return Math.abs(r) * Math.sqrt(n)
			}, $t.computeOrientation = function(t, e, i) {
				return $t.orientationIndex(t, e, i)
			}, $t.distancePointLine = function() {
				if (2 === arguments.length) {
					var t = arguments[0],
						e = arguments[1];
					if (0 === e.length) throw new n("Line array must contain at least one vertex");
					for (var i = t.distance(e[0]), r = 0; r < e.length - 1; r++) {
						var o = $t.distancePointLine(t, e[r], e[r + 1]);
						i > o && (i = o)
					}
					return i
				}
				if (3 === arguments.length) {
					var s = arguments[0],
						a = arguments[1],
						l = arguments[2];
					if (a.x === l.x && a.y === l.y) return s.distance(a);
					var u = (l.x - a.x) * (l.x - a.x) + (l.y - a.y) * (l.y - a.y),
						h = ((s.x - a.x) * (l.x - a.x) + (s.y - a.y) * (l.y - a.y)) / u;
					if (0 >= h) return s.distance(a);
					if (h >= 1) return s.distance(l);
					var c = ((a.y - s.y) * (l.x - a.x) - (a.x - s.x) * (l.y - a.y)) / u;
					return Math.abs(c) * Math.sqrt(u)
				}
			}, $t.isOnLine = function(t, e) {
				for (var i = new Kt, n = 1; n < e.length; n++) {
					var r = e[n - 1],
						o = e[n];
					if (i.computeIntersection(t, r, o), i.hasIntersection()) return !0
				}
				return !1
			}, $t.CLOCKWISE = -1, $t.RIGHT = $t.CLOCKWISE, $t.COUNTERCLOCKWISE = 1, $t.LEFT = $t.COUNTERCLOCKWISE, $t.COLLINEAR = 0, $t.STRAIGHT = $t.COLLINEAR, e(te.prototype, {
				minX: function() {
					return Math.min(this.p0.x, this.p1.x)
				},
				orientationIndex: function() {
					if (arguments[0] instanceof te) {
						var t = arguments[0],
							e = $t.orientationIndex(this.p0, this.p1, t.p0),
							i = $t.orientationIndex(this.p0, this.p1, t.p1);
						return e >= 0 && i >= 0 ? Math.max(e, i) : 0 >= e && 0 >= i ? Math.max(e, i) : 0
					}
					if (arguments[0] instanceof f) {
						var n = arguments[0];
						return $t.orientationIndex(this.p0, this.p1, n)
					}
				},
				toGeometry: function(t) {
					return t.createLineString([this.p0, this.p1])
				},
				isVertical: function() {
					return this.p0.x === this.p1.x
				},
				equals: function(t) {
					if (!(t instanceof te)) return !1;
					var e = t;
					return this.p0.equals(e.p0) && this.p1.equals(e.p1)
				},
				intersection: function(t) {
					var e = new Kt;
					return e.computeIntersection(this.p0, this.p1, t.p0, t.p1), e.hasIntersection() ? e.getIntersection(0) : null
				},
				project: function() {
					if (arguments[0] instanceof f) {
						var t = arguments[0];
						if (t.equals(this.p0) || t.equals(this.p1)) return new f(t);
						var e = this.projectionFactor(t),
							i = new f;
						return i.x = this.p0.x + e * (this.p1.x - this.p0.x), i.y = this.p0.y + e * (this.p1.y - this.p0.y), i
					}
					if (arguments[0] instanceof te) {
						var n = arguments[0],
							r = this.projectionFactor(n.p0),
							o = this.projectionFactor(n.p1);
						if (r >= 1 && o >= 1) return null;
						if (0 >= r && 0 >= o) return null;
						var s = this.project(n.p0);
						0 > r && (s = this.p0), r > 1 && (s = this.p1);
						var a = this.project(n.p1);
						return 0 > o && (a = this.p0), o > 1 && (a = this.p1), new te(s, a)
					}
				},
				normalize: function() {
					this.p1.compareTo(this.p0) < 0 && this.reverse()
				},
				angle: function() {
					return Math.atan2(this.p1.y - this.p0.y, this.p1.x - this.p0.x)
				},
				getCoordinate: function(t) {
					return 0 === t ? this.p0 : this.p1
				},
				distancePerpendicular: function(t) {
					return $t.distancePointLinePerpendicular(t, this.p0, this.p1)
				},
				minY: function() {
					return Math.min(this.p0.y, this.p1.y)
				},
				midPoint: function() {
					return te.midPoint(this.p0, this.p1)
				},
				projectionFactor: function(t) {
					if (t.equals(this.p0)) return 0;
					if (t.equals(this.p1)) return 1;
					var e = this.p1.x - this.p0.x,
						i = this.p1.y - this.p0.y,
						n = e * e + i * i;
					return 0 >= n ? r.NaN : ((t.x - this.p0.x) * e + (t.y - this.p0.y) * i) / n
				},
				closestPoints: function(t) {
					var e = this.intersection(t);
					if (null !== e) return [e, e];
					var i = new Array(2).fill(null),
						n = r.MAX_VALUE,
						o = null,
						s = this.closestPoint(t.p0);
					n = s.distance(t.p0), i[0] = s, i[1] = t.p0;
					var a = this.closestPoint(t.p1);
					n > (o = a.distance(t.p1)) && (n = o, i[0] = a, i[1] = t.p1);
					var l = t.closestPoint(this.p0);
					n > (o = l.distance(this.p0)) && (n = o, i[0] = this.p0, i[1] = l);
					var u = t.closestPoint(this.p1);
					return n > (o = u.distance(this.p1)) && (n = o, i[0] = this.p1, i[1] = u), i
				},
				closestPoint: function(t) {
					var e = this.projectionFactor(t);
					if (e > 0 && 1 > e) return this.project(t);
					var i = this.p0.distance(t);
					return this.p1.distance(t) > i ? this.p0 : this.p1
				},
				maxX: function() {
					return Math.max(this.p0.x, this.p1.x)
				},
				getLength: function() {
					return this.p0.distance(this.p1)
				},
				compareTo: function(t) {
					var e = t,
						i = this.p0.compareTo(e.p0);
					return 0 !== i ? i : this.p1.compareTo(e.p1)
				},
				reverse: function() {
					var t = this.p0;
					this.p0 = this.p1, this.p1 = t
				},
				equalsTopo: function(t) {
					return this.p0.equals(t.p0) && this.p1.equals(t.p1) || this.p0.equals(t.p1) && this.p1.equals(t.p0)
				},
				lineIntersection: function(t) {
					try {
						return D.intersection(this.p0, this.p1, t.p0, t.p1)
					} catch (t) {
						if (!(t instanceof S)) throw t
					}
					return null
				},
				maxY: function() {
					return Math.max(this.p0.y, this.p1.y)
				},
				pointAlongOffset: function(t, e) {
					var i = this.p0.x + t * (this.p1.x - this.p0.x),
						n = this.p0.y + t * (this.p1.y - this.p0.y),
						r = this.p1.x - this.p0.x,
						o = this.p1.y - this.p0.y,
						s = Math.sqrt(r * r + o * o),
						a = 0,
						l = 0;
					if (0 !== e) {
						if (0 >= s) throw new IllegalStateException("Cannot compute offset from zero-length line segment");
						a = e * r / s, l = e * o / s
					}
					return new f(i - l, n + a)
				},
				setCoordinates: function() {
					if (1 === arguments.length) {
						var t = arguments[0];
						this.setCoordinates(t.p0, t.p1)
					} else if (2 === arguments.length) {
						var e = arguments[0],
							i = arguments[1];
						this.p0.x = e.x, this.p0.y = e.y, this.p1.x = i.x, this.p1.y = i.y
					}
				},
				segmentFraction: function(t) {
					var e = this.projectionFactor(t);
					return 0 > e ? e = 0 : (e > 1 || r.isNaN(e)) && (e = 1), e
				},
				toString: function() {
					return "LINESTRING( " + this.p0.x + " " + this.p0.y + ", " + this.p1.x + " " + this.p1.y + ")"
				},
				isHorizontal: function() {
					return this.p0.y === this.p1.y
				},
				distance: function() {
					if (arguments[0] instanceof te) {
						var t = arguments[0];
						return $t.distanceLineLine(this.p0, this.p1, t.p0, t.p1)
					}
					if (arguments[0] instanceof f) {
						var e = arguments[0];
						return $t.distancePointLine(e, this.p0, this.p1)
					}
				},
				pointAlong: function(t) {
					var e = new f;
					return e.x = this.p0.x + t * (this.p1.x - this.p0.x), e.y = this.p0.y + t * (this.p1.y - this.p0.y), e
				},
				hashCode: function() {
					var t = java.lang.Double.doubleToLongBits(this.p0.x);
					t ^= 31 * java.lang.Double.doubleToLongBits(this.p0.y);
					var e = Math.trunc(t) ^ Math.trunc(t >> 32),
						i = java.lang.Double.doubleToLongBits(this.p1.x);
					return i ^= 31 * java.lang.Double.doubleToLongBits(this.p1.y), e ^ Math.trunc(i) ^ Math.trunc(i >> 32)
				},
				interfaces_: function() {
					return [o, l]
				},
				getClass: function() {
					return te
				}
			}), te.midPoint = function(t, e) {
				return new f((t.x + e.x) / 2, (t.y + e.y) / 2)
			}, te.serialVersionUID = 0x2d2172135f411c00, e(ee.prototype, {
				isIntersects: function() {
					return !this.isDisjoint()
				},
				isCovers: function() {
					return (ee.isTrue(this.matrix[T.INTERIOR][T.INTERIOR]) || ee.isTrue(this.matrix[T.INTERIOR][T.BOUNDARY]) || ee.isTrue(this.matrix[T.BOUNDARY][T.INTERIOR]) || ee.isTrue(this.matrix[T.BOUNDARY][T.BOUNDARY])) && this.matrix[T.EXTERIOR][T.INTERIOR] === ut.FALSE && this.matrix[T.EXTERIOR][T.BOUNDARY] === ut.FALSE
				},
				isCoveredBy: function() {
					return (ee.isTrue(this.matrix[T.INTERIOR][T.INTERIOR]) || ee.isTrue(this.matrix[T.INTERIOR][T.BOUNDARY]) || ee.isTrue(this.matrix[T.BOUNDARY][T.INTERIOR]) || ee.isTrue(this.matrix[T.BOUNDARY][T.BOUNDARY])) && this.matrix[T.INTERIOR][T.EXTERIOR] === ut.FALSE && this.matrix[T.BOUNDARY][T.EXTERIOR] === ut.FALSE
				},
				set: function() {
					if (1 === arguments.length) for (var t = arguments[0], e = 0; e < t.length; e++) {
						var i = Math.trunc(e / 3),
							n = e % 3;
						this.matrix[i][n] = ut.toDimensionValue(t.charAt(e))
					} else if (3 === arguments.length) {
						var r = arguments[0],
							o = arguments[1],
							s = arguments[2];
						this.matrix[r][o] = s
					}
				},
				isContains: function() {
					return ee.isTrue(this.matrix[T.INTERIOR][T.INTERIOR]) && this.matrix[T.EXTERIOR][T.INTERIOR] === ut.FALSE && this.matrix[T.EXTERIOR][T.BOUNDARY] === ut.FALSE
				},
				setAtLeast: function() {
					if (1 === arguments.length) for (var t = arguments[0], e = 0; e < t.length; e++) {
						var i = Math.trunc(e / 3),
							n = e % 3;
						this.setAtLeast(i, n, ut.toDimensionValue(t.charAt(e)))
					} else if (3 === arguments.length) {
						var r = arguments[0],
							o = arguments[1],
							s = arguments[2];
						this.matrix[r][o] < s && (this.matrix[r][o] = s)
					}
				},
				setAtLeastIfValid: function(t, e, i) {
					t >= 0 && e >= 0 && this.setAtLeast(t, e, i)
				},
				isWithin: function() {
					return ee.isTrue(this.matrix[T.INTERIOR][T.INTERIOR]) && this.matrix[T.INTERIOR][T.EXTERIOR] === ut.FALSE && this.matrix[T.BOUNDARY][T.EXTERIOR] === ut.FALSE
				},
				isTouches: function(t, e) {
					return t > e ? this.isTouches(e, t) : (t === ut.A && e === ut.A || t === ut.L && e === ut.L || t === ut.L && e === ut.A || t === ut.P && e === ut.A || t === ut.P && e === ut.L) && this.matrix[T.INTERIOR][T.INTERIOR] === ut.FALSE && (ee.isTrue(this.matrix[T.INTERIOR][T.BOUNDARY]) || ee.isTrue(this.matrix[T.BOUNDARY][T.INTERIOR]) || ee.isTrue(this.matrix[T.BOUNDARY][T.BOUNDARY]))
				},
				isOverlaps: function(t, e) {
					return t === ut.P && e === ut.P || t === ut.A && e === ut.A ? ee.isTrue(this.matrix[T.INTERIOR][T.INTERIOR]) && ee.isTrue(this.matrix[T.INTERIOR][T.EXTERIOR]) && ee.isTrue(this.matrix[T.EXTERIOR][T.INTERIOR]) : t === ut.L && e === ut.L && 1 === this.matrix[T.INTERIOR][T.INTERIOR] && ee.isTrue(this.matrix[T.INTERIOR][T.EXTERIOR]) && ee.isTrue(this.matrix[T.EXTERIOR][T.INTERIOR])
				},
				isEquals: function(t, e) {
					return t === e && ee.isTrue(this.matrix[T.INTERIOR][T.INTERIOR]) && this.matrix[T.INTERIOR][T.EXTERIOR] === ut.FALSE && this.matrix[T.BOUNDARY][T.EXTERIOR] === ut.FALSE && this.matrix[T.EXTERIOR][T.INTERIOR] === ut.FALSE && this.matrix[T.EXTERIOR][T.BOUNDARY] === ut.FALSE
				},
				toString: function() {
					for (var t = new L("123456789"), e = 0; 3 > e; e++) for (var i = 0; 3 > i; i++) t.setCharAt(3 * e + i, ut.toDimensionSymbol(this.matrix[e][i]));
					return t.toString()
				},
				setAll: function(t) {
					for (var e = 0; 3 > e; e++) for (var i = 0; 3 > i; i++) this.matrix[e][i] = t
				},
				get: function(t, e) {
					return this.matrix[t][e]
				},
				transpose: function() {
					var t = this.matrix[1][0];
					return this.matrix[1][0] = this.matrix[0][1], this.matrix[0][1] = t, t = this.matrix[2][0], this.matrix[2][0] = this.matrix[0][2], this.matrix[0][2] = t, t = this.matrix[2][1], this.matrix[2][1] = this.matrix[1][2], this.matrix[1][2] = t, this
				},
				matches: function(t) {
					if (9 !== t.length) throw new n("Should be length 9: " + t);
					for (var e = 0; 3 > e; e++) for (var i = 0; 3 > i; i++) if (!ee.matches(this.matrix[e][i], t.charAt(3 * e + i))) return !1;
					return !0
				},
				add: function(t) {
					for (var e = 0; 3 > e; e++) for (var i = 0; 3 > i; i++) this.setAtLeast(e, i, t.get(e, i))
				},
				isDisjoint: function() {
					return this.matrix[T.INTERIOR][T.INTERIOR] === ut.FALSE && this.matrix[T.INTERIOR][T.BOUNDARY] === ut.FALSE && this.matrix[T.BOUNDARY][T.INTERIOR] === ut.FALSE && this.matrix[T.BOUNDARY][T.BOUNDARY] === ut.FALSE
				},
				isCrosses: function(t, e) {
					return t === ut.P && e === ut.L || t === ut.P && e === ut.A || t === ut.L && e === ut.A ? ee.isTrue(this.matrix[T.INTERIOR][T.INTERIOR]) && ee.isTrue(this.matrix[T.INTERIOR][T.EXTERIOR]) : t === ut.L && e === ut.P || t === ut.A && e === ut.P || t === ut.A && e === ut.L ? ee.isTrue(this.matrix[T.INTERIOR][T.INTERIOR]) && ee.isTrue(this.matrix[T.EXTERIOR][T.INTERIOR]) : t === ut.L && e === ut.L && 0 === this.matrix[T.INTERIOR][T.INTERIOR]
				},
				interfaces_: function() {
					return [s]
				},
				getClass: function() {
					return ee
				}
			}), ee.matches = function() {
				if (Number.isInteger(arguments[0]) && "string" == typeof arguments[1]) {
					var t = arguments[0],
						e = arguments[1];
					return e === ut.SYM_DONTCARE || e === ut.SYM_TRUE && (t >= 0 || t === ut.TRUE) || e === ut.SYM_FALSE && t === ut.FALSE || e === ut.SYM_P && t === ut.P || e === ut.SYM_L && t === ut.L || e === ut.SYM_A && t === ut.A
				}
				if ("string" == typeof arguments[0] && "string" == typeof arguments[1]) {
					var i = arguments[0],
						n = arguments[1],
						r = new ee(i);
					return r.matches(n)
				}
			}, ee.isTrue = function(t) {
				return t >= 0 || t === ut.TRUE
			};
			var Ko = Object.freeze({
				Coordinate: f,
				CoordinateList: x,
				Envelope: C,
				LineSegment: te,
				GeometryFactory: Wt,
				Geometry: U,
				Point: St,
				LineString: Ct,
				LinearRing: Lt,
				Polygon: Rt,
				GeometryCollection: dt,
				MultiPoint: wt,
				MultiLineString: ft,
				MultiPolygon: Nt,
				Dimension: ut,
				IntersectionMatrix: ee
			});
			e(ie.prototype, {
				addPoint: function(t) {
					this.ptCount += 1, this.ptCentSum.x += t.x, this.ptCentSum.y += t.y
				},
				setBasePoint: function(t) {
					null === this.areaBasePt && (this.areaBasePt = t)
				},
				addLineSegments: function(t) {
					for (var e = 0, i = 0; i < t.length - 1; i++) {
						var n = t[i].distance(t[i + 1]);
						if (0 !== n) {
							e += n;
							var r = (t[i].x + t[i + 1].x) / 2;
							this.lineCentSum.x += n * r;
							var o = (t[i].y + t[i + 1].y) / 2;
							this.lineCentSum.y += n * o
						}
					}
					this.totalLength += e, 0 === e && t.length > 0 && this.addPoint(t[0])
				},
				addHole: function(t) {
					for (var e = $t.isCCW(t), i = 0; i < t.length - 1; i++) this.addTriangle(this.areaBasePt, t[i], t[i + 1], e);
					this.addLineSegments(t)
				},
				getCentroid: function() {
					var t = new f;
					if (Math.abs(this.areasum2) > 0) t.x = this.cg3.x / 3 / this.areasum2, t.y = this.cg3.y / 3 / this.areasum2;
					else if (this.totalLength > 0) t.x = this.lineCentSum.x / this.totalLength, t.y = this.lineCentSum.y / this.totalLength;
					else {
						if (!(this.ptCount > 0)) return null;
						t.x = this.ptCentSum.x / this.ptCount, t.y = this.ptCentSum.y / this.ptCount
					}
					return t
				},
				addShell: function(t) {
					t.length > 0 && this.setBasePoint(t[0]);
					for (var e = !$t.isCCW(t), i = 0; i < t.length - 1; i++) this.addTriangle(this.areaBasePt, t[i], t[i + 1], e);
					this.addLineSegments(t)
				},
				addTriangle: function(t, e, i, n) {
					var r = n ? 1 : -1;
					ie.centroid3(t, e, i, this.triangleCent3);
					var o = ie.area2(t, e, i);
					this.cg3.x += r * o * this.triangleCent3.x, this.cg3.y += r * o * this.triangleCent3.y, this.areasum2 += r * o
				},
				add: function() {
					if (arguments[0] instanceof Rt) {
						var t = arguments[0];
						this.addShell(t.getExteriorRing().getCoordinates());
						for (var e = 0; e < t.getNumInteriorRing(); e++) this.addHole(t.getInteriorRingN(e).getCoordinates())
					} else if (arguments[0] instanceof U) {
						var i = arguments[0];
						if (i.isEmpty()) return null;
						if (i instanceof St) this.addPoint(i.getCoordinate());
						else if (i instanceof Ct) this.addLineSegments(i.getCoordinates());
						else if (i instanceof Rt) {
							var n = i;
							this.add(n)
						} else if (i instanceof dt) {
							var r = i;
							for (e = 0; e < r.getNumGeometries(); e++) this.add(r.getGeometryN(e))
						}
					}
				},
				interfaces_: function() {
					return []
				},
				getClass: function() {
					return ie
				}
			}), ie.area2 = function(t, e, i) {
				return (e.x - t.x) * (i.y - t.y) - (i.x - t.x) * (e.y - t.y)
			}, ie.centroid3 = function(t, e, i, n) {
				return n.x = t.x + e.x + i.x, n.y = t.y + e.y + i.y, null
			}, ie.getCentroid = function(t) {
				return new ie(t).getCentroid()
			}, ne.prototype = new Error, ne.prototype.name = "EmptyStackException", re.prototype = new v, re.prototype.add = function(t) {
				return this.array_.push(t), !0
			}, re.prototype.get = function(t) {
				if (0 > t || t >= this.size()) throw new IndexOutOfBoundsException;
				return this.array_[t]
			}, re.prototype.push = function(t) {
				return this.array_.push(t), t
			}, re.prototype.pop = function(t) {
				if (0 === this.array_.length) throw new ne;
				return this.array_.pop()
			}, re.prototype.peek = function() {
				if (0 === this.array_.length) throw new ne;
				return this.array_[this.array_.length - 1]
			}, re.prototype.empty = function() {
				return 0 === this.array_.length
			}, re.prototype.isEmpty = function() {
				return this.empty()
			}, re.prototype.search = function(t) {
				return this.array_.indexOf(t)
			}, re.prototype.size = function() {
				return this.array_.length
			}, re.prototype.toArray = function() {
				for (var t = [], e = 0, i = this.array_.length; i > e; e++) t.push(this.array_[e]);
				return t
			}, e(oe.prototype, {
				filter: function(t) {
					this.treeSet.contains(t) || (this.list.add(t), this.treeSet.add(t))
				},
				getCoordinates: function() {
					var t = new Array(this.list.size()).fill(null);
					return this.list.toArray(t)
				},
				interfaces_: function() {
					return [B]
				},
				getClass: function() {
					return oe
				}
			}), oe.filterCoordinates = function(t) {
				for (var e = new oe, i = 0; i < t.length; i++) e.filter(t[i]);
				return e.getCoordinates()
			}, e(se.prototype, {
				preSort: function(t) {
					for (var e = null, i = 1; i < t.length; i++)(t[i].y < t[0].y || t[i].y === t[0].y && t[i].x < t[0].x) && (e = t[0], t[0] = t[i], t[i] = e);
					return lt.sort(t, 1, t.length, new ae(t[0])), t
				},
				computeOctRing: function(t) {
					var e = this.computeOctPts(t),
						i = new x;
					return i.add(e, !1), i.size() < 3 ? null : (i.closeRing(), i.toCoordinateArray())
				},
				lineOrPolygon: function(t) {
					if (3 === (t = this.cleanRing(t)).length) return this.geomFactory.createLineString([t[0], t[1]]);
					var e = this.geomFactory.createLinearRing(t);
					return this.geomFactory.createPolygon(e, null)
				},
				cleanRing: function(t) {
					d.equals(t[0], t[t.length - 1]);
					for (var e = new E, i = null, n = 0; n <= t.length - 2; n++) {
						var r = t[n],
							o = t[n + 1];
						r.equals(o) || null !== i && this.isBetween(i, r, o) || (e.add(r), i = r)
					}
					e.add(t[t.length - 1]);
					var s = new Array(e.size()).fill(null);
					return e.toArray(s)
				},
				isBetween: function(t, e, i) {
					if (0 !== $t.computeOrientation(t, e, i)) return !1;
					if (t.x !== i.x) {
						if (t.x <= e.x && e.x <= i.x) return !0;
						if (i.x <= e.x && e.x <= t.x) return !0
					}
					if (t.y !== i.y) {
						if (t.y <= e.y && e.y <= i.y) return !0;
						if (i.y <= e.y && e.y <= t.y) return !0
					}
					return !1
				},
				reduce: function(t) {
					var e = this.computeOctRing(t);
					if (null === e) return t;
					for (var i = new at, n = 0; n < e.length; n++) i.add(e[n]);
					for (n = 0; n < t.length; n++) $t.isPointInRing(t[n], e) || i.add(t[n]);
					var r = W.toCoordinateArray(i);
					return r.length < 3 ? this.padArray3(r) : r
				},
				getConvexHull: function() {
					if (0 === this.inputPts.length) return this.geomFactory.createGeometryCollection(null);
					if (1 === this.inputPts.length) return this.geomFactory.createPoint(this.inputPts[0]);
					if (2 === this.inputPts.length) return this.geomFactory.createLineString(this.inputPts);
					var t = this.inputPts;
					this.inputPts.length > 50 && (t = this.reduce(this.inputPts));
					var e = this.preSort(t),
						i = this.grahamScan(e),
						n = this.toCoordinateArray(i);
					return this.lineOrPolygon(n)
				},
				padArray3: function(t) {
					for (var e = new Array(3).fill(null), i = 0; i < e.length; i++) i < t.length ? e[i] = t[i] : e[i] = t[0];
					return e
				},
				computeOctPts: function(t) {
					for (var e = new Array(8).fill(null), i = 0; i < e.length; i++) e[i] = t[0];
					for (var n = 1; n < t.length; n++) t[n].x < e[0].x && (e[0] = t[n]), t[n].x - t[n].y < e[1].x - e[1].y && (e[1] = t[n]), t[n].y > e[2].y && (e[2] = t[n]), t[n].x + t[n].y > e[3].x + e[3].y && (e[3] = t[n]), t[n].x > e[4].x && (e[4] = t[n]), t[n].x - t[n].y > e[5].x - e[5].y && (e[5] = t[n]), t[n].y < e[6].y && (e[6] = t[n]), t[n].x + t[n].y < e[7].x + e[7].y && (e[7] = t[n]);
					return e
				},
				toCoordinateArray: function(t) {
					for (var e = new Array(t.size()).fill(null), i = 0; i < t.size(); i++) {
						var n = t.get(i);
						e[i] = n
					}
					return e
				},
				grahamScan: function(t) {
					var e = null,
						i = new re;
					e = i.push(t[0]), e = i.push(t[1]), e = i.push(t[2]);
					for (var n = 3; n < t.length; n++) {
						for (e = i.pop(); !i.empty() && $t.computeOrientation(i.peek(), e, t[n]) > 0;) e = i.pop();
						e = i.push(e), e = i.push(t[n])
					}
					return e = i.push(t[0]), i
				},
				interfaces_: function() {
					return []
				},
				getClass: function() {
					return se
				}
			}), se.extractCoordinates = function(t) {
				var e = new oe;
				return t.apply(e), e.getCoordinates()
			}, e(ae.prototype, {
				compare: function(t, e) {
					var i = t,
						n = e;
					return ae.polarCompare(this.origin, i, n)
				},
				interfaces_: function() {
					return [a]
				},
				getClass: function() {
					return ae
				}
			}), ae.polarCompare = function(t, e, i) {
				var n = e.x - t.x,
					r = e.y - t.y,
					o = i.x - t.x,
					s = i.y - t.y,
					a = $t.computeOrientation(t, e, i);
				if (a === $t.COUNTERCLOCKWISE) return 1;
				if (a === $t.CLOCKWISE) return -1;
				var l = n * n + r * r,
					u = o * o + s * s;
				return u > l ? -1 : l > u ? 1 : 0
			}, se.RadialComparator = ae, e(le.prototype, {
				transformPoint: function(t, e) {
					return this.factory.createPoint(this.transformCoordinates(t.getCoordinateSequence(), t))
				},
				transformPolygon: function(t, e) {
					var i = !0,
						n = this.transformLinearRing(t.getExteriorRing(), t);
					null !== n && n instanceof Lt && !n.isEmpty() || (i = !1);
					for (var r = new E, o = 0; o < t.getNumInteriorRing(); o++) {
						var s = this.transformLinearRing(t.getInteriorRingN(o), t);
						null === s || s.isEmpty() || (s instanceof Lt || (i = !1), r.add(s))
					}
					if (i) return this.factory.createPolygon(n, r.toArray([]));
					var a = new E;
					return null !== n && a.add(n), a.addAll(r), this.factory.buildGeometry(a)
				},
				createCoordinateSequence: function(t) {
					return this.factory.getCoordinateSequenceFactory().create(t)
				},
				getInputGeometry: function() {
					return this.inputGeom
				},
				transformMultiLineString: function(t, e) {
					for (var i = new E, n = 0; n < t.getNumGeometries(); n++) {
						var r = this.transformLineString(t.getGeometryN(n), t);
						null !== r && (r.isEmpty() || i.add(r))
					}
					return this.factory.buildGeometry(i)
				},
				transformCoordinates: function(t, e) {
					return this.copy(t)
				},
				transformLineString: function(t, e) {
					return this.factory.createLineString(this.transformCoordinates(t.getCoordinateSequence(), t))
				},
				transformMultiPoint: function(t, e) {
					for (var i = new E, n = 0; n < t.getNumGeometries(); n++) {
						var r = this.transformPoint(t.getGeometryN(n), t);
						null !== r && (r.isEmpty() || i.add(r))
					}
					return this.factory.buildGeometry(i)
				},
				transformMultiPolygon: function(t, e) {
					for (var i = new E, n = 0; n < t.getNumGeometries(); n++) {
						var r = this.transformPolygon(t.getGeometryN(n), t);
						null !== r && (r.isEmpty() || i.add(r))
					}
					return this.factory.buildGeometry(i)
				},
				copy: function(t) {
					return t.copy()
				},
				transformGeometryCollection: function(t, e) {
					for (var i = new E, n = 0; n < t.getNumGeometries(); n++) {
						var r = this.transform(t.getGeometryN(n));
						null !== r && (this.pruneEmptyGeometry && r.isEmpty() || i.add(r))
					}
					return this.preserveGeometryCollectionType ? this.factory.createGeometryCollection(Wt.toGeometryArray(i)) : this.factory.buildGeometry(i)
				},
				transform: function(t) {
					if (this.inputGeom = t, this.factory = t.getFactory(), t instanceof St) return this.transformPoint(t, null);
					if (t instanceof wt) return this.transformMultiPoint(t, null);
					if (t instanceof Lt) return this.transformLinearRing(t, null);
					if (t instanceof Ct) return this.transformLineString(t, null);
					if (t instanceof ft) return this.transformMultiLineString(t, null);
					if (t instanceof Rt) return this.transformPolygon(t, null);
					if (t instanceof Nt) return this.transformMultiPolygon(t, null);
					if (t instanceof dt) return this.transformGeometryCollection(t, null);
					throw new n("Unknown Geometry subtype: " + t.getClass().getName())
				},
				transformLinearRing: function(t, e) {
					var i = this.transformCoordinates(t.getCoordinateSequence(), t);
					if (null === i) return this.factory.createLinearRing(null);
					var n = i.size();
					return n > 0 && 4 > n && !this.preserveType ? this.factory.createLineString(i) : this.factory.createLinearRing(i)
				},
				interfaces_: function() {
					return []
				},
				getClass: function() {
					return le
				}
			}), e(ue.prototype, {
				snapVertices: function(t, e) {
					for (var i = this._isClosed ? t.size() - 1 : t.size(), n = 0; i > n; n++) {
						var r = t.get(n),
							o = this.findSnapForVertex(r, e);
						null !== o && (t.set(n, new f(o)), 0 === n && this._isClosed && t.set(t.size() - 1, new f(o)))
					}
				},
				findSnapForVertex: function(t, e) {
					for (var i = 0; i < e.length; i++) {
						if (t.equals2D(e[i])) return null;
						if (t.distance(e[i]) < this.snapTolerance) return e[i]
					}
					return null
				},
				snapTo: function(t) {
					var e = new x(this.srcPts);
					return this.snapVertices(e, t), this.snapSegments(e, t), e.toCoordinateArray()
				},
				snapSegments: function(t, e) {
					if (0 === e.length) return null;
					var i = e.length;
					e[0].equals2D(e[e.length - 1]) && (i = e.length - 1);
					for (var n = 0; i > n; n++) {
						var r = e[n],
							o = this.findSegmentIndexToSnap(r, t);
						o >= 0 && t.add(o + 1, new f(r), !1)
					}
				},
				findSegmentIndexToSnap: function(t, e) {
					for (var i = r.MAX_VALUE, n = -1, o = 0; o < e.size() - 1; o++) {
						if (this.seg.p0 = e.get(o), this.seg.p1 = e.get(o + 1), this.seg.p0.equals2D(t) || this.seg.p1.equals2D(t)) {
							if (this.allowSnappingToSourceVertices) continue;
							return -1
						}
						var s = this.seg.distance(t);
						s < this.snapTolerance && i > s && (i = s, n = o)
					}
					return n
				},
				setAllowSnappingToSourceVertices: function(t) {
					this.allowSnappingToSourceVertices = t
				},
				interfaces_: function() {
					return []
				},
				getClass: function() {
					return ue
				}
			}), ue.isClosed = function(t) {
				return !(t.length <= 1) && t[0].equals2D(t[t.length - 1])
			}, e(he.prototype, {
				snapTo: function(t, e) {
					return new ce(e, this.extractTargetCoordinates(t)).transform(this.srcGeom)
				},
				snapToSelf: function(t, e) {
					var i = new ce(t, this.extractTargetCoordinates(this.srcGeom), !0).transform(this.srcGeom),
						n = i;
					return e && R(n, Tt) && (n = i.buffer(0)), n
				},
				computeSnapTolerance: function(t) {
					return this.computeMinimumSegmentLength(t) / 10
				},
				extractTargetCoordinates: function(t) {
					for (var e = new at, i = t.getCoordinates(), n = 0; n < i.length; n++) e.add(i[n]);
					return e.toArray(new Array(0).fill(null))
				},
				computeMinimumSegmentLength: function(t) {
					for (var e = r.MAX_VALUE, i = 0; i < t.length - 1; i++) {
						var n = t[i].distance(t[i + 1]);
						e > n && (e = n)
					}
					return e
				},
				interfaces_: function() {
					return []
				},
				getClass: function() {
					return he
				}
			}), he.snap = function(t, e, i) {
				var n = new Array(2).fill(null),
					r = new he(t);
				n[0] = r.snapTo(e, i);
				var o = new he(e);
				return n[1] = o.snapTo(n[0], i), n
			}, he.computeOverlaySnapTolerance = function() {
				if (1 === arguments.length) {
					var t = arguments[0],
						e = he.computeSizeBasedSnapTolerance(t),
						i = t.getPrecisionModel();
					if (i.getType() === zt.FIXED) {
						var n = 1 / i.getScale() * 2 / 1.415;
						n > e && (e = n)
					}
					return e
				}
				if (2 === arguments.length) {
					var r = arguments[0],
						o = arguments[1];
					return Math.min(he.computeOverlaySnapTolerance(r), he.computeOverlaySnapTolerance(o))
				}
			}, he.computeSizeBasedSnapTolerance = function(t) {
				var e = t.getEnvelopeInternal();
				return Math.min(e.getHeight(), e.getWidth()) * he.SNAP_PRECISION_FACTOR
			}, he.snapToSelf = function(t, e, i) {
				return new he(t).snapToSelf(e, i)
			}, he.SNAP_PRECISION_FACTOR = 1e-9, h(ce, le), e(ce.prototype, {
				snapLine: function(t, e) {
					var i = new ue(t, this.snapTolerance);
					return i.setAllowSnappingToSourceVertices(this.isSelfSnap), i.snapTo(e)
				},
				transformCoordinates: function(t, e) {
					var i = t.toCoordinateArray(),
						n = this.snapLine(i, this.snapPts);
					return this.factory.getCoordinateSequenceFactory().create(n)
				},
				interfaces_: function() {
					return []
				},
				getClass: function() {
					return ce
				}
			}), e(de.prototype, {
				getCommon: function() {
					return r.longBitsToDouble(this.commonBits)
				},
				add: function(t) {
					var e = r.doubleToLongBits(t);
					return this.isFirst ? (this.commonBits = e, this.commonSignExp = de.signExpBits(this.commonBits), this.isFirst = !1, null) : de.signExpBits(e) !== this.commonSignExp ? (this.commonBits = 0, null) : (this.commonMantissaBitsCount = de.numCommonMostSigMantissaBits(this.commonBits, e), void(this.commonBits = de.zeroLowerBits(this.commonBits, 64 - (12 + this.commonMantissaBitsCount))))
				},
				toString: function() {
					if (1 === arguments.length) {
						var t = arguments[0],
							e = r.longBitsToDouble(t),
							i = Long.toBinaryString(t),
							n = "0000000000000000000000000000000000000000000000000000000000000000" + i,
							o = n.substring(n.length - 64),
							s = o.substring(0, 1) + "  " + o.substring(1, 12) + "(exp) " + o.substring(12) + " [ " + e + " ]";
						return s
					}
				},
				interfaces_: function() {
					return []
				},
				getClass: function() {
					return de
				}
			}), de.getBit = function(t, e) {
				return 0 != (t & 1 << e) ? 1 : 0
			}, de.signExpBits = function(t) {
				return t >> 52
			}, de.zeroLowerBits = function(t, e) {
				return t & ~ ((1 << e) - 1)
			}, de.numCommonMostSigMantissaBits = function(t, e) {
				for (var i = 0, n = 52; n >= 0; n--) {
					if (de.getBit(t, n) !== de.getBit(e, n)) return i;
					i++
				}
				return 52
			}, e(fe.prototype, {
				addCommonBits: function(t) {
					var e = new pe(this.commonCoord);
					t.apply(e), t.geometryChanged()
				},
				removeCommonBits: function(t) {
					if (0 === this.commonCoord.x && 0 === this.commonCoord.y) return t;
					var e = new f(this.commonCoord);
					e.x = -e.x, e.y = -e.y;
					var i = new pe(e);
					return t.apply(i), t.geometryChanged(), t
				},
				getCommonCoordinate: function() {
					return this.commonCoord
				},
				add: function(t) {
					t.apply(this.ccFilter), this.commonCoord = this.ccFilter.getCommonCoordinate()
				},
				interfaces_: function() {
					return []
				},
				getClass: function() {
					return fe
				}
			}), e(Ae.prototype, {
				filter: function(t) {
					this.commonBitsX.add(t.x), this.commonBitsY.add(t.y)
				},
				getCommonCoordinate: function() {
					return new f(this.commonBitsX.getCommon(), this.commonBitsY.getCommon())
				},
				interfaces_: function() {
					return [B]
				},
				getClass: function() {
					return Ae
				}
			}), e(pe.prototype, {
				filter: function(t, e) {
					var i = t.getOrdinate(e, 0) + this.trans.x,
						n = t.getOrdinate(e, 1) + this.trans.y;
					t.setOrdinate(e, 0, i), t.setOrdinate(e, 1, n)
				},
				isDone: function() {
					return !1
				},
				isGeometryChanged: function() {
					return !0
				},
				interfaces_: function() {
					return [ct]
				},
				getClass: function() {
					return pe
				}
			}), fe.CommonCoordinateFilter = Ae, fe.Translater = pe, e(ge.prototype, {
				next: function() {
					if (this.atStart) return this.atStart = !1, ge.isAtomic(this.parent) && this.index++, this.parent;
					if (null !== this.subcollectionIterator) {
						if (this.subcollectionIterator.hasNext()) return this.subcollectionIterator.next();
						this.subcollectionIterator = null
					}
					if (this.index >= this.max) throw new y;
					var t = this.parent.getGeometryN(this.index++);
					return t instanceof dt ? (this.subcollectionIterator = new ge(t), this.subcollectionIterator.next()) : t
				},
				remove: function() {
					throw new UnsupportedOperationException(this.getClass().getName())
				},
				hasNext: function() {
					if (this.atStart) return !0;
					if (null !== this.subcollectionIterator) {
						if (this.subcollectionIterator.hasNext()) return !0;
						this.subcollectionIterator = null
					}
					return !(this.index >= this.max)
				},
				interfaces_: function() {
					return [p]
				},
				getClass: function() {
					return ge
				}
			}), ge.isAtomic = function(t) {
				return !(t instanceof dt)
			}, e(me.prototype, {
				locateInternal: function() {
					if (arguments[0] instanceof f && arguments[1] instanceof Rt) {
						var t = arguments[0],
							e = arguments[1];
						if (e.isEmpty()) return T.EXTERIOR;
						var i = e.getExteriorRing(),
							n = this.locateInPolygonRing(t, i);
						if (n === T.EXTERIOR) return T.EXTERIOR;
						if (n === T.BOUNDARY) return T.BOUNDARY;
						for (var r = 0; r < e.getNumInteriorRing(); r++) {
							var o = e.getInteriorRingN(r),
								s = this.locateInPolygonRing(t, o);
							if (s === T.INTERIOR) return T.EXTERIOR;
							if (s === T.BOUNDARY) return T.BOUNDARY
						}
						return T.INTERIOR
					}
					if (arguments[0] instanceof f && arguments[1] instanceof Ct) {
						var a = arguments[0],
							l = arguments[1];
						if (!l.getEnvelopeInternal().intersects(a)) return T.EXTERIOR;
						var u = l.getCoordinates();
						return l.isClosed() || !a.equals(u[0]) && !a.equals(u[u.length - 1]) ? $t.isOnLine(a, u) ? T.INTERIOR : T.EXTERIOR : T.BOUNDARY
					}
					if (arguments[0] instanceof f && arguments[1] instanceof St) {
						var h = arguments[0],
							c = arguments[1],
							d = c.getCoordinate();
						return d.equals2D(h) ? T.INTERIOR : T.EXTERIOR
					}
				},
				locateInPolygonRing: function(t, e) {
					return e.getEnvelopeInternal().intersects(t) ? $t.locatePointInRing(t, e.getCoordinates()) : T.EXTERIOR
				},
				intersects: function(t, e) {
					return this.locate(t, e) !== T.EXTERIOR
				},
				updateLocationInfo: function(t) {
					t === T.INTERIOR && (this.isIn = !0), t === T.BOUNDARY && this.numBoundaries++
				},
				computeLocation: function(t, e) {
					if (e instanceof St && this.updateLocationInfo(this.locateInternal(t, e)), e instanceof Ct) this.updateLocationInfo(this.locateInternal(t, e));
					else if (e instanceof Rt) this.updateLocationInfo(this.locateInternal(t, e));
					else if (e instanceof ft) for (var i = e, n = 0; n < i.getNumGeometries(); n++) {
						var r = i.getGeometryN(n);
						this.updateLocationInfo(this.locateInternal(t, r))
					} else if (e instanceof Nt) {
						var o = e;
						for (n = 0; n < o.getNumGeometries(); n++) {
							var s = o.getGeometryN(n);
							this.updateLocationInfo(this.locateInternal(t, s))
						}
					} else if (e instanceof dt) for (var a = new ge(e); a.hasNext();) {
						var l = a.next();
						l !== e && this.computeLocation(t, l)
					}
				},
				locate: function(t, e) {
					return e.isEmpty() ? T.EXTERIOR : e instanceof Ct ? this.locateInternal(t, e) : e instanceof Rt ? this.locateInternal(t, e) : (this.isIn = !1, this.numBoundaries = 0, this.computeLocation(t, e), this.boundaryRule.isInBoundary(this.numBoundaries) ? T.BOUNDARY : this.numBoundaries > 0 || this.isIn ? T.INTERIOR : T.EXTERIOR)
				},
				interfaces_: function() {
					return []
				},
				getClass: function() {
					return me
				}
			}), e(ve.prototype, {
				interfaces_: function() {
					return []
				},
				getClass: function() {
					return ve
				}
			}), ve.octant = function() {
				if ("number" == typeof arguments[0] && "number" == typeof arguments[1]) {
					var t = arguments[0],
						e = arguments[1];
					if (0 === t && 0 === e) throw new n("Cannot compute the octant for point ( " + t + ", " + e + " )");
					var i = Math.abs(t),
						r = Math.abs(e);
					return t >= 0 ? e >= 0 ? i >= r ? 0 : 1 : i >= r ? 7 : 6 : e >= 0 ? i >= r ? 3 : 2 : i >= r ? 4 : 5
				}
				if (arguments[0] instanceof f && arguments[1] instanceof f) {
					var o = arguments[0],
						s = arguments[1],
						a = s.x - o.x,
						l = s.y - o.y;
					if (0 === a && 0 === l) throw new n("Cannot compute the octant for two identical points " + o);
					return ve.octant(a, l)
				}
			}, e(ye.prototype, {
				getCoordinates: function() {},
				size: function() {},
				getCoordinate: function(t) {},
				isClosed: function() {},
				setData: function(t) {},
				getData: function() {},
				interfaces_: function() {
					return []
				},
				getClass: function() {
					return ye
				}
			}), e(_e.prototype, {
				getCoordinates: function() {
					return this.pts
				},
				size: function() {
					return this.pts.length
				},
				getCoordinate: function(t) {
					return this.pts[t]
				},
				isClosed: function() {
					return this.pts[0].equals(this.pts[this.pts.length - 1])
				},
				getSegmentOctant: function(t) {
					return t === this.pts.length - 1 ? -1 : ve.octant(this.getCoordinate(t), this.getCoordinate(t + 1))
				},
				setData: function(t) {
					this.data = t
				},
				getData: function() {
					return this.data
				},
				toString: function() {
					return Ht.toLineString(new Dt(this.pts))
				},
				interfaces_: function() {
					return [ye]
				},
				getClass: function() {
					return _e
				}
			}), e(Ee.prototype, {
				getBounds: function() {},
				interfaces_: function() {
					return []
				},
				getClass: function() {
					return Ee
				}
			}), e(xe.prototype, {
				getItem: function() {
					return this.item
				},
				getBounds: function() {
					return this.bounds
				},
				interfaces_: function() {
					return [Ee, l]
				},
				getClass: function() {
					return xe
				}
			}), e(Ce.prototype, {
				poll: function() {
					if (this.isEmpty()) return null;
					var t = this.items.get(1);
					return this.items.set(1, this.items.get(this._size)), this._size -= 1, this.reorder(1), t
				},
				size: function() {
					return this._size
				},
				reorder: function(t) {
					for (var e = null, i = this.items.get(t); 2 * t <= this._size && ((e = 2 * t) !== this._size && this.items.get(e + 1).compareTo(this.items.get(e)) < 0 && e++, this.items.get(e).compareTo(i) < 0); t = e) this.items.set(t, this.items.get(e));
					this.items.set(t, i)
				},
				clear: function() {
					this._size = 0, this.items.clear()
				},
				isEmpty: function() {
					return 0 === this._size
				},
				add: function(t) {
					this.items.add(null), this._size += 1;
					var e = this._size;
					for (this.items.set(0, t); t.compareTo(this.items.get(Math.trunc(e / 2))) < 0; e /= 2) this.items.set(e, this.items.get(Math.trunc(e / 2)));
					this.items.set(e, t)
				},
				interfaces_: function() {
					return []
				},
				getClass: function() {
					return Ce
				}
			}), e(Ie.prototype, {
				visitItem: function(t) {},
				interfaces_: function() {
					return []
				},
				getClass: function() {
					return Ie
				}
			}), e(Se.prototype, {
				insert: function(t, e) {},
				remove: function(t, e) {},
				query: function() {
					1 === arguments.length ? arguments[0] : 2 === arguments.length && (arguments[0], arguments[1])
				},
				interfaces_: function() {
					return []
				},
				getClass: function() {
					return Se
				}
			}), e(Te.prototype, {
				getLevel: function() {
					return this.level
				},
				size: function() {
					return this.childBoundables.size()
				},
				getChildBoundables: function() {
					return this.childBoundables
				},
				addChildBoundable: function(t) {
					d.isTrue(null === this.bounds), this.childBoundables.add(t)
				},
				isEmpty: function() {
					return this.childBoundables.isEmpty()
				},
				getBounds: function() {
					return null === this.bounds && (this.bounds = this.computeBounds()), this.bounds
				},
				interfaces_: function() {
					return [Ee, l]
				},
				getClass: function() {
					return Te
				}
			}), Te.serialVersionUID = 0x5a1e55ec41369800;
			var Jo = {
				reverseOrder: function() {
					return {
						compare: function(t, e) {
							return e.compareTo(t)
						}
					}
				},
				min: function(t) {
					return Jo.sort(t), t.get(0)
				},
				sort: function(t, e) {
					var i = t.toArray();
					e ? lt.sort(i, e) : lt.sort(i);
					for (var n = t.iterator(), r = 0, o = i.length; o > r; r++) n.next(), n.set(i[r])
				},
				singletonList: function(t) {
					var e = new E;
					return e.add(t), e
				}
			};
			e(Re.prototype, {
				expandToQueue: function(t, e) {
					var i = Re.isComposite(this.boundable1),
						r = Re.isComposite(this.boundable2);
					if (i && r) return Re.area(this.boundable1) > Re.area(this.boundable2) ? (this.expand(this.boundable1, this.boundable2, t, e), null) : (this.expand(this.boundable2, this.boundable1, t, e), null);
					if (i) return this.expand(this.boundable1, this.boundable2, t, e), null;
					if (r) return this.expand(this.boundable2, this.boundable1, t, e), null;
					throw new n("neither boundable is composite")
				},
				isLeaves: function() {
					return !(Re.isComposite(this.boundable1) || Re.isComposite(this.boundable2))
				},
				compareTo: function(t) {
					var e = t;
					return this._distance < e._distance ? -1 : this._distance > e._distance ? 1 : 0
				},
				expand: function(t, e, i, n) {
					for (var r = t.getChildBoundables().iterator(); r.hasNext();) {
						var o = new Re(r.next(), e, this.itemDistance);
						o.getDistance() < n && i.add(o)
					}
				},
				getBoundable: function(t) {
					return 0 === t ? this.boundable1 : this.boundable2
				},
				getDistance: function() {
					return this._distance
				},
				distance: function() {
					return this.isLeaves() ? this.itemDistance.distance(this.boundable1, this.boundable2) : this.boundable1.getBounds().distance(this.boundable2.getBounds())
				},
				interfaces_: function() {
					return [o]
				},
				getClass: function() {
					return Re
				}
			}), Re.area = function(t) {
				return t.getBounds().getArea()
			}, Re.isComposite = function(t) {
				return t instanceof Te
			}, e(we.prototype, {
				getNodeCapacity: function() {
					return this.nodeCapacity
				},
				lastNode: function(t) {
					return t.get(t.size() - 1)
				},
				size: function() {
					if (0 === arguments.length) return this.isEmpty() ? 0 : (this.build(), this.size(this.root));
					if (1 === arguments.length) {
						for (var t = arguments[0], e = 0, i = t.getChildBoundables().iterator(); i.hasNext();) {
							var n = i.next();
							n instanceof Te ? e += this.size(n) : n instanceof xe && (e += 1)
						}
						return e
					}
				},
				removeItem: function(t, e) {
					for (var i = null, n = t.getChildBoundables().iterator(); n.hasNext();) {
						var r = n.next();
						r instanceof xe && r.getItem() === e && (i = r)
					}
					return null !== i && (t.getChildBoundables().remove(i), !0)
				},
				itemsTree: function() {
					if (0 === arguments.length) {
						this.build();
						var t = this.itemsTree(this.root);
						return null === t ? new E : t
					}
					if (1 === arguments.length) {
						for (var e = arguments[0], i = new E, n = e.getChildBoundables().iterator(); n.hasNext();) {
							var r = n.next();
							if (r instanceof Te) {
								var o = this.itemsTree(r);
								null !== o && i.add(o)
							} else r instanceof xe ? i.add(r.getItem()) : d.shouldNeverReachHere()
						}
						return i.size() <= 0 ? null : i
					}
				},
				insert: function(t, e) {
					d.isTrue(!this.built, "Cannot insert items into an STR packed R-tree after it has been built."), this.itemBoundables.add(new xe(t, e))
				},
				boundablesAtLevel: function() {
					if (1 === arguments.length) {
						var t = arguments[0],
							e = new E;
						return this.boundablesAtLevel(t, this.root, e), e
					}
					if (3 === arguments.length) {
						var i = arguments[0],
							n = arguments[1],
							r = arguments[2];
						if (d.isTrue(i > -2), n.getLevel() === i) return r.add(n), null;
						for (var o = n.getChildBoundables().iterator(); o.hasNext();) {
							var s = o.next();
							s instanceof Te ? this.boundablesAtLevel(i, s, r) : (d.isTrue(s instanceof xe), -1 === i && r.add(s))
						}
						return null
					}
				},
				query: function() {
					if (1 === arguments.length) {
						var t = arguments[0];
						this.build();
						var e = new E;
						return this.isEmpty() ? e : (this.getIntersectsOp().intersects(this.root.getBounds(), t) && this.query(t, this.root, e), e)
					}
					if (2 === arguments.length) {
						var i = arguments[0],
							n = arguments[1];
						if (this.build(), this.isEmpty()) return null;
						this.getIntersectsOp().intersects(this.root.getBounds(), i) && this.query(i, this.root, n)
					} else if (3 === arguments.length) if (R(arguments[2], Ie) && arguments[0] instanceof Object && arguments[1] instanceof Te) for (var r = arguments[0], o = arguments[1], s = arguments[2], a = o.getChildBoundables(), l = 0; l < a.size(); l++) {
						var u = a.get(l);
						this.getIntersectsOp().intersects(u.getBounds(), r) && (u instanceof Te ? this.query(r, u, s) : u instanceof xe ? s.visitItem(u.getItem()) : d.shouldNeverReachHere())
					} else if (R(arguments[2], v) && arguments[0] instanceof Object && arguments[1] instanceof Te) {
						var h = arguments[0],
							c = arguments[1],
							f = arguments[2];
						for (a = c.getChildBoundables(), l = 0; l < a.size(); l++) u = a.get(l), this.getIntersectsOp().intersects(u.getBounds(), h) && (u instanceof Te ? this.query(h, u, f) : u instanceof xe ? f.add(u.getItem()) : d.shouldNeverReachHere())
					}
				},
				build: function() {
					return this.built ? null : (this.root = this.itemBoundables.isEmpty() ? this.createNode(0) : this.createHigherLevels(this.itemBoundables, -1), this.itemBoundables = null, void(this.built = !0))
				},
				getRoot: function() {
					return this.build(), this.root
				},
				remove: function() {
					if (2 === arguments.length) {
						var t = arguments[0],
							e = arguments[1];
						return this.build(), !! this.getIntersectsOp().intersects(this.root.getBounds(), t) && this.remove(t, this.root, e)
					}
					if (3 === arguments.length) {
						var i = arguments[0],
							n = arguments[1],
							r = arguments[2],
							o = this.removeItem(n, r);
						if (o) return !0;
						for (var s = null, a = n.getChildBoundables().iterator(); a.hasNext();) {
							var l = a.next();
							if (this.getIntersectsOp().intersects(l.getBounds(), i) && l instanceof Te && (o = this.remove(i, l, r))) {
								s = l;
								break
							}
						}
						return null !== s && s.getChildBoundables().isEmpty() && n.getChildBoundables().remove(s), o
					}
				},
				createHigherLevels: function(t, e) {
					d.isTrue(!t.isEmpty());
					var i = this.createParentBoundables(t, e + 1);
					return 1 === i.size() ? i.get(0) : this.createHigherLevels(i, e + 1)
				},
				depth: function() {
					if (0 === arguments.length) return this.isEmpty() ? 0 : (this.build(), this.depth(this.root));
					if (1 === arguments.length) {
						for (var t = arguments[0], e = 0, i = t.getChildBoundables().iterator(); i.hasNext();) {
							var n = i.next();
							if (n instanceof Te) {
								var r = this.depth(n);
								r > e && (e = r)
							}
						}
						return e + 1
					}
				},
				createParentBoundables: function(t, e) {
					d.isTrue(!t.isEmpty());
					var i = new E;
					i.add(this.createNode(e));
					var n = new E(t);
					Jo.sort(n, this.getComparator());
					for (var r = n.iterator(); r.hasNext();) {
						var o = r.next();
						this.lastNode(i).getChildBoundables().size() === this.getNodeCapacity() && i.add(this.createNode(e)), this.lastNode(i).addChildBoundable(o)
					}
					return i
				},
				isEmpty: function() {
					return this.built ? this.root.isEmpty() : this.itemBoundables.isEmpty()
				},
				interfaces_: function() {
					return [l]
				},
				getClass: function() {
					return we
				}
			}), we.compareDoubles = function(t, e) {
				return t > e ? 1 : e > t ? -1 : 0
			}, we.IntersectsOp = function() {}, we.serialVersionUID = -0x35ef64c82d4c5400, we.DEFAULT_NODE_CAPACITY = 10, e(Le.prototype, {
				distance: function(t, e) {},
				interfaces_: function() {
					return []
				},
				getClass: function() {
					return Le
				}
			}), h(Ne, we), e(Ne.prototype, {
				createParentBoundablesFromVerticalSlices: function(t, e) {
					d.isTrue(t.length > 0);
					for (var i = new E, n = 0; n < t.length; n++) i.addAll(this.createParentBoundablesFromVerticalSlice(t[n], e));
					return i
				},
				createNode: function(t) {
					return new Pe(t)
				},
				size: function() {
					return 0 === arguments.length ? we.prototype.size.call(this) : we.prototype.size.apply(this, arguments)
				},
				insert: function() {
					if (2 !== arguments.length) return we.prototype.insert.apply(this, arguments);
					var t = arguments[0],
						e = arguments[1];
					return t.isNull() ? null : void we.prototype.insert.call(this, t, e)
				},
				getIntersectsOp: function() {
					return Ne.intersectsOp
				},
				verticalSlices: function(t, e) {
					for (var i = Math.trunc(Math.ceil(t.size() / e)), n = new Array(e).fill(null), r = t.iterator(), o = 0; e > o; o++) {
						n[o] = new E;
						for (var s = 0; r.hasNext() && i > s;) {
							var a = r.next();
							n[o].add(a), s++
						}
					}
					return n
				},
				query: function() {
					if (1 === arguments.length) {
						var t = arguments[0];
						return we.prototype.query.call(this, t)
					}
					if (2 === arguments.length) {
						var e = arguments[0],
							i = arguments[1];
						we.prototype.query.call(this, e, i)
					} else if (3 === arguments.length) if (R(arguments[2], Ie) && arguments[0] instanceof Object && arguments[1] instanceof Te) {
						var n = arguments[0],
							r = arguments[1],
							o = arguments[2];
						we.prototype.query.call(this, n, r, o)
					} else if (R(arguments[2], v) && arguments[0] instanceof Object && arguments[1] instanceof Te) {
						var s = arguments[0],
							a = arguments[1],
							l = arguments[2];
						we.prototype.query.call(this, s, a, l)
					}
				},
				getComparator: function() {
					return Ne.yComparator
				},
				createParentBoundablesFromVerticalSlice: function(t, e) {
					return we.prototype.createParentBoundables.call(this, t, e)
				},
				remove: function() {
					if (2 === arguments.length) {
						var t = arguments[0],
							e = arguments[1];
						return we.prototype.remove.call(this, t, e)
					}
					return we.prototype.remove.apply(this, arguments)
				},
				depth: function() {
					return 0 === arguments.length ? we.prototype.depth.call(this) : we.prototype.depth.apply(this, arguments)
				},
				createParentBoundables: function(t, e) {
					d.isTrue(!t.isEmpty());
					var i = Math.trunc(Math.ceil(t.size() / this.getNodeCapacity())),
						n = new E(t);
					Jo.sort(n, Ne.xComparator);
					var r = this.verticalSlices(n, Math.trunc(Math.ceil(Math.sqrt(i))));
					return this.createParentBoundablesFromVerticalSlices(r, e)
				},
				nearestNeighbour: function() {
					if (1 === arguments.length) {
						if (R(arguments[0], Le)) {
							var t = arguments[0],
								e = new Re(this.getRoot(), this.getRoot(), t);
							return this.nearestNeighbour(e)
						}
						if (arguments[0] instanceof Re) {
							var i = arguments[0];
							return this.nearestNeighbour(i, r.POSITIVE_INFINITY)
						}
					} else if (2 === arguments.length) {
						if (arguments[0] instanceof Ne && R(arguments[1], Le)) {
							var n = arguments[0],
								o = arguments[1];
							return e = new Re(this.getRoot(), n.getRoot(), o), this.nearestNeighbour(e)
						}
						if (arguments[0] instanceof Re && "number" == typeof arguments[1]) {
							var s = arguments[0],
								a = arguments[1],
								l = a,
								u = null,
								h = new Ce;
							for (h.add(s); !h.isEmpty() && l > 0;) {
								var c = h.poll(),
									d = c.getDistance();
								if (d >= l) break;
								c.isLeaves() ? (l = d, u = c) : c.expandToQueue(h, l)
							}
							return [u.getBoundable(0).getItem(), u.getBoundable(1).getItem()]
						}
					} else if (3 === arguments.length) {
						var f = arguments[0],
							A = arguments[1],
							p = arguments[2],
							g = new xe(f, A);
						return e = new Re(this.getRoot(), g, p), this.nearestNeighbour(e)[0]
					}
				},
				interfaces_: function() {
					return [Se, l]
				},
				getClass: function() {
					return Ne
				}
			}), Ne.centreX = function(t) {
				return Ne.avg(t.getMinX(), t.getMaxX())
			}, Ne.avg = function(t, e) {
				return (t + e) / 2
			}, Ne.centreY = function(t) {
				return Ne.avg(t.getMinY(), t.getMaxY())
			}, h(Pe, Te), e(Pe.prototype, {
				computeBounds: function() {
					for (var t = null, e = this.getChildBoundables().iterator(); e.hasNext();) {
						var i = e.next();
						null === t ? t = new C(i.getBounds()) : t.expandToInclude(i.getBounds())
					}
					return t
				},
				interfaces_: function() {
					return []
				},
				getClass: function() {
					return Pe
				}
			}), Ne.STRtreeNode = Pe, Ne.serialVersionUID = 0x39920f7d5f261e0, Ne.xComparator = {
				interfaces_: function() {
					return [a]
				},
				compare: function(t, e) {
					return we.compareDoubles(Ne.centreX(t.getBounds()), Ne.centreX(e.getBounds()))
				}
			}, Ne.yComparator = {
				interfaces_: function() {
					return [a]
				},
				compare: function(t, e) {
					return we.compareDoubles(Ne.centreY(t.getBounds()), Ne.centreY(e.getBounds()))
				}
			}, Ne.intersectsOp = {
				interfaces_: function() {
					return [IntersectsOp]
				},
				intersects: function(t, e) {
					return t.intersects(e)
				}
			}, Ne.DEFAULT_NODE_CAPACITY = 10, e(Oe.prototype, {
				interfaces_: function() {
					return []
				},
				getClass: function() {
					return Oe
				}
			}), Oe.relativeSign = function(t, e) {
				return e > t ? -1 : t > e ? 1 : 0
			}, Oe.compare = function(t, e, i) {
				if (e.equals2D(i)) return 0;
				var n = Oe.relativeSign(e.x, i.x),
					r = Oe.relativeSign(e.y, i.y);
				switch (t) {
				case 0:
					return Oe.compareValue(n, r);
				case 1:
					return Oe.compareValue(r, n);
				case 2:
					return Oe.compareValue(r, -n);
				case 3:
					return Oe.compareValue(-n, r);
				case 4:
					return Oe.compareValue(-n, -r);
				case 5:
					return Oe.compareValue(-r, -n);
				case 6:
					return Oe.compareValue(-r, n);
				case 7:
					return Oe.compareValue(n, -r)
				}
				return d.shouldNeverReachHere("invalid octant value"), 0
			}, Oe.compareValue = function(t, e) {
				return 0 > t ? -1 : t > 0 ? 1 : 0 > e ? -1 : e > 0 ? 1 : 0
			}, e(Me.prototype, {
				getCoordinate: function() {
					return this.coord
				},
				print: function(t) {
					t.print(this.coord), t.print(" seg # = " + this.segmentIndex)
				},
				compareTo: function(t) {
					var e = t;
					return this.segmentIndex < e.segmentIndex ? -1 : this.segmentIndex > e.segmentIndex ? 1 : this.coord.equals2D(e.coord) ? 0 : Oe.compare(this.segmentOctant, this.coord, e.coord)
				},
				isEndPoint: function(t) {
					return 0 === this.segmentIndex && !this._isInterior || this.segmentIndex === t
				},
				isInterior: function() {
					return this._isInterior
				},
				interfaces_: function() {
					return [o]
				},
				getClass: function() {
					return Me
				}
			}), e(be.prototype, {
				getSplitCoordinates: function() {
					var t = new x;
					this.addEndpoints();
					for (var e = this.iterator(), i = e.next(); e.hasNext();) {
						var n = e.next();
						this.addEdgeCoordinates(i, n, t), i = n
					}
					return t.toCoordinateArray()
				},
				addCollapsedNodes: function() {
					var t = new E;
					this.findCollapsesFromInsertedNodes(t), this.findCollapsesFromExistingVertices(t);
					for (var e = t.iterator(); e.hasNext();) {
						var i = e.next().intValue();
						this.add(this.edge.getCoordinate(i), i)
					}
				},
				print: function(t) {
					t.println("Intersections:");
					for (var e = this.iterator(); e.hasNext();) e.next().print(t)
				},
				findCollapsesFromExistingVertices: function(t) {
					for (var e = 0; e < this.edge.size() - 2; e++) {
						var i = this.edge.getCoordinate(e),
							n = (this.edge.getCoordinate(e + 1), this.edge.getCoordinate(e + 2));
						i.equals2D(n) && t.add(new N(e + 1))
					}
				},
				addEdgeCoordinates: function(t, e, i) {
					e.segmentIndex, t.segmentIndex;
					var n = this.edge.getCoordinate(e.segmentIndex),
						r = e.isInterior() || !e.coord.equals2D(n);
					i.add(new f(t.coord), !1);
					for (var o = t.segmentIndex + 1; o <= e.segmentIndex; o++) i.add(this.edge.getCoordinate(o));
					r && i.add(new f(e.coord))
				},
				iterator: function() {
					return this.nodeMap.values().iterator()
				},
				addSplitEdges: function(t) {
					this.addEndpoints(), this.addCollapsedNodes();
					for (var e = this.iterator(), i = e.next(); e.hasNext();) {
						var n = e.next(),
							r = this.createSplitEdge(i, n);
						t.add(r), i = n
					}
				},
				findCollapseIndex: function(t, e, i) {
					if (!t.coord.equals2D(e.coord)) return !1;
					var n = e.segmentIndex - t.segmentIndex;
					return e.isInterior() || n--, 1 === n && (i[0] = t.segmentIndex + 1, !0)
				},
				findCollapsesFromInsertedNodes: function(t) {
					for (var e = new Array(1).fill(null), i = this.iterator(), n = i.next(); i.hasNext();) {
						var r = i.next();
						this.findCollapseIndex(n, r, e) && t.add(new N(e[0])), n = r
					}
				},
				getEdge: function() {
					return this.edge
				},
				addEndpoints: function() {
					var t = this.edge.size() - 1;
					this.add(this.edge.getCoordinate(0), 0), this.add(this.edge.getCoordinate(t), t)
				},
				createSplitEdge: function(t, e) {
					var i = e.segmentIndex - t.segmentIndex + 2,
						n = this.edge.getCoordinate(e.segmentIndex),
						r = e.isInterior() || !e.coord.equals2D(n);
					r || i--;
					var o = new Array(i).fill(null),
						s = 0;
					o[s++] = new f(t.coord);
					for (var a = t.segmentIndex + 1; a <= e.segmentIndex; a++) o[s++] = this.edge.getCoordinate(a);
					return r && (o[s] = new f(e.coord)), new Ge(o, this.edge.getData())
				},
				add: function(t, e) {
					var i = new Me(this.edge, t, e, this.edge.getSegmentOctant(e)),
						n = this.nodeMap.get(i);
					return null !== n ? (d.isTrue(n.coord.equals2D(t), "Found equal nodes with different coordinates"), n) : (this.nodeMap.put(i, i), i)
				},
				checkSplitEdgesCorrectness: function(t) {
					var e = this.edge.getCoordinates(),
						i = t.get(0).getCoordinate(0);
					if (!i.equals2D(e[0])) throw new u("bad split edge start point at " + i);
					var n = t.get(t.size() - 1).getCoordinates(),
						r = n[n.length - 1];
					if (!r.equals2D(e[e.length - 1])) throw new u("bad split edge end point at " + r)
				},
				interfaces_: function() {
					return []
				},
				getClass: function() {
					return be
				}
			}), e(Fe.prototype, {
				next: function() {
					return null === this.currNode ? (this.currNode = this.nextNode, this.currSegIndex = this.currNode.segmentIndex, this.readNextNode(), this.currNode) : null === this.nextNode ? null : this.nextNode.segmentIndex === this.currNode.segmentIndex ? (this.currNode = this.nextNode, this.currSegIndex = this.currNode.segmentIndex, this.readNextNode(), this.currNode) : (this.nextNode.segmentIndex, this.currNode.segmentIndex, null)
				},
				remove: function() {
					throw new UnsupportedOperationException(this.getClass().getName())
				},
				hasNext: function() {
					return null !== this.nextNode
				},
				readNextNode: function() {
					this.nodeIt.hasNext() ? this.nextNode = this.nodeIt.next() : this.nextNode = null
				},
				interfaces_: function() {
					return [p]
				},
				getClass: function() {
					return Fe
				}
			}), e(De.prototype, {
				addIntersection: function(t, e) {},
				interfaces_: function() {
					return [ye]
				},
				getClass: function() {
					return De
				}
			}), e(Ge.prototype, {
				getCoordinates: function() {
					return this.pts
				},
				size: function() {
					return this.pts.length
				},
				getCoordinate: function(t) {
					return this.pts[t]
				},
				isClosed: function() {
					return this.pts[0].equals(this.pts[this.pts.length - 1])
				},
				getSegmentOctant: function(t) {
					return t === this.pts.length - 1 ? -1 : this.safeOctant(this.getCoordinate(t), this.getCoordinate(t + 1))
				},
				setData: function(t) {
					this.data = t
				},
				safeOctant: function(t, e) {
					return t.equals2D(e) ? 0 : ve.octant(t, e)
				},
				getData: function() {
					return this.data
				},
				addIntersection: function() {
					if (2 === arguments.length) {
						var t = arguments[0],
							e = arguments[1];
						this.addIntersectionNode(t, e)
					} else if (4 === arguments.length) {
						var i = arguments[0],
							n = arguments[1],
							r = (arguments[2], arguments[3]),
							o = new f(i.getIntersection(r));
						this.addIntersection(o, n)
					}
				},
				toString: function() {
					return Ht.toLineString(new Dt(this.pts))
				},
				getNodeList: function() {
					return this.nodeList
				},
				addIntersectionNode: function(t, e) {
					var i = e,
						n = i + 1;
					if (n < this.pts.length) {
						var r = this.pts[n];
						t.equals2D(r) && (i = n)
					}
					return this.nodeList.add(t, i)
				},
				addIntersections: function(t, e, i) {
					for (var n = 0; n < t.getIntersectionNum(); n++) this.addIntersection(t, e, i, n)
				},
				interfaces_: function() {
					return [De]
				},
				getClass: function() {
					return Ge
				}
			}), Ge.getNodedSubstrings = function() {
				if (1 === arguments.length) {
					var t = arguments[0],
						e = new E;
					return Ge.getNodedSubstrings(t, e), e
				}
				if (2 === arguments.length) for (var i = arguments[0], n = arguments[1], r = i.iterator(); r.hasNext();) {
					var o = r.next();
					o.getNodeList().addSplitEdges(n)
				}
			}, e(ke.prototype, {
				overlap: function() {
					if (2 === arguments.length) arguments[0], arguments[1];
					else if (4 === arguments.length) {
						var t = arguments[0],
							e = arguments[1],
							i = arguments[2],
							n = arguments[3];
						t.getLineSegment(e, this.overlapSeg1), i.getLineSegment(n, this.overlapSeg2), this.overlap(this.overlapSeg1, this.overlapSeg2)
					}
				},
				interfaces_: function() {
					return []
				},
				getClass: function() {
					return ke
				}
			}), e(Ue.prototype, {
				getLineSegment: function(t, e) {
					e.p0 = this.pts[t], e.p1 = this.pts[t + 1]
				},
				computeSelect: function(t, e, i, n) {
					var r = this.pts[e],
						o = this.pts[i];
					if (n.tempEnv1.init(r, o), i - e == 1) return n.select(this, e), null;
					if (!t.intersects(n.tempEnv1)) return null;
					var s = Math.trunc((e + i) / 2);
					s > e && this.computeSelect(t, e, s, n), i > s && this.computeSelect(t, s, i, n)
				},
				getCoordinates: function() {
					for (var t = new Array(this.end - this.start + 1).fill(null), e = 0, i = this.start; i <= this.end; i++) t[e++] = this.pts[i];
					return t
				},
				computeOverlaps: function(t, e) {
					this.computeOverlapsInternal(this.start, this.end, t, t.start, t.end, e)
				},
				setId: function(t) {
					this.id = t
				},
				select: function(t, e) {
					this.computeSelect(t, this.start, this.end, e)
				},
				getEnvelope: function() {
					if (null === this.env) {
						var t = this.pts[this.start],
							e = this.pts[this.end];
						this.env = new C(t, e)
					}
					return this.env
				},
				getEndIndex: function() {
					return this.end
				},
				getStartIndex: function() {
					return this.start
				},
				getContext: function() {
					return this.context
				},
				getId: function() {
					return this.id
				},
				computeOverlapsInternal: function(t, e, i, n, r, o) {
					var s = this.pts[t],
						a = this.pts[e],
						l = i.pts[n],
						u = i.pts[r];
					if (e - t == 1 && r - n == 1) return o.overlap(this, t, i, n), null;
					if (o.tempEnv1.init(s, a), o.tempEnv2.init(l, u), !o.tempEnv1.intersects(o.tempEnv2)) return null;
					var h = Math.trunc((t + e) / 2),
						c = Math.trunc((n + r) / 2);
					h > t && (c > n && this.computeOverlapsInternal(t, h, i, n, c, o), r > c && this.computeOverlapsInternal(t, h, i, c, r, o)), e > h && (c > n && this.computeOverlapsInternal(h, e, i, n, c, o), r > c && this.computeOverlapsInternal(h, e, i, c, r, o))
				},
				interfaces_: function() {
					return []
				},
				getClass: function() {
					return Ue
				}
			}), e(Be.prototype, {
				interfaces_: function() {
					return []
				},
				getClass: function() {
					return Be
				}
			}), Be.isNorthern = function(t) {
				return t === Be.NE || t === Be.NW
			}, Be.isOpposite = function(t, e) {
				return t !== e && 2 == (t - e + 4) % 4
			}, Be.commonHalfPlane = function(t, e) {
				if (t === e) return t;
				if (2 == (t - e + 4) % 4) return -1;
				var i = e > t ? t : e;
				return 0 === i && 3 === (t > e ? t : e) ? 3 : i
			}, Be.isInHalfPlane = function(t, e) {
				return e === Be.SE ? t === Be.SE || t === Be.SW : t === e || t === e + 1
			}, Be.quadrant = function() {
				if ("number" == typeof arguments[0] && "number" == typeof arguments[1]) {
					var t = arguments[0],
						e = arguments[1];
					if (0 === t && 0 === e) throw new n("Cannot compute the quadrant for point ( " + t + ", " + e + " )");
					return t >= 0 ? e >= 0 ? Be.NE : Be.SE : e >= 0 ? Be.NW : Be.SW
				}
				if (arguments[0] instanceof f && arguments[1] instanceof f) {
					var i = arguments[0],
						r = arguments[1];
					if (r.x === i.x && r.y === i.y) throw new n("Cannot compute the quadrant for two identical points " + i);
					return r.x >= i.x ? r.y >= i.y ? Be.NE : Be.SE : r.y >= i.y ? Be.NW : Be.SW
				}
			}, Be.NE = 0, Be.NW = 1, Be.SW = 2, Be.SE = 3, e(je.prototype, {
				interfaces_: function() {
					return []
				},
				getClass: function() {
					return je
				}
			}), je.getChainStartIndices = function(t) {
				var e = 0,
					i = new E;
				i.add(new N(e));
				do {
					var n = je.findChainEnd(t, e);
					i.add(new N(n)), e = n
				} while (e < t.length - 1);
				return je.toIntArray(i)
			}, je.findChainEnd = function(t, e) {
				for (var i = e; i < t.length - 1 && t[i].equals2D(t[i + 1]);) i++;
				if (i >= t.length - 1) return t.length - 1;
				for (var n = Be.quadrant(t[i], t[i + 1]), r = e + 1; r < t.length && (t[r - 1].equals2D(t[r]) || Be.quadrant(t[r - 1], t[r]) === n);) r++;
				return r - 1
			}, je.getChains = function() {
				if (1 === arguments.length) {
					var t = arguments[0];
					return je.getChains(t, null)
				}
				if (2 === arguments.length) {
					for (var e = arguments[0], i = arguments[1], n = new E, r = je.getChainStartIndices(e), o = 0; o < r.length - 1; o++) {
						var s = new Ue(e, r[o], r[o + 1], i);
						n.add(s)
					}
					return n
				}
			}, je.toIntArray = function(t) {
				for (var e = new Array(t.size()).fill(null), i = 0; i < e.length; i++) e[i] = t.get(i).intValue();
				return e
			}, e(Ve.prototype, {
				computeNodes: function(t) {},
				getNodedSubstrings: function() {},
				interfaces_: function() {
					return []
				},
				getClass: function() {
					return Ve
				}
			}), e(Ye.prototype, {
				setSegmentIntersector: function(t) {
					this.segInt = t
				},
				interfaces_: function() {
					return [Ve]
				},
				getClass: function() {
					return Ye
				}
			}), h(ze, Ye), e(ze.prototype, {
				getMonotoneChains: function() {
					return this.monoChains
				},
				getNodedSubstrings: function() {
					return Ge.getNodedSubstrings(this.nodedSegStrings)
				},
				getIndex: function() {
					return this.index
				},
				add: function(t) {
					for (var e = je.getChains(t.getCoordinates(), t).iterator(); e.hasNext();) {
						var i = e.next();
						i.setId(this.idCounter++), this.index.insert(i.getEnvelope(), i), this.monoChains.add(i)
					}
				},
				computeNodes: function(t) {
					this.nodedSegStrings = t;
					for (var e = t.iterator(); e.hasNext();) this.add(e.next());
					this.intersectChains()
				},
				intersectChains: function() {
					for (var t = new Xe(this.segInt), e = this.monoChains.iterator(); e.hasNext();) for (var i = e.next(), n = this.index.query(i.getEnvelope()).iterator(); n.hasNext();) {
						var r = n.next();
						if (r.getId() > i.getId() && (i.computeOverlaps(r, t), this.nOverlaps++), this.segInt.isDone()) return null
					}
				},
				interfaces_: function() {
					return []
				},
				getClass: function() {
					return ze
				}
			}), h(Xe, ke), e(Xe.prototype, {
				overlap: function() {
					if (4 !== arguments.length) return ke.prototype.overlap.apply(this, arguments);
					var t = arguments[0],
						e = arguments[1],
						i = arguments[2],
						n = arguments[3],
						r = t.getContext(),
						o = i.getContext();
					this.si.processIntersections(r, e, o, n)
				},
				interfaces_: function() {
					return []
				},
				getClass: function() {
					return Xe
				}
			}), ze.SegmentOverlapAction = Xe, h(We, u), e(We.prototype, {
				getCoordinate: function() {
					return this.pt
				},
				interfaces_: function() {
					return []
				},
				getClass: function() {
					return We
				}
			}), We.msgWithCoord = function(t, e) {
				return null !== e ? t + " [ " + e + " ]" : t
			}, e(qe.prototype, {
				processIntersections: function(t, e, i, n) {},
				isDone: function() {},
				interfaces_: function() {
					return []
				},
				getClass: function() {
					return qe
				}
			}), e(He.prototype, {
				getInteriorIntersection: function() {
					return this.interiorIntersection
				},
				setCheckEndSegmentsOnly: function(t) {
					this.isCheckEndSegmentsOnly = t
				},
				getIntersectionSegments: function() {
					return this.intSegments
				},
				count: function() {
					return this.intersectionCount
				},
				getIntersections: function() {
					return this.intersections
				},
				setFindAllIntersections: function(t) {
					this.findAllIntersections = t
				},
				setKeepIntersections: function(t) {
					this.keepIntersections = t
				},
				processIntersections: function(t, e, i, n) {
					if (!this.findAllIntersections && this.hasIntersection()) return null;
					if (t === i && e === n) return null;
					if (this.isCheckEndSegmentsOnly && !this.isEndSegment(t, e) && !this.isEndSegment(i, n)) return null;
					var r = t.getCoordinates()[e],
						o = t.getCoordinates()[e + 1],
						s = i.getCoordinates()[n],
						a = i.getCoordinates()[n + 1];
					this.li.computeIntersection(r, o, s, a), this.li.hasIntersection() && this.li.isInteriorIntersection() && (this.intSegments = new Array(4).fill(null), this.intSegments[0] = r, this.intSegments[1] = o, this.intSegments[2] = s, this.intSegments[3] = a, this.interiorIntersection = this.li.getIntersection(0), this.keepIntersections && this.intersections.add(this.interiorIntersection), this.intersectionCount++)
				},
				isEndSegment: function(t, e) {
					return 0 === e || e >= t.size() - 2
				},
				hasIntersection: function() {
					return null !== this.interiorIntersection
				},
				isDone: function() {
					return !this.findAllIntersections && null !== this.interiorIntersection
				},
				interfaces_: function() {
					return [qe]
				},
				getClass: function() {
					return He
				}
			}), He.createAllIntersectionsFinder = function(t) {
				var e = new He(t);
				return e.setFindAllIntersections(!0), e
			}, He.createAnyIntersectionFinder = function(t) {
				return new He(t)
			}, He.createIntersectionCounter = function(t) {
				var e = new He(t);
				return e.setFindAllIntersections(!0), e.setKeepIntersections(!1), e
			}, e(Ze.prototype, {
				execute: function() {
					return null !== this.segInt ? null : void this.checkInteriorIntersections()
				},
				getIntersections: function() {
					return this.segInt.getIntersections()
				},
				isValid: function() {
					return this.execute(), this._isValid
				},
				setFindAllIntersections: function(t) {
					this.findAllIntersections = t
				},
				checkInteriorIntersections: function() {
					this._isValid = !0, this.segInt = new He(this.li), this.segInt.setFindAllIntersections(this.findAllIntersections);
					var t = new ze;
					return t.setSegmentIntersector(this.segInt), t.computeNodes(this.segStrings), this.segInt.hasIntersection() ? (this._isValid = !1, null) : void 0
				},
				checkValid: function() {
					if (this.execute(), !this._isValid) throw new We(this.getErrorMessage(), this.segInt.getInteriorIntersection())
				},
				getErrorMessage: function() {
					if (this._isValid) return "no intersections found";
					var t = this.segInt.getIntersectionSegments();
					return "found non-noded intersection between " + Ht.toLineString(t[0], t[1]) + " and " + Ht.toLineString(t[2], t[3])
				},
				interfaces_: function() {
					return []
				},
				getClass: function() {
					return Ze
				}
			}), Ze.computeIntersections = function(t) {
				var e = new Ze(t);
				return e.setFindAllIntersections(!0), e.isValid(), e.getIntersections()
			}, e(Ke.prototype, {
				checkValid: function() {
					this.nv.checkValid()
				},
				interfaces_: function() {
					return []
				},
				getClass: function() {
					return Ke
				}
			}), Ke.toSegmentStrings = function(t) {
				for (var e = new E, i = t.iterator(); i.hasNext();) {
					var n = i.next();
					e.add(new _e(n.getCoordinates(), n))
				}
				return e
			}, Ke.checkValid = function(t) {
				new Ke(t).checkValid()
			}, e(Je.prototype, {
				map: function(t) {
					for (var e = new E, i = 0; i < t.getNumGeometries(); i++) {
						var n = this.mapOp.map(t.getGeometryN(i));
						n.isEmpty() || e.add(n)
					}
					return t.getFactory().createGeometryCollection(Wt.toGeometryArray(e))
				},
				interfaces_: function() {
					return []
				},
				getClass: function() {
					return Je
				}
			}), Je.map = function(t, e) {
				return new Je(e).map(t)
			}, e(Qe.prototype, {
				interfaces_: function() {
					return []
				},
				getClass: function() {
					return Qe
				}
			}), Qe.opposite = function(t) {
				return t === Qe.LEFT ? Qe.RIGHT : t === Qe.RIGHT ? Qe.LEFT : t
			}, Qe.ON = 0, Qe.LEFT = 1, Qe.RIGHT = 2, e($e.prototype, {
				setAllLocations: function(t) {
					for (var e = 0; e < this.location.length; e++) this.location[e] = t
				},
				isNull: function() {
					for (var t = 0; t < this.location.length; t++) if (this.location[t] !== T.NONE) return !1;
					return !0
				},
				setAllLocationsIfNull: function(t) {
					for (var e = 0; e < this.location.length; e++) this.location[e] === T.NONE && (this.location[e] = t)
				},
				isLine: function() {
					return 1 === this.location.length
				},
				merge: function(t) {
					if (t.location.length > this.location.length) {
						var e = new Array(3).fill(null);
						e[Qe.ON] = this.location[Qe.ON], e[Qe.LEFT] = T.NONE, e[Qe.RIGHT] = T.NONE, this.location = e
					}
					for (var i = 0; i < this.location.length; i++) this.location[i] === T.NONE && i < t.location.length && (this.location[i] = t.location[i])
				},
				getLocations: function() {
					return this.location
				},
				flip: function() {
					if (this.location.length <= 1) return null;
					var t = this.location[Qe.LEFT];
					this.location[Qe.LEFT] = this.location[Qe.RIGHT], this.location[Qe.RIGHT] = t
				},
				toString: function() {
					var t = new L;
					return this.location.length > 1 && t.append(T.toLocationSymbol(this.location[Qe.LEFT])), t.append(T.toLocationSymbol(this.location[Qe.ON])), this.location.length > 1 && t.append(T.toLocationSymbol(this.location[Qe.RIGHT])), t.toString()
				},
				setLocations: function(t, e, i) {
					this.location[Qe.ON] = t, this.location[Qe.LEFT] = e, this.location[Qe.RIGHT] = i
				},
				get: function(t) {
					return t < this.location.length ? this.location[t] : T.NONE
				},
				isArea: function() {
					return this.location.length > 1
				},
				isAnyNull: function() {
					for (var t = 0; t < this.location.length; t++) if (this.location[t] === T.NONE) return !0;
					return !1
				},
				setLocation: function() {
					if (1 === arguments.length) {
						var t = arguments[0];
						this.setLocation(Qe.ON, t)
					} else if (2 === arguments.length) {
						var e = arguments[0],
							i = arguments[1];
						this.location[e] = i
					}
				},
				init: function(t) {
					this.location = new Array(t).fill(null), this.setAllLocations(T.NONE)
				},
				isEqualOnSide: function(t, e) {
					return this.location[e] === t.location[e]
				},
				allPositionsEqual: function(t) {
					for (var e = 0; e < this.location.length; e++) if (this.location[e] !== t) return !1;
					return !0
				},
				interfaces_: function() {
					return []
				},
				getClass: function() {
					return $e
				}
			}), e(ti.prototype, {
				getGeometryCount: function() {
					var t = 0;
					return this.elt[0].isNull() || t++, this.elt[1].isNull() || t++, t
				},
				setAllLocations: function(t, e) {
					this.elt[t].setAllLocations(e)
				},
				isNull: function(t) {
					return this.elt[t].isNull()
				},
				setAllLocationsIfNull: function() {
					if (1 === arguments.length) {
						var t = arguments[0];
						this.setAllLocationsIfNull(0, t), this.setAllLocationsIfNull(1, t)
					} else if (2 === arguments.length) {
						var e = arguments[0],
							i = arguments[1];
						this.elt[e].setAllLocationsIfNull(i)
					}
				},
				isLine: function(t) {
					return this.elt[t].isLine()
				},
				merge: function(t) {
					for (var e = 0; 2 > e; e++) null === this.elt[e] && null !== t.elt[e] ? this.elt[e] = new $e(t.elt[e]) : this.elt[e].merge(t.elt[e])
				},
				flip: function() {
					this.elt[0].flip(), this.elt[1].flip()
				},
				getLocation: function() {
					if (1 === arguments.length) {
						var t = arguments[0];
						return this.elt[t].get(Qe.ON)
					}
					if (2 === arguments.length) {
						var e = arguments[0],
							i = arguments[1];
						return this.elt[e].get(i)
					}
				},
				toString: function() {
					var t = new L;
					return null !== this.elt[0] && (t.append("A:"), t.append(this.elt[0].toString())), null !== this.elt[1] && (t.append(" B:"), t.append(this.elt[1].toString())), t.toString()
				},
				isArea: function() {
					if (0 === arguments.length) return this.elt[0].isArea() || this.elt[1].isArea();
					if (1 === arguments.length) {
						var t = arguments[0];
						return this.elt[t].isArea()
					}
				},
				isAnyNull: function(t) {
					return this.elt[t].isAnyNull()
				},
				setLocation: function() {
					if (2 === arguments.length) {
						var t = arguments[0],
							e = arguments[1];
						this.elt[t].setLocation(Qe.ON, e)
					} else if (3 === arguments.length) {
						var i = arguments[0],
							n = arguments[1],
							r = arguments[2];
						this.elt[i].setLocation(n, r)
					}
				},
				isEqualOnSide: function(t, e) {
					return this.elt[0].isEqualOnSide(t.elt[0], e) && this.elt[1].isEqualOnSide(t.elt[1], e)
				},
				allPositionsEqual: function(t, e) {
					return this.elt[t].allPositionsEqual(e)
				},
				toLine: function(t) {
					this.elt[t].isArea() && (this.elt[t] = new $e(this.elt[t].location[0]))
				},
				interfaces_: function() {
					return []
				},
				getClass: function() {
					return ti
				}
			}), ti.toLineLabel = function(t) {
				for (var e = new ti(T.NONE), i = 0; 2 > i; i++) e.setLocation(i, t.getLocation(i));
				return e
			}, e(ei.prototype, {
				computeRing: function() {
					if (null !== this.ring) return null;
					for (var t = new Array(this.pts.size()).fill(null), e = 0; e < this.pts.size(); e++) t[e] = this.pts.get(e);
					this.ring = this.geometryFactory.createLinearRing(t), this._isHole = $t.isCCW(this.ring.getCoordinates())
				},
				isIsolated: function() {
					return 1 === this.label.getGeometryCount()
				},
				computePoints: function(t) {
					this.startDe = t;
					var e = t,
						i = !0;
					do {
						if (null === e) throw new We("Found null DirectedEdge");
						if (e.getEdgeRing() === this) throw new We("Directed Edge visited twice during ring-building at " + e.getCoordinate());
						this.edges.add(e);
						var n = e.getLabel();
						d.isTrue(n.isArea()), this.mergeLabel(n), this.addPoints(e.getEdge(), e.isForward(), i), i = !1, this.setEdgeRing(e, this), e = this.getNext(e)
					} while (e !== this.startDe)
				},
				getLinearRing: function() {
					return this.ring
				},
				getCoordinate: function(t) {
					return this.pts.get(t)
				},
				computeMaxNodeDegree: function() {
					this.maxNodeDegree = 0;
					var t = this.startDe;
					do {
						var e = t.getNode().getEdges().getOutgoingDegree(this);
						e > this.maxNodeDegree && (this.maxNodeDegree = e), t = this.getNext(t)
					} while (t !== this.startDe);
					this.maxNodeDegree *= 2
				},
				addPoints: function(t, e, i) {
					var n = t.getCoordinates();
					if (e) {
						var r = 1;
						i && (r = 0);
						for (var o = r; o < n.length; o++) this.pts.add(n[o])
					} else for (r = n.length - 2, i && (r = n.length - 1), o = r; o >= 0; o--) this.pts.add(n[o])
				},
				isHole: function() {
					return this._isHole
				},
				setInResult: function() {
					var t = this.startDe;
					do {
						t.getEdge().setInResult(!0), t = t.getNext()
					} while (t !== this.startDe)
				},
				containsPoint: function(t) {
					var e = this.getLinearRing();
					if (!e.getEnvelopeInternal().contains(t)) return !1;
					if (!$t.isPointInRing(t, e.getCoordinates())) return !1;
					for (var i = this.holes.iterator(); i.hasNext();) if (i.next().containsPoint(t)) return !1;
					return !0
				},
				addHole: function(t) {
					this.holes.add(t)
				},
				isShell: function() {
					return null === this.shell
				},
				getLabel: function() {
					return this.label
				},
				getEdges: function() {
					return this.edges
				},
				getMaxNodeDegree: function() {
					return this.maxNodeDegree < 0 && this.computeMaxNodeDegree(), this.maxNodeDegree
				},
				getShell: function() {
					return this.shell
				},
				mergeLabel: function() {
					if (1 === arguments.length) {
						var t = arguments[0];
						this.mergeLabel(t, 0), this.mergeLabel(t, 1)
					} else if (2 === arguments.length) {
						var e = arguments[0],
							i = arguments[1],
							n = e.getLocation(i, Qe.RIGHT);
						if (n === T.NONE) return null;
						if (this.label.getLocation(i) === T.NONE) return this.label.setLocation(i, n), null
					}
				},
				setShell: function(t) {
					this.shell = t, null !== t && t.addHole(this)
				},
				toPolygon: function(t) {
					for (var e = new Array(this.holes.size()).fill(null), i = 0; i < this.holes.size(); i++) e[i] = this.holes.get(i).getLinearRing();
					return t.createPolygon(this.getLinearRing(), e)
				},
				interfaces_: function() {
					return []
				},
				getClass: function() {
					return ei
				}
			}), h(ii, ei), e(ii.prototype, {
				setEdgeRing: function(t, e) {
					t.setMinEdgeRing(e)
				},
				getNext: function(t) {
					return t.getNextMin()
				},
				interfaces_: function() {
					return []
				},
				getClass: function() {
					return ii
				}
			}), h(ni, ei), e(ni.prototype, {
				buildMinimalRings: function() {
					var t = new E,
						e = this.startDe;
					do {
						if (null === e.getMinEdgeRing()) {
							var i = new ii(e, this.geometryFactory);
							t.add(i)
						}
						e = e.getNext()
					} while (e !== this.startDe);
					return t
				},
				setEdgeRing: function(t, e) {
					t.setEdgeRing(e)
				},
				linkDirectedEdgesForMinimalEdgeRings: function() {
					var t = this.startDe;
					do {
						t.getNode().getEdges().linkMinimalDirectedEdges(this), t = t.getNext()
					} while (t !== this.startDe)
				},
				getNext: function(t) {
					return t.getNext()
				},
				interfaces_: function() {
					return []
				},
				getClass: function() {
					return ni
				}
			}), e(ri.prototype, {
				setVisited: function(t) {
					this._isVisited = t
				},
				setInResult: function(t) {
					this._isInResult = t
				},
				isCovered: function() {
					return this._isCovered
				},
				isCoveredSet: function() {
					return this._isCoveredSet
				},
				setLabel: function(t) {
					this.label = t
				},
				getLabel: function() {
					return this.label
				},
				setCovered: function(t) {
					this._isCovered = t, this._isCoveredSet = !0
				},
				updateIM: function(t) {
					d.isTrue(this.label.getGeometryCount() >= 2, "found partial label"), this.computeIM(t)
				},
				isInResult: function() {
					return this._isInResult
				},
				isVisited: function() {
					return this._isVisited
				},
				interfaces_: function() {
					return []
				},
				getClass: function() {
					return ri
				}
			}), h(oi, ri), e(oi.prototype, {
				isIncidentEdgeInResult: function() {
					for (var t = this.getEdges().getEdges().iterator(); t.hasNext();) if (t.next().getEdge().isInResult()) return !0;
					return !1
				},
				isIsolated: function() {
					return 1 === this.label.getGeometryCount()
				},
				getCoordinate: function() {
					return this.coord
				},
				print: function(t) {
					t.println("node " + this.coord + " lbl: " + this.label)
				},
				computeIM: function(t) {},
				computeMergedLocation: function(t, e) {
					var i = T.NONE;
					if (i = this.label.getLocation(e), !t.isNull(e)) {
						var n = t.getLocation(e);
						i !== T.BOUNDARY && (i = n)
					}
					return i
				},
				setLabel: function() {
					if (2 !== arguments.length) return ri.prototype.setLabel.apply(this, arguments);
					var t = arguments[0],
						e = arguments[1];
					null === this.label ? this.label = new ti(t, e) : this.label.setLocation(t, e)
				},
				getEdges: function() {
					return this.edges
				},
				mergeLabel: function() {
					if (arguments[0] instanceof oi) {
						var t = arguments[0];
						this.mergeLabel(t.label)
					} else if (arguments[0] instanceof ti) for (var e = arguments[0], i = 0; 2 > i; i++) {
						var n = this.computeMergedLocation(e, i),
							r = this.label.getLocation(i);
						r === T.NONE && this.label.setLocation(i, n)
					}
				},
				add: function(t) {
					this.edges.insert(t), t.setNode(this)
				},
				setLabelBoundary: function(t) {
					if (null === this.label) return null;
					var e = T.NONE;
					null !== this.label && (e = this.label.getLocation(t));
					var i = null;
					switch (e) {
					case T.BOUNDARY:
						i = T.INTERIOR;
						break;
					case T.INTERIOR:
						i = T.BOUNDARY;
						break;
					default:
						i = T.BOUNDARY
					}
					this.label.setLocation(t, i)
				},
				interfaces_: function() {
					return []
				},
				getClass: function() {
					return oi
				}
			}), e(si.prototype, {
				find: function(t) {
					return this.nodeMap.get(t)
				},
				addNode: function() {
					if (arguments[0] instanceof f) {
						var t = arguments[0];
						return null === (e = this.nodeMap.get(t)) && (e = this.nodeFact.createNode(t), this.nodeMap.put(t, e)), e
					}
					if (arguments[0] instanceof oi) {
						var e, i = arguments[0];
						return null === (e = this.nodeMap.get(i.getCoordinate())) ? (this.nodeMap.put(i.getCoordinate(), i), i) : (e.mergeLabel(i), e)
					}
				},
				print: function(t) {
					for (var e = this.iterator(); e.hasNext();) e.next().print(t)
				},
				iterator: function() {
					return this.nodeMap.values().iterator()
				},
				values: function() {
					return this.nodeMap.values()
				},
				getBoundaryNodes: function(t) {
					for (var e = new E, i = this.iterator(); i.hasNext();) {
						var n = i.next();
						n.getLabel().getLocation(t) === T.BOUNDARY && e.add(n)
					}
					return e
				},
				add: function(t) {
					var e = t.getCoordinate();
					this.addNode(e).add(t)
				},
				interfaces_: function() {
					return []
				},
				getClass: function() {
					return si
				}
			}), e(ai.prototype, {
				compareDirection: function(t) {
					return this.dx === t.dx && this.dy === t.dy ? 0 : this.quadrant > t.quadrant ? 1 : this.quadrant < t.quadrant ? -1 : $t.computeOrientation(t.p0, t.p1, this.p1)
				},
				getDy: function() {
					return this.dy
				},
				getCoordinate: function() {
					return this.p0
				},
				setNode: function(t) {
					this.node = t
				},
				print: function(t) {
					var e = Math.atan2(this.dy, this.dx),
						i = this.getClass().getName(),
						n = i.lastIndexOf("."),
						r = i.substring(n + 1);
					t.print("  " + r + ": " + this.p0 + " - " + this.p1 + " " + this.quadrant + ":" + e + "   " + this.label)
				},
				compareTo: function(t) {
					var e = t;
					return this.compareDirection(e)
				},
				getDirectedCoordinate: function() {
					return this.p1
				},
				getDx: function() {
					return this.dx
				},
				getLabel: function() {
					return this.label
				},
				getEdge: function() {
					return this.edge
				},
				getQuadrant: function() {
					return this.quadrant
				},
				getNode: function() {
					return this.node
				},
				toString: function() {
					var t = Math.atan2(this.dy, this.dx),
						e = this.getClass().getName(),
						i = e.lastIndexOf(".");
					return "  " + e.substring(i + 1) + ": " + this.p0 + " - " + this.p1 + " " + this.quadrant + ":" + t + "   " + this.label
				},
				computeLabel: function(t) {},
				init: function(t, e) {
					this.p0 = t, this.p1 = e, this.dx = e.x - t.x, this.dy = e.y - t.y, this.quadrant = Be.quadrant(this.dx, this.dy), d.isTrue(!(0 === this.dx && 0 === this.dy), "EdgeEnd with identical endpoints found")
				},
				interfaces_: function() {
					return [o]
				},
				getClass: function() {
					return ai
				}
			}), h(li, ai), e(li.prototype, {
				getNextMin: function() {
					return this.nextMin
				},
				getDepth: function(t) {
					return this.depth[t]
				},
				setVisited: function(t) {
					this._isVisited = t
				},
				computeDirectedLabel: function() {
					this.label = new ti(this.edge.getLabel()), this._isForward || this.label.flip()
				},
				getNext: function() {
					return this.next
				},
				setDepth: function(t, e) {
					if (-999 !== this.depth[t] && this.depth[t] !== e) throw new We("assigned depths do not match", this.getCoordinate());
					this.depth[t] = e
				},
				isInteriorAreaEdge: function() {
					for (var t = !0, e = 0; 2 > e; e++) this.label.isArea(e) && this.label.getLocation(e, Qe.LEFT) === T.INTERIOR && this.label.getLocation(e, Qe.RIGHT) === T.INTERIOR || (t = !1);
					return t
				},
				setNextMin: function(t) {
					this.nextMin = t
				},
				print: function(t) {
					ai.prototype.print.call(this, t), t.print(" " + this.depth[Qe.LEFT] + "/" + this.depth[Qe.RIGHT]), t.print(" (" + this.getDepthDelta() + ")"), this._isInResult && t.print(" inResult")
				},
				setMinEdgeRing: function(t) {
					this.minEdgeRing = t
				},
				isLineEdge: function() {
					var t = this.label.isLine(0) || this.label.isLine(1),
						e = !this.label.isArea(0) || this.label.allPositionsEqual(0, T.EXTERIOR),
						i = !this.label.isArea(1) || this.label.allPositionsEqual(1, T.EXTERIOR);
					return t && e && i
				},
				setEdgeRing: function(t) {
					this.edgeRing = t
				},
				getMinEdgeRing: function() {
					return this.minEdgeRing
				},
				getDepthDelta: function() {
					var t = this.edge.getDepthDelta();
					return this._isForward || (t = -t), t
				},
				setInResult: function(t) {
					this._isInResult = t
				},
				getSym: function() {
					return this.sym
				},
				isForward: function() {
					return this._isForward
				},
				getEdge: function() {
					return this.edge
				},
				printEdge: function(t) {
					this.print(t), t.print(" "), this._isForward ? this.edge.print(t) : this.edge.printReverse(t)
				},
				setSym: function(t) {
					this.sym = t
				},
				setVisitedEdge: function(t) {
					this.setVisited(t), this.sym.setVisited(t)
				},
				setEdgeDepths: function(t, e) {
					var i = this.getEdge().getDepthDelta();
					this._isForward || (i = -i);
					var n = 1;
					t === Qe.LEFT && (n = -1);
					var r = Qe.opposite(t),
						o = e + i * n;
					this.setDepth(t, e), this.setDepth(r, o)
				},
				getEdgeRing: function() {
					return this.edgeRing
				},
				isInResult: function() {
					return this._isInResult
				},
				setNext: function(t) {
					this.next = t
				},
				isVisited: function() {
					return this._isVisited
				},
				interfaces_: function() {
					return []
				},
				getClass: function() {
					return li
				}
			}), li.depthFactor = function(t, e) {
				return t === T.EXTERIOR && e === T.INTERIOR ? 1 : t === T.INTERIOR && e === T.EXTERIOR ? -1 : 0
			}, e(ui.prototype, {
				createNode: function(t) {
					return new oi(t, null)
				},
				interfaces_: function() {
					return []
				},
				getClass: function() {
					return ui
				}
			}), e(hi.prototype, {
				printEdges: function(t) {
					t.println("Edges:");
					for (var e = 0; e < this.edges.size(); e++) {
						t.println("edge " + e + ":");
						var i = this.edges.get(e);
						i.print(t), i.eiList.print(t)
					}
				},
				find: function(t) {
					return this.nodes.find(t)
				},
				addNode: function() {
					if (arguments[0] instanceof oi) {
						var t = arguments[0];
						return this.nodes.addNode(t)
					}
					if (arguments[0] instanceof f) {
						var e = arguments[0];
						return this.nodes.addNode(e)
					}
				},
				getNodeIterator: function() {
					return this.nodes.iterator()
				},
				linkResultDirectedEdges: function() {
					for (var t = this.nodes.iterator(); t.hasNext();) t.next().getEdges().linkResultDirectedEdges()
				},
				debugPrintln: function(t) {
					F.out.println(t)
				},
				isBoundaryNode: function(t, e) {
					var i = this.nodes.find(e);
					if (null === i) return !1;
					var n = i.getLabel();
					return null !== n && n.getLocation(t) === T.BOUNDARY
				},
				linkAllDirectedEdges: function() {
					for (var t = this.nodes.iterator(); t.hasNext();) t.next().getEdges().linkAllDirectedEdges()
				},
				matchInSameDirection: function(t, e, i, n) {
					return !!t.equals(i) && $t.computeOrientation(t, e, n) === $t.COLLINEAR && Be.quadrant(t, e) === Be.quadrant(i, n)
				},
				getEdgeEnds: function() {
					return this.edgeEndList
				},
				debugPrint: function(t) {
					F.out.print(t)
				},
				getEdgeIterator: function() {
					return this.edges.iterator()
				},
				findEdgeInSameDirection: function(t, e) {
					for (var i = 0; i < this.edges.size(); i++) {
						var n = this.edges.get(i),
							r = n.getCoordinates();
						if (this.matchInSameDirection(t, e, r[0], r[1])) return n;
						if (this.matchInSameDirection(t, e, r[r.length - 1], r[r.length - 2])) return n
					}
					return null
				},
				insertEdge: function(t) {
					this.edges.add(t)
				},
				findEdgeEnd: function(t) {
					for (var e = this.getEdgeEnds().iterator(); e.hasNext();) {
						var i = e.next();
						if (i.getEdge() === t) return i
					}
					return null
				},
				addEdges: function(t) {
					for (var e = t.iterator(); e.hasNext();) {
						var i = e.next();
						this.edges.add(i);
						var n = new li(i, !0),
							r = new li(i, !1);
						n.setSym(r), r.setSym(n), this.add(n), this.add(r)
					}
				},
				add: function(t) {
					this.nodes.add(t), this.edgeEndList.add(t)
				},
				getNodes: function() {
					return this.nodes.values()
				},
				findEdge: function(t, e) {
					for (var i = 0; i < this.edges.size(); i++) {
						var n = this.edges.get(i),
							r = n.getCoordinates();
						if (t.equals(r[0]) && e.equals(r[1])) return n
					}
					return null
				},
				interfaces_: function() {
					return []
				},
				getClass: function() {
					return hi
				}
			}), hi.linkResultDirectedEdges = function(t) {
				for (var e = t.iterator(); e.hasNext();) e.next().getEdges().linkResultDirectedEdges()
			}, e(ci.prototype, {
				sortShellsAndHoles: function(t, e, i) {
					for (var n = t.iterator(); n.hasNext();) {
						var r = n.next();
						r.isHole() ? i.add(r) : e.add(r)
					}
				},
				computePolygons: function(t) {
					for (var e = new E, i = t.iterator(); i.hasNext();) {
						var n = i.next().toPolygon(this.geometryFactory);
						e.add(n)
					}
					return e
				},
				placeFreeHoles: function(t, e) {
					for (var i = e.iterator(); i.hasNext();) {
						var n = i.next();
						if (null === n.getShell()) {
							var r = this.findEdgeRingContaining(n, t);
							if (null === r) throw new We("unable to assign hole to a shell", n.getCoordinate(0));
							n.setShell(r)
						}
					}
				},
				buildMinimalEdgeRings: function(t, e, i) {
					for (var n = new E, r = t.iterator(); r.hasNext();) {
						var o = r.next();
						if (o.getMaxNodeDegree() > 2) {
							o.linkDirectedEdgesForMinimalEdgeRings();
							var s = o.buildMinimalRings(),
								a = this.findShell(s);
							null !== a ? (this.placePolygonHoles(a, s), e.add(a)) : i.addAll(s)
						} else n.add(o)
					}
					return n
				},
				containsPoint: function(t) {
					for (var e = this.shellList.iterator(); e.hasNext();) if (e.next().containsPoint(t)) return !0;
					return !1
				},
				buildMaximalEdgeRings: function(t) {
					for (var e = new E, i = t.iterator(); i.hasNext();) {
						var n = i.next();
						if (n.isInResult() && n.getLabel().isArea() && null === n.getEdgeRing()) {
							var r = new ni(n, this.geometryFactory);
							e.add(r), r.setInResult()
						}
					}
					return e
				},
				placePolygonHoles: function(t, e) {
					for (var i = e.iterator(); i.hasNext();) {
						var n = i.next();
						n.isHole() && n.setShell(t)
					}
				},
				getPolygons: function() {
					return this.computePolygons(this.shellList)
				},
				findEdgeRingContaining: function(t, e) {
					for (var i = t.getLinearRing(), n = i.getEnvelopeInternal(), r = i.getCoordinateN(0), o = null, s = null, a = e.iterator(); a.hasNext();) {
						var l = a.next(),
							u = l.getLinearRing(),
							h = u.getEnvelopeInternal();
						null !== o && (s = o.getLinearRing().getEnvelopeInternal());
						var c = !1;
						h.contains(n) && $t.isPointInRing(r, u.getCoordinates()) && (c = !0), c && (null === o || s.contains(h)) && (o = l)
					}
					return o
				},
				findShell: function(t) {
					for (var e = 0, i = null, n = t.iterator(); n.hasNext();) {
						var r = n.next();
						r.isHole() || (i = r, e++)
					}
					return d.isTrue(1 >= e, "found two shells in MinimalEdgeRing list"), i
				},
				add: function() {
					if (1 === arguments.length) {
						var t = arguments[0];
						this.add(t.getEdgeEnds(), t.getNodes())
					} else if (2 === arguments.length) {
						var e = arguments[0],
							i = arguments[1];
						hi.linkResultDirectedEdges(i);
						var n = this.buildMaximalEdgeRings(e),
							r = new E,
							o = this.buildMinimalEdgeRings(n, this.shellList, r);
						this.sortShellsAndHoles(o, this.shellList, r), this.placeFreeHoles(this.shellList, r)
					}
				},
				interfaces_: function() {
					return []
				},
				getClass: function() {
					return ci
				}
			}), e(di.prototype, {
				collectLines: function(t) {
					for (var e = this.op.getGraph().getEdgeEnds().iterator(); e.hasNext();) {
						var i = e.next();
						this.collectLineEdge(i, t, this.lineEdgesList), this.collectBoundaryTouchEdge(i, t, this.lineEdgesList)
					}
				},
				labelIsolatedLine: function(t, e) {
					var i = this.ptLocator.locate(t.getCoordinate(), this.op.getArgGeometry(e));
					t.getLabel().setLocation(e, i)
				},
				build: function(t) {
					return this.findCoveredLineEdges(), this.collectLines(t), this.buildLines(t), this.resultLineList
				},
				collectLineEdge: function(t, e, i) {
					var n = t.getLabel(),
						r = t.getEdge();
					t.isLineEdge() && (t.isVisited() || !zi.isResultOfOp(n, e) || r.isCovered() || (i.add(r), t.setVisitedEdge(!0)))
				},
				findCoveredLineEdges: function() {
					for (var t = this.op.getGraph().getNodes().iterator(); t.hasNext();) t.next().getEdges().findCoveredLineEdges();
					for (var e = this.op.getGraph().getEdgeEnds().iterator(); e.hasNext();) {
						var i = e.next(),
							n = i.getEdge();
						if (i.isLineEdge() && !n.isCoveredSet()) {
							var r = this.op.isCoveredByA(i.getCoordinate());
							n.setCovered(r)
						}
					}
				},
				labelIsolatedLines: function(t) {
					for (var e = t.iterator(); e.hasNext();) {
						var i = e.next(),
							n = i.getLabel();
						i.isIsolated() && (n.isNull(0) ? this.labelIsolatedLine(i, 0) : this.labelIsolatedLine(i, 1))
					}
				},
				buildLines: function(t) {
					for (var e = this.lineEdgesList.iterator(); e.hasNext();) {
						var i = e.next(),
							n = (i.getLabel(), this.geometryFactory.createLineString(i.getCoordinates()));
						this.resultLineList.add(n), i.setInResult(!0)
					}
				},
				collectBoundaryTouchEdge: function(t, e, i) {
					var n = t.getLabel();
					return t.isLineEdge() ? null : t.isVisited() ? null : t.isInteriorAreaEdge() ? null : t.getEdge().isInResult() ? null : (d.isTrue(!(t.isInResult() || t.getSym().isInResult()) || !t.getEdge().isInResult()), void(zi.isResultOfOp(n, e) && e === zi.INTERSECTION && (i.add(t.getEdge()), t.setVisitedEdge(!0))))
				},
				interfaces_: function() {
					return []
				},
				getClass: function() {
					return di
				}
			}), e(fi.prototype, {
				filterCoveredNodeToPoint: function(t) {
					var e = t.getCoordinate();
					if (!this.op.isCoveredByLA(e)) {
						var i = this.geometryFactory.createPoint(e);
						this.resultPointList.add(i)
					}
				},
				extractNonCoveredResultNodes: function(t) {
					for (var e = this.op.getGraph().getNodes().iterator(); e.hasNext();) {
						var i = e.next();
						if (!(i.isInResult() || i.isIncidentEdgeInResult() || 0 !== i.getEdges().getDegree() && t !== zi.INTERSECTION)) {
							var n = i.getLabel();
							zi.isResultOfOp(n, t) && this.filterCoveredNodeToPoint(i)
						}
					}
				},
				build: function(t) {
					return this.extractNonCoveredResultNodes(t), this.resultPointList
				},
				interfaces_: function() {
					return []
				},
				getClass: function() {
					return fi
				}
			}), e(Ai.prototype, {
				locate: function(t) {},
				interfaces_: function() {
					return []
				},
				getClass: function() {
					return Ai
				}
			}), e(pi.prototype, {
				locate: function(t) {
					return pi.locate(t, this.geom)
				},
				interfaces_: function() {
					return [Ai]
				},
				getClass: function() {
					return pi
				}
			}), pi.isPointInRing = function(t, e) {
				return !!e.getEnvelopeInternal().intersects(t) && $t.isPointInRing(t, e.getCoordinates())
			}, pi.containsPointInPolygon = function(t, e) {
				if (e.isEmpty()) return !1;
				var i = e.getExteriorRing();
				if (!pi.isPointInRing(t, i)) return !1;
				for (var n = 0; n < e.getNumInteriorRing(); n++) {
					var r = e.getInteriorRingN(n);
					if (pi.isPointInRing(t, r)) return !1
				}
				return !0
			}, pi.containsPoint = function(t, e) {
				if (e instanceof Rt) return pi.containsPointInPolygon(t, e);
				if (e instanceof dt) for (var i = new ge(e); i.hasNext();) {
					var n = i.next();
					if (n !== e && pi.containsPoint(t, n)) return !0
				}
				return !1
			}, pi.locate = function(t, e) {
				return e.isEmpty() ? T.EXTERIOR : pi.containsPoint(t, e) ? T.INTERIOR : T.EXTERIOR
			}, e(gi.prototype, {
				getNextCW: function(t) {
					this.getEdges();
					var e = this.edgeList.indexOf(t),
						i = e - 1;
					return 0 === e && (i = this.edgeList.size() - 1), this.edgeList.get(i)
				},
				propagateSideLabels: function(t) {
					for (var e = T.NONE, i = this.iterator(); i.hasNext();)(o = (r = i.next()).getLabel()).isArea(t) && o.getLocation(t, Qe.LEFT) !== T.NONE && (e = o.getLocation(t, Qe.LEFT));
					if (e === T.NONE) return null;
					var n = e;
					for (i = this.iterator(); i.hasNext();) {
						var r, o;
						if ((o = (r = i.next()).getLabel()).getLocation(t, Qe.ON) === T.NONE && o.setLocation(t, Qe.ON, n), o.isArea(t)) {
							var s = o.getLocation(t, Qe.LEFT),
								a = o.getLocation(t, Qe.RIGHT);
							if (a !== T.NONE) {
								if (a !== n) throw new We("side location conflict", r.getCoordinate());
								s === T.NONE && d.shouldNeverReachHere("found single null side (at " + r.getCoordinate() + ")"), n = s
							} else d.isTrue(o.getLocation(t, Qe.LEFT) === T.NONE, "found single null side"), o.setLocation(t, Qe.RIGHT, n), o.setLocation(t, Qe.LEFT, n)
						}
					}
				},
				getCoordinate: function() {
					var t = this.iterator();
					return t.hasNext() ? t.next().getCoordinate() : null
				},
				print: function(t) {
					F.out.println("EdgeEndStar:   " + this.getCoordinate());
					for (var e = this.iterator(); e.hasNext();) e.next().print(t)
				},
				isAreaLabelsConsistent: function(t) {
					return this.computeEdgeEndLabels(t.getBoundaryNodeRule()), this.checkAreaLabelsConsistent(0)
				},
				checkAreaLabelsConsistent: function(t) {
					var e = this.getEdges();
					if (e.size() <= 0) return !0;
					var i = e.size() - 1,
						n = e.get(i).getLabel().getLocation(t, Qe.LEFT);
					d.isTrue(n !== T.NONE, "Found unlabelled area edge");
					for (var r = n, o = this.iterator(); o.hasNext();) {
						var s = o.next().getLabel();
						d.isTrue(s.isArea(t), "Found non-area edge");
						var a = s.getLocation(t, Qe.LEFT),
							l = s.getLocation(t, Qe.RIGHT);
						if (a === l) return !1;
						if (l !== r) return !1;
						r = a
					}
					return !0
				},
				findIndex: function(t) {
					this.iterator();
					for (var e = 0; e < this.edgeList.size(); e++) if (this.edgeList.get(e) === t) return e;
					return -1
				},
				iterator: function() {
					return this.getEdges().iterator()
				},
				getEdges: function() {
					return null === this.edgeList && (this.edgeList = new E(this.edgeMap.values())), this.edgeList
				},
				getLocation: function(t, e, i) {
					return this.ptInAreaLocation[t] === T.NONE && (this.ptInAreaLocation[t] = pi.locate(e, i[t].getGeometry())), this.ptInAreaLocation[t]
				},
				toString: function() {
					var t = new L;
					t.append("EdgeEndStar:   " + this.getCoordinate()), t.append("\n");
					for (var e = this.iterator(); e.hasNext();) {
						var i = e.next();
						t.append(i), t.append("\n")
					}
					return t.toString()
				},
				computeEdgeEndLabels: function(t) {
					for (var e = this.iterator(); e.hasNext();) e.next().computeLabel(t)
				},
				computeLabelling: function(t) {
					this.computeEdgeEndLabels(t[0].getBoundaryNodeRule()), this.propagateSideLabels(0), this.propagateSideLabels(1);
					for (var e = [!1, !1], i = this.iterator(); i.hasNext();) for (var n = (o = i.next()).getLabel(), r = 0; 2 > r; r++) n.isLine(r) && n.getLocation(r) === T.BOUNDARY && (e[r] = !0);
					for (i = this.iterator(); i.hasNext();) {
						var o;
						for (n = (o = i.next()).getLabel(), r = 0; 2 > r; r++) if (n.isAnyNull(r)) {
							var s = T.NONE;
							if (e[r]) s = T.EXTERIOR;
							else {
								var a = o.getCoordinate();
								s = this.getLocation(r, a, t)
							}
							n.setAllLocationsIfNull(r, s)
						}
					}
				},
				getDegree: function() {
					return this.edgeMap.size()
				},
				insertEdgeEnd: function(t, e) {
					this.edgeMap.put(t, e), this.edgeList = null
				},
				interfaces_: function() {
					return []
				},
				getClass: function() {
					return gi
				}
			}), h(mi, gi), e(mi.prototype, {
				linkResultDirectedEdges: function() {
					this.getResultAreaEdges();
					for (var t = null, e = null, i = this.SCANNING_FOR_INCOMING, n = 0; n < this.resultAreaEdgeList.size(); n++) {
						var r = this.resultAreaEdgeList.get(n),
							o = r.getSym();
						if (r.getLabel().isArea()) switch (null === t && r.isInResult() && (t = r), i) {
						case this.SCANNING_FOR_INCOMING:
							if (!o.isInResult()) continue;
							e = o, i = this.LINKING_TO_OUTGOING;
							break;
						case this.LINKING_TO_OUTGOING:
							if (!r.isInResult()) continue;
							e.setNext(r), i = this.SCANNING_FOR_INCOMING
						}
					}
					if (i === this.LINKING_TO_OUTGOING) {
						if (null === t) throw new We("no outgoing dirEdge found", this.getCoordinate());
						d.isTrue(t.isInResult(), "unable to link last incoming dirEdge"), e.setNext(t)
					}
				},
				insert: function(t) {
					var e = t;
					this.insertEdgeEnd(e, e)
				},
				getRightmostEdge: function() {
					var t = this.getEdges(),
						e = t.size();
					if (1 > e) return null;
					var i = t.get(0);
					if (1 === e) return i;
					var n = t.get(e - 1),
						r = i.getQuadrant(),
						o = n.getQuadrant();
					return Be.isNorthern(r) && Be.isNorthern(o) ? i : Be.isNorthern(r) || Be.isNorthern(o) ? 0 !== i.getDy() ? i : 0 !== n.getDy() ? n : (d.shouldNeverReachHere("found two horizontal edges incident on node"), null) : n
				},
				print: function(t) {
					F.out.println("DirectedEdgeStar: " + this.getCoordinate());
					for (var e = this.iterator(); e.hasNext();) {
						var i = e.next();
						t.print("out "), i.print(t), t.println(), t.print("in "), i.getSym().print(t), t.println()
					}
				},
				getResultAreaEdges: function() {
					if (null !== this.resultAreaEdgeList) return this.resultAreaEdgeList;
					this.resultAreaEdgeList = new E;
					for (var t = this.iterator(); t.hasNext();) {
						var e = t.next();
						(e.isInResult() || e.getSym().isInResult()) && this.resultAreaEdgeList.add(e)
					}
					return this.resultAreaEdgeList
				},
				updateLabelling: function(t) {
					for (var e = this.iterator(); e.hasNext();) {
						var i = e.next().getLabel();
						i.setAllLocationsIfNull(0, t.getLocation(0)), i.setAllLocationsIfNull(1, t.getLocation(1))
					}
				},
				linkAllDirectedEdges: function() {
					this.getEdges();
					for (var t = null, e = null, i = this.edgeList.size() - 1; i >= 0; i--) {
						var n = this.edgeList.get(i),
							r = n.getSym();
						null === e && (e = r), null !== t && r.setNext(t), t = n
					}
					e.setNext(t)
				},
				computeDepths: function() {
					if (1 === arguments.length) {
						var t = arguments[0],
							e = this.findIndex(t),
							i = (t.getLabel(), t.getDepth(Qe.LEFT)),
							n = t.getDepth(Qe.RIGHT),
							r = this.computeDepths(e + 1, this.edgeList.size(), i),
							o = this.computeDepths(0, e, r);
						if (o !== n) throw new We("depth mismatch at " + t.getCoordinate())
					} else if (3 === arguments.length) {
						for (var s = arguments[0], a = arguments[1], l = arguments[2], u = l, h = s; a > h; h++) {
							var c = this.edgeList.get(h);
							c.getLabel(), c.setEdgeDepths(Qe.RIGHT, u), u = c.getDepth(Qe.LEFT)
						}
						return u
					}
				},
				mergeSymLabels: function() {
					for (var t = this.iterator(); t.hasNext();) {
						var e = t.next();
						e.getLabel().merge(e.getSym().getLabel())
					}
				},
				linkMinimalDirectedEdges: function(t) {
					for (var e = null, i = null, n = this.SCANNING_FOR_INCOMING, r = this.resultAreaEdgeList.size() - 1; r >= 0; r--) {
						var o = this.resultAreaEdgeList.get(r),
							s = o.getSym();
						switch (null === e && o.getEdgeRing() === t && (e = o), n) {
						case this.SCANNING_FOR_INCOMING:
							if (s.getEdgeRing() !== t) continue;
							i = s, n = this.LINKING_TO_OUTGOING;
							break;
						case this.LINKING_TO_OUTGOING:
							if (o.getEdgeRing() !== t) continue;
							i.setNextMin(o), n = this.SCANNING_FOR_INCOMING
						}
					}
					n === this.LINKING_TO_OUTGOING && (d.isTrue(null !== e, "found null for first outgoing dirEdge"), d.isTrue(e.getEdgeRing() === t, "unable to link last incoming dirEdge"), i.setNextMin(e))
				},
				getOutgoingDegree: function() {
					if (0 === arguments.length) {
						for (var t = 0, e = this.iterator(); e.hasNext();) e.next().isInResult() && t++;
						return t
					}
					if (1 === arguments.length) {
						var i = arguments[0];
						for (t = 0, e = this.iterator(); e.hasNext();) e.next().getEdgeRing() === i && t++;
						return t
					}
				},
				getLabel: function() {
					return this.label
				},
				findCoveredLineEdges: function() {
					for (var t = T.NONE, e = this.iterator(); e.hasNext();) {
						var i = (r = e.next()).getSym();
						if (!r.isLineEdge()) {
							if (r.isInResult()) {
								t = T.INTERIOR;
								break
							}
							if (i.isInResult()) {
								t = T.EXTERIOR;
								break
							}
						}
					}
					if (t === T.NONE) return null;
					var n = t;
					for (e = this.iterator(); e.hasNext();) {
						var r;
						i = (r = e.next()).getSym(), r.isLineEdge() ? r.getEdge().setCovered(n === T.INTERIOR) : (r.isInResult() && (n = T.EXTERIOR), i.isInResult() && (n = T.INTERIOR))
					}
				},
				computeLabelling: function(t) {
					gi.prototype.computeLabelling.call(this, t), this.label = new ti(T.NONE);
					for (var e = this.iterator(); e.hasNext();) for (var i = e.next().getEdge().getLabel(), n = 0; 2 > n; n++) {
						var r = i.getLocation(n);
						r !== T.INTERIOR && r !== T.BOUNDARY || this.label.setLocation(n, T.INTERIOR)
					}
				},
				interfaces_: function() {
					return []
				},
				getClass: function() {
					return mi
				}
			}), h(vi, ui), e(vi.prototype, {
				createNode: function(t) {
					return new oi(t, new mi)
				},
				interfaces_: function() {
					return []
				},
				getClass: function() {
					return vi
				}
			}), e(yi.prototype, {
				computeIntersections: function(t, e) {
					this.mce.computeIntersectsForChain(this.chainIndex, t.mce, t.chainIndex, e)
				},
				interfaces_: function() {
					return []
				},
				getClass: function() {
					return yi
				}
			}), e(_i.prototype, {
				isDelete: function() {
					return this.eventType === _i.DELETE
				},
				setDeleteEventIndex: function(t) {
					this.deleteEventIndex = t
				},
				getObject: function() {
					return this.obj
				},
				compareTo: function(t) {
					var e = t;
					return this.xValue < e.xValue ? -1 : this.xValue > e.xValue ? 1 : this.eventType < e.eventType ? -1 : this.eventType > e.eventType ? 1 : 0
				},
				getInsertEvent: function() {
					return this.insertEvent
				},
				isInsert: function() {
					return this.eventType === _i.INSERT
				},
				isSameLabel: function(t) {
					return null !== this.label && this.label === t.label
				},
				getDeleteEventIndex: function() {
					return this.deleteEventIndex
				},
				interfaces_: function() {
					return [o]
				},
				getClass: function() {
					return _i
				}
			}), _i.INSERT = 1, _i.DELETE = 2, e(Ei.prototype, {
				interfaces_: function() {
					return []
				},
				getClass: function() {
					return Ei
				}
			}), e(xi.prototype, {
				isTrivialIntersection: function(t, e, i, n) {
					if (t === i && 1 === this.li.getIntersectionNum()) {
						if (xi.isAdjacentSegments(e, n)) return !0;
						if (t.isClosed()) {
							var r = t.getNumPoints() - 1;
							if (0 === e && n === r || 0 === n && e === r) return !0
						}
					}
					return !1
				},
				getProperIntersectionPoint: function() {
					return this.properIntersectionPoint
				},
				setIsDoneIfProperInt: function(t) {
					this.isDoneWhenProperInt = t
				},
				hasProperInteriorIntersection: function() {
					return this.hasProperInterior
				},
				isBoundaryPointInternal: function(t, e) {
					for (var i = e.iterator(); i.hasNext();) {
						var n = i.next().getCoordinate();
						if (t.isIntersection(n)) return !0
					}
					return !1
				},
				hasProperIntersection: function() {
					return this.hasProper
				},
				hasIntersection: function() {
					return this._hasIntersection
				},
				isDone: function() {
					return this._isDone
				},
				isBoundaryPoint: function(t, e) {
					return !(null === e || !this.isBoundaryPointInternal(t, e[0]) && !this.isBoundaryPointInternal(t, e[1]))
				},
				setBoundaryNodes: function(t, e) {
					this.bdyNodes = new Array(2).fill(null), this.bdyNodes[0] = t, this.bdyNodes[1] = e
				},
				addIntersections: function(t, e, i, n) {
					if (t === i && e === n) return null;
					this.numTests++;
					var r = t.getCoordinates()[e],
						o = t.getCoordinates()[e + 1],
						s = i.getCoordinates()[n],
						a = i.getCoordinates()[n + 1];
					this.li.computeIntersection(r, o, s, a), this.li.hasIntersection() && (this.recordIsolated && (t.setIsolated(!1), i.setIsolated(!1)), this.numIntersections++, this.isTrivialIntersection(t, e, i, n) || (this._hasIntersection = !0, !this.includeProper && this.li.isProper() || (t.addIntersections(this.li, e, 0), i.addIntersections(this.li, n, 1)), this.li.isProper() && (this.properIntersectionPoint = this.li.getIntersection(0).copy(), this.hasProper = !0, this.isDoneWhenProperInt && (this._isDone = !0), this.isBoundaryPoint(this.li, this.bdyNodes) || (this.hasProperInterior = !0))))
				},
				interfaces_: function() {
					return []
				},
				getClass: function() {
					return xi
				}
			}), xi.isAdjacentSegments = function(t, e) {
				return 1 === Math.abs(t - e)
			}, h(Ci, Ei), e(Ci.prototype, {
				prepareEvents: function() {
					Jo.sort(this.events);
					for (var t = 0; t < this.events.size(); t++) {
						var e = this.events.get(t);
						e.isDelete() && e.getInsertEvent().setDeleteEventIndex(t)
					}
				},
				computeIntersections: function() {
					if (1 === arguments.length) {
						var t = arguments[0];
						this.nOverlaps = 0, this.prepareEvents();
						for (var e = 0; e < this.events.size(); e++) {
							var i = this.events.get(e);
							if (i.isInsert() && this.processOverlaps(e, i.getDeleteEventIndex(), i, t), t.isDone()) break
						}
					} else if (3 === arguments.length) if (arguments[2] instanceof xi && R(arguments[0], v) && R(arguments[1], v)) {
						var n = arguments[0],
							r = arguments[1],
							o = arguments[2];
						this.addEdges(n, n), this.addEdges(r, r), this.computeIntersections(o)
					} else if ("boolean" == typeof arguments[2] && R(arguments[0], v) && arguments[1] instanceof xi) {
						var s = arguments[0],
							a = arguments[1],
							l = arguments[2];
						l ? this.addEdges(s, null) : this.addEdges(s), this.computeIntersections(a)
					}
				},
				addEdge: function(t, e) {
					for (var i = t.getMonotoneChainEdge(), n = i.getStartIndexes(), r = 0; r < n.length - 1; r++) {
						var o = new yi(i, r),
							s = new _i(e, i.getMinX(r), o);
						this.events.add(s), this.events.add(new _i(i.getMaxX(r), s))
					}
				},
				processOverlaps: function(t, e, i, n) {
					for (var r = i.getObject(), o = t; e > o; o++) {
						var s = this.events.get(o);
						if (s.isInsert()) {
							var a = s.getObject();
							i.isSameLabel(s) || (r.computeIntersections(a, n), this.nOverlaps++)
						}
					}
				},
				addEdges: function() {
					if (1 === arguments.length) for (var t = arguments[0], e = t.iterator(); e.hasNext();) {
						var i = e.next();
						this.addEdge(i, i)
					} else if (2 === arguments.length) {
						var n = arguments[0],
							r = arguments[1];
						for (e = n.iterator(); e.hasNext();) i = e.next(), this.addEdge(i, r)
					}
				},
				interfaces_: function() {
					return []
				},
				getClass: function() {
					return Ci
				}
			}), e(Ii.prototype, {
				getMin: function() {
					return this.min
				},
				intersects: function(t, e) {
					return !(this.min > e || this.max < t)
				},
				getMax: function() {
					return this.max
				},
				toString: function() {
					return Ht.toLineString(new f(this.min, 0), new f(this.max, 0))
				},
				interfaces_: function() {
					return []
				},
				getClass: function() {
					return Ii
				}
			}), e(Si.prototype, {
				compare: function(t, e) {
					var i = t,
						n = e,
						r = (i.min + i.max) / 2,
						o = (n.min + n.max) / 2;
					return o > r ? -1 : r > o ? 1 : 0
				},
				interfaces_: function() {
					return [a]
				},
				getClass: function() {
					return Si
				}
			}), Ii.NodeComparator = Si, h(Ti, Ii), e(Ti.prototype, {
				query: function(t, e, i) {
					return this.intersects(t, e) ? void i.visitItem(this.item) : null
				},
				interfaces_: function() {
					return []
				},
				getClass: function() {
					return Ti
				}
			}), h(Ri, Ii), e(Ri.prototype, {
				buildExtent: function(t, e) {
					this.min = Math.min(t.min, e.min), this.max = Math.max(t.max, e.max)
				},
				query: function(t, e, i) {
					return this.intersects(t, e) ? (null !== this.node1 && this.node1.query(t, e, i), void(null !== this.node2 && this.node2.query(t, e, i))) : null
				},
				interfaces_: function() {
					return []
				},
				getClass: function() {
					return Ri
				}
			}), e(wi.prototype, {
				buildTree: function() {
					Jo.sort(this.leaves, new IntervalRTreeNode.NodeComparator);
					for (var t = this.leaves, e = null, i = new E;;) {
						if (this.buildLevel(t, i), 1 === i.size()) return i.get(0);
						e = t, t = i, i = e
					}
				},
				insert: function(t, e, i) {
					if (null !== this.root) throw new IllegalStateException("Index cannot be added to once it has been queried");
					this.leaves.add(new Ti(t, e, i))
				},
				query: function(t, e, i) {
					this.init(), this.root.query(t, e, i)
				},
				buildRoot: function() {
					return null !== this.root ? null : void(this.root = this.buildTree())
				},
				printNode: function(t) {
					F.out.println(Ht.toLineString(new f(t.min, this.level), new f(t.max, this.level)))
				},
				init: function() {
					return null !== this.root ? null : void this.buildRoot()
				},
				buildLevel: function(t, e) {
					this.level++, e.clear();
					for (var i = 0; i < t.size(); i += 2) {
						var n = t.get(i);
						if (null === (i + 1 < t.size() ? t.get(i) : null)) e.add(n);
						else {
							var r = new Ri(t.get(i), t.get(i + 1));
							e.add(r)
						}
					}
				},
				interfaces_: function() {
					return []
				},
				getClass: function() {
					return wi
				}
			}), e(Li.prototype, {
				filter: function(t) {
					if (this.isForcedToLineString && t instanceof Lt) {
						var e = t.getFactory().createLineString(t.getCoordinateSequence());
						return this.lines.add(e), null
					}
					t instanceof Ct && this.lines.add(t)
				},
				setForceToLineString: function(t) {
					this.isForcedToLineString = t
				},
				interfaces_: function() {
					return [k]
				},
				getClass: function() {
					return Li
				}
			}), Li.getGeometry = function() {
				if (1 === arguments.length) {
					var t = arguments[0];
					return t.getFactory().buildGeometry(Li.getLines(t))
				}
				if (2 === arguments.length) {
					var e = arguments[0],
						i = arguments[1];
					return e.getFactory().buildGeometry(Li.getLines(e, i))
				}
			}, Li.getLines = function() {
				if (1 === arguments.length) {
					var t = arguments[0];
					return Li.getLines(t, !1)
				}
				if (2 === arguments.length) {
					if (R(arguments[0], g) && R(arguments[1], g)) {
						for (var e = arguments[0], i = arguments[1], n = e.iterator(); n.hasNext();) {
							var r = n.next();
							Li.getLines(r, i)
						}
						return i
					}
					if (arguments[0] instanceof U && "boolean" == typeof arguments[1]) {
						var o = arguments[0],
							s = arguments[1],
							a = new E;
						return o.apply(new Li(a, s)), a
					}
					if (arguments[0] instanceof U && R(arguments[1], g)) {
						var l = arguments[0],
							u = arguments[1];
						return l instanceof Ct ? u.add(l) : l.apply(new Li(u)), u
					}
				} else if (3 === arguments.length) {
					if ("boolean" == typeof arguments[2] && R(arguments[0], g) && R(arguments[1], g)) {
						var h = arguments[0],
							c = arguments[1],
							d = arguments[2];
						for (n = h.iterator(); n.hasNext();) r = n.next(), Li.getLines(r, c, d);
						return c
					}
					if ("boolean" == typeof arguments[2] && arguments[0] instanceof U && R(arguments[1], g)) {
						var f = arguments[0],
							A = arguments[1],
							p = arguments[2];
						return f.apply(new Li(A, p)), A
					}
				}
			}, e(Ni.prototype, {
				visitItem: function(t) {
					this.items.add(t)
				},
				getItems: function() {
					return this.items
				},
				interfaces_: function() {
					return [Ie]
				},
				getClass: function() {
					return Ni
				}
			}), e(Pi.prototype, {
				locate: function(t) {
					var e = new Qt(t),
						i = new Oi(e);
					return this.index.query(t.y, t.y, i), e.getLocation()
				},
				interfaces_: function() {
					return [Ai]
				},
				getClass: function() {
					return Pi
				}
			}), e(Oi.prototype, {
				visitItem: function(t) {
					var e = t;
					this.counter.countSegment(e.getCoordinate(0), e.getCoordinate(1))
				},
				interfaces_: function() {
					return [Ie]
				},
				getClass: function() {
					return Oi
				}
			}), e(Mi.prototype, {
				init: function(t) {
					for (var e = Li.getLines(t).iterator(); e.hasNext();) {
						var i = e.next().getCoordinates();
						this.addLine(i)
					}
				},
				addLine: function(t) {
					for (var e = 1; e < t.length; e++) {
						var i = new te(t[e - 1], t[e]),
							n = Math.min(i.p0.y, i.p1.y),
							r = Math.max(i.p0.y, i.p1.y);
						this.index.insert(n, r, i)
					}
				},
				query: function() {
					if (2 === arguments.length) {
						var t = arguments[0],
							e = arguments[1],
							i = new Ni;
						return this.index.query(t, e, i), i.getItems()
					}
					if (3 === arguments.length) {
						var n = arguments[0],
							r = arguments[1],
							o = arguments[2];
						this.index.query(n, r, o)
					}
				},
				interfaces_: function() {
					return []
				},
				getClass: function() {
					return Mi
				}
			}), Pi.SegmentVisitor = Oi, Pi.IntervalIndexedGeometry = Mi, e(bi.prototype, {
				getSegmentIndex: function() {
					return this.segmentIndex
				},
				getCoordinate: function() {
					return this.coord
				},
				print: function(t) {
					t.print(this.coord), t.print(" seg # = " + this.segmentIndex), t.println(" dist = " + this.dist)
				},
				compareTo: function(t) {
					var e = t;
					return this.compare(e.segmentIndex, e.dist)
				},
				isEndPoint: function(t) {
					return 0 === this.segmentIndex && 0 === this.dist || this.segmentIndex === t
				},
				toString: function() {
					return this.coord + " seg # = " + this.segmentIndex + " dist = " + this.dist
				},
				getDistance: function() {
					return this.dist
				},
				compare: function(t, e) {
					return this.segmentIndex < t ? -1 : this.segmentIndex > t ? 1 : this.dist < e ? -1 : this.dist > e ? 1 : 0
				},
				interfaces_: function() {
					return [o]
				},
				getClass: function() {
					return bi
				}
			}), e(Fi.prototype, {
				print: function(t) {
					t.println("Intersections:");
					for (var e = this.iterator(); e.hasNext();) e.next().print(t)
				},
				iterator: function() {
					return this.nodeMap.values().iterator()
				},
				addSplitEdges: function(t) {
					this.addEndpoints();
					for (var e = this.iterator(), i = e.next(); e.hasNext();) {
						var n = e.next(),
							r = this.createSplitEdge(i, n);
						t.add(r), i = n
					}
				},
				addEndpoints: function() {
					var t = this.edge.pts.length - 1;
					this.add(this.edge.pts[0], 0, 0), this.add(this.edge.pts[t], t, 0)
				},
				createSplitEdge: function(t, e) {
					var i = e.segmentIndex - t.segmentIndex + 2,
						n = this.edge.pts[e.segmentIndex],
						r = e.dist > 0 || !e.coord.equals2D(n);
					r || i--;
					var o = new Array(i).fill(null),
						s = 0;
					o[s++] = new f(t.coord);
					for (var a = t.segmentIndex + 1; a <= e.segmentIndex; a++) o[s++] = this.edge.pts[a];
					return r && (o[s] = e.coord), new Ui(o, new ti(this.edge.label))
				},
				add: function(t, e, i) {
					var n = new bi(t, e, i),
						r = this.nodeMap.get(n);
					return null !== r ? r : (this.nodeMap.put(n, n), n)
				},
				isIntersection: function(t) {
					for (var e = this.iterator(); e.hasNext();) if (e.next().coord.equals(t)) return !0;
					return !1
				},
				interfaces_: function() {
					return []
				},
				getClass: function() {
					return Fi
				}
			}), e(Di.prototype, {
				getChainStartIndices: function(t) {
					var e = 0,
						i = new E;
					i.add(new N(e));
					do {
						var n = this.findChainEnd(t, e);
						i.add(new N(n)), e = n
					} while (e < t.length - 1);
					return Di.toIntArray(i)
				},
				findChainEnd: function(t, e) {
					for (var i = Be.quadrant(t[e], t[e + 1]), n = e + 1; n < t.length && Be.quadrant(t[n - 1], t[n]) === i;) n++;
					return n - 1
				},
				interfaces_: function() {
					return []
				},
				getClass: function() {
					return Di
				}
			}), Di.toIntArray = function(t) {
				for (var e = new Array(t.size()).fill(null), i = 0; i < e.length; i++) e[i] = t.get(i).intValue();
				return e
			}, e(Gi.prototype, {
				getCoordinates: function() {
					return this.pts
				},
				getMaxX: function(t) {
					var e = this.pts[this.startIndex[t]].x,
						i = this.pts[this.startIndex[t + 1]].x;
					return e > i ? e : i
				},
				getMinX: function(t) {
					var e = this.pts[this.startIndex[t]].x,
						i = this.pts[this.startIndex[t + 1]].x;
					return i > e ? e : i
				},
				computeIntersectsForChain: function() {
					if (4 === arguments.length) {
						var t = arguments[0],
							e = arguments[1],
							i = arguments[2],
							n = arguments[3];
						this.computeIntersectsForChain(this.startIndex[t], this.startIndex[t + 1], e, e.startIndex[i], e.startIndex[i + 1], n)
					} else if (6 === arguments.length) {
						var r = arguments[0],
							o = arguments[1],
							s = arguments[2],
							a = arguments[3],
							l = arguments[4],
							u = arguments[5],
							h = this.pts[r],
							c = this.pts[o],
							d = s.pts[a],
							f = s.pts[l];
						if (o - r == 1 && l - a == 1) return u.addIntersections(this.e, r, s.e, a), null;
						if (this.env1.init(h, c), this.env2.init(d, f), !this.env1.intersects(this.env2)) return null;
						var A = Math.trunc((r + o) / 2),
							p = Math.trunc((a + l) / 2);
						A > r && (p > a && this.computeIntersectsForChain(r, A, s, a, p, u), l > p && this.computeIntersectsForChain(r, A, s, p, l, u)), o > A && (p > a && this.computeIntersectsForChain(A, o, s, a, p, u), l > p && this.computeIntersectsForChain(A, o, s, p, l, u))
					}
				},
				getStartIndexes: function() {
					return this.startIndex
				},
				computeIntersects: function(t, e) {
					for (var i = 0; i < this.startIndex.length - 1; i++) for (var n = 0; n < t.startIndex.length - 1; n++) this.computeIntersectsForChain(i, t, n, e)
				},
				interfaces_: function() {
					return []
				},
				getClass: function() {
					return Gi
				}
			}), e(ki.prototype, {
				getDepth: function(t, e) {
					return this.depth[t][e]
				},
				setDepth: function(t, e, i) {
					this.depth[t][e] = i
				},
				isNull: function() {
					if (0 === arguments.length) {
						for (var t = 0; 2 > t; t++) for (var e = 0; 3 > e; e++) if (this.depth[t][e] !== ki.NULL_VALUE) return !1;
						return !0
					}
					if (1 === arguments.length) {
						var i = arguments[0];
						return this.depth[i][1] === ki.NULL_VALUE
					}
					if (2 === arguments.length) {
						var n = arguments[0],
							r = arguments[1];
						return this.depth[n][r] === ki.NULL_VALUE
					}
				},
				normalize: function() {
					for (var t = 0; 2 > t; t++) if (!this.isNull(t)) {
						var e = this.depth[t][1];
						this.depth[t][2] < e && (e = this.depth[t][2]), 0 > e && (e = 0);
						for (var i = 1; 3 > i; i++) {
							var n = 0;
							this.depth[t][i] > e && (n = 1), this.depth[t][i] = n
						}
					}
				},
				getDelta: function(t) {
					return this.depth[t][Qe.RIGHT] - this.depth[t][Qe.LEFT]
				},
				getLocation: function(t, e) {
					return this.depth[t][e] <= 0 ? T.EXTERIOR : T.INTERIOR
				},
				toString: function() {
					return "A: " + this.depth[0][1] + "," + this.depth[0][2] + " B: " + this.depth[1][1] + "," + this.depth[1][2]
				},
				add: function() {
					if (1 === arguments.length) for (var t = arguments[0], e = 0; 2 > e; e++) for (var i = 1; 3 > i; i++) {
						var n = t.getLocation(e, i);
						n !== T.EXTERIOR && n !== T.INTERIOR || (this.isNull(e, i) ? this.depth[e][i] = ki.depthAtLocation(n) : this.depth[e][i] += ki.depthAtLocation(n))
					} else if (3 === arguments.length) {
						var r = arguments[0],
							o = arguments[1],
							s = arguments[2];
						s === T.INTERIOR && this.depth[r][o]++
					}
				},
				interfaces_: function() {
					return []
				},
				getClass: function() {
					return ki
				}
			}), ki.depthAtLocation = function(t) {
				return t === T.EXTERIOR ? 0 : t === T.INTERIOR ? 1 : ki.NULL_VALUE
			}, ki.NULL_VALUE = -1, h(Ui, ri), e(Ui.prototype, {
				getDepth: function() {
					return this.depth
				},
				getCollapsedEdge: function() {
					var t = new Array(2).fill(null);
					return t[0] = this.pts[0], t[1] = this.pts[1], new Ui(t, ti.toLineLabel(this.label))
				},
				isIsolated: function() {
					return this._isIsolated
				},
				getCoordinates: function() {
					return this.pts
				},
				setIsolated: function(t) {
					this._isIsolated = t
				},
				setName: function(t) {
					this.name = t
				},
				equals: function(t) {
					if (!(t instanceof Ui)) return !1;
					var e = t;
					if (this.pts.length !== e.pts.length) return !1;
					for (var i = !0, n = !0, r = this.pts.length, o = 0; o < this.pts.length; o++) if (this.pts[o].equals2D(e.pts[o]) || (i = !1), this.pts[o].equals2D(e.pts[--r]) || (n = !1), !i && !n) return !1;
					return !0
				},
				getCoordinate: function() {
					if (0 === arguments.length) return this.pts.length > 0 ? this.pts[0] : null;
					if (1 === arguments.length) {
						var t = arguments[0];
						return this.pts[t]
					}
				},
				print: function(t) {
					t.print("edge " + this.name + ": "), t.print("LINESTRING (");
					for (var e = 0; e < this.pts.length; e++) e > 0 && t.print(","), t.print(this.pts[e].x + " " + this.pts[e].y);
					t.print(")  " + this.label + " " + this.depthDelta)
				},
				computeIM: function(t) {
					Ui.updateIM(this.label, t)
				},
				isCollapsed: function() {
					return !!this.label.isArea() && 3 === this.pts.length && !! this.pts[0].equals(this.pts[2])
				},
				isClosed: function() {
					return this.pts[0].equals(this.pts[this.pts.length - 1])
				},
				getMaximumSegmentIndex: function() {
					return this.pts.length - 1
				},
				getDepthDelta: function() {
					return this.depthDelta
				},
				getNumPoints: function() {
					return this.pts.length
				},
				printReverse: function(t) {
					t.print("edge " + this.name + ": ");
					for (var e = this.pts.length - 1; e >= 0; e--) t.print(this.pts[e] + " ");
					t.println("")
				},
				getMonotoneChainEdge: function() {
					return null === this.mce && (this.mce = new Gi(this)), this.mce
				},
				getEnvelope: function() {
					if (null === this.env) {
						this.env = new C;
						for (var t = 0; t < this.pts.length; t++) this.env.expandToInclude(this.pts[t])
					}
					return this.env
				},
				addIntersection: function(t, e, i, n) {
					var r = new f(t.getIntersection(n)),
						o = e,
						s = t.getEdgeDistance(i, n),
						a = o + 1;
					if (a < this.pts.length) {
						var l = this.pts[a];
						r.equals2D(l) && (o = a, s = 0)
					}
					this.eiList.add(r, o, s)
				},
				toString: function() {
					var t = new L;
					t.append("edge " + this.name + ": "), t.append("LINESTRING (");
					for (var e = 0; e < this.pts.length; e++) e > 0 && t.append(","), t.append(this.pts[e].x + " " + this.pts[e].y);
					return t.append(")  " + this.label + " " + this.depthDelta), t.toString()
				},
				isPointwiseEqual: function(t) {
					if (this.pts.length !== t.pts.length) return !1;
					for (var e = 0; e < this.pts.length; e++) if (!this.pts[e].equals2D(t.pts[e])) return !1;
					return !0
				},
				setDepthDelta: function(t) {
					this.depthDelta = t
				},
				getEdgeIntersectionList: function() {
					return this.eiList
				},
				addIntersections: function(t, e, i) {
					for (var n = 0; n < t.getIntersectionNum(); n++) this.addIntersection(t, e, i, n)
				},
				interfaces_: function() {
					return []
				},
				getClass: function() {
					return Ui
				}
			}), Ui.updateIM = function() {
				if (2 !== arguments.length) return ri.prototype.updateIM.apply(this, arguments);
				var t = arguments[0],
					e = arguments[1];
				e.setAtLeastIfValid(t.getLocation(0, Qe.ON), t.getLocation(1, Qe.ON), 1), t.isArea() && (e.setAtLeastIfValid(t.getLocation(0, Qe.LEFT), t.getLocation(1, Qe.LEFT), 2), e.setAtLeastIfValid(t.getLocation(0, Qe.RIGHT), t.getLocation(1, Qe.RIGHT), 2))
			}, h(Bi, hi), e(Bi.prototype, {
				insertBoundaryPoint: function(t, e) {
					var i = this.nodes.addNode(e).getLabel(),
						n = 1;
					T.NONE, i.getLocation(t, Qe.ON) === T.BOUNDARY && n++;
					var r = Bi.determineBoundary(this.boundaryNodeRule, n);
					i.setLocation(t, r)
				},
				computeSelfNodes: function() {
					if (2 === arguments.length) {
						var t = arguments[0],
							e = arguments[1];
						return this.computeSelfNodes(t, e, !1)
					}
					if (3 === arguments.length) {
						var i = arguments[0],
							n = arguments[1],
							r = arguments[2],
							o = new xi(i, !0, !1);
						o.setIsDoneIfProperInt(r);
						var s = this.createEdgeSetIntersector(),
							a = this.parentGeom instanceof Lt || this.parentGeom instanceof Rt || this.parentGeom instanceof Nt,
							l = n || !a;
						return s.computeIntersections(this.edges, o, l), this.addSelfIntersectionNodes(this.argIndex), o
					}
				},
				computeSplitEdges: function(t) {
					for (var e = this.edges.iterator(); e.hasNext();) e.next().eiList.addSplitEdges(t)
				},
				computeEdgeIntersections: function(t, e, i) {
					var n = new xi(e, i, !0);
					return n.setBoundaryNodes(this.getBoundaryNodes(), t.getBoundaryNodes()), this.createEdgeSetIntersector().computeIntersections(this.edges, t.edges, n), n
				},
				getGeometry: function() {
					return this.parentGeom
				},
				getBoundaryNodeRule: function() {
					return this.boundaryNodeRule
				},
				hasTooFewPoints: function() {
					return this._hasTooFewPoints
				},
				addPoint: function() {
					if (arguments[0] instanceof St) {
						var t = arguments[0],
							e = t.getCoordinate();
						this.insertPoint(this.argIndex, e, T.INTERIOR)
					} else if (arguments[0] instanceof f) {
						var i = arguments[0];
						this.insertPoint(this.argIndex, i, T.INTERIOR)
					}
				},
				addPolygon: function(t) {
					this.addPolygonRing(t.getExteriorRing(), T.EXTERIOR, T.INTERIOR);
					for (var e = 0; e < t.getNumInteriorRing(); e++) {
						var i = t.getInteriorRingN(e);
						this.addPolygonRing(i, T.INTERIOR, T.EXTERIOR)
					}
				},
				addEdge: function(t) {
					this.insertEdge(t);
					var e = t.getCoordinates();
					this.insertPoint(this.argIndex, e[0], T.BOUNDARY), this.insertPoint(this.argIndex, e[e.length - 1], T.BOUNDARY)
				},
				addLineString: function(t) {
					var e = W.removeRepeatedPoints(t.getCoordinates());
					if (e.length < 2) return this._hasTooFewPoints = !0, this.invalidPoint = e[0], null;
					var i = new Ui(e, new ti(this.argIndex, T.INTERIOR));
					this.lineEdgeMap.put(t, i), this.insertEdge(i), d.isTrue(e.length >= 2, "found LineString with single point"), this.insertBoundaryPoint(this.argIndex, e[0]), this.insertBoundaryPoint(this.argIndex, e[e.length - 1])
				},
				getInvalidPoint: function() {
					return this.invalidPoint
				},
				getBoundaryPoints: function() {
					for (var t = this.getBoundaryNodes(), e = new Array(t.size()).fill(null), i = 0, n = t.iterator(); n.hasNext();) {
						var r = n.next();
						e[i++] = r.getCoordinate().copy()
					}
					return e
				},
				getBoundaryNodes: function() {
					return null === this.boundaryNodes && (this.boundaryNodes = this.nodes.getBoundaryNodes(this.argIndex)), this.boundaryNodes
				},
				addSelfIntersectionNode: function(t, e, i) {
					return this.isBoundaryNode(t, e) ? null : void(i === T.BOUNDARY && this.useBoundaryDeterminationRule ? this.insertBoundaryPoint(t, e) : this.insertPoint(t, e, i))
				},
				addPolygonRing: function(t, e, i) {
					if (t.isEmpty()) return null;
					var n = W.removeRepeatedPoints(t.getCoordinates());
					if (n.length < 4) return this._hasTooFewPoints = !0, this.invalidPoint = n[0], null;
					var r = e,
						o = i;
					$t.isCCW(n) && (r = i, o = e);
					var s = new Ui(n, new ti(this.argIndex, T.BOUNDARY, r, o));
					this.lineEdgeMap.put(t, s), this.insertEdge(s), this.insertPoint(this.argIndex, n[0], T.BOUNDARY)
				},
				insertPoint: function(t, e, i) {
					var n = this.nodes.addNode(e),
						r = n.getLabel();
					null === r ? n.label = new ti(t, i) : r.setLocation(t, i)
				},
				createEdgeSetIntersector: function() {
					return new Ci
				},
				addSelfIntersectionNodes: function(t) {
					for (var e = this.edges.iterator(); e.hasNext();) for (var i = e.next(), n = i.getLabel().getLocation(t), r = i.eiList.iterator(); r.hasNext();) {
						var o = r.next();
						this.addSelfIntersectionNode(t, o.coord, n)
					}
				},
				add: function() {
					if (1 !== arguments.length) return hi.prototype.add.apply(this, arguments);
					var t = arguments[0];
					if (t.isEmpty()) return null;
					if (t instanceof Nt && (this.useBoundaryDeterminationRule = !1), t instanceof Rt) this.addPolygon(t);
					else if (t instanceof Ct) this.addLineString(t);
					else if (t instanceof St) this.addPoint(t);
					else if (t instanceof wt) this.addCollection(t);
					else if (t instanceof ft) this.addCollection(t);
					else if (t instanceof Nt) this.addCollection(t);
					else {
						if (!(t instanceof dt)) throw new UnsupportedOperationException(t.getClass().getName());
						this.addCollection(t)
					}
				},
				addCollection: function(t) {
					for (var e = 0; e < t.getNumGeometries(); e++) {
						var i = t.getGeometryN(e);
						this.add(i)
					}
				},
				locate: function(t) {
					return R(this.parentGeom, Tt) && this.parentGeom.getNumGeometries() > 50 ? (null === this.areaPtLocator && (this.areaPtLocator = new Pi(this.parentGeom)), this.areaPtLocator.locate(t)) : this.ptLocator.locate(t, this.parentGeom)
				},
				findEdge: function() {
					if (1 === arguments.length) {
						var t = arguments[0];
						return this.lineEdgeMap.get(t)
					}
					return hi.prototype.findEdge.apply(this, arguments)
				},
				interfaces_: function() {
					return []
				},
				getClass: function() {
					return Bi
				}
			}), Bi.determineBoundary = function(t, e) {
				return t.isInBoundary(e) ? T.BOUNDARY : T.INTERIOR
			}, e(ji.prototype, {
				getArgGeometry: function(t) {
					return this.arg[t].getGeometry()
				},
				setComputationPrecision: function(t) {
					this.resultPrecisionModel = t, this.li.setPrecisionModel(this.resultPrecisionModel)
				},
				interfaces_: function() {
					return []
				},
				getClass: function() {
					return ji
				}
			}), e(Vi.prototype, {
				compareTo: function(t) {
					var e = t;
					return Vi.compareOriented(this.pts, this._orientation, e.pts, e._orientation)
				},
				interfaces_: function() {
					return [o]
				},
				getClass: function() {
					return Vi
				}
			}), Vi.orientation = function(t) {
				return 1 === W.increasingDirection(t)
			}, Vi.compareOriented = function(t, e, i, n) {
				for (var r = e ? 1 : -1, o = n ? 1 : -1, s = e ? t.length : -1, a = n ? i.length : -1, l = e ? 0 : t.length - 1, u = n ? 0 : i.length - 1;;) {
					var h = t[l].compareTo(i[u]);
					if (0 !== h) return h;
					var c = (l += r) === s,
						d = (u += o) === a;
					if (c && !d) return -1;
					if (!c && d) return 1;
					if (c && d) return 0
				}
			}, e(Yi.prototype, {
				print: function(t) {
					t.print("MULTILINESTRING ( ");
					for (var e = 0; e < this.edges.size(); e++) {
						var i = this.edges.get(e);
						e > 0 && t.print(","), t.print("(");
						for (var n = i.getCoordinates(), r = 0; r < n.length; r++) r > 0 && t.print(","), t.print(n[r].x + " " + n[r].y);
						t.println(")")
					}
					t.print(")  ")
				},
				addAll: function(t) {
					for (var e = t.iterator(); e.hasNext();) this.add(e.next())
				},
				findEdgeIndex: function(t) {
					for (var e = 0; e < this.edges.size(); e++) if (this.edges.get(e).equals(t)) return e;
					return -1
				},
				iterator: function() {
					return this.edges.iterator()
				},
				getEdges: function() {
					return this.edges
				},
				get: function(t) {
					return this.edges.get(t)
				},
				findEqualEdge: function(t) {
					var e = new Vi(t.getCoordinates());
					return this.ocaMap.get(e)
				},
				add: function(t) {
					this.edges.add(t);
					var e = new Vi(t.getCoordinates());
					this.ocaMap.put(e, t)
				},
				interfaces_: function() {
					return []
				},
				getClass: function() {
					return Yi
				}
			}), h(zi, ji), e(zi.prototype, {
				insertUniqueEdge: function(t) {
					var e = this.edgeList.findEqualEdge(t);
					if (null !== e) {
						var i = e.getLabel(),
							n = t.getLabel();
						e.isPointwiseEqual(t) || (n = new ti(t.getLabel())).flip();
						var r = e.getDepth();
						r.isNull() && r.add(i), r.add(n), i.merge(n)
					} else this.edgeList.add(t)
				},
				getGraph: function() {
					return this.graph
				},
				cancelDuplicateResultEdges: function() {
					for (var t = this.graph.getEdgeEnds().iterator(); t.hasNext();) {
						var e = t.next(),
							i = e.getSym();
						e.isInResult() && i.isInResult() && (e.setInResult(!1), i.setInResult(!1))
					}
				},
				isCoveredByLA: function(t) {
					return !!this.isCovered(t, this.resultLineList) || !! this.isCovered(t, this.resultPolyList)
				},
				computeGeometry: function(t, e, i, n) {
					var r = new E;
					return r.addAll(t), r.addAll(e), r.addAll(i), r.isEmpty() ? zi.createEmptyResult(n, this.arg[0].getGeometry(), this.arg[1].getGeometry(), this.geomFact) : this.geomFact.buildGeometry(r)
				},
				mergeSymLabels: function() {
					for (var t = this.graph.getNodes().iterator(); t.hasNext();) t.next().getEdges().mergeSymLabels()
				},
				isCovered: function(t, e) {
					for (var i = e.iterator(); i.hasNext();) {
						var n = i.next();
						if (this.ptLocator.locate(t, n) !== T.EXTERIOR) return !0
					}
					return !1
				},
				replaceCollapsedEdges: function() {
					for (var t = new E, e = this.edgeList.iterator(); e.hasNext();) {
						var i = e.next();
						i.isCollapsed() && (e.remove(), t.add(i.getCollapsedEdge()))
					}
					this.edgeList.addAll(t)
				},
				updateNodeLabelling: function() {
					for (var t = this.graph.getNodes().iterator(); t.hasNext();) {
						var e = t.next(),
							i = e.getEdges().getLabel();
						e.getLabel().merge(i)
					}
				},
				getResultGeometry: function(t) {
					return this.computeOverlay(t), this.resultGeom
				},
				insertUniqueEdges: function(t) {
					for (var e = t.iterator(); e.hasNext();) {
						var i = e.next();
						this.insertUniqueEdge(i)
					}
				},
				computeOverlay: function(t) {
					this.copyPoints(0), this.copyPoints(1), this.arg[0].computeSelfNodes(this.li, !1), this.arg[1].computeSelfNodes(this.li, !1), this.arg[0].computeEdgeIntersections(this.arg[1], this.li, !0);
					var e = new E;
					this.arg[0].computeSplitEdges(e), this.arg[1].computeSplitEdges(e), this.insertUniqueEdges(e), this.computeLabelsFromDepths(), this.replaceCollapsedEdges(), Ke.checkValid(this.edgeList.getEdges()), this.graph.addEdges(this.edgeList.getEdges()), this.computeLabelling(), this.labelIncompleteNodes(), this.findResultAreaEdges(t), this.cancelDuplicateResultEdges();
					var i = new ci(this.geomFact);
					i.add(this.graph), this.resultPolyList = i.getPolygons();
					var n = new di(this, this.geomFact, this.ptLocator);
					this.resultLineList = n.build(t);
					var r = new fi(this, this.geomFact, this.ptLocator);
					this.resultPointList = r.build(t), this.resultGeom = this.computeGeometry(this.resultPointList, this.resultLineList, this.resultPolyList, t)
				},
				labelIncompleteNode: function(t, e) {
					var i = this.ptLocator.locate(t.getCoordinate(), this.arg[e].getGeometry());
					t.getLabel().setLocation(e, i)
				},
				copyPoints: function(t) {
					for (var e = this.arg[t].getNodeIterator(); e.hasNext();) {
						var i = e.next();
						this.graph.addNode(i.getCoordinate()).setLabel(t, i.getLabel().getLocation(t))
					}
				},
				findResultAreaEdges: function(t) {
					for (var e = this.graph.getEdgeEnds().iterator(); e.hasNext();) {
						var i = e.next(),
							n = i.getLabel();
						n.isArea() && !i.isInteriorAreaEdge() && zi.isResultOfOp(n.getLocation(0, Qe.RIGHT), n.getLocation(1, Qe.RIGHT), t) && i.setInResult(!0)
					}
				},
				computeLabelsFromDepths: function() {
					for (var t = this.edgeList.iterator(); t.hasNext();) {
						var e = t.next(),
							i = e.getLabel(),
							n = e.getDepth();
						if (!n.isNull()) {
							n.normalize();
							for (var r = 0; 2 > r; r++) i.isNull(r) || !i.isArea() || n.isNull(r) || (0 === n.getDelta(r) ? i.toLine(r) : (d.isTrue(!n.isNull(r, Qe.LEFT), "depth of LEFT side has not been initialized"), i.setLocation(r, Qe.LEFT, n.getLocation(r, Qe.LEFT)), d.isTrue(!n.isNull(r, Qe.RIGHT), "depth of RIGHT side has not been initialized"), i.setLocation(r, Qe.RIGHT, n.getLocation(r, Qe.RIGHT))))
						}
					}
				},
				computeLabelling: function() {
					for (var t = this.graph.getNodes().iterator(); t.hasNext();) t.next().getEdges().computeLabelling(this.arg);
					this.mergeSymLabels(), this.updateNodeLabelling()
				},
				labelIncompleteNodes: function() {
					for (var t = this.graph.getNodes().iterator(); t.hasNext();) {
						var e = t.next(),
							i = e.getLabel();
						e.isIsolated() && (i.isNull(0) ? this.labelIncompleteNode(e, 0) : this.labelIncompleteNode(e, 1)), e.getEdges().updateLabelling(i)
					}
				},
				isCoveredByA: function(t) {
					return !!this.isCovered(t, this.resultPolyList)
				},
				interfaces_: function() {
					return []
				},
				getClass: function() {
					return zi
				}
			}), zi.overlayOp = function(t, e, i) {
				return new zi(t, e).getResultGeometry(i)
			}, zi.intersection = function(t, e) {
				if (t.isEmpty() || e.isEmpty()) return zi.createEmptyResult(zi.INTERSECTION, t, e, t.getFactory());
				if (t.isGeometryCollection()) {
					var i = e;
					return Je.map(t, {
						interfaces_: function() {
							return [MapOp]
						},
						map: function(t) {
							return t.intersection(i)
						}
					})
				}
				return t.checkNotGeometryCollection(t), t.checkNotGeometryCollection(e), Wi.overlayOp(t, e, zi.INTERSECTION)
			}, zi.symDifference = function(t, e) {
				if (t.isEmpty() || e.isEmpty()) {
					if (t.isEmpty() && e.isEmpty()) return zi.createEmptyResult(zi.SYMDIFFERENCE, t, e, t.getFactory());
					if (t.isEmpty()) return e.copy();
					if (e.isEmpty()) return t.copy()
				}
				return t.checkNotGeometryCollection(t), t.checkNotGeometryCollection(e), Wi.overlayOp(t, e, zi.SYMDIFFERENCE)
			}, zi.resultDimension = function(t, e, i) {
				var n = e.getDimension(),
					r = i.getDimension(),
					o = -1;
				switch (t) {
				case zi.INTERSECTION:
					o = Math.min(n, r);
					break;
				case zi.UNION:
					o = Math.max(n, r);
					break;
				case zi.DIFFERENCE:
					o = n;
					break;
				case zi.SYMDIFFERENCE:
					o = Math.max(n, r)
				}
				return o
			}, zi.createEmptyResult = function(t, e, i, n) {
				var r = null;
				switch (zi.resultDimension(t, e, i)) {
				case -1:
					r = n.createGeometryCollection(new Array(0).fill(null));
					break;
				case 0:
					r = n.createPoint();
					break;
				case 1:
					r = n.createLineString();
					break;
				case 2:
					r = n.createPolygon()
				}
				return r
			}, zi.difference = function(t, e) {
				return t.isEmpty() ? zi.createEmptyResult(zi.DIFFERENCE, t, e, t.getFactory()) : e.isEmpty() ? t.copy() : (t.checkNotGeometryCollection(t), t.checkNotGeometryCollection(e), Wi.overlayOp(t, e, zi.DIFFERENCE))
			}, zi.isResultOfOp = function() {
				if (2 === arguments.length) {
					var t = arguments[0],
						e = arguments[1],
						i = t.getLocation(0),
						n = t.getLocation(1);
					return zi.isResultOfOp(i, n, e)
				}
				if (3 === arguments.length) {
					var r = arguments[0],
						o = arguments[1],
						s = arguments[2];
					switch (r === T.BOUNDARY && (r = T.INTERIOR), o === T.BOUNDARY && (o = T.INTERIOR), s) {
					case zi.INTERSECTION:
						return r === T.INTERIOR && o === T.INTERIOR;
					case zi.UNION:
						return r === T.INTERIOR || o === T.INTERIOR;
					case zi.DIFFERENCE:
						return r === T.INTERIOR && o !== T.INTERIOR;
					case zi.SYMDIFFERENCE:
						return r === T.INTERIOR && o !== T.INTERIOR || r !== T.INTERIOR && o === T.INTERIOR
					}
					return !1
				}
			}, zi.INTERSECTION = 1, zi.UNION = 2, zi.DIFFERENCE = 3, zi.SYMDIFFERENCE = 4, e(Xi.prototype, {
				selfSnap: function(t) {
					return new he(t).snapTo(t, this.snapTolerance)
				},
				removeCommonBits: function(t) {
					this.cbr = new fe, this.cbr.add(t[0]), this.cbr.add(t[1]);
					var e = new Array(2).fill(null);
					return e[0] = this.cbr.removeCommonBits(t[0].copy()), e[1] = this.cbr.removeCommonBits(t[1].copy()), e
				},
				prepareResult: function(t) {
					return this.cbr.addCommonBits(t), t
				},
				getResultGeometry: function(t) {
					var e = this.snap(this.geom),
						i = zi.overlayOp(e[0], e[1], t);
					return this.prepareResult(i)
				},
				checkValid: function(t) {
					t.isValid() || F.out.println("Snapped geometry is invalid")
				},
				computeSnapTolerance: function() {
					this.snapTolerance = he.computeOverlaySnapTolerance(this.geom[0], this.geom[1])
				},
				snap: function(t) {
					var e = this.removeCommonBits(t);
					return he.snap(e[0], e[1], this.snapTolerance)
				},
				interfaces_: function() {
					return []
				},
				getClass: function() {
					return Xi
				}
			}), Xi.overlayOp = function(t, e, i) {
				return new Xi(t, e).getResultGeometry(i)
			}, Xi.union = function(t, e) {
				return Xi.overlayOp(t, e, zi.UNION)
			}, Xi.intersection = function(t, e) {
				return Xi.overlayOp(t, e, zi.INTERSECTION)
			}, Xi.symDifference = function(t, e) {
				return Xi.overlayOp(t, e, zi.SYMDIFFERENCE)
			}, Xi.difference = function(t, e) {
				return Xi.overlayOp(t, e, zi.DIFFERENCE)
			}, e(Wi.prototype, {
				getResultGeometry: function(t) {
					var e = null,
						i = !1,
						n = null;
					try {
						e = zi.overlayOp(this.geom[0], this.geom[1], t), i = !0
					} catch (t) {
						if (!(t instanceof u)) throw t;
						n = t
					}
					if (!i) try {
						e = Xi.overlayOp(this.geom[0], this.geom[1], t)
					} catch (t) {
						throw t instanceof u ? n : t
					}
					return e
				},
				interfaces_: function() {
					return []
				},
				getClass: function() {
					return Wi
				}
			}), Wi.overlayOp = function(t, e, i) {
				return new Wi(t, e).getResultGeometry(i)
			}, Wi.union = function(t, e) {
				return Wi.overlayOp(t, e, zi.UNION)
			}, Wi.intersection = function(t, e) {
				return Wi.overlayOp(t, e, zi.INTERSECTION)
			}, Wi.symDifference = function(t, e) {
				return Wi.overlayOp(t, e, zi.SYMDIFFERENCE)
			}, Wi.difference = function(t, e) {
				return Wi.overlayOp(t, e, zi.DIFFERENCE)
			}, e(qi.prototype, {
				addPolygon: function(t) {
					if (t.isEmpty()) return null;
					var e = null,
						i = 0,
						n = this.horizontalBisector(t);
					if (0 === n.getLength()) i = 0, e = n.getCoordinate();
					else {
						var r = Wi.overlayOp(n, t, zi.INTERSECTION),
							o = this.widestGeometry(r);
						i = o.getEnvelopeInternal().getWidth(), e = qi.centre(o.getEnvelopeInternal())
					}(null === this.interiorPoint || i > this.maxWidth) && (this.interiorPoint = e, this.maxWidth = i)
				},
				getInteriorPoint: function() {
					return this.interiorPoint
				},
				widestGeometry: function() {
					if (arguments[0] instanceof dt) {
						var t = arguments[0];
						if (t.isEmpty()) return t;
						for (var e = t.getGeometryN(0), i = 1; i < t.getNumGeometries(); i++) t.getGeometryN(i).getEnvelopeInternal().getWidth() > e.getEnvelopeInternal().getWidth() && (e = t.getGeometryN(i));
						return e
					}
					if (arguments[0] instanceof U) {
						var n = arguments[0];
						return n instanceof dt ? this.widestGeometry(n) : n
					}
				},
				horizontalBisector: function(t) {
					var e = t.getEnvelopeInternal(),
						i = Hi.getBisectorY(t);
					return this.factory.createLineString([new f(e.getMinX(), i), new f(e.getMaxX(), i)])
				},
				add: function(t) {
					if (t instanceof Rt) this.addPolygon(t);
					else if (t instanceof dt) for (var e = t, i = 0; i < e.getNumGeometries(); i++) this.add(e.getGeometryN(i))
				},
				interfaces_: function() {
					return []
				},
				getClass: function() {
					return qi
				}
			}), qi.centre = function(t) {
				return new f(qi.avg(t.getMinX(), t.getMaxX()), qi.avg(t.getMinY(), t.getMaxY()))
			}, qi.avg = function(t, e) {
				return (t + e) / 2
			}, e(Hi.prototype, {
				updateInterval: function(t) {
					t <= this.centreY ? t > this.loY && (this.loY = t) : t > this.centreY && t < this.hiY && (this.hiY = t)
				},
				getBisectorY: function() {
					this.process(this.poly.getExteriorRing());
					for (var t = 0; t < this.poly.getNumInteriorRing(); t++) this.process(this.poly.getInteriorRingN(t));
					return qi.avg(this.hiY, this.loY)
				},
				process: function(t) {
					for (var e = t.getCoordinateSequence(), i = 0; i < e.size(); i++) {
						var n = e.getY(i);
						this.updateInterval(n)
					}
				},
				interfaces_: function() {
					return []
				},
				getClass: function() {
					return Hi
				}
			}), Hi.getBisectorY = function(t) {
				return new Hi(t).getBisectorY()
			}, qi.SafeBisectorFinder = Hi, e(Zi.prototype, {
				addEndpoints: function() {
					if (arguments[0] instanceof U) {
						var t = arguments[0];
						if (t instanceof Ct) this.addEndpoints(t.getCoordinates());
						else if (t instanceof dt) for (var e = t, i = 0; i < e.getNumGeometries(); i++) this.addEndpoints(e.getGeometryN(i))
					} else if (arguments[0] instanceof Array) {
						var n = arguments[0];
						this.add(n[0]), this.add(n[n.length - 1])
					}
				},
				getInteriorPoint: function() {
					return this.interiorPoint
				},
				addInterior: function() {
					if (arguments[0] instanceof U) {
						var t = arguments[0];
						if (t instanceof Ct) this.addInterior(t.getCoordinates());
						else if (t instanceof dt) for (var e = t, i = 0; i < e.getNumGeometries(); i++) this.addInterior(e.getGeometryN(i))
					} else if (arguments[0] instanceof Array) {
						var n = arguments[0];
						for (i = 1; i < n.length - 1; i++) this.add(n[i])
					}
				},
				add: function(t) {
					var e = t.distance(this.centroid);
					e < this.minDistance && (this.interiorPoint = new f(t), this.minDistance = e)
				},
				interfaces_: function() {
					return []
				},
				getClass: function() {
					return Zi
				}
			}), e(Ki.prototype, {
				getInteriorPoint: function() {
					return this.interiorPoint
				},
				add: function() {
					if (arguments[0] instanceof U) {
						var t = arguments[0];
						if (t instanceof St) this.add(t.getCoordinate());
						else if (t instanceof dt) for (var e = t, i = 0; i < e.getNumGeometries(); i++) this.add(e.getGeometryN(i))
					} else if (arguments[0] instanceof f) {
						var n = arguments[0],
							r = n.distance(this.centroid);
						r < this.minDistance && (this.interiorPoint = new f(n), this.minDistance = r)
					}
				},
				interfaces_: function() {
					return []
				},
				getClass: function() {
					return Ki
				}
			}), e(Ji.prototype, {
				interfaces_: function() {
					return []
				},
				getClass: function() {
					return Ji
				}
			}), Ji.toDegrees = function(t) {
				return 180 * t / Math.PI
			}, Ji.normalize = function(t) {
				for (; t > Math.PI;) t -= Ji.PI_TIMES_2;
				for (; t <= -Math.PI;) t += Ji.PI_TIMES_2;
				return t
			}, Ji.angle = function() {
				if (1 === arguments.length) {
					var t = arguments[0];
					return Math.atan2(t.y, t.x)
				}
				if (2 === arguments.length) {
					var e = arguments[0],
						i = arguments[1],
						n = i.x - e.x,
						r = i.y - e.y;
					return Math.atan2(r, n)
				}
			}, Ji.isAcute = function(t, e, i) {
				var n = t.x - e.x,
					r = t.y - e.y;
				return n * (i.x - e.x) + r * (i.y - e.y) > 0
			}, Ji.isObtuse = function(t, e, i) {
				var n = t.x - e.x,
					r = t.y - e.y;
				return 0 > n * (i.x - e.x) + r * (i.y - e.y)
			}, Ji.interiorAngle = function(t, e, i) {
				var n = Ji.angle(e, t),
					r = Ji.angle(e, i);
				return Math.abs(r - n)
			}, Ji.normalizePositive = function(t) {
				if (0 > t) {
					for (; 0 > t;) t += Ji.PI_TIMES_2;
					t >= Ji.PI_TIMES_2 && (t = 0)
				} else {
					for (; t >= Ji.PI_TIMES_2;) t -= Ji.PI_TIMES_2;
					0 > t && (t = 0)
				}
				return t
			}, Ji.angleBetween = function(t, e, i) {
				var n = Ji.angle(e, t),
					r = Ji.angle(e, i);
				return Ji.diff(n, r)
			}, Ji.diff = function(t, e) {
				var i = null;
				return (i = e > t ? e - t : t - e) > Math.PI && (i = 2 * Math.PI - i), i
			}, Ji.toRadians = function(t) {
				return t * Math.PI / 180
			}, Ji.getTurn = function(t, e) {
				var i = Math.sin(e - t);
				return i > 0 ? Ji.COUNTERCLOCKWISE : 0 > i ? Ji.CLOCKWISE : Ji.NONE
			}, Ji.angleBetweenOriented = function(t, e, i) {
				var n = Ji.angle(e, t),
					r = Ji.angle(e, i) - n;
				return r <= -Math.PI ? r + Ji.PI_TIMES_2 : r > Math.PI ? r - Ji.PI_TIMES_2 : r
			}, Ji.PI_TIMES_2 = 2 * Math.PI, Ji.PI_OVER_2 = Math.PI / 2, Ji.PI_OVER_4 = Math.PI / 4, Ji.COUNTERCLOCKWISE = $t.COUNTERCLOCKWISE, Ji.CLOCKWISE = $t.CLOCKWISE, Ji.NONE = $t.COLLINEAR, e(Qi.prototype, {
				area: function() {
					return Qi.area(this.p0, this.p1, this.p2)
				},
				signedArea: function() {
					return Qi.signedArea(this.p0, this.p1, this.p2)
				},
				interpolateZ: function(t) {
					if (null === t) throw new n("Supplied point is null.");
					return Qi.interpolateZ(t, this.p0, this.p1, this.p2)
				},
				longestSideLength: function() {
					return Qi.longestSideLength(this.p0, this.p1, this.p2)
				},
				isAcute: function() {
					return Qi.isAcute(this.p0, this.p1, this.p2)
				},
				circumcentre: function() {
					return Qi.circumcentre(this.p0, this.p1, this.p2)
				},
				area3D: function() {
					return Qi.area3D(this.p0, this.p1, this.p2)
				},
				centroid: function() {
					return Qi.centroid(this.p0, this.p1, this.p2)
				},
				inCentre: function() {
					return Qi.inCentre(this.p0, this.p1, this.p2)
				},
				interfaces_: function() {
					return []
				},
				getClass: function() {
					return Qi
				}
			}), Qi.area = function(t, e, i) {
				return Math.abs(((i.x - t.x) * (e.y - t.y) - (e.x - t.x) * (i.y - t.y)) / 2)
			}, Qi.signedArea = function(t, e, i) {
				return ((i.x - t.x) * (e.y - t.y) - (e.x - t.x) * (i.y - t.y)) / 2
			}, Qi.det = function(t, e, i, n) {
				return t * n - e * i
			}, Qi.interpolateZ = function(t, e, i, n) {
				var r = e.x,
					o = e.y,
					s = i.x - r,
					a = n.x - r,
					l = i.y - o,
					u = n.y - o,
					h = s * u - a * l,
					c = t.x - r,
					d = t.y - o,
					f = (u * c - a * d) / h,
					A = (-l * c + s * d) / h;
				return e.z + f * (i.z - e.z) + A * (n.z - e.z)
			}, Qi.longestSideLength = function(t, e, i) {
				var n = t.distance(e),
					r = e.distance(i),
					o = i.distance(t),
					s = n;
				return r > s && (s = r), o > s && (s = o), s
			}, Qi.isAcute = function(t, e, i) {
				return !(!Ji.isAcute(t, e, i) || !Ji.isAcute(e, i, t) || !Ji.isAcute(i, t, e))
			}, Qi.circumcentre = function(t, e, i) {
				var n = i.x,
					r = i.y,
					o = t.x - n,
					s = t.y - r,
					a = e.x - n,
					l = e.y - r,
					u = 2 * Qi.det(o, s, a, l);
				return new f(n - Qi.det(s, o * o + s * s, l, a * a + l * l) / u, r + Qi.det(o, o * o + s * s, a, a * a + l * l) / u)
			}, Qi.perpendicularBisector = function(t, e) {
				var i = e.x - t.x,
					n = e.y - t.y,
					r = new D(t.x + i / 2, t.y + n / 2, 1),
					o = new D(t.x - n + i / 2, t.y + i + n / 2, 1);
				return new D(r, o)
			}, Qi.angleBisector = function(t, e, i) {
				var n = e.distance(t),
					r = n / (n + e.distance(i)),
					o = i.x - t.x,
					s = i.y - t.y;
				return new f(t.x + r * o, t.y + r * s)
			}, Qi.area3D = function(t, e, i) {
				var n = e.x - t.x,
					r = e.y - t.y,
					o = e.z - t.z,
					s = i.x - t.x,
					a = i.y - t.y,
					l = i.z - t.z,
					u = r * l - o * a,
					h = o * s - n * l,
					c = n * a - r * s,
					d = u * u + h * h + c * c;
				return Math.sqrt(d) / 2
			}, Qi.centroid = function(t, e, i) {
				return new f((t.x + e.x + i.x) / 3, (t.y + e.y + i.y) / 3)
			}, Qi.inCentre = function(t, e, i) {
				var n = e.distance(i),
					r = t.distance(i),
					o = t.distance(e),
					s = n + r + o;
				return new f((n * t.x + r * e.x + o * i.x) / s, (n * t.y + r * e.y + o * i.y) / s)
			}, e($i.prototype, {
				getRadius: function() {
					return this.compute(), this.radius
				},
				getDiameter: function() {
					switch (this.compute(), this.extremalPts.length) {
					case 0:
						return this.input.getFactory().createLineString();
					case 1:
						return this.input.getFactory().createPoint(this.centre)
					}
					var t = this.extremalPts[0],
						e = this.extremalPts[1];
					return this.input.getFactory().createLineString([t, e])
				},
				getExtremalPoints: function() {
					return this.compute(), this.extremalPts
				},
				computeCirclePoints: function() {
					if (this.input.isEmpty()) return this.extremalPts = new Array(0).fill(null), null;
					if (1 === this.input.getNumPoints()) {
						var t = this.input.getCoordinates();
						return this.extremalPts = [new f(t[0])], null
					}
					var e = this.input.convexHull().getCoordinates();
					if (t = e, e[0].equals2D(e[e.length - 1]) && (t = new Array(e.length - 1).fill(null), W.copyDeep(e, 0, t, 0, e.length - 1)), t.length <= 2) return this.extremalPts = W.copyDeep(t), null;
					for (var i = $i.lowestPoint(t), n = $i.pointWitMinAngleWithX(t, i), r = 0; r < t.length; r++) {
						var o = $i.pointWithMinAngleWithSegment(t, i, n);
						if (Ji.isObtuse(i, o, n)) return this.extremalPts = [new f(i), new f(n)], null;
						if (Ji.isObtuse(o, i, n)) i = o;
						else {
							if (!Ji.isObtuse(o, n, i)) return this.extremalPts = [new f(i), new f(n), new f(o)], null;
							n = o
						}
					}
					d.shouldNeverReachHere("Logic failure in Minimum Bounding Circle algorithm!")
				},
				compute: function() {
					return null !== this.extremalPts ? null : (this.computeCirclePoints(), this.computeCentre(), void(null !== this.centre && (this.radius = this.centre.distance(this.extremalPts[0]))))
				},
				getFarthestPoints: function() {
					switch (this.compute(), this.extremalPts.length) {
					case 0:
						return this.input.getFactory().createLineString();
					case 1:
						return this.input.getFactory().createPoint(this.centre)
					}
					var t = this.extremalPts[0],
						e = this.extremalPts[this.extremalPts.length - 1];
					return this.input.getFactory().createLineString([t, e])
				},
				getCircle: function() {
					if (this.compute(), null === this.centre) return this.input.getFactory().createPolygon();
					var t = this.input.getFactory().createPoint(this.centre);
					return 0 === this.radius ? t : t.buffer(this.radius)
				},
				getCentre: function() {
					return this.compute(), this.centre
				},
				computeCentre: function() {
					switch (this.extremalPts.length) {
					case 0:
						this.centre = null;
						break;
					case 1:
						this.centre = this.extremalPts[0];
						break;
					case 2:
						this.centre = new f((this.extremalPts[0].x + this.extremalPts[1].x) / 2, (this.extremalPts[0].y + this.extremalPts[1].y) / 2);
						break;
					case 3:
						this.centre = Qi.circumcentre(this.extremalPts[0], this.extremalPts[1], this.extremalPts[2])
					}
				},
				interfaces_: function() {
					return []
				},
				getClass: function() {
					return $i
				}
			}), $i.pointWitMinAngleWithX = function(t, e) {
				for (var i = r.MAX_VALUE, n = null, o = 0; o < t.length; o++) {
					var s = t[o];
					if (s !== e) {
						var a = s.x - e.x,
							l = s.y - e.y;
						0 > l && (l = -l);
						var u = l / Math.sqrt(a * a + l * l);
						i > u && (i = u, n = s)
					}
				}
				return n
			}, $i.lowestPoint = function(t) {
				for (var e = t[0], i = 1; i < t.length; i++) t[i].y < e.y && (e = t[i]);
				return e
			}, $i.pointWithMinAngleWithSegment = function(t, e, i) {
				for (var n = r.MAX_VALUE, o = null, s = 0; s < t.length; s++) {
					var a = t[s];
					if (a !== e && a !== i) {
						var l = Ji.angleBetween(e, a, i);
						n > l && (n = l, o = a)
					}
				}
				return o
			}, e(tn.prototype, {
				getWidthCoordinate: function() {
					return this.computeMinimumDiameter(), this.minWidthPt
				},
				getSupportingSegment: function() {
					return this.computeMinimumDiameter(), this.inputGeom.getFactory().createLineString([this.minBaseSeg.p0, this.minBaseSeg.p1])
				},
				getDiameter: function() {
					if (this.computeMinimumDiameter(), null === this.minWidthPt) return this.inputGeom.getFactory().createLineString(null);
					var t = this.minBaseSeg.project(this.minWidthPt);
					return this.inputGeom.getFactory().createLineString([t, this.minWidthPt])
				},
				computeWidthConvex: function(t) {
					this.convexHullPts = t instanceof Rt ? t.getExteriorRing().getCoordinates() : t.getCoordinates(), 0 === this.convexHullPts.length ? (this.minWidth = 0, this.minWidthPt = null, this.minBaseSeg = null) : 1 === this.convexHullPts.length ? (this.minWidth = 0, this.minWidthPt = this.convexHullPts[0], this.minBaseSeg.p0 = this.convexHullPts[0], this.minBaseSeg.p1 = this.convexHullPts[0]) : 2 === this.convexHullPts.length || 3 === this.convexHullPts.length ? (this.minWidth = 0, this.minWidthPt = this.convexHullPts[0], this.minBaseSeg.p0 = this.convexHullPts[0], this.minBaseSeg.p1 = this.convexHullPts[1]) : this.computeConvexRingMinDiameter(this.convexHullPts)
				},
				computeConvexRingMinDiameter: function(t) {
					this.minWidth = r.MAX_VALUE;
					for (var e = 1, i = new te, n = 0; n < t.length - 1; n++) i.p0 = t[n], i.p1 = t[n + 1], e = this.findMaxPerpDistance(t, i, e)
				},
				computeMinimumDiameter: function() {
					if (null !== this.minWidthPt) return null;
					if (this.isConvex) this.computeWidthConvex(this.inputGeom);
					else {
						var t = new se(this.inputGeom).getConvexHull();
						this.computeWidthConvex(t)
					}
				},
				getLength: function() {
					return this.computeMinimumDiameter(), this.minWidth
				},
				findMaxPerpDistance: function(t, e, i) {
					for (var n = e.distancePerpendicular(t[i]), r = n, o = i, s = o; r >= n;) n = r, o = s, s = tn.nextIndex(t, o), r = e.distancePerpendicular(t[s]);
					return n < this.minWidth && (this.minPtIndex = o, this.minWidth = n, this.minWidthPt = t[this.minPtIndex], this.minBaseSeg = new te(e)), o
				},
				getMinimumRectangle: function() {
					if (this.computeMinimumDiameter(), 0 === this.minWidth) return this.minBaseSeg.p0.equals2D(this.minBaseSeg.p1) ? this.inputGeom.getFactory().createPoint(this.minBaseSeg.p0) : this.minBaseSeg.toGeometry(this.inputGeom.getFactory());
					for (var t = this.minBaseSeg.p1.x - this.minBaseSeg.p0.x, e = this.minBaseSeg.p1.y - this.minBaseSeg.p0.y, i = r.MAX_VALUE, n = -r.MAX_VALUE, o = r.MAX_VALUE, s = -r.MAX_VALUE, a = 0; a < this.convexHullPts.length; a++) {
						var l = tn.computeC(t, e, this.convexHullPts[a]);
						l > n && (n = l), i > l && (i = l);
						var u = tn.computeC(-e, t, this.convexHullPts[a]);
						u > s && (s = u), o > u && (o = u)
					}
					var h = tn.computeSegmentForLine(-t, -e, s),
						c = tn.computeSegmentForLine(-t, -e, o),
						d = tn.computeSegmentForLine(-e, t, n),
						f = tn.computeSegmentForLine(-e, t, i),
						A = d.lineIntersection(h),
						p = f.lineIntersection(h),
						g = f.lineIntersection(c),
						m = d.lineIntersection(c),
						v = this.inputGeom.getFactory().createLinearRing([A, p, g, m, A]);
					return this.inputGeom.getFactory().createPolygon(v, null)
				},
				interfaces_: function() {
					return []
				},
				getClass: function() {
					return tn
				}
			}), tn.nextIndex = function(t, e) {
				return ++e >= t.length && (e = 0), e
			}, tn.computeC = function(t, e, i) {
				return t * i.y - e * i.x
			}, tn.getMinimumDiameter = function(t) {
				return new tn(t).getDiameter()
			}, tn.getMinimumRectangle = function(t) {
				return new tn(t).getMinimumRectangle()
			}, tn.computeSegmentForLine = function(t, e, i) {
				var n = null,
					r = null;
				return Math.abs(e) > Math.abs(t) ? (n = new f(0, i / e), r = new f(1, i / e - t / e)) : (n = new f(i / t, 0), r = new f(i / t - e / t, 1)), new te(n, r)
			};
			var Qo = Object.freeze({
				Centroid: ie,
				CGAlgorithms: $t,
				ConvexHull: se,
				InteriorPointArea: qi,
				InteriorPointLine: Zi,
				InteriorPointPoint: Ki,
				RobustLineIntersector: Kt,
				MinimumBoundingCircle: $i,
				MinimumDiameter: tn
			});
			e(en.prototype, {
				getResultGeometry: function() {
					return new nn(this.distanceTolerance).transform(this.inputGeom)
				},
				setDistanceTolerance: function(t) {
					if (0 >= t) throw new n("Tolerance must be positive");
					this.distanceTolerance = t
				},
				interfaces_: function() {
					return []
				},
				getClass: function() {
					return en
				}
			}), en.densifyPoints = function(t, e, i) {
				for (var n = new te, r = new x, o = 0; o < t.length - 1; o++) {
					n.p0 = t[o], n.p1 = t[o + 1], r.add(n.p0, !1);
					var s = n.getLength(),
						a = Math.trunc(s / e) + 1;
					if (a > 1) for (var l = s / a, u = 1; a > u; u++) {
						var h = u * l / s,
							c = n.pointAlong(h);
						i.makePrecise(c), r.add(c, !1)
					}
				}
				return r.add(t[t.length - 1], !1), r.toCoordinateArray()
			}, en.densify = function(t, e) {
				var i = new en(t);
				return i.setDistanceTolerance(e), i.getResultGeometry()
			}, h(nn, le), e(nn.prototype, {
				transformMultiPolygon: function(t, e) {
					var i = le.prototype.transformMultiPolygon.call(this, t, e);
					return this.createValidArea(i)
				},
				transformPolygon: function(t, e) {
					var i = le.prototype.transformPolygon.call(this, t, e);
					return e instanceof Nt ? i : this.createValidArea(i)
				},
				transformCoordinates: function(t, e) {
					var i = t.toCoordinateArray(),
						n = en.densifyPoints(i, this.distanceTolerance, e.getPrecisionModel());
					return e instanceof Ct && 1 === n.length && (n = new Array(0).fill(null)), this.factory.getCoordinateSequenceFactory().create(n)
				},
				createValidArea: function(t) {
					return t.buffer(0)
				},
				interfaces_: function() {
					return []
				},
				getClass: function() {
					return nn
				}
			}), en.DensifyTransformer = nn;
			var $o = Object.freeze({
				Densifier: en
			});
			e(rn.prototype, {
				find: function(t) {
					var e = this;
					do {
						if (null === e) return null;
						if (e.dest().equals2D(t)) return e;
						e = e.oNext()
					} while (e !== this);
					return null
				},
				dest: function() {
					return this._sym._orig
				},
				oNext: function() {
					return this._sym._next
				},
				insert: function(t) {
					if (this.oNext() === this) return this.insertAfter(t), null;
					var e = this.compareTo(t),
						i = this;
					do {
						var n = i.oNext();
						if (n.compareTo(t) !== e || n === this) return i.insertAfter(t), null;
						i = n
					} while (i !== this);
					d.shouldNeverReachHere()
				},
				insertAfter: function(t) {
					d.equals(this._orig, t.orig());
					var e = this.oNext();
					this._sym.setNext(t), t.sym().setNext(e)
				},
				degree: function() {
					var t = 0,
						e = this;
					do {
						t++, e = e.oNext()
					} while (e !== this);
					return t
				},
				equals: function() {
					if (2 === arguments.length) {
						var t = arguments[0],
							e = arguments[1];
						return this._orig.equals2D(t) && this._sym._orig.equals(e)
					}
				},
				deltaY: function() {
					return this._sym._orig.y - this._orig.y
				},
				sym: function() {
					return this._sym
				},
				prev: function() {
					return this._sym.next()._sym
				},
				compareAngularDirection: function(t) {
					var e = this.deltaX(),
						i = this.deltaY(),
						n = t.deltaX(),
						r = t.deltaY();
					if (e === n && i === r) return 0;
					var o = Be.quadrant(e, i),
						s = Be.quadrant(n, r);
					return o > s ? 1 : s > o ? -1 : $t.computeOrientation(t._orig, t.dest(), this.dest())
				},
				prevNode: function() {
					for (var t = this; 2 === t.degree();) if ((t = t.prev()) === this) return null;
					return t
				},
				compareTo: function(t) {
					var e = t;
					return this.compareAngularDirection(e)
				},
				next: function() {
					return this._next
				},
				setSym: function(t) {
					this._sym = t
				},
				orig: function() {
					return this._orig
				},
				toString: function() {
					return "HE(" + this._orig.x + " " + this._orig.y + ", " + this._sym._orig.x + " " + this._sym._orig.y + ")"
				},
				setNext: function(t) {
					this._next = t
				},
				init: function(t) {
					this.setSym(t), t.setSym(this), this.setNext(t), t.setNext(this)
				},
				deltaX: function() {
					return this._sym._orig.x - this._orig.x
				},
				interfaces_: function() {
					return []
				},
				getClass: function() {
					return rn
				}
			}), rn.init = function(t, e) {
				if (null !== t._sym || null !== e._sym || null !== t._next || null !== e._next) throw new IllegalStateException("Edges are already initialized");
				return t.init(e), t
			}, rn.create = function(t, e) {
				var i = new rn(t),
					n = new rn(e);
				return i.init(n), i
			}, h(on, rn), e(on.prototype, {
				mark: function() {
					this._isMarked = !0
				},
				setMark: function(t) {
					this._isMarked = t
				},
				isMarked: function() {
					return this._isMarked
				},
				interfaces_: function() {
					return []
				},
				getClass: function() {
					return on
				}
			}), on.setMarkBoth = function(t, e) {
				t.setMark(e), t.sym().setMark(e)
			}, on.isMarked = function(t) {
				return t.isMarked()
			}, on.setMark = function(t, e) {
				t.setMark(e)
			}, on.markBoth = function(t) {
				t.mark(), t.sym().mark()
			}, on.mark = function(t) {
				t.mark()
			}, e(sn.prototype, {
				insert: function(t, e, i) {
					var n = this.create(t, e);
					null !== i ? i.insert(n) : this.vertexMap.put(t, n);
					var r = this.vertexMap.get(e);
					return null !== r ? r.insert(n.sym()) : this.vertexMap.put(e, n.sym()), n
				},
				create: function(t, e) {
					var i = this.createEdge(t),
						n = this.createEdge(e);
					return rn.init(i, n), i
				},
				createEdge: function(t) {
					return new rn(t)
				},
				addEdge: function(t, e) {
					if (!sn.isValidEdge(t, e)) return null;
					var i = this.vertexMap.get(t),
						n = null;
					return null !== i && (n = i.find(e)), null !== n ? n : this.insert(t, e, i)
				},
				getVertexEdges: function() {
					return this.vertexMap.values()
				},
				findEdge: function(t, e) {
					var i = this.vertexMap.get(t);
					return null === i ? null : i.find(e)
				},
				interfaces_: function() {
					return []
				},
				getClass: function() {
					return sn
				}
			}), sn.isValidEdge = function(t, e) {
				return 0 !== e.compareTo(t)
			}, h(an, on), e(an.prototype, {
				setStart: function() {
					this._isStart = !0
				},
				isStart: function() {
					return this._isStart
				},
				interfaces_: function() {
					return []
				},
				getClass: function() {
					return an
				}
			}), h(ln, sn), e(ln.prototype, {
				createEdge: function(t) {
					return new an(t)
				},
				interfaces_: function() {
					return []
				},
				getClass: function() {
					return ln
				}
			}), e(un.prototype, {
				addLine: function(t) {
					this.lines.add(this.factory.createLineString(t.toCoordinateArray()))
				},
				updateRingStartEdge: function(t) {
					return t.isStart() || (t = t.sym()).isStart() ? null === this.ringStartEdge ? (this.ringStartEdge = t, null) : void(t.orig().compareTo(this.ringStartEdge.orig()) < 0 && (this.ringStartEdge = t)) : null
				},
				getResult: function() {
					return null === this.result && this.computeResult(), this.result
				},
				process: function(t) {
					var e = t.prevNode();
					null === e && (e = t), this.stackEdges(e), this.buildLines()
				},
				buildRing: function(t) {
					var e = new x,
						i = t;
					for (e.add(i.orig().copy(), !1); 2 === i.sym().degree();) {
						var n = i.next();
						if (n === t) break;
						e.add(n.orig().copy(), !1), i = n
					}
					e.add(i.dest().copy(), !1), this.addLine(e)
				},
				buildLine: function(t) {
					var e = new x,
						i = t;
					for (this.ringStartEdge = null, on.markBoth(i), e.add(i.orig().copy(), !1); 2 === i.sym().degree();) {
						this.updateRingStartEdge(i);
						var n = i.next();
						if (n === t) return this.buildRing(this.ringStartEdge), null;
						e.add(n.orig().copy(), !1), i = n, on.markBoth(i)
					}
					e.add(i.dest().copy(), !1), this.stackEdges(i.sym()), this.addLine(e)
				},
				stackEdges: function(t) {
					var e = t;
					do {
						on.isMarked(e) || this.nodeEdgeStack.add(e), e = e.oNext()
					} while (e !== t)
				},
				computeResult: function() {
					for (var t = this.graph.getVertexEdges().iterator(); t.hasNext();) {
						var e = t.next();
						on.isMarked(e) || this.process(e)
					}
					this.result = this.factory.buildGeometry(this.lines)
				},
				buildLines: function() {
					for (; !this.nodeEdgeStack.empty();) {
						var t = this.nodeEdgeStack.pop();
						on.isMarked(t) || this.buildLine(t)
					}
				},
				add: function() {
					if (arguments[0] instanceof U) {
						var t = arguments[0];
						t.apply({
							interfaces_: function() {
								return [k]
							},
							filter: function(t) {
								t instanceof Ct && this.add(t)
							}
						})
					} else if (R(arguments[0], g)) for (var e = arguments[0], i = e.iterator(); i.hasNext();) {
						var n = i.next();
						this.add(n)
					} else if (arguments[0] instanceof Ct) {
						var r = arguments[0];
						null === this.factory && (this.factory = r.getFactory());
						var o = r.getCoordinateSequence(),
							s = !1;
						for (i = 1; i < o.size(); i++) {
							var a = this.graph.addEdge(o.getCoordinate(i - 1), o.getCoordinate(i));
							null !== a && (s || (a.setStart(), s = !0))
						}
					}
				},
				interfaces_: function() {
					return []
				},
				getClass: function() {
					return un
				}
			}), un.dissolve = function(t) {
				var e = new un;
				return e.add(t), e.getResult()
			};
			var ts = Object.freeze({
				LineDissolver: un
			});
			e(hn.prototype, {
				hasChildren: function() {
					for (var t = 0; 4 > t; t++) if (null !== this.subnode[t]) return !0;
					return !1
				},
				isPrunable: function() {
					return !(this.hasChildren() || this.hasItems())
				},
				addAllItems: function(t) {
					t.addAll(this.items);
					for (var e = 0; 4 > e; e++) null !== this.subnode[e] && this.subnode[e].addAllItems(t);
					return t
				},
				getNodeCount: function() {
					for (var t = 0, e = 0; 4 > e; e++) null !== this.subnode[e] && (t += this.subnode[e].size());
					return t + 1
				},
				size: function() {
					for (var t = 0, e = 0; 4 > e; e++) null !== this.subnode[e] && (t += this.subnode[e].size());
					return t + this.items.size()
				},
				addAllItemsFromOverlapping: function(t, e) {
					if (!this.isSearchMatch(t)) return null;
					e.addAll(this.items);
					for (var i = 0; 4 > i; i++) null !== this.subnode[i] && this.subnode[i].addAllItemsFromOverlapping(t, e)
				},
				visitItems: function(t, e) {
					for (var i = this.items.iterator(); i.hasNext();) e.visitItem(i.next())
				},
				hasItems: function() {
					return !this.items.isEmpty()
				},
				remove: function(t, e) {
					if (!this.isSearchMatch(t)) return !1;
					for (var i = !1, n = 0; 4 > n; n++) if (null !== this.subnode[n] && (i = this.subnode[n].remove(t, e))) {
						this.subnode[n].isPrunable() && (this.subnode[n] = null);
						break
					}
					return i || (i = this.items.remove(e))
				},
				visit: function(t, e) {
					if (!this.isSearchMatch(t)) return null;
					this.visitItems(t, e);
					for (var i = 0; 4 > i; i++) null !== this.subnode[i] && this.subnode[i].visit(t, e)
				},
				getItems: function() {
					return this.items
				},
				depth: function() {
					for (var t = 0, e = 0; 4 > e; e++) if (null !== this.subnode[e]) {
						var i = this.subnode[e].depth();
						i > t && (t = i)
					}
					return t + 1
				},
				isEmpty: function() {
					var t = !0;
					this.items.isEmpty() || (t = !1);
					for (var e = 0; 4 > e; e++) null !== this.subnode[e] && (this.subnode[e].isEmpty() || (t = !1));
					return t
				},
				add: function(t) {
					this.items.add(t)
				},
				interfaces_: function() {
					return [l]
				},
				getClass: function() {
					return hn
				}
			}), hn.getSubnodeIndex = function(t, e, i) {
				var n = -1;
				return t.getMinX() >= e && (t.getMinY() >= i && (n = 3), t.getMaxY() <= i && (n = 1)), t.getMaxX() <= e && (t.getMinY() >= i && (n = 2), t.getMaxY() <= i && (n = 0)), n
			}, cn.exponent = function(t) {
				return function(t, e) {
					var i, n, r, o, s = {
						32: 8,
						64: 11
					}[t];
					if (o || (i = 0 > e || 0 > 1 / e, isFinite(e) || (o = {
						32: {
							d: 127,
							c: 128,
							b: 0,
							a: 0
						},
						64: {
							d: 32752,
							c: 0,
							b: 0,
							a: 0
						}
					}[t], i && (o.d += 1 << t / 4 - 1), n = Math.pow(2, s) - 1, r = 0)), !o) {
						for (n = {
							32: 127,
							64: 1023
						}[t], r = Math.abs(e); r >= 2;) n++, r /= 2;
						for (; 1 > r && n > 0;) n--, r *= 2;
						0 >= n && (r /= 2), 32 === t && n > 254 && (o = {
							d: i ? 255 : 127,
							c: 128,
							b: 0,
							a: 0
						}, n = Math.pow(2, s) - 1, r = 0)
					}
					return n
				}(64, t) - 1023
			}, cn.powerOf2 = function(t) {
				return Math.pow(2, t)
			}, e(dn.prototype, {
				getLevel: function() {
					return this.level
				},
				computeKey: function() {
					if (1 === arguments.length) {
						var t = arguments[0];
						for (this.level = dn.computeQuadLevel(t), this.env = new C, this.computeKey(this.level, t); !this.env.contains(t);) this.level += 1, this.computeKey(this.level, t)
					} else if (2 === arguments.length) {
						var e = arguments[0],
							i = arguments[1],
							n = cn.powerOf2(e);
						this.pt.x = Math.floor(i.getMinX() / n) * n, this.pt.y = Math.floor(i.getMinY() / n) * n, this.env.init(this.pt.x, this.pt.x + n, this.pt.y, this.pt.y + n)
					}
				},
				getEnvelope: function() {
					return this.env
				},
				getCentre: function() {
					return new f((this.env.getMinX() + this.env.getMaxX()) / 2, (this.env.getMinY() + this.env.getMaxY()) / 2)
				},
				getPoint: function() {
					return this.pt
				},
				interfaces_: function() {
					return []
				},
				getClass: function() {
					return dn
				}
			}), dn.computeQuadLevel = function(t) {
				var e = t.getWidth(),
					i = t.getHeight(),
					n = e > i ? e : i;
				return cn.exponent(n) + 1
			}, h(fn, hn), e(fn.prototype, {
				find: function(t) {
					var e = hn.getSubnodeIndex(t, this.centrex, this.centrey);
					return -1 === e ? this : null !== this.subnode[e] ? this.subnode[e].find(t) : this
				},
				isSearchMatch: function(t) {
					return this.env.intersects(t)
				},
				getSubnode: function(t) {
					return null === this.subnode[t] && (this.subnode[t] = this.createSubnode(t)), this.subnode[t]
				},
				getEnvelope: function() {
					return this.env
				},
				getNode: function(t) {
					var e = hn.getSubnodeIndex(t, this.centrex, this.centrey);
					return -1 !== e ? this.getSubnode(e).getNode(t) : this
				},
				createSubnode: function(t) {
					var e = 0,
						i = 0,
						n = 0,
						r = 0;
					switch (t) {
					case 0:
						e = this.env.getMinX(), i = this.centrex, n = this.env.getMinY(), r = this.centrey;
						break;
					case 1:
						e = this.centrex, i = this.env.getMaxX(), n = this.env.getMinY(), r = this.centrey;
						break;
					case 2:
						e = this.env.getMinX(), i = this.centrex, n = this.centrey, r = this.env.getMaxY();
						break;
					case 3:
						e = this.centrex, i = this.env.getMaxX(), n = this.centrey, r = this.env.getMaxY()
					}
					return new fn(new C(e, i, n, r), this.level - 1)
				},
				insertNode: function(t) {
					d.isTrue(null === this.env || this.env.contains(t.env));
					var e = hn.getSubnodeIndex(t.env, this.centrex, this.centrey);
					if (t.level === this.level - 1) this.subnode[e] = t;
					else {
						var i = this.createSubnode(e);
						i.insertNode(t), this.subnode[e] = i
					}
				},
				interfaces_: function() {
					return []
				},
				getClass: function() {
					return fn
				}
			}), fn.createNode = function(t) {
				var e = new dn(t);
				return new fn(e.getEnvelope(), e.getLevel())
			}, fn.createExpanded = function(t, e) {
				var i = new C(e);
				null !== t && i.expandToInclude(t.env);
				var n = fn.createNode(i);
				return null !== t && n.insertNode(t), n
			}, e(An.prototype, {
				interfaces_: function() {
					return []
				},
				getClass: function() {
					return An
				}
			}), An.isZeroWidth = function(t, e) {
				var i = e - t;
				if (0 === i) return !0;
				var n = i / Math.max(Math.abs(t), Math.abs(e));
				return cn.exponent(n) <= An.MIN_BINARY_EXPONENT
			}, An.MIN_BINARY_EXPONENT = -50, h(pn, hn), e(pn.prototype, {
				insert: function(t, e) {
					var i = hn.getSubnodeIndex(t, pn.origin.x, pn.origin.y);
					if (-1 === i) return this.add(e), null;
					var n = this.subnode[i];
					if (null === n || !n.getEnvelope().contains(t)) {
						var r = fn.createExpanded(n, t);
						this.subnode[i] = r
					}
					this.insertContained(this.subnode[i], t, e)
				},
				isSearchMatch: function(t) {
					return !0
				},
				insertContained: function(t, e, i) {
					d.isTrue(t.getEnvelope().contains(e));
					var n = An.isZeroWidth(e.getMinX(), e.getMaxX()),
						r = An.isZeroWidth(e.getMinY(), e.getMaxY());
					(n || r ? t.find(e) : t.getNode(e)).add(i)
				},
				interfaces_: function() {
					return []
				},
				getClass: function() {
					return pn
				}
			}), pn.origin = new f(0, 0), e(gn.prototype, {
				size: function() {
					return null !== this.root ? this.root.size() : 0
				},
				insert: function(t, e) {
					this.collectStats(t);
					var i = gn.ensureExtent(t, this.minExtent);
					this.root.insert(i, e)
				},
				query: function() {
					if (1 === arguments.length) {
						var t = arguments[0],
							e = new Ni;
						return this.query(t, e), e.getItems()
					}
					if (2 === arguments.length) {
						var i = arguments[0],
							n = arguments[1];
						this.root.visit(i, n)
					}
				},
				queryAll: function() {
					var t = new E;
					return this.root.addAllItems(t), t
				},
				remove: function(t, e) {
					var i = gn.ensureExtent(t, this.minExtent);
					return this.root.remove(i, e)
				},
				collectStats: function(t) {
					var e = t.getWidth();
					e < this.minExtent && e > 0 && (this.minExtent = e);
					var i = t.getHeight();
					i < this.minExtent && i > 0 && (this.minExtent = i)
				},
				depth: function() {
					return null !== this.root ? this.root.depth() : 0
				},
				isEmpty: function() {
					return null === this.root
				},
				interfaces_: function() {
					return [Se, l]
				},
				getClass: function() {
					return gn
				}
			}), gn.ensureExtent = function(t, e) {
				var i = t.getMinX(),
					n = t.getMaxX(),
					r = t.getMinY(),
					o = t.getMaxY();
				return i !== n && r !== o ? t : (i === n && (n = (i -= e / 2) + e / 2), r === o && (o = (r -= e / 2) + e / 2), new C(i, n, r, o))
			}, gn.serialVersionUID = -0x678b60c967a25400;
			var es = Object.freeze({
				Quadtree: gn
			}),
				is = Object.freeze({
					STRtree: Ne
				}),
				ns = Object.freeze({
					quadtree: es,
					strtree: is
				}),
				rs = ["Point", "MultiPoint", "LineString", "MultiLineString", "Polygon", "MultiPolygon"];
			e(mn.prototype, {
				read: function(t) {
					var e, i = (e = "string" == typeof t ? JSON.parse(t) : t).type;
					if (!os[i]) throw new Error("Unknown GeoJSON type: " + e.type);
					return -1 !== rs.indexOf(i) ? os[i].apply(this, [e.coordinates]) : "GeometryCollection" === i ? os[i].apply(this, [e.geometries]) : os[i].apply(this, [e])
				},
				write: function(t) {
					var e = t.getGeometryType();
					if (!ss[e]) throw new Error("Geometry is not supported");
					return ss[e].apply(this, [t])
				}
			});
			var os = {
				Feature: function(t) {
					var e = {};
					for (var i in t) e[i] = t[i];
					if (t.geometry) {
						var n = t.geometry.type;
						if (!os[n]) throw new Error("Unknown GeoJSON type: " + t.type);
						e.geometry = this.read(t.geometry)
					}
					return t.bbox && (e.bbox = os.bbox.apply(this, [t.bbox])), e
				},
				FeatureCollection: function(t) {
					var e = {};
					if (t.features) {
						e.features = [];
						for (var i = 0; i < t.features.length; ++i) e.features.push(this.read(t.features[i]))
					}
					return t.bbox && (e.bbox = this.parse.bbox.apply(this, [t.bbox])), e
				},
				coordinates: function(t) {
					for (var e = [], i = 0; i < t.length; ++i) {
						var n = t[i];
						e.push(new f(n[0], n[1]))
					}
					return e
				},
				bbox: function(t) {
					return this.geometryFactory.createLinearRing([new f(t[0], t[1]), new f(t[2], t[1]), new f(t[2], t[3]), new f(t[0], t[3]), new f(t[0], t[1])])
				},
				Point: function(t) {
					var e = new f(t[0], t[1]);
					return this.geometryFactory.createPoint(e)
				},
				MultiPoint: function(t) {
					for (var e = [], i = 0; i < t.length; ++i) e.push(os.Point.apply(this, [t[i]]));
					return this.geometryFactory.createMultiPoint(e)
				},
				LineString: function(t) {
					var e = os.coordinates.apply(this, [t]);
					return this.geometryFactory.createLineString(e)
				},
				MultiLineString: function(t) {
					for (var e = [], i = 0; i < t.length; ++i) e.push(os.LineString.apply(this, [t[i]]));
					return this.geometryFactory.createMultiLineString(e)
				},
				Polygon: function(t) {
					for (var e = os.coordinates.apply(this, [t[0]]), i = this.geometryFactory.createLinearRing(e), n = [], r = 1; r < t.length; ++r) {
						var o = t[r],
							s = os.coordinates.apply(this, [o]),
							a = this.geometryFactory.createLinearRing(s);
						n.push(a)
					}
					return this.geometryFactory.createPolygon(i, n)
				},
				MultiPolygon: function(t) {
					for (var e = [], i = 0; i < t.length; ++i) {
						var n = t[i];
						e.push(os.Polygon.apply(this, [n]))
					}
					return this.geometryFactory.createMultiPolygon(e)
				},
				GeometryCollection: function(t) {
					for (var e = [], i = 0; i < t.length; ++i) {
						var n = t[i];
						e.push(this.read(n))
					}
					return this.geometryFactory.createGeometryCollection(e)
				}
			},
				ss = {
					coordinate: function(t) {
						return [t.x, t.y]
					},
					Point: function(t) {
						return {
							type: "Point",
							coordinates: ss.coordinate.apply(this, [t.getCoordinate()])
						}
					},
					MultiPoint: function(t) {
						for (var e = [], i = 0; i < t.geometries.length; ++i) {
							var n = t.geometries[i],
								r = ss.Point.apply(this, [n]);
							e.push(r.coordinates)
						}
						return {
							type: "MultiPoint",
							coordinates: e
						}
					},
					LineString: function(t) {
						for (var e = [], i = t.getCoordinates(), n = 0; n < i.length; ++n) {
							var r = i[n];
							e.push(ss.coordinate.apply(this, [r]))
						}
						return {
							type: "LineString",
							coordinates: e
						}
					},
					MultiLineString: function(t) {
						for (var e = [], i = 0; i < t.geometries.length; ++i) {
							var n = t.geometries[i],
								r = ss.LineString.apply(this, [n]);
							e.push(r.coordinates)
						}
						return {
							type: "MultiLineString",
							coordinates: e
						}
					},
					Polygon: function(t) {
						var e = [],
							i = ss.LineString.apply(this, [t.shell]);
						e.push(i.coordinates);
						for (var n = 0; n < t.holes.length; ++n) {
							var r = t.holes[n],
								o = ss.LineString.apply(this, [r]);
							e.push(o.coordinates)
						}
						return {
							type: "Polygon",
							coordinates: e
						}
					},
					MultiPolygon: function(t) {
						for (var e = [], i = 0; i < t.geometries.length; ++i) {
							var n = t.geometries[i],
								r = ss.Polygon.apply(this, [n]);
							e.push(r.coordinates)
						}
						return {
							type: "MultiPolygon",
							coordinates: e
						}
					},
					GeometryCollection: function(t) {
						for (var e = [], i = 0; i < t.geometries.length; ++i) {
							var n = t.geometries[i],
								r = n.getGeometryType();
							e.push(ss[r].apply(this, [n]))
						}
						return {
							type: "GeometryCollection",
							geometries: e
						}
					}
				};
			e(vn.prototype, {
				read: function(t) {
					var e = this.parser.read(t);
					return this.precisionModel.getType() === zt.FIXED && this.reducePrecision(e), e
				},
				reducePrecision: function(t) {
					var e, i;
					if (t.coordinate) this.precisionModel.makePrecise(t.coordinate);
					else if (t.points) for (e = 0, i = t.points.length; i > e; e++) this.precisionModel.makePrecise(t.points[e]);
					else if (t.geometries) for (e = 0, i = t.geometries.length; i > e; e++) this.reducePrecision(t.geometries[e])
				}
			}), e(yn.prototype, {
				write: function(t) {
					return this.parser.write(t)
				}
			}), e(_n.prototype, {
				read: function(t) {
					var e = this.parser.read(t);
					return this.precisionModel.getType() === zt.FIXED && this.reducePrecision(e), e
				},
				reducePrecision: function(t) {
					if (t.coordinate) this.precisionModel.makePrecise(t.coordinate);
					else if (t.points) for (var e = 0, i = t.points.coordinates.length; i > e; e++) this.precisionModel.makePrecise(t.points.coordinates[e]);
					else if (t.geometries) for (var n = 0, r = t.geometries.length; r > n; n++) this.reducePrecision(t.geometries[n])
				}
			}), e(xn.prototype, {
				read: function(t) {
					return t instanceof ol.geom.Point ? this.convertFromPoint(t) : t instanceof ol.geom.LineString ? this.convertFromLineString(t) : t instanceof ol.geom.LinearRing ? this.convertFromLinearRing(t) : t instanceof ol.geom.Polygon ? this.convertFromPolygon(t) : t instanceof ol.geom.MultiPoint ? this.convertFromMultiPoint(t) : t instanceof ol.geom.MultiLineString ? this.convertFromMultiLineString(t) : t instanceof ol.geom.MultiPolygon ? this.convertFromMultiPolygon(t) : t instanceof ol.geom.GeometryCollection ? this.convertFromCollection(t) : void 0
				},
				convertFromPoint: function(t) {
					var e = t.getCoordinates();
					return this.geometryFactory.createPoint(new f(e[0], e[1]))
				},
				convertFromLineString: function(t) {
					return this.geometryFactory.createLineString(t.getCoordinates().map((function(t) {
						return new f(t[0], t[1])
					})))
				},
				convertFromLinearRing: function(t) {
					return this.geometryFactory.createLinearRing(t.getCoordinates().map((function(t) {
						return new f(t[0], t[1])
					})))
				},
				convertFromPolygon: function(t) {
					for (var e = t.getLinearRings(), i = null, n = [], r = 0; r < e.length; r++) {
						var o = this.convertFromLinearRing(e[r]);
						0 === r ? i = o : n.push(o)
					}
					return this.geometryFactory.createPolygon(i, n)
				},
				convertFromMultiPoint: function(t) {
					var e = t.getPoints().map((function(t) {
						return this.convertFromPoint(t)
					}), this);
					return this.geometryFactory.createMultiPoint(e)
				},
				convertFromMultiLineString: function(t) {
					var e = t.getLineStrings().map((function(t) {
						return this.convertFromLineString(t)
					}), this);
					return this.geometryFactory.createMultiLineString(e)
				},
				convertFromMultiPolygon: function(t) {
					var e = t.getPolygons().map((function(t) {
						return this.convertFromPolygon(t)
					}), this);
					return this.geometryFactory.createMultiPolygon(e)
				},
				convertFromCollection: function(t) {
					var e = t.getGeometries().map((function(t) {
						return this.read(t)
					}), this);
					return this.geometryFactory.createGeometryCollection(e)
				},
				write: function(t) {
					return "Point" === t.getGeometryType() ? this.convertToPoint(t.getCoordinate()) : "LineString" === t.getGeometryType() ? this.convertToLineString(t) : "LinearRing" === t.getGeometryType() ? this.convertToLinearRing(t) : "Polygon" === t.getGeometryType() ? this.convertToPolygon(t) : "MultiPoint" === t.getGeometryType() ? this.convertToMultiPoint(t) : "MultiLineString" === t.getGeometryType() ? this.convertToMultiLineString(t) : "MultiPolygon" === t.getGeometryType() ? this.convertToMultiPolygon(t) : "GeometryCollection" === t.getGeometryType() ? this.convertToCollection(t) : void 0
				},
				convertToPoint: function(t) {
					return new ol.geom.Point([t.x, t.y])
				},
				convertToLineString: function(t) {
					var e = t.points.coordinates.map(En);
					return new ol.geom.LineString(e)
				},
				convertToLinearRing: function(t) {
					var e = t.points.coordinates.map(En);
					return new ol.geom.LinearRing(e)
				},
				convertToPolygon: function(t) {
					for (var e = [t.shell.points.coordinates.map(En)], i = 0; i < t.holes.length; i++) e.push(t.holes[i].points.coordinates.map(En));
					return new ol.geom.Polygon(e)
				},
				convertToMultiPoint: function(t) {
					return new ol.geom.MultiPoint(t.getCoordinates().map(En))
				},
				convertToMultiLineString: function(t) {
					for (var e = [], i = 0; i < t.geometries.length; i++) e.push(this.convertToLineString(t.geometries[i]).getCoordinates());
					return new ol.geom.MultiLineString(e)
				},
				convertToMultiPolygon: function(t) {
					for (var e = [], i = 0; i < t.geometries.length; i++) e.push(this.convertToPolygon(t.geometries[i]).getCoordinates());
					return new ol.geom.MultiPolygon(e)
				},
				convertToCollection: function(t) {
					for (var e = [], i = 0; i < t.geometries.length; i++) {
						var n = t.geometries[i];
						e.push(this.write(n))
					}
					return new ol.geom.GeometryCollection(e)
				}
			});
			var as = Object.freeze({
				GeoJSONReader: vn,
				GeoJSONWriter: yn,
				OL3Parser: xn,
				WKTReader: _n,
				WKTWriter: Ht
			});
			e(Cn.prototype, {
				rescale: function() {
					if (R(arguments[0], g)) for (var t = arguments[0], e = t.iterator(); e.hasNext();) {
						var i = e.next();
						this.rescale(i.getCoordinates())
					} else if (arguments[0] instanceof Array) {
						var n = arguments[0];
						for (2 === n.length && (new f(n[0]), new f(n[1])), e = 0; e < n.length; e++) n[e].x = n[e].x / this.scaleFactor + this.offsetX, n[e].y = n[e].y / this.scaleFactor + this.offsetY;
						2 === n.length && n[0].equals2D(n[1]) && F.out.println(n)
					}
				},
				scale: function() {
					if (R(arguments[0], g)) {
						for (var t = arguments[0], e = new E, i = t.iterator(); i.hasNext();) {
							var n = i.next();
							e.add(new Ge(this.scale(n.getCoordinates()), n.getData()))
						}
						return e
					}
					if (arguments[0] instanceof Array) {
						var r = arguments[0],
							o = new Array(r.length).fill(null);
						for (i = 0; i < r.length; i++) o[i] = new f(Math.round((r[i].x - this.offsetX) * this.scaleFactor), Math.round((r[i].y - this.offsetY) * this.scaleFactor), r[i].z);
						var s = W.removeRepeatedPoints(o);
						return s
					}
				},
				isIntegerPrecision: function() {
					return 1 === this.scaleFactor
				},
				getNodedSubstrings: function() {
					var t = this.noder.getNodedSubstrings();
					return this.isScaled && this.rescale(t), t
				},
				computeNodes: function(t) {
					var e = t;
					this.isScaled && (e = this.scale(t)), this.noder.computeNodes(e)
				},
				interfaces_: function() {
					return [Ve]
				},
				getClass: function() {
					return Cn
				}
			});
			var ls = Object.freeze({
				MCIndexNoder: ze,
				ScaledNoder: Cn,
				SegmentString: ye
			});
			e(In.prototype, {
				isSimpleMultiPoint: function(t) {
					if (t.isEmpty()) return !0;
					for (var e = new at, i = 0; i < t.getNumGeometries(); i++) {
						var n = t.getGeometryN(i).getCoordinate();
						if (e.contains(n)) return this.nonSimpleLocation = n, !1;
						e.add(n)
					}
					return !0
				},
				isSimplePolygonal: function(t) {
					for (var e = Li.getLines(t).iterator(); e.hasNext();) {
						var i = e.next();
						if (!this.isSimpleLinearGeometry(i)) return !1
					}
					return !0
				},
				hasClosedEndpointIntersection: function(t) {
					for (var e = new rt, i = t.getEdgeIterator(); i.hasNext();) {
						var n = i.next(),
							r = (n.getMaximumSegmentIndex(), n.isClosed()),
							o = n.getCoordinate(0);
						this.addEndpoint(e, o, r);
						var s = n.getCoordinate(n.getNumPoints() - 1);
						this.addEndpoint(e, s, r)
					}
					for (i = e.values().iterator(); i.hasNext();) {
						var a = i.next();
						if (a.isClosed && 2 !== a.degree) return this.nonSimpleLocation = a.getCoordinate(), !0
					}
					return !1
				},
				getNonSimpleLocation: function() {
					return this.nonSimpleLocation
				},
				isSimpleLinearGeometry: function(t) {
					if (t.isEmpty()) return !0;
					var e = new Bi(0, t),
						i = new Kt,
						n = e.computeSelfNodes(i, !0);
					return !(n.hasIntersection() && (n.hasProperIntersection() ? (this.nonSimpleLocation = n.getProperIntersectionPoint(), 1) : this.hasNonEndpointIntersection(e) || this.isClosedEndpointsInInterior && this.hasClosedEndpointIntersection(e)))
				},
				hasNonEndpointIntersection: function(t) {
					for (var e = t.getEdgeIterator(); e.hasNext();) for (var i = e.next(), n = i.getMaximumSegmentIndex(), r = i.getEdgeIntersectionList().iterator(); r.hasNext();) {
						var o = r.next();
						if (!o.isEndPoint(n)) return this.nonSimpleLocation = o.getCoordinate(), !0
					}
					return !1
				},
				addEndpoint: function(t, e, i) {
					var n = t.get(e);
					null === n && (n = new Sn(e), t.put(e, n)), n.addEndpoint(i)
				},
				computeSimple: function(t) {
					return this.nonSimpleLocation = null, !! t.isEmpty() || (t instanceof Ct ? this.isSimpleLinearGeometry(t) : t instanceof ft ? this.isSimpleLinearGeometry(t) : t instanceof wt ? this.isSimpleMultiPoint(t) : R(t, Tt) ? this.isSimplePolygonal(t) : !(t instanceof dt) || this.isSimpleGeometryCollection(t))
				},
				isSimple: function() {
					return this.nonSimpleLocation = null, this.computeSimple(this.inputGeom)
				},
				isSimpleGeometryCollection: function(t) {
					for (var e = 0; e < t.getNumGeometries(); e++) {
						var i = t.getGeometryN(e);
						if (!this.computeSimple(i)) return !1
					}
					return !0
				},
				interfaces_: function() {
					return []
				},
				getClass: function() {
					return In
				}
			}), e(Sn.prototype, {
				addEndpoint: function(t) {
					this.degree++, this.isClosed |= t
				},
				getCoordinate: function() {
					return this.pt
				},
				interfaces_: function() {
					return []
				},
				getClass: function() {
					return Sn
				}
			}), In.EndpointInfo = Sn, e(Tn.prototype, {
				getEndCapStyle: function() {
					return this.endCapStyle
				},
				isSingleSided: function() {
					return this._isSingleSided
				},
				setQuadrantSegments: function(t) {
					this.quadrantSegments = t, 0 === this.quadrantSegments && (this.joinStyle = Tn.JOIN_BEVEL), this.quadrantSegments < 0 && (this.joinStyle = Tn.JOIN_MITRE, this.mitreLimit = Math.abs(this.quadrantSegments)), 0 >= t && (this.quadrantSegments = 1), this.joinStyle !== Tn.JOIN_ROUND && (this.quadrantSegments = Tn.DEFAULT_QUADRANT_SEGMENTS)
				},
				getJoinStyle: function() {
					return this.joinStyle
				},
				setJoinStyle: function(t) {
					this.joinStyle = t
				},
				setSimplifyFactor: function(t) {
					this.simplifyFactor = 0 > t ? 0 : t
				},
				getSimplifyFactor: function() {
					return this.simplifyFactor
				},
				getQuadrantSegments: function() {
					return this.quadrantSegments
				},
				setEndCapStyle: function(t) {
					this.endCapStyle = t
				},
				getMitreLimit: function() {
					return this.mitreLimit
				},
				setMitreLimit: function(t) {
					this.mitreLimit = t
				},
				setSingleSided: function(t) {
					this._isSingleSided = t
				},
				interfaces_: function() {
					return []
				},
				getClass: function() {
					return Tn
				}
			}), Tn.bufferDistanceError = function(t) {
				var e = Math.PI / 2 / t;
				return 1 - Math.cos(e / 2)
			}, Tn.CAP_ROUND = 1, Tn.CAP_FLAT = 2, Tn.CAP_SQUARE = 3, Tn.JOIN_ROUND = 1, Tn.JOIN_MITRE = 2, Tn.JOIN_BEVEL = 3, Tn.DEFAULT_QUADRANT_SEGMENTS = 8, Tn.DEFAULT_MITRE_LIMIT = 5, Tn.DEFAULT_SIMPLIFY_FACTOR = .01, e(Rn.prototype, {
				getCoordinate: function() {
					return this.minCoord
				},
				getRightmostSide: function(t, e) {
					var i = this.getRightmostSideOfSegment(t, e);
					return 0 > i && (i = this.getRightmostSideOfSegment(t, e - 1)), 0 > i && (this.minCoord = null, this.checkForRightmostCoordinate(t)), i
				},
				findRightmostEdgeAtVertex: function() {
					var t = this.minDe.getEdge().getCoordinates();
					d.isTrue(this.minIndex > 0 && this.minIndex < t.length, "rightmost point expected to be interior vertex of edge");
					var e = t[this.minIndex - 1],
						i = t[this.minIndex + 1],
						n = $t.computeOrientation(this.minCoord, i, e),
						r = !1;
					e.y < this.minCoord.y && i.y < this.minCoord.y && n === $t.COUNTERCLOCKWISE ? r = !0 : e.y > this.minCoord.y && i.y > this.minCoord.y && n === $t.CLOCKWISE && (r = !0), r && (this.minIndex = this.minIndex - 1)
				},
				getRightmostSideOfSegment: function(t, e) {
					var i = t.getEdge().getCoordinates();
					if (0 > e || e + 1 >= i.length) return -1;
					if (i[e].y === i[e + 1].y) return -1;
					var n = Qe.LEFT;
					return i[e].y < i[e + 1].y && (n = Qe.RIGHT), n
				},
				getEdge: function() {
					return this.orientedDe
				},
				checkForRightmostCoordinate: function(t) {
					for (var e = t.getEdge().getCoordinates(), i = 0; i < e.length - 1; i++)(null === this.minCoord || e[i].x > this.minCoord.x) && (this.minDe = t, this.minIndex = i, this.minCoord = e[i])
				},
				findRightmostEdgeAtNode: function() {
					var t = this.minDe.getNode().getEdges();
					this.minDe = t.getRightmostEdge(), this.minDe.isForward() || (this.minDe = this.minDe.getSym(), this.minIndex = this.minDe.getEdge().getCoordinates().length - 1)
				},
				findEdge: function(t) {
					for (var e = t.iterator(); e.hasNext();) {
						var i = e.next();
						i.isForward() && this.checkForRightmostCoordinate(i)
					}
					d.isTrue(0 !== this.minIndex || this.minCoord.equals(this.minDe.getCoordinate()), "inconsistency in rightmost processing"), 0 === this.minIndex ? this.findRightmostEdgeAtNode() : this.findRightmostEdgeAtVertex(), this.orientedDe = this.minDe, this.getRightmostSide(this.minDe, this.minIndex) === Qe.LEFT && (this.orientedDe = this.minDe.getSym())
				},
				interfaces_: function() {
					return []
				},
				getClass: function() {
					return Rn
				}
			}), wn.prototype.addLast = function(t) {
				this.array_.push(t)
			}, wn.prototype.removeFirst = function() {
				return this.array_.shift()
			}, wn.prototype.isEmpty = function() {
				return 0 === this.array_.length
			}, e(Ln.prototype, {
				clearVisitedEdges: function() {
					for (var t = this.dirEdgeList.iterator(); t.hasNext();) t.next().setVisited(!1)
				},
				getRightmostCoordinate: function() {
					return this.rightMostCoord
				},
				computeNodeDepth: function(t) {
					for (var e = null, i = t.getEdges().iterator(); i.hasNext();) if ((n = i.next()).isVisited() || n.getSym().isVisited()) {
						e = n;
						break
					}
					if (null === e) throw new We("unable to find edge to compute depths at " + t.getCoordinate());
					for (t.getEdges().computeDepths(e), i = t.getEdges().iterator(); i.hasNext();) {
						var n;
						(n = i.next()).setVisited(!0), this.copySymDepths(n)
					}
				},
				computeDepth: function(t) {
					this.clearVisitedEdges();
					var e = this.finder.getEdge();
					e.getNode(), e.getLabel(), e.setEdgeDepths(Qe.RIGHT, t), this.copySymDepths(e), this.computeDepths(e)
				},
				create: function(t) {
					this.addReachable(t), this.finder.findEdge(this.dirEdgeList), this.rightMostCoord = this.finder.getCoordinate()
				},
				findResultEdges: function() {
					for (var t = this.dirEdgeList.iterator(); t.hasNext();) {
						var e = t.next();
						e.getDepth(Qe.RIGHT) >= 1 && e.getDepth(Qe.LEFT) <= 0 && !e.isInteriorAreaEdge() && e.setInResult(!0)
					}
				},
				computeDepths: function(t) {
					var e = new Q,
						i = new wn,
						n = t.getNode();
					for (i.addLast(n), e.add(n), t.setVisited(!0); !i.isEmpty();) {
						var r = i.removeFirst();
						e.add(r), this.computeNodeDepth(r);
						for (var o = r.getEdges().iterator(); o.hasNext();) {
							var s = o.next().getSym();
							if (!s.isVisited()) {
								var a = s.getNode();
								e.contains(a) || (i.addLast(a), e.add(a))
							}
						}
					}
				},
				compareTo: function(t) {
					var e = t;
					return this.rightMostCoord.x < e.rightMostCoord.x ? -1 : this.rightMostCoord.x > e.rightMostCoord.x ? 1 : 0
				},
				getEnvelope: function() {
					if (null === this.env) {
						for (var t = new C, e = this.dirEdgeList.iterator(); e.hasNext();) for (var i = e.next().getEdge().getCoordinates(), n = 0; n < i.length - 1; n++) t.expandToInclude(i[n]);
						this.env = t
					}
					return this.env
				},
				addReachable: function(t) {
					var e = new re;
					for (e.add(t); !e.empty();) {
						var i = e.pop();
						this.add(i, e)
					}
				},
				copySymDepths: function(t) {
					var e = t.getSym();
					e.setDepth(Qe.LEFT, t.getDepth(Qe.RIGHT)), e.setDepth(Qe.RIGHT, t.getDepth(Qe.LEFT))
				},
				add: function(t, e) {
					t.setVisited(!0), this.nodes.add(t);
					for (var i = t.getEdges().iterator(); i.hasNext();) {
						var n = i.next();
						this.dirEdgeList.add(n);
						var r = n.getSym().getNode();
						r.isVisited() || e.push(r)
					}
				},
				getNodes: function() {
					return this.nodes
				},
				getDirectedEdges: function() {
					return this.dirEdgeList
				},
				interfaces_: function() {
					return [o]
				},
				getClass: function() {
					return Ln
				}
			}), e(Nn.prototype, {
				isDeletable: function(t, e, i, n) {
					var r = this.inputLine[t],
						o = this.inputLine[e],
						s = this.inputLine[i];
					return !(!this.isConcave(r, o, s) || !this.isShallow(r, o, s, n)) && this.isShallowSampled(r, o, t, i, n)
				},
				deleteShallowConcavities: function() {
					for (var t = 1, e = (this.inputLine.length, this.findNextNonDeletedIndex(t)), i = this.findNextNonDeletedIndex(e), n = !1; i < this.inputLine.length;) {
						var r = !1;
						this.isDeletable(t, e, i, this.distanceTol) && (this.isDeleted[e] = Nn.DELETE, r = !0, n = !0), t = r ? i : e, e = this.findNextNonDeletedIndex(t), i = this.findNextNonDeletedIndex(e)
					}
					return n
				},
				isShallowConcavity: function(t, e, i, n) {
					return $t.computeOrientation(t, e, i) === this.angleOrientation && n > $t.distancePointLine(e, t, i)
				},
				isShallowSampled: function(t, e, i, n, r) {
					var o = Math.trunc((n - i) / Nn.NUM_PTS_TO_CHECK);
					0 >= o && (o = 1);
					for (var s = i; n > s; s += o) if (!this.isShallow(t, e, this.inputLine[s], r)) return !1;
					return !0
				},
				isConcave: function(t, e, i) {
					var n = $t.computeOrientation(t, e, i) === this.angleOrientation;
					return n
				},
				simplify: function(t) {
					this.distanceTol = Math.abs(t), 0 > t && (this.angleOrientation = $t.CLOCKWISE), this.isDeleted = new Array(this.inputLine.length).fill(null);
					var e = !1;
					do {
						e = this.deleteShallowConcavities()
					} while (e);
					return this.collapseLine()
				},
				findNextNonDeletedIndex: function(t) {
					for (var e = t + 1; e < this.inputLine.length && this.isDeleted[e] === Nn.DELETE;) e++;
					return e
				},
				isShallow: function(t, e, i, n) {
					return n > $t.distancePointLine(e, t, i)
				},
				collapseLine: function() {
					for (var t = new x, e = 0; e < this.inputLine.length; e++) this.isDeleted[e] !== Nn.DELETE && t.add(this.inputLine[e]);
					return t.toCoordinateArray()
				},
				interfaces_: function() {
					return []
				},
				getClass: function() {
					return Nn
				}
			}), Nn.simplify = function(t, e) {
				return new Nn(t).simplify(e)
			}, Nn.INIT = 0, Nn.DELETE = 1, Nn.KEEP = 1, Nn.NUM_PTS_TO_CHECK = 10, e(Pn.prototype, {
				getCoordinates: function() {
					return this.ptList.toArray(Pn.COORDINATE_ARRAY_TYPE)
				},
				setPrecisionModel: function(t) {
					this.precisionModel = t
				},
				addPt: function(t) {
					var e = new f(t);
					return this.precisionModel.makePrecise(e), this.isRedundant(e) ? null : void this.ptList.add(e)
				},
				reverse: function() {},
				addPts: function(t, e) {
					if (e) for (var i = 0; i < t.length; i++) this.addPt(t[i]);
					else for (i = t.length - 1; i >= 0; i--) this.addPt(t[i])
				},
				isRedundant: function(t) {
					if (this.ptList.size() < 1) return !1;
					var e = this.ptList.get(this.ptList.size() - 1);
					return t.distance(e) < this.minimimVertexDistance
				},
				toString: function() {
					return (new Wt).createLineString(this.getCoordinates()).toString()
				},
				closeRing: function() {
					if (this.ptList.size() < 1) return null;
					var t = new f(this.ptList.get(0)),
						e = this.ptList.get(this.ptList.size() - 1);
					return this.ptList.size() >= 2 && this.ptList.get(this.ptList.size() - 2), t.equals(e) ? null : void this.ptList.add(t)
				},
				setMinimumVertexDistance: function(t) {
					this.minimimVertexDistance = t
				},
				interfaces_: function() {
					return []
				},
				getClass: function() {
					return Pn
				}
			}), Pn.COORDINATE_ARRAY_TYPE = new Array(0).fill(null), e(On.prototype, {
				addNextSegment: function(t, e) {
					if (this.s0 = this.s1, this.s1 = this.s2, this.s2 = t, this.seg0.setCoordinates(this.s0, this.s1), this.computeOffsetSegment(this.seg0, this.side, this.distance, this.offset0), this.seg1.setCoordinates(this.s1, this.s2), this.computeOffsetSegment(this.seg1, this.side, this.distance, this.offset1), this.s1.equals(this.s2)) return null;
					var i = $t.computeOrientation(this.s0, this.s1, this.s2),
						n = i === $t.CLOCKWISE && this.side === Qe.LEFT || i === $t.COUNTERCLOCKWISE && this.side === Qe.RIGHT;
					0 === i ? this.addCollinear(e) : n ? this.addOutsideTurn(i, e) : this.addInsideTurn(i, e)
				},
				addLineEndCap: function(t, e) {
					var i = new te(t, e),
						n = new te;
					this.computeOffsetSegment(i, Qe.LEFT, this.distance, n);
					var r = new te;
					this.computeOffsetSegment(i, Qe.RIGHT, this.distance, r);
					var o = e.x - t.x,
						s = e.y - t.y,
						a = Math.atan2(s, o);
					switch (this.bufParams.getEndCapStyle()) {
					case Tn.CAP_ROUND:
						this.segList.addPt(n.p1), this.addFilletArc(e, a + Math.PI / 2, a - Math.PI / 2, $t.CLOCKWISE, this.distance), this.segList.addPt(r.p1);
						break;
					case Tn.CAP_FLAT:
						this.segList.addPt(n.p1), this.segList.addPt(r.p1);
						break;
					case Tn.CAP_SQUARE:
						var l = new f;
						l.x = Math.abs(this.distance) * Math.cos(a), l.y = Math.abs(this.distance) * Math.sin(a);
						var u = new f(n.p1.x + l.x, n.p1.y + l.y),
							h = new f(r.p1.x + l.x, r.p1.y + l.y);
						this.segList.addPt(u), this.segList.addPt(h)
					}
				},
				getCoordinates: function() {
					return this.segList.getCoordinates()
				},
				addMitreJoin: function(t, e, i, n) {
					var r = !0,
						o = null;
					try {
						o = D.intersection(e.p0, e.p1, i.p0, i.p1), (0 >= n ? 1 : o.distance(t) / Math.abs(n)) > this.bufParams.getMitreLimit() && (r = !1)
					} catch (t) {
						if (!(t instanceof S)) throw t;
						o = new f(0, 0), r = !1
					}
					r ? this.segList.addPt(o) : this.addLimitedMitreJoin(e, i, n, this.bufParams.getMitreLimit())
				},
				addFilletCorner: function(t, e, i, n, r) {
					var o = e.x - t.x,
						s = e.y - t.y,
						a = Math.atan2(s, o),
						l = i.x - t.x,
						u = i.y - t.y,
						h = Math.atan2(u, l);
					n === $t.CLOCKWISE ? h >= a && (a += 2 * Math.PI) : a >= h && (a -= 2 * Math.PI), this.segList.addPt(e), this.addFilletArc(t, a, h, n, r), this.segList.addPt(i)
				},
				addOutsideTurn: function(t, e) {
					return this.offset0.p1.distance(this.offset1.p0) < this.distance * On.OFFSET_SEGMENT_SEPARATION_FACTOR ? (this.segList.addPt(this.offset0.p1), null) : void(this.bufParams.getJoinStyle() === Tn.JOIN_MITRE ? this.addMitreJoin(this.s1, this.offset0, this.offset1, this.distance) : this.bufParams.getJoinStyle() === Tn.JOIN_BEVEL ? this.addBevelJoin(this.offset0, this.offset1) : (e && this.segList.addPt(this.offset0.p1), this.addFilletCorner(this.s1, this.offset0.p1, this.offset1.p0, t, this.distance), this.segList.addPt(this.offset1.p0)))
				},
				createSquare: function(t) {
					this.segList.addPt(new f(t.x + this.distance, t.y + this.distance)), this.segList.addPt(new f(t.x + this.distance, t.y - this.distance)), this.segList.addPt(new f(t.x - this.distance, t.y - this.distance)), this.segList.addPt(new f(t.x - this.distance, t.y + this.distance)), this.segList.closeRing()
				},
				addSegments: function(t, e) {
					this.segList.addPts(t, e)
				},
				addFirstSegment: function() {
					this.segList.addPt(this.offset1.p0)
				},
				addLastSegment: function() {
					this.segList.addPt(this.offset1.p1)
				},
				initSideSegments: function(t, e, i) {
					this.s1 = t, this.s2 = e, this.side = i, this.seg1.setCoordinates(t, e), this.computeOffsetSegment(this.seg1, i, this.distance, this.offset1)
				},
				addLimitedMitreJoin: function(t, e, i, n) {
					var r = this.seg0.p1,
						o = Ji.angle(r, this.seg0.p0),
						s = (Ji.angle(r, this.seg1.p1), Ji.angleBetweenOriented(this.seg0.p0, r, this.seg1.p1) / 2),
						a = Ji.normalize(o + s),
						l = Ji.normalize(a + Math.PI),
						u = n * i,
						h = i - u * Math.abs(Math.sin(s)),
						c = new te(r, new f(r.x + u * Math.cos(l), r.y + u * Math.sin(l))),
						d = c.pointAlongOffset(1, h),
						A = c.pointAlongOffset(1, -h);
					this.side === Qe.LEFT ? (this.segList.addPt(d), this.segList.addPt(A)) : (this.segList.addPt(A), this.segList.addPt(d))
				},
				computeOffsetSegment: function(t, e, i, n) {
					var r = e === Qe.LEFT ? 1 : -1,
						o = t.p1.x - t.p0.x,
						s = t.p1.y - t.p0.y,
						a = Math.sqrt(o * o + s * s),
						l = r * i * o / a,
						u = r * i * s / a;
					n.p0.x = t.p0.x - u, n.p0.y = t.p0.y + l, n.p1.x = t.p1.x - u, n.p1.y = t.p1.y + l
				},
				addFilletArc: function(t, e, i, n, r) {
					var o, s = n === $t.CLOCKWISE ? -1 : 1,
						a = Math.abs(e - i),
						l = Math.trunc(a / this.filletAngleQuantum + .5);
					if (1 > l) return null;
					o = a / l;
					for (var u = 0, h = new f; a > u;) {
						var c = e + s * u;
						h.x = t.x + r * Math.cos(c), h.y = t.y + r * Math.sin(c), this.segList.addPt(h), u += o
					}
				},
				addInsideTurn: function(t, e) {
					if (this.li.computeIntersection(this.offset0.p0, this.offset0.p1, this.offset1.p0, this.offset1.p1), this.li.hasIntersection()) this.segList.addPt(this.li.getIntersection(0));
					else if (this._hasNarrowConcaveAngle = !0, this.offset0.p1.distance(this.offset1.p0) < this.distance * On.INSIDE_TURN_VERTEX_SNAP_DISTANCE_FACTOR) this.segList.addPt(this.offset0.p1);
					else {
						if (this.segList.addPt(this.offset0.p1), this.closingSegLengthFactor > 0) {
							var i = new f((this.closingSegLengthFactor * this.offset0.p1.x + this.s1.x) / (this.closingSegLengthFactor + 1), (this.closingSegLengthFactor * this.offset0.p1.y + this.s1.y) / (this.closingSegLengthFactor + 1));
							this.segList.addPt(i);
							var n = new f((this.closingSegLengthFactor * this.offset1.p0.x + this.s1.x) / (this.closingSegLengthFactor + 1), (this.closingSegLengthFactor * this.offset1.p0.y + this.s1.y) / (this.closingSegLengthFactor + 1));
							this.segList.addPt(n)
						} else this.segList.addPt(this.s1);
						this.segList.addPt(this.offset1.p0)
					}
				},
				createCircle: function(t) {
					var e = new f(t.x + this.distance, t.y);
					this.segList.addPt(e), this.addFilletArc(t, 0, 2 * Math.PI, -1, this.distance), this.segList.closeRing()
				},
				addBevelJoin: function(t, e) {
					this.segList.addPt(t.p1), this.segList.addPt(e.p0)
				},
				init: function(t) {
					this.distance = t, this.maxCurveSegmentError = t * (1 - Math.cos(this.filletAngleQuantum / 2)), this.segList = new Pn, this.segList.setPrecisionModel(this.precisionModel), this.segList.setMinimumVertexDistance(t * On.CURVE_VERTEX_SNAP_DISTANCE_FACTOR)
				},
				addCollinear: function(t) {
					this.li.computeIntersection(this.s0, this.s1, this.s1, this.s2), this.li.getIntersectionNum() >= 2 && (this.bufParams.getJoinStyle() === Tn.JOIN_BEVEL || this.bufParams.getJoinStyle() === Tn.JOIN_MITRE ? (t && this.segList.addPt(this.offset0.p1), this.segList.addPt(this.offset1.p0)) : this.addFilletCorner(this.s1, this.offset0.p1, this.offset1.p0, $t.CLOCKWISE, this.distance))
				},
				closeRing: function() {
					this.segList.closeRing()
				},
				hasNarrowConcaveAngle: function() {
					return this._hasNarrowConcaveAngle
				},
				interfaces_: function() {
					return []
				},
				getClass: function() {
					return On
				}
			}), On.OFFSET_SEGMENT_SEPARATION_FACTOR = .001, On.INSIDE_TURN_VERTEX_SNAP_DISTANCE_FACTOR = .001, On.CURVE_VERTEX_SNAP_DISTANCE_FACTOR = 1e-6, On.MAX_CLOSING_SEG_LEN_FACTOR = 80, e(Mn.prototype, {
				getOffsetCurve: function(t, e) {
					if (this.distance = e, 0 === e) return null;
					var i = 0 > e,
						n = Math.abs(e),
						r = this.getSegGen(n);
					t.length <= 1 ? this.computePointCurve(t[0], r) : this.computeOffsetCurve(t, i, r);
					var o = r.getCoordinates();
					return i && W.reverse(o), o
				},
				computeSingleSidedBufferCurve: function(t, e, i) {
					var n = this.simplifyTolerance(this.distance);
					if (e) {
						i.addSegments(t, !0);
						var r = Nn.simplify(t, -n),
							o = r.length - 1;
						i.initSideSegments(r[o], r[o - 1], Qe.LEFT), i.addFirstSegment();
						for (var s = o - 2; s >= 0; s--) i.addNextSegment(r[s], !0)
					} else {
						i.addSegments(t, !1);
						var a = Nn.simplify(t, n),
							l = a.length - 1;
						for (i.initSideSegments(a[0], a[1], Qe.LEFT), i.addFirstSegment(), s = 2; l >= s; s++) i.addNextSegment(a[s], !0)
					}
					i.addLastSegment(), i.closeRing()
				},
				computeRingBufferCurve: function(t, e, i) {
					var n = this.simplifyTolerance(this.distance);
					e === Qe.RIGHT && (n = -n);
					var r = Nn.simplify(t, n),
						o = r.length - 1;
					i.initSideSegments(r[o - 1], r[0], e);
					for (var s = 1; o >= s; s++) {
						var a = 1 !== s;
						i.addNextSegment(r[s], a)
					}
					i.closeRing()
				},
				computeLineBufferCurve: function(t, e) {
					var i = this.simplifyTolerance(this.distance),
						n = Nn.simplify(t, i),
						r = n.length - 1;
					e.initSideSegments(n[0], n[1], Qe.LEFT);
					for (var o = 2; r >= o; o++) e.addNextSegment(n[o], !0);
					e.addLastSegment(), e.addLineEndCap(n[r - 1], n[r]);
					var s = Nn.simplify(t, -i),
						a = s.length - 1;
					for (e.initSideSegments(s[a], s[a - 1], Qe.LEFT), o = a - 2; o >= 0; o--) e.addNextSegment(s[o], !0);
					e.addLastSegment(), e.addLineEndCap(s[1], s[0]), e.closeRing()
				},
				computePointCurve: function(t, e) {
					switch (this.bufParams.getEndCapStyle()) {
					case Tn.CAP_ROUND:
						e.createCircle(t);
						break;
					case Tn.CAP_SQUARE:
						e.createSquare(t)
					}
				},
				getLineCurve: function(t, e) {
					if (this.distance = e, 0 > e && !this.bufParams.isSingleSided()) return null;
					if (0 === e) return null;
					var i = Math.abs(e),
						n = this.getSegGen(i);
					if (t.length <= 1) this.computePointCurve(t[0], n);
					else if (this.bufParams.isSingleSided()) {
						var r = 0 > e;
						this.computeSingleSidedBufferCurve(t, r, n)
					} else this.computeLineBufferCurve(t, n);
					return n.getCoordinates()
				},
				getBufferParameters: function() {
					return this.bufParams
				},
				simplifyTolerance: function(t) {
					return t * this.bufParams.getSimplifyFactor()
				},
				getRingCurve: function(t, e, i) {
					if (this.distance = i, t.length <= 2) return this.getLineCurve(t, i);
					if (0 === i) return Mn.copyCoordinates(t);
					var n = this.getSegGen(i);
					return this.computeRingBufferCurve(t, e, n), n.getCoordinates()
				},
				computeOffsetCurve: function(t, e, i) {
					var n = this.simplifyTolerance(this.distance);
					if (e) {
						var r = Nn.simplify(t, -n),
							o = r.length - 1;
						i.initSideSegments(r[o], r[o - 1], Qe.LEFT), i.addFirstSegment();
						for (var s = o - 2; s >= 0; s--) i.addNextSegment(r[s], !0)
					} else {
						var a = Nn.simplify(t, n),
							l = a.length - 1;
						for (i.initSideSegments(a[0], a[1], Qe.LEFT), i.addFirstSegment(), s = 2; l >= s; s++) i.addNextSegment(a[s], !0)
					}
					i.addLastSegment()
				},
				getSegGen: function(t) {
					return new On(this.precisionModel, this.bufParams, t)
				},
				interfaces_: function() {
					return []
				},
				getClass: function() {
					return Mn
				}
			}), Mn.copyCoordinates = function(t) {
				for (var e = new Array(t.length).fill(null), i = 0; i < e.length; i++) e[i] = new f(t[i]);
				return e
			}, e(bn.prototype, {
				findStabbedSegments: function() {
					if (1 === arguments.length) {
						for (var t = arguments[0], e = new E, i = this.subgraphs.iterator(); i.hasNext();) {
							var n = i.next(),
								r = n.getEnvelope();
							t.y < r.getMinY() || t.y > r.getMaxY() || this.findStabbedSegments(t, n.getDirectedEdges(), e)
						}
						return e
					}
					if (3 === arguments.length) if (R(arguments[2], v) && arguments[0] instanceof f && arguments[1] instanceof li) {
						var o = arguments[0],
							s = arguments[1],
							a = arguments[2],
							l = s.getEdge().getCoordinates();
						for (i = 0; i < l.length - 1; i++) {
							this.seg.p0 = l[i], this.seg.p1 = l[i + 1], this.seg.p0.y > this.seg.p1.y && this.seg.reverse();
							var u = Math.max(this.seg.p0.x, this.seg.p1.x);
							if (!(u < o.x || this.seg.isHorizontal() || o.y < this.seg.p0.y || o.y > this.seg.p1.y || $t.computeOrientation(this.seg.p0, this.seg.p1, o) === $t.RIGHT)) {
								var h = s.getDepth(Qe.LEFT);
								this.seg.p0.equals(l[i]) || (h = s.getDepth(Qe.RIGHT));
								var c = new Fn(this.seg, h);
								a.add(c)
							}
						}
					} else if (R(arguments[2], v) && arguments[0] instanceof f && R(arguments[1], v)) {
						var d = arguments[0],
							A = arguments[1],
							p = arguments[2];
						for (i = A.iterator(); i.hasNext();) {
							var g = i.next();
							g.isForward() && this.findStabbedSegments(d, g, p)
						}
					}
				},
				getDepth: function(t) {
					var e = this.findStabbedSegments(t);
					return 0 === e.size() ? 0 : Jo.min(e).leftDepth
				},
				interfaces_: function() {
					return []
				},
				getClass: function() {
					return bn
				}
			}), e(Fn.prototype, {
				compareTo: function(t) {
					var e = t;
					if (this.upwardSeg.minX() >= e.upwardSeg.maxX()) return 1;
					if (this.upwardSeg.maxX() <= e.upwardSeg.minX()) return -1;
					var i = this.upwardSeg.orientationIndex(e.upwardSeg);
					return 0 !== i ? i : 0 != (i = -1 * e.upwardSeg.orientationIndex(this.upwardSeg)) ? i : this.upwardSeg.compareTo(e.upwardSeg)
				},
				compareX: function(t, e) {
					var i = t.p0.compareTo(e.p0);
					return 0 !== i ? i : t.p1.compareTo(e.p1)
				},
				toString: function() {
					return this.upwardSeg.toString()
				},
				interfaces_: function() {
					return [o]
				},
				getClass: function() {
					return Fn
				}
			}), bn.DepthSegment = Fn, e(Dn.prototype, {
				addPoint: function(t) {
					if (this.distance <= 0) return null;
					var e = t.getCoordinates(),
						i = this.curveBuilder.getLineCurve(e, this.distance);
					this.addCurve(i, T.EXTERIOR, T.INTERIOR)
				},
				addPolygon: function(t) {
					var e = this.distance,
						i = Qe.LEFT;
					this.distance < 0 && (e = -this.distance, i = Qe.RIGHT);
					var n = t.getExteriorRing(),
						r = W.removeRepeatedPoints(n.getCoordinates());
					if (this.distance < 0 && this.isErodedCompletely(n, this.distance)) return null;
					if (this.distance <= 0 && r.length < 3) return null;
					this.addPolygonRing(r, e, i, T.EXTERIOR, T.INTERIOR);
					for (var o = 0; o < t.getNumInteriorRing(); o++) {
						var s = t.getInteriorRingN(o),
							a = W.removeRepeatedPoints(s.getCoordinates());
						this.distance > 0 && this.isErodedCompletely(s, -this.distance) || this.addPolygonRing(a, e, Qe.opposite(i), T.INTERIOR, T.EXTERIOR)
					}
				},
				isTriangleErodedCompletely: function(t, e) {
					var i = new Qi(t[0], t[1], t[2]),
						n = i.inCentre();
					return $t.distancePointLine(n, i.p0, i.p1) < Math.abs(e)
				},
				addLineString: function(t) {
					if (this.distance <= 0 && !this.curveBuilder.getBufferParameters().isSingleSided()) return null;
					var e = W.removeRepeatedPoints(t.getCoordinates()),
						i = this.curveBuilder.getLineCurve(e, this.distance);
					this.addCurve(i, T.EXTERIOR, T.INTERIOR)
				},
				addCurve: function(t, e, i) {
					if (null === t || t.length < 2) return null;
					var n = new Ge(t, new ti(0, T.BOUNDARY, e, i));
					this.curveList.add(n)
				},
				getCurves: function() {
					return this.add(this.inputGeom), this.curveList
				},
				addPolygonRing: function(t, e, i, n, r) {
					if (0 === e && t.length < Lt.MINIMUM_VALID_SIZE) return null;
					var o = n,
						s = r;
					t.length >= Lt.MINIMUM_VALID_SIZE && $t.isCCW(t) && (o = r, s = n, i = Qe.opposite(i));
					var a = this.curveBuilder.getRingCurve(t, i, e);
					this.addCurve(a, o, s)
				},
				add: function(t) {
					if (t.isEmpty()) return null;
					if (t instanceof Rt) this.addPolygon(t);
					else if (t instanceof Ct) this.addLineString(t);
					else if (t instanceof St) this.addPoint(t);
					else if (t instanceof wt) this.addCollection(t);
					else if (t instanceof ft) this.addCollection(t);
					else if (t instanceof Nt) this.addCollection(t);
					else {
						if (!(t instanceof dt)) throw new UnsupportedOperationException(t.getClass().getName());
						this.addCollection(t)
					}
				},
				isErodedCompletely: function(t, e) {
					var i = t.getCoordinates();
					if (i.length < 4) return 0 > e;
					if (4 === i.length) return this.isTriangleErodedCompletely(i, e);
					var n = t.getEnvelopeInternal(),
						r = Math.min(n.getHeight(), n.getWidth());
					return 0 > e && 2 * Math.abs(e) > r
				},
				addCollection: function(t) {
					for (var e = 0; e < t.getNumGeometries(); e++) {
						var i = t.getGeometryN(e);
						this.add(i)
					}
				},
				interfaces_: function() {
					return []
				},
				getClass: function() {
					return Dn
				}
			}), e(Gn.prototype, {
				isTrivialIntersection: function(t, e, i, n) {
					if (t === i && 1 === this.li.getIntersectionNum()) {
						if (Gn.isAdjacentSegments(e, n)) return !0;
						if (t.isClosed()) {
							var r = t.size() - 1;
							if (0 === e && n === r || 0 === n && e === r) return !0
						}
					}
					return !1
				},
				getProperIntersectionPoint: function() {
					return this.properIntersectionPoint
				},
				hasProperInteriorIntersection: function() {
					return this.hasProperInterior
				},
				getLineIntersector: function() {
					return this.li
				},
				hasProperIntersection: function() {
					return this.hasProper
				},
				processIntersections: function(t, e, i, n) {
					if (t === i && e === n) return null;
					this.numTests++;
					var r = t.getCoordinates()[e],
						o = t.getCoordinates()[e + 1],
						s = i.getCoordinates()[n],
						a = i.getCoordinates()[n + 1];
					this.li.computeIntersection(r, o, s, a), this.li.hasIntersection() && (this.numIntersections++, this.li.isInteriorIntersection() && (this.numInteriorIntersections++, this.hasInterior = !0), this.isTrivialIntersection(t, e, i, n) || (this._hasIntersection = !0, t.addIntersections(this.li, e, 0), i.addIntersections(this.li, n, 1), this.li.isProper() && (this.numProperIntersections++, this.hasProper = !0, this.hasProperInterior = !0)))
				},
				hasIntersection: function() {
					return this._hasIntersection
				},
				isDone: function() {
					return !1
				},
				hasInteriorIntersection: function() {
					return this.hasInterior
				},
				interfaces_: function() {
					return [qe]
				},
				getClass: function() {
					return Gn
				}
			}), Gn.isAdjacentSegments = function(t, e) {
				return 1 === Math.abs(t - e)
			}, e(kn.prototype, {
				setWorkingPrecisionModel: function(t) {
					this.workingPrecisionModel = t
				},
				insertUniqueEdge: function(t) {
					var e = this.edgeList.findEqualEdge(t);
					if (null !== e) {
						var i = e.getLabel(),
							n = t.getLabel();
						e.isPointwiseEqual(t) || (n = new ti(t.getLabel())).flip(), i.merge(n);
						var r = kn.depthDelta(n),
							o = e.getDepthDelta() + r;
						e.setDepthDelta(o)
					} else this.edgeList.add(t), t.setDepthDelta(kn.depthDelta(t.getLabel()))
				},
				buildSubgraphs: function(t, e) {
					for (var i = new E, n = t.iterator(); n.hasNext();) {
						var r = n.next(),
							o = r.getRightmostCoordinate(),
							s = new bn(i).getDepth(o);
						r.computeDepth(s), r.findResultEdges(), i.add(r), e.add(r.getDirectedEdges(), r.getNodes())
					}
				},
				createSubgraphs: function(t) {
					for (var e = new E, i = t.getNodes().iterator(); i.hasNext();) {
						var n = i.next();
						if (!n.isVisited()) {
							var r = new Ln;
							r.create(n), e.add(r)
						}
					}
					return Jo.sort(e, Jo.reverseOrder()), e
				},
				createEmptyResultGeometry: function() {
					return this.geomFact.createPolygon()
				},
				getNoder: function(t) {
					if (null !== this.workingNoder) return this.workingNoder;
					var e = new ze,
						i = new Kt;
					return i.setPrecisionModel(t), e.setSegmentIntersector(new Gn(i)), e
				},
				buffer: function(t, e) {
					var i = this.workingPrecisionModel;
					null === i && (i = t.getPrecisionModel()), this.geomFact = t.getFactory();
					var n = new Dn(t, e, new Mn(i, this.bufParams)).getCurves();
					if (n.size() <= 0) return this.createEmptyResultGeometry();
					this.computeNodedEdges(n, i), this.graph = new hi(new vi), this.graph.addEdges(this.edgeList.getEdges());
					var r = this.createSubgraphs(this.graph),
						o = new ci(this.geomFact);
					this.buildSubgraphs(r, o);
					var s = o.getPolygons();
					return s.size() <= 0 ? this.createEmptyResultGeometry() : this.geomFact.buildGeometry(s)
				},
				computeNodedEdges: function(t, e) {
					var i = this.getNoder(e);
					i.computeNodes(t);
					for (var n = i.getNodedSubstrings().iterator(); n.hasNext();) {
						var r = n.next(),
							o = r.getCoordinates();
						if (2 !== o.length || !o[0].equals2D(o[1])) {
							var s = r.getData(),
								a = new Ui(r.getCoordinates(), new ti(s));
							this.insertUniqueEdge(a)
						}
					}
				},
				setNoder: function(t) {
					this.workingNoder = t
				},
				interfaces_: function() {
					return []
				},
				getClass: function() {
					return kn
				}
			}), kn.depthDelta = function(t) {
				var e = t.getLocation(0, Qe.LEFT),
					i = t.getLocation(0, Qe.RIGHT);
				return e === T.INTERIOR && i === T.EXTERIOR ? 1 : e === T.EXTERIOR && i === T.INTERIOR ? -1 : 0
			}, kn.convertSegStrings = function(t) {
				for (var e = new Wt, i = new E; t.hasNext();) {
					var n = t.next(),
						r = e.createLineString(n.getCoordinates());
					i.add(r)
				}
				return e.buildGeometry(i)
			}, e(Un.prototype, {
				checkEndPtVertexIntersections: function() {
					if (0 === arguments.length) for (var t = this.segStrings.iterator(); t.hasNext();) {
						var e = t.next().getCoordinates();
						this.checkEndPtVertexIntersections(e[0], this.segStrings), this.checkEndPtVertexIntersections(e[e.length - 1], this.segStrings)
					} else if (2 === arguments.length) {
						var i = arguments[0],
							n = arguments[1];
						for (t = n.iterator(); t.hasNext();) {
							e = t.next().getCoordinates();
							for (var r = 1; r < e.length - 1; r++) if (e[r].equals(i)) throw new u("found endpt/interior pt intersection at index " + r + " :pt " + i)
						}
					}
				},
				checkInteriorIntersections: function() {
					if (0 === arguments.length) for (var t = this.segStrings.iterator(); t.hasNext();) for (var e = t.next(), i = this.segStrings.iterator(); i.hasNext();) {
						var n = i.next();
						this.checkInteriorIntersections(e, n)
					} else if (2 === arguments.length) for (var r = arguments[0], o = arguments[1], s = r.getCoordinates(), a = o.getCoordinates(), l = 0; l < s.length - 1; l++) for (var h = 0; h < a.length - 1; h++) this.checkInteriorIntersections(r, l, o, h);
					else if (4 === arguments.length) {
						var c = arguments[0],
							d = arguments[1],
							f = arguments[2],
							A = arguments[3];
						if (c === f && d === A) return null;
						var p = c.getCoordinates()[d],
							g = c.getCoordinates()[d + 1],
							m = f.getCoordinates()[A],
							v = f.getCoordinates()[A + 1];
						if (this.li.computeIntersection(p, g, m, v), this.li.hasIntersection() && (this.li.isProper() || this.hasInteriorIntersection(this.li, p, g) || this.hasInteriorIntersection(this.li, m, v))) throw new u("found non-noded intersection at " + p + "-" + g + " and " + m + "-" + v)
					}
				},
				checkValid: function() {
					this.checkEndPtVertexIntersections(), this.checkInteriorIntersections(), this.checkCollapses()
				},
				checkCollapses: function() {
					if (0 === arguments.length) for (var t = this.segStrings.iterator(); t.hasNext();) {
						var e = t.next();
						this.checkCollapses(e)
					} else if (1 === arguments.length) {
						var i = arguments[0],
							n = i.getCoordinates();
						for (t = 0; t < n.length - 2; t++) this.checkCollapse(n[t], n[t + 1], n[t + 2])
					}
				},
				hasInteriorIntersection: function(t, e, i) {
					for (var n = 0; n < t.getIntersectionNum(); n++) {
						var r = t.getIntersection(n);
						if (!r.equals(e) && !r.equals(i)) return !0
					}
					return !1
				},
				checkCollapse: function(t, e, i) {
					if (t.equals(i)) throw new u("found non-noded collapse at " + Un.fact.createLineString([t, e, i]))
				},
				interfaces_: function() {
					return []
				},
				getClass: function() {
					return Un
				}
			}), Un.fact = new Wt, e(Bn.prototype, {
				intersectsScaled: function(t, e) {
					var i = Math.min(t.x, e.x),
						n = Math.max(t.x, e.x),
						r = Math.min(t.y, e.y),
						o = Math.max(t.y, e.y),
						s = this.maxx < i || this.minx > n || this.maxy < r || this.miny > o;
					if (s) return !1;
					var a = this.intersectsToleranceSquare(t, e);
					return d.isTrue(!(s && a), "Found bad envelope test"), a
				},
				initCorners: function(t) {
					this.minx = t.x - .5, this.maxx = t.x + .5, this.miny = t.y - .5, this.maxy = t.y + .5, this.corner[0] = new f(this.maxx, this.maxy), this.corner[1] = new f(this.minx, this.maxy), this.corner[2] = new f(this.minx, this.miny), this.corner[3] = new f(this.maxx, this.miny)
				},
				intersects: function(t, e) {
					return 1 === this.scaleFactor ? this.intersectsScaled(t, e) : (this.copyScaled(t, this.p0Scaled), this.copyScaled(e, this.p1Scaled), this.intersectsScaled(this.p0Scaled, this.p1Scaled))
				},
				scale: function(t) {
					return Math.round(t * this.scaleFactor)
				},
				getCoordinate: function() {
					return this.originalPt
				},
				copyScaled: function(t, e) {
					e.x = this.scale(t.x), e.y = this.scale(t.y)
				},
				getSafeEnvelope: function() {
					if (null === this.safeEnv) {
						var t = Bn.SAFE_ENV_EXPANSION_FACTOR / this.scaleFactor;
						this.safeEnv = new C(this.originalPt.x - t, this.originalPt.x + t, this.originalPt.y - t, this.originalPt.y + t)
					}
					return this.safeEnv
				},
				intersectsPixelClosure: function(t, e) {
					return this.li.computeIntersection(t, e, this.corner[0], this.corner[1]), !! (this.li.hasIntersection() || (this.li.computeIntersection(t, e, this.corner[1], this.corner[2]), this.li.hasIntersection() || (this.li.computeIntersection(t, e, this.corner[2], this.corner[3]), this.li.hasIntersection() || (this.li.computeIntersection(t, e, this.corner[3], this.corner[0]), this.li.hasIntersection()))))
				},
				intersectsToleranceSquare: function(t, e) {
					var i = !1,
						n = !1;
					return this.li.computeIntersection(t, e, this.corner[0], this.corner[1]), !! (this.li.isProper() || (this.li.computeIntersection(t, e, this.corner[1], this.corner[2]), this.li.isProper() || (this.li.hasIntersection() && (i = !0), this.li.computeIntersection(t, e, this.corner[2], this.corner[3]), this.li.isProper() || (this.li.hasIntersection() && (n = !0), this.li.computeIntersection(t, e, this.corner[3], this.corner[0]), this.li.isProper() || i && n || t.equals(this.pt) || e.equals(this.pt)))))
				},
				addSnappedNode: function(t, e) {
					var i = t.getCoordinate(e),
						n = t.getCoordinate(e + 1);
					return !!this.intersects(i, n) && (t.addIntersection(this.getCoordinate(), e), !0)
				},
				interfaces_: function() {
					return []
				},
				getClass: function() {
					return Bn
				}
			}), Bn.SAFE_ENV_EXPANSION_FACTOR = .75, e(jn.prototype, {
				select: function() {
					if (1 === arguments.length) arguments[0];
					else if (2 === arguments.length) {
						var t = arguments[0],
							e = arguments[1];
						t.getLineSegment(e, this.selectedSegment), this.select(this.selectedSegment)
					}
				},
				interfaces_: function() {
					return []
				},
				getClass: function() {
					return jn
				}
			}), e(Vn.prototype, {
				snap: function() {
					if (1 === arguments.length) {
						var t = arguments[0];
						return this.snap(t, null, -1)
					}
					if (3 === arguments.length) {
						var e = arguments[0],
							i = arguments[1],
							n = arguments[2],
							r = e.getSafeEnvelope(),
							o = new Yn(e, i, n);
						return this.index.query(r, {
							interfaces_: function() {
								return [Ie]
							},
							visitItem: function(t) {
								t.select(r, o)
							}
						}), o.isNodeAdded()
					}
				},
				interfaces_: function() {
					return []
				},
				getClass: function() {
					return Vn
				}
			}), h(Yn, jn), e(Yn.prototype, {
				isNodeAdded: function() {
					return this._isNodeAdded
				},
				select: function() {
					if (2 !== arguments.length) return jn.prototype.select.apply(this, arguments);
					var t = arguments[0],
						e = arguments[1],
						i = t.getContext();
					return null !== this.parentEdge && i === this.parentEdge && e === this.hotPixelVertexIndex ? null : void(this._isNodeAdded = this.hotPixel.addSnappedNode(i, e))
				},
				interfaces_: function() {
					return []
				},
				getClass: function() {
					return Yn
				}
			}), Vn.HotPixelSnapAction = Yn, e(zn.prototype, {
				processIntersections: function(t, e, i, n) {
					if (t === i && e === n) return null;
					var r = t.getCoordinates()[e],
						o = t.getCoordinates()[e + 1],
						s = i.getCoordinates()[n],
						a = i.getCoordinates()[n + 1];
					if (this.li.computeIntersection(r, o, s, a), this.li.hasIntersection() && this.li.isInteriorIntersection()) {
						for (var l = 0; l < this.li.getIntersectionNum(); l++) this.interiorIntersections.add(this.li.getIntersection(l));
						t.addIntersections(this.li, e, 0), i.addIntersections(this.li, n, 1)
					}
				},
				isDone: function() {
					return !1
				},
				getInteriorIntersections: function() {
					return this.interiorIntersections
				},
				interfaces_: function() {
					return [qe]
				},
				getClass: function() {
					return zn
				}
			}), e(Xn.prototype, {
				checkCorrectness: function(t) {
					var e = new Un(Ge.getNodedSubstrings(t));
					try {
						e.checkValid()
					} catch (t) {
						if (!(t instanceof I)) throw t;
						t.printStackTrace()
					}
				},
				getNodedSubstrings: function() {
					return Ge.getNodedSubstrings(this.nodedSegStrings)
				},
				snapRound: function(t, e) {
					var i = this.findInteriorIntersections(t, e);
					this.computeIntersectionSnaps(i), this.computeVertexSnaps(t)
				},
				findInteriorIntersections: function(t, e) {
					var i = new zn(e);
					return this.noder.setSegmentIntersector(i), this.noder.computeNodes(t), i.getInteriorIntersections()
				},
				computeVertexSnaps: function() {
					if (R(arguments[0], g)) for (var t = arguments[0], e = t.iterator(); e.hasNext();) {
						var i = e.next();
						this.computeVertexSnaps(i)
					} else if (arguments[0] instanceof Ge) for (var n = arguments[0], r = n.getCoordinates(), o = 0; o < r.length; o++) {
						var s = new Bn(r[o], this.scaleFactor, this.li),
							a = this.pointSnapper.snap(s, n, o);
						a && n.addIntersection(r[o], o)
					}
				},
				computeNodes: function(t) {
					this.nodedSegStrings = t, this.noder = new ze, this.pointSnapper = new Vn(this.noder.getIndex()), this.snapRound(t, this.li)
				},
				computeIntersectionSnaps: function(t) {
					for (var e = t.iterator(); e.hasNext();) {
						var i = new Bn(e.next(), this.scaleFactor, this.li);
						this.pointSnapper.snap(i)
					}
				},
				interfaces_: function() {
					return [Ve]
				},
				getClass: function() {
					return Xn
				}
			}), e(Wn.prototype, {
				bufferFixedPrecision: function(t) {
					var e = new Cn(new Xn(new zt(1)), t.getScale()),
						i = new kn(this.bufParams);
					i.setWorkingPrecisionModel(t), i.setNoder(e), this.resultGeometry = i.buffer(this.argGeom, this.distance)
				},
				bufferReducedPrecision: function() {
					if (0 === arguments.length) {
						for (var t = Wn.MAX_PRECISION_DIGITS; t >= 0; t--) {
							try {
								this.bufferReducedPrecision(t)
							} catch (t) {
								if (!(t instanceof We)) throw t;
								this.saveException = t
							}
							if (null !== this.resultGeometry) return null
						}
						throw this.saveException
					}
					if (1 === arguments.length) {
						var e = arguments[0],
							i = Wn.precisionScaleFactor(this.argGeom, this.distance, e),
							n = new zt(i);
						this.bufferFixedPrecision(n)
					}
				},
				computeGeometry: function() {
					if (this.bufferOriginalPrecision(), null !== this.resultGeometry) return null;
					var t = this.argGeom.getFactory().getPrecisionModel();
					t.getType() === zt.FIXED ? this.bufferFixedPrecision(t) : this.bufferReducedPrecision()
				},
				setQuadrantSegments: function(t) {
					this.bufParams.setQuadrantSegments(t)
				},
				bufferOriginalPrecision: function() {
					try {
						var t = new kn(this.bufParams);
						this.resultGeometry = t.buffer(this.argGeom, this.distance)
					} catch (t) {
						if (!(t instanceof u)) throw t;
						this.saveException = t
					}
				},
				getResultGeometry: function(t) {
					return this.distance = t, this.computeGeometry(), this.resultGeometry
				},
				setEndCapStyle: function(t) {
					this.bufParams.setEndCapStyle(t)
				},
				interfaces_: function() {
					return []
				},
				getClass: function() {
					return Wn
				}
			}), Wn.bufferOp = function() {
				if (2 === arguments.length) {
					var t = arguments[0],
						e = arguments[1],
						i = new Wn(t);
					return i.getResultGeometry(e)
				}
				if (3 === arguments.length) {
					if (Number.isInteger(arguments[2]) && arguments[0] instanceof U && "number" == typeof arguments[1]) {
						var n = arguments[0],
							r = arguments[1],
							o = arguments[2];
						return (u = new Wn(n)).setQuadrantSegments(o), u.getResultGeometry(r)
					}
					if (arguments[2] instanceof Tn && arguments[0] instanceof U && "number" == typeof arguments[1]) {
						var s = arguments[0],
							a = arguments[1],
							l = arguments[2];
						return (u = new Wn(s, l)).getResultGeometry(a)
					}
				} else if (4 === arguments.length) {
					var u, h = arguments[0],
						c = arguments[1],
						d = arguments[2],
						f = arguments[3];
					return (u = new Wn(h)).setQuadrantSegments(d), u.setEndCapStyle(f), u.getResultGeometry(c)
				}
			}, Wn.precisionScaleFactor = function(t, e, i) {
				var n = t.getEnvelopeInternal(),
					r = w.max(Math.abs(n.getMaxX()), Math.abs(n.getMaxY()), Math.abs(n.getMinX()), Math.abs(n.getMinY())) + 2 * (e > 0 ? e : 0),
					o = i - Math.trunc(Math.log(r) / Math.log(10) + 1);
				return Math.pow(10, o)
			}, Wn.CAP_ROUND = Tn.CAP_ROUND, Wn.CAP_BUTT = Tn.CAP_FLAT, Wn.CAP_FLAT = Tn.CAP_FLAT, Wn.CAP_SQUARE = Tn.CAP_SQUARE, Wn.MAX_PRECISION_DIGITS = 12;
			var us = Object.freeze({
				BufferOp: Wn,
				BufferParameters: Tn
			});
			e(qn.prototype, {
				filter: function(t) {
					t instanceof Rt && this.comps.add(t)
				},
				interfaces_: function() {
					return [ht]
				},
				getClass: function() {
					return qn
				}
			}), qn.getPolygons = function() {
				if (1 === arguments.length) {
					var t = arguments[0];
					return qn.getPolygons(t, new E)
				}
				if (2 === arguments.length) {
					var e = arguments[0],
						i = arguments[1];
					return e instanceof Rt ? i.add(e) : e instanceof dt && e.apply(new qn(i)), i
				}
			}, e(Hn.prototype, {
				isInsideArea: function() {
					return this.segIndex === Hn.INSIDE_AREA
				},
				getCoordinate: function() {
					return this.pt
				},
				getGeometryComponent: function() {
					return this.component
				},
				getSegmentIndex: function() {
					return this.segIndex
				},
				interfaces_: function() {
					return []
				},
				getClass: function() {
					return Hn
				}
			}), Hn.INSIDE_AREA = -1, e(Zn.prototype, {
				filter: function(t) {
					t instanceof St && this.pts.add(t)
				},
				interfaces_: function() {
					return [ht]
				},
				getClass: function() {
					return Zn
				}
			}), Zn.getPoints = function() {
				if (1 === arguments.length) {
					var t = arguments[0];
					return t instanceof St ? Jo.singletonList(t) : Zn.getPoints(t, new E)
				}
				if (2 === arguments.length) {
					var e = arguments[0],
						i = arguments[1];
					return e instanceof St ? i.add(e) : e instanceof dt && e.apply(new Zn(i)), i
				}
			}, e(Kn.prototype, {
				filter: function(t) {
					(t instanceof St || t instanceof Ct || t instanceof Rt) && this.locations.add(new Hn(t, 0, t.getCoordinate()))
				},
				interfaces_: function() {
					return [ht]
				},
				getClass: function() {
					return Kn
				}
			}), Kn.getLocations = function(t) {
				var e = new E;
				return t.apply(new Kn(e)), e
			}, e(Jn.prototype, {
				computeContainmentDistance: function() {
					if (0 === arguments.length) {
						var t = new Array(2).fill(null);
						if (this.computeContainmentDistance(0, t), this.minDistance <= this.terminateDistance) return null;
						this.computeContainmentDistance(1, t)
					} else if (2 === arguments.length) {
						var e = arguments[0],
							i = arguments[1],
							n = 1 - e,
							r = qn.getPolygons(this.geom[e]);
						if (r.size() > 0) {
							var o = Kn.getLocations(this.geom[n]);
							if (this.computeContainmentDistance(o, r, i), this.minDistance <= this.terminateDistance) return this.minDistanceLocation[n] = i[0], this.minDistanceLocation[e] = i[1], null
						}
					} else if (3 === arguments.length) if (arguments[2] instanceof Array && R(arguments[0], v) && R(arguments[1], v)) {
						for (var s = arguments[0], a = arguments[1], l = arguments[2], u = 0; u < s.size(); u++) for (var h = s.get(u), c = 0; c < a.size(); c++) if (this.computeContainmentDistance(h, a.get(c), l), this.minDistance <= this.terminateDistance) return null
					} else if (arguments[2] instanceof Array && arguments[0] instanceof Hn && arguments[1] instanceof Rt) {
						var d = arguments[0],
							f = arguments[1],
							A = arguments[2],
							p = d.getCoordinate();
						if (T.EXTERIOR !== this.ptLocator.locate(p, f)) return this.minDistance = 0, A[0] = d, A[1] = new Hn(f, p), null
					}
				},
				computeMinDistanceLinesPoints: function(t, e, i) {
					for (var n = 0; n < t.size(); n++) for (var r = t.get(n), o = 0; o < e.size(); o++) {
						var s = e.get(o);
						if (this.computeMinDistance(r, s, i), this.minDistance <= this.terminateDistance) return null
					}
				},
				computeFacetDistance: function() {
					var t = new Array(2).fill(null),
						e = Li.getLines(this.geom[0]),
						i = Li.getLines(this.geom[1]),
						n = Zn.getPoints(this.geom[0]),
						r = Zn.getPoints(this.geom[1]);
					return this.computeMinDistanceLines(e, i, t), this.updateMinDistance(t, !1), this.minDistance <= this.terminateDistance ? null : (t[0] = null, t[1] = null, this.computeMinDistanceLinesPoints(e, r, t), this.updateMinDistance(t, !1), this.minDistance <= this.terminateDistance ? null : (t[0] = null, t[1] = null, this.computeMinDistanceLinesPoints(i, n, t), this.updateMinDistance(t, !0), this.minDistance <= this.terminateDistance ? null : (t[0] = null, t[1] = null, this.computeMinDistancePoints(n, r, t), void this.updateMinDistance(t, !1))))
				},
				nearestLocations: function() {
					return this.computeMinDistance(), this.minDistanceLocation
				},
				updateMinDistance: function(t, e) {
					return null === t[0] ? null : void(e ? (this.minDistanceLocation[0] = t[1], this.minDistanceLocation[1] = t[0]) : (this.minDistanceLocation[0] = t[0], this.minDistanceLocation[1] = t[1]))
				},
				nearestPoints: function() {
					return this.computeMinDistance(), [this.minDistanceLocation[0].getCoordinate(), this.minDistanceLocation[1].getCoordinate()]
				},
				computeMinDistance: function() {
					if (0 === arguments.length) {
						if (null !== this.minDistanceLocation) return null;
						if (this.minDistanceLocation = new Array(2).fill(null), this.computeContainmentDistance(), this.minDistance <= this.terminateDistance) return null;
						this.computeFacetDistance()
					} else if (3 === arguments.length) if (arguments[2] instanceof Array && arguments[0] instanceof Ct && arguments[1] instanceof St) {
						var t = arguments[0],
							e = arguments[1],
							i = arguments[2];
						if (t.getEnvelopeInternal().distance(e.getEnvelopeInternal()) > this.minDistance) return null;
						for (var n = t.getCoordinates(), r = e.getCoordinate(), o = 0; o < n.length - 1; o++) {
							if ((f = $t.distancePointLine(r, n[o], n[o + 1])) < this.minDistance) {
								this.minDistance = f;
								var s = new te(n[o], n[o + 1]),
									a = s.closestPoint(r);
								i[0] = new Hn(t, o, a), i[1] = new Hn(e, 0, r)
							}
							if (this.minDistance <= this.terminateDistance) return null
						}
					} else if (arguments[2] instanceof Array && arguments[0] instanceof Ct && arguments[1] instanceof Ct) {
						var l = arguments[0],
							u = arguments[1],
							h = arguments[2];
						if (l.getEnvelopeInternal().distance(u.getEnvelopeInternal()) > this.minDistance) return null;
						n = l.getCoordinates();
						var c = u.getCoordinates();
						for (o = 0; o < n.length - 1; o++) for (var d = 0; d < c.length - 1; d++) {
							var f;
							if ((f = $t.distanceLineLine(n[o], n[o + 1], c[d], c[d + 1])) < this.minDistance) {
								this.minDistance = f;
								var A = new te(n[o], n[o + 1]),
									p = new te(c[d], c[d + 1]),
									g = A.closestPoints(p);
								h[0] = new Hn(l, o, g[0]), h[1] = new Hn(u, d, g[1])
							}
							if (this.minDistance <= this.terminateDistance) return null
						}
					}
				},
				computeMinDistancePoints: function(t, e, i) {
					for (var n = 0; n < t.size(); n++) for (var r = t.get(n), o = 0; o < e.size(); o++) {
						var s = e.get(o),
							a = r.getCoordinate().distance(s.getCoordinate());
						if (a < this.minDistance && (this.minDistance = a, i[0] = new Hn(r, 0, r.getCoordinate()), i[1] = new Hn(s, 0, s.getCoordinate())), this.minDistance <= this.terminateDistance) return null
					}
				},
				distance: function() {
					if (null === this.geom[0] || null === this.geom[1]) throw new n("null geometries are not supported");
					return this.geom[0].isEmpty() || this.geom[1].isEmpty() ? 0 : (this.computeMinDistance(), this.minDistance)
				},
				computeMinDistanceLines: function(t, e, i) {
					for (var n = 0; n < t.size(); n++) for (var r = t.get(n), o = 0; o < e.size(); o++) {
						var s = e.get(o);
						if (this.computeMinDistance(r, s, i), this.minDistance <= this.terminateDistance) return null
					}
				},
				interfaces_: function() {
					return []
				},
				getClass: function() {
					return Jn
				}
			}), Jn.distance = function(t, e) {
				return new Jn(t, e).distance()
			}, Jn.isWithinDistance = function(t, e, i) {
				return new Jn(t, e, i).distance() <= i
			}, Jn.nearestPoints = function(t, e) {
				return new Jn(t, e).nearestPoints()
			};
			var hs = Object.freeze({
				DistanceOp: Jn
			});
			e(Qn.prototype, {
				getCoordinates: function() {
					if (null === this.coordinates) {
						for (var t = 0, e = 0, i = new x, n = this.directedEdges.iterator(); n.hasNext();) {
							var r = n.next();
							r.getEdgeDirection() ? t++ : e++, i.add(r.getEdge().getLine().getCoordinates(), !1, r.getEdgeDirection())
						}
						this.coordinates = i.toCoordinateArray(), e > t && W.reverse(this.coordinates)
					}
					return this.coordinates
				},
				toLineString: function() {
					return this.factory.createLineString(this.getCoordinates())
				},
				add: function(t) {
					this.directedEdges.add(t)
				},
				interfaces_: function() {
					return []
				},
				getClass: function() {
					return Qn
				}
			}), e($n.prototype, {
				setVisited: function(t) {
					this._isVisited = t
				},
				isMarked: function() {
					return this._isMarked
				},
				setData: function(t) {
					this.data = t
				},
				getData: function() {
					return this.data
				},
				setMarked: function(t) {
					this._isMarked = t
				},
				getContext: function() {
					return this.data
				},
				isVisited: function() {
					return this._isVisited
				},
				setContext: function(t) {
					this.data = t
				},
				interfaces_: function() {
					return []
				},
				getClass: function() {
					return $n
				}
			}), $n.getComponentWithVisitedState = function(t, e) {
				for (; t.hasNext();) {
					var i = t.next();
					if (i.isVisited() === e) return i
				}
				return null
			}, $n.setVisited = function(t, e) {
				for (; t.hasNext();) t.next().setVisited(e)
			}, $n.setMarked = function(t, e) {
				for (; t.hasNext();) t.next().setMarked(e)
			}, h(tr, $n), e(tr.prototype, {
				isRemoved: function() {
					return null === this.parentEdge
				},
				compareDirection: function(t) {
					return this.quadrant > t.quadrant ? 1 : this.quadrant < t.quadrant ? -1 : $t.computeOrientation(t.p0, t.p1, this.p1)
				},
				getCoordinate: function() {
					return this.from.getCoordinate()
				},
				print: function(t) {
					var e = this.getClass().getName(),
						i = e.lastIndexOf("."),
						n = e.substring(i + 1);
					t.print("  " + n + ": " + this.p0 + " - " + this.p1 + " " + this.quadrant + ":" + this.angle)
				},
				getDirectionPt: function() {
					return this.p1
				},
				getAngle: function() {
					return this.angle
				},
				compareTo: function(t) {
					var e = t;
					return this.compareDirection(e)
				},
				getFromNode: function() {
					return this.from
				},
				getSym: function() {
					return this.sym
				},
				setEdge: function(t) {
					this.parentEdge = t
				},
				remove: function() {
					this.sym = null, this.parentEdge = null
				},
				getEdge: function() {
					return this.parentEdge
				},
				getQuadrant: function() {
					return this.quadrant
				},
				setSym: function(t) {
					this.sym = t
				},
				getToNode: function() {
					return this.to
				},
				getEdgeDirection: function() {
					return this.edgeDirection
				},
				interfaces_: function() {
					return [o]
				},
				getClass: function() {
					return tr
				}
			}), tr.toEdges = function(t) {
				for (var e = new E, i = t.iterator(); i.hasNext();) e.add(i.next().parentEdge);
				return e
			}, h(er, tr), e(er.prototype, {
				getNext: function() {
					return 2 !== this.getToNode().getDegree() ? null : this.getToNode().getOutEdges().getEdges().get(0) === this.getSym() ? this.getToNode().getOutEdges().getEdges().get(1) : (d.isTrue(this.getToNode().getOutEdges().getEdges().get(1) === this.getSym()), this.getToNode().getOutEdges().getEdges().get(0))
				},
				interfaces_: function() {
					return []
				},
				getClass: function() {
					return er
				}
			}), h(ir, $n), e(ir.prototype, {
				isRemoved: function() {
					return null === this.dirEdge
				},
				setDirectedEdges: function(t, e) {
					this.dirEdge = [t, e], t.setEdge(this), e.setEdge(this), t.setSym(e), e.setSym(t), t.getFromNode().addOutEdge(t), e.getFromNode().addOutEdge(e)
				},
				getDirEdge: function() {
					if (Number.isInteger(arguments[0])) {
						var t = arguments[0];
						return this.dirEdge[t]
					}
					if (arguments[0] instanceof rr) {
						var e = arguments[0];
						return this.dirEdge[0].getFromNode() === e ? this.dirEdge[0] : this.dirEdge[1].getFromNode() === e ? this.dirEdge[1] : null
					}
				},
				remove: function() {
					this.dirEdge = null
				},
				getOppositeNode: function(t) {
					return this.dirEdge[0].getFromNode() === t ? this.dirEdge[0].getToNode() : this.dirEdge[1].getFromNode() === t ? this.dirEdge[1].getToNode() : null
				},
				interfaces_: function() {
					return []
				},
				getClass: function() {
					return ir
				}
			}), e(nr.prototype, {
				getNextEdge: function(t) {
					var e = this.getIndex(t);
					return this.outEdges.get(this.getIndex(e + 1))
				},
				getCoordinate: function() {
					var t = this.iterator();
					return t.hasNext() ? t.next().getCoordinate() : null
				},
				iterator: function() {
					return this.sortEdges(), this.outEdges.iterator()
				},
				sortEdges: function() {
					this.sorted || (Jo.sort(this.outEdges), this.sorted = !0)
				},
				remove: function(t) {
					this.outEdges.remove(t)
				},
				getEdges: function() {
					return this.sortEdges(), this.outEdges
				},
				getNextCWEdge: function(t) {
					var e = this.getIndex(t);
					return this.outEdges.get(this.getIndex(e - 1))
				},
				getIndex: function() {
					if (arguments[0] instanceof ir) {
						var t = arguments[0];
						this.sortEdges();
						for (var e = 0; e < this.outEdges.size(); e++) if (this.outEdges.get(e).getEdge() === t) return e;
						return -1
					}
					if (arguments[0] instanceof tr) {
						var i = arguments[0];
						for (this.sortEdges(), e = 0; e < this.outEdges.size(); e++) if (this.outEdges.get(e) === i) return e;
						return -1
					}
					if (Number.isInteger(arguments[0])) {
						var n = arguments[0],
							r = n % this.outEdges.size();
						return 0 > r && (r += this.outEdges.size()), r
					}
				},
				add: function(t) {
					this.outEdges.add(t), this.sorted = !1
				},
				getDegree: function() {
					return this.outEdges.size()
				},
				interfaces_: function() {
					return []
				},
				getClass: function() {
					return nr
				}
			}), h(rr, $n), e(rr.prototype, {
				isRemoved: function() {
					return null === this.pt
				},
				addOutEdge: function(t) {
					this.deStar.add(t)
				},
				getCoordinate: function() {
					return this.pt
				},
				getOutEdges: function() {
					return this.deStar
				},
				remove: function() {
					if (0 === arguments.length) this.pt = null;
					else if (1 === arguments.length) {
						var t = arguments[0];
						this.deStar.remove(t)
					}
				},
				getIndex: function(t) {
					return this.deStar.getIndex(t)
				},
				getDegree: function() {
					return this.deStar.getDegree()
				},
				interfaces_: function() {
					return []
				},
				getClass: function() {
					return rr
				}
			}), rr.getEdgesBetween = function(t, e) {
				var i = new Q(tr.toEdges(t.getOutEdges().getEdges())),
					n = tr.toEdges(e.getOutEdges().getEdges());
				return i.retainAll(n), i
			}, h(or, ir), e(or.prototype, {
				getLine: function() {
					return this.line
				},
				interfaces_: function() {
					return []
				},
				getClass: function() {
					return or
				}
			}), e(sr.prototype, {
				find: function(t) {
					return this.nodeMap.get(t)
				},
				iterator: function() {
					return this.nodeMap.values().iterator()
				},
				remove: function(t) {
					return this.nodeMap.remove(t)
				},
				values: function() {
					return this.nodeMap.values()
				},
				add: function(t) {
					return this.nodeMap.put(t.getCoordinate(), t), t
				},
				interfaces_: function() {
					return []
				},
				getClass: function() {
					return sr
				}
			}), e(ar.prototype, {
				findNodesOfDegree: function(t) {
					for (var e = new E, i = this.nodeIterator(); i.hasNext();) {
						var n = i.next();
						n.getDegree() === t && e.add(n)
					}
					return e
				},
				dirEdgeIterator: function() {
					return this.dirEdges.iterator()
				},
				edgeIterator: function() {
					return this.edges.iterator()
				},
				remove: function() {
					if (arguments[0] instanceof ir) {
						var t = arguments[0];
						this.remove(t.getDirEdge(0)), this.remove(t.getDirEdge(1)), this.edges.remove(t), t.remove()
					} else if (arguments[0] instanceof tr) {
						var e = arguments[0];
						null !== (o = e.getSym()) && o.setSym(null), e.getFromNode().remove(e), e.remove(), this.dirEdges.remove(e)
					} else if (arguments[0] instanceof rr) {
						for (var i = arguments[0], n = i.getOutEdges().getEdges(), r = n.iterator(); r.hasNext();) {
							var o, s = r.next();
							null !== (o = s.getSym()) && this.remove(o), this.dirEdges.remove(s);
							var a = s.getEdge();
							null !== a && this.edges.remove(a)
						}
						this.nodeMap.remove(i.getCoordinate()), i.remove()
					}
				},
				findNode: function(t) {
					return this.nodeMap.find(t)
				},
				getEdges: function() {
					return this.edges
				},
				nodeIterator: function() {
					return this.nodeMap.iterator()
				},
				contains: function() {
					if (arguments[0] instanceof ir) {
						var t = arguments[0];
						return this.edges.contains(t)
					}
					if (arguments[0] instanceof tr) {
						var e = arguments[0];
						return this.dirEdges.contains(e)
					}
				},
				add: function() {
					if (arguments[0] instanceof rr) {
						var t = arguments[0];
						this.nodeMap.add(t)
					} else if (arguments[0] instanceof ir) {
						var e = arguments[0];
						this.edges.add(e), this.add(e.getDirEdge(0)), this.add(e.getDirEdge(1))
					} else if (arguments[0] instanceof tr) {
						var i = arguments[0];
						this.dirEdges.add(i)
					}
				},
				getNodes: function() {
					return this.nodeMap.values()
				},
				interfaces_: function() {
					return []
				},
				getClass: function() {
					return ar
				}
			}), h(lr, ar), e(lr.prototype, {
				addEdge: function(t) {
					if (t.isEmpty()) return null;
					var e = W.removeRepeatedPoints(t.getCoordinates());
					if (e.length <= 1) return null;
					var i = e[0],
						n = e[e.length - 1],
						r = this.getNode(i),
						o = this.getNode(n),
						s = new er(r, o, e[1], !0),
						a = new er(o, r, e[e.length - 2], !1),
						l = new or(t);
					l.setDirectedEdges(s, a), this.add(l)
				},
				getNode: function(t) {
					var e = this.findNode(t);
					return null === e && (e = new rr(t), this.add(e)), e
				},
				interfaces_: function() {
					return []
				},
				getClass: function() {
					return lr
				}
			}), e(ur.prototype, {
				buildEdgeStringsForUnprocessedNodes: function() {
					for (var t = this.graph.getNodes().iterator(); t.hasNext();) {
						var e = t.next();
						e.isMarked() || (d.isTrue(2 === e.getDegree()), this.buildEdgeStringsStartingAt(e), e.setMarked(!0))
					}
				},
				buildEdgeStringsForNonDegree2Nodes: function() {
					for (var t = this.graph.getNodes().iterator(); t.hasNext();) {
						var e = t.next();
						2 !== e.getDegree() && (this.buildEdgeStringsStartingAt(e), e.setMarked(!0))
					}
				},
				buildEdgeStringsForObviousStartNodes: function() {
					this.buildEdgeStringsForNonDegree2Nodes()
				},
				getMergedLineStrings: function() {
					return this.merge(), this.mergedLineStrings
				},
				buildEdgeStringsStartingAt: function(t) {
					for (var e = t.getOutEdges().iterator(); e.hasNext();) {
						var i = e.next();
						i.getEdge().isMarked() || this.edgeStrings.add(this.buildEdgeStringStartingWith(i))
					}
				},
				merge: function() {
					if (null !== this.mergedLineStrings) return null;
					$n.setMarked(this.graph.nodeIterator(), !1), $n.setMarked(this.graph.edgeIterator(), !1), this.edgeStrings = new E, this.buildEdgeStringsForObviousStartNodes(), this.buildEdgeStringsForIsolatedLoops(), this.mergedLineStrings = new E;
					for (var t = this.edgeStrings.iterator(); t.hasNext();) {
						var e = t.next();
						this.mergedLineStrings.add(e.toLineString())
					}
				},
				buildEdgeStringStartingWith: function(t) {
					var e = new Qn(this.factory),
						i = t;
					do {
						e.add(i), i.getEdge().setMarked(!0), i = i.getNext()
					} while (null !== i && i !== t);
					return e
				},
				add: function() {
					if (arguments[0] instanceof U) {
						var t = arguments[0];
						t.apply({
							interfaces_: function() {
								return [k]
							},
							filter: function(t) {
								t instanceof Ct && this.add(t)
							}
						})
					} else if (R(arguments[0], g)) {
						var e = arguments[0];
						this.mergedLineStrings = null;
						for (var i = e.iterator(); i.hasNext();) {
							var n = i.next();
							this.add(n)
						}
					} else if (arguments[0] instanceof Ct) {
						var r = arguments[0];
						null === this.factory && (this.factory = r.getFactory()), this.graph.addEdge(r)
					}
				},
				buildEdgeStringsForIsolatedLoops: function() {
					this.buildEdgeStringsForUnprocessedNodes()
				},
				interfaces_: function() {
					return []
				},
				getClass: function() {
					return ur
				}
			});
			var cs = Object.freeze({
				LineMerger: ur
			}),
				ds = Object.freeze({
					OverlayOp: zi
				});
			h(hr, tr), e(hr.prototype, {
				getNext: function() {
					return this.next
				},
				isInRing: function() {
					return null !== this.edgeRing
				},
				setRing: function(t) {
					this.edgeRing = t
				},
				setLabel: function(t) {
					this.label = t
				},
				getLabel: function() {
					return this.label
				},
				setNext: function(t) {
					this.next = t
				},
				getRing: function() {
					return this.edgeRing
				},
				interfaces_: function() {
					return []
				},
				getClass: function() {
					return hr
				}
			}), h(cr, ir), e(cr.prototype, {
				getLine: function() {
					return this.line
				},
				interfaces_: function() {
					return []
				},
				getClass: function() {
					return cr
				}
			}), e(dr.prototype, {
				isIncluded: function() {
					return this._isIncluded
				},
				getCoordinates: function() {
					if (null === this.ringPts) {
						for (var t = new x, e = this.deList.iterator(); e.hasNext();) {
							var i = e.next(),
								n = i.getEdge();
							dr.addEdge(n.getLine().getCoordinates(), i.getEdgeDirection(), t)
						}
						this.ringPts = t.toCoordinateArray()
					}
					return this.ringPts
				},
				isIncludedSet: function() {
					return this._isIncludedSet
				},
				isValid: function() {
					return this.getCoordinates(), !(this.ringPts.length <= 3) && (this.getRing(), this.ring.isValid())
				},
				build: function(t) {
					var e = t;
					do {
						this.add(e), e.setRing(this), e = e.getNext(), d.isTrue(null !== e, "found null DE in ring"), d.isTrue(e === t || !e.isInRing(), "found DE already in ring")
					} while (e !== t)
				},
				isOuterHole: function() {
					return !!this._isHole && !this.hasShell()
				},
				getPolygon: function() {
					var t = null;
					if (null !== this.holes) {
						t = new Array(this.holes.size()).fill(null);
						for (var e = 0; e < this.holes.size(); e++) t[e] = this.holes.get(e)
					}
					return this.factory.createPolygon(this.ring, t)
				},
				isHole: function() {
					return this._isHole
				},
				isProcessed: function() {
					return this._isProcessed
				},
				addHole: function() {
					if (arguments[0] instanceof Lt) {
						var t = arguments[0];
						null === this.holes && (this.holes = new E), this.holes.add(t)
					} else if (arguments[0] instanceof dr) {
						var e = arguments[0];
						e.setShell(this);
						var i = e.getRing();
						null === this.holes && (this.holes = new E), this.holes.add(i)
					}
				},
				setIncluded: function(t) {
					this._isIncluded = t, this._isIncludedSet = !0
				},
				getOuterHole: function() {
					if (this.isHole()) return null;
					for (var t = 0; t < this.deList.size(); t++) {
						var e = this.deList.get(t).getSym().getRing();
						if (e.isOuterHole()) return e
					}
					return null
				},
				computeHole: function() {
					var t = this.getRing();
					this._isHole = $t.isCCW(t.getCoordinates())
				},
				hasShell: function() {
					return null !== this.shell
				},
				isOuterShell: function() {
					return null !== this.getOuterHole()
				},
				getLineString: function() {
					return this.getCoordinates(), this.factory.createLineString(this.ringPts)
				},
				toString: function() {
					return Ht.toLineString(new Dt(this.getCoordinates()))
				},
				getShell: function() {
					return this.isHole() ? this.shell : this
				},
				add: function(t) {
					this.deList.add(t)
				},
				getRing: function() {
					if (null !== this.ring) return this.ring;
					this.getCoordinates(), this.ringPts.length < 3 && F.out.println(this.ringPts);
					try {
						this.ring = this.factory.createLinearRing(this.ringPts)
					} catch (t) {
						if (!(t instanceof I)) throw t;
						F.out.println(this.ringPts)
					}
					return this.ring
				},
				updateIncluded: function() {
					if (this.isHole()) return null;
					for (var t = 0; t < this.deList.size(); t++) {
						var e = this.deList.get(t).getSym().getRing().getShell();
						if (null !== e && e.isIncludedSet()) return this.setIncluded(!e.isIncluded()), null
					}
				},
				setShell: function(t) {
					this.shell = t
				},
				setProcessed: function(t) {
					this._isProcessed = t
				},
				interfaces_: function() {
					return []
				},
				getClass: function() {
					return dr
				}
			}), dr.findDirEdgesInRing = function(t) {
				var e = t,
					i = new E;
				do {
					i.add(e), e = e.getNext(), d.isTrue(null !== e, "found null DE in ring"), d.isTrue(e === t || !e.isInRing(), "found DE already in ring")
				} while (e !== t);
				return i
			}, dr.addEdge = function(t, e, i) {
				if (e) for (var n = 0; n < t.length; n++) i.add(t[n], !1);
				else for (n = t.length - 1; n >= 0; n--) i.add(t[n], !1)
			}, dr.findEdgeRingContaining = function(t, e) {
				for (var i = t.getRing(), n = i.getEnvelopeInternal(), r = i.getCoordinateN(0), o = null, s = null, a = e.iterator(); a.hasNext();) {
					var l = a.next(),
						u = l.getRing(),
						h = u.getEnvelopeInternal();
					if (!h.equals(n) && h.contains(n)) {
						r = W.ptNotInList(i.getCoordinates(), u.getCoordinates());
						var c = !1;
						$t.isPointInRing(r, u.getCoordinates()) && (c = !0), c && (null === o || s.contains(h)) && (s = (o = l).getRing().getEnvelopeInternal())
					}
				}
				return o
			}, e(fr.prototype, {
				compare: function(t, e) {
					var i = e;
					return t.getRing().getEnvelope().compareTo(i.getRing().getEnvelope())
				},
				interfaces_: function() {
					return [a]
				},
				getClass: function() {
					return fr
				}
			}), dr.EnvelopeComparator = fr, h(Ar, ar), e(Ar.prototype, {
				findEdgeRing: function(t) {
					var e = new dr(this.factory);
					return e.build(t), e
				},
				computeDepthParity: function() {
					if (0 === arguments.length) for (;;) {
						var t = null;
						if (null === t) return null;
						this.computeDepthParity(t)
					} else 1 === arguments.length && arguments[0]
				},
				computeNextCWEdges: function() {
					for (var t = this.nodeIterator(); t.hasNext();) {
						var e = t.next();
						Ar.computeNextCWEdges(e)
					}
				},
				addEdge: function(t) {
					if (t.isEmpty()) return null;
					var e = W.removeRepeatedPoints(t.getCoordinates());
					if (e.length < 2) return null;
					var i = e[0],
						n = e[e.length - 1],
						r = this.getNode(i),
						o = this.getNode(n),
						s = new hr(r, o, e[1], !0),
						a = new hr(o, r, e[e.length - 2], !1),
						l = new cr(t);
					l.setDirectedEdges(s, a), this.add(l)
				},
				deleteCutEdges: function() {
					this.computeNextCWEdges(), Ar.findLabeledEdgeRings(this.dirEdges);
					for (var t = new E, e = this.dirEdges.iterator(); e.hasNext();) {
						var i = e.next();
						if (!i.isMarked()) {
							var n = i.getSym();
							if (i.getLabel() === n.getLabel()) {
								i.setMarked(!0), n.setMarked(!0);
								var r = i.getEdge();
								t.add(r.getLine())
							}
						}
					}
					return t
				},
				getEdgeRings: function() {
					this.computeNextCWEdges(), Ar.label(this.dirEdges, -1);
					var t = Ar.findLabeledEdgeRings(this.dirEdges);
					this.convertMaximalToMinimalEdgeRings(t);
					for (var e = new E, i = this.dirEdges.iterator(); i.hasNext();) {
						var n = i.next();
						if (!n.isMarked() && !n.isInRing()) {
							var r = this.findEdgeRing(n);
							e.add(r)
						}
					}
					return e
				},
				getNode: function(t) {
					var e = this.findNode(t);
					return null === e && (e = new rr(t), this.add(e)), e
				},
				convertMaximalToMinimalEdgeRings: function(t) {
					for (var e = t.iterator(); e.hasNext();) {
						var i = e.next(),
							n = i.getLabel(),
							r = Ar.findIntersectionNodes(i, n);
						if (null !== r) for (var o = r.iterator(); o.hasNext();) {
							var s = o.next();
							Ar.computeNextCCWEdges(s, n)
						}
					}
				},
				deleteDangles: function() {
					for (var t = this.findNodesOfDegree(1), e = new Q, i = new re, n = t.iterator(); n.hasNext();) i.push(n.next());
					for (; !i.isEmpty();) {
						var r = i.pop();
						for (Ar.deleteAllEdges(r), n = r.getOutEdges().getEdges().iterator(); n.hasNext();) {
							var o = n.next();
							o.setMarked(!0);
							var s = o.getSym();
							null !== s && s.setMarked(!0);
							var a = o.getEdge();
							e.add(a.getLine());
							var l = o.getToNode();
							1 === Ar.getDegreeNonDeleted(l) && i.push(l)
						}
					}
					return e
				},
				interfaces_: function() {
					return []
				},
				getClass: function() {
					return Ar
				}
			}), Ar.findLabeledEdgeRings = function(t) {
				for (var e = new E, i = 1, n = t.iterator(); n.hasNext();) {
					var r = n.next();
					if (!(r.isMarked() || r.getLabel() >= 0)) {
						e.add(r);
						var o = dr.findDirEdgesInRing(r);
						Ar.label(o, i), i++
					}
				}
				return e
			}, Ar.getDegreeNonDeleted = function(t) {
				for (var e = 0, i = t.getOutEdges().getEdges().iterator(); i.hasNext();) i.next().isMarked() || e++;
				return e
			}, Ar.deleteAllEdges = function(t) {
				for (var e = t.getOutEdges().getEdges().iterator(); e.hasNext();) {
					var i = e.next();
					i.setMarked(!0);
					var n = i.getSym();
					null !== n && n.setMarked(!0)
				}
			}, Ar.label = function(t, e) {
				for (var i = t.iterator(); i.hasNext();) i.next().setLabel(e)
			}, Ar.computeNextCWEdges = function(t) {
				for (var e = null, i = null, n = t.getOutEdges().getEdges().iterator(); n.hasNext();) {
					var r = n.next();
					r.isMarked() || (null === e && (e = r), null !== i && i.getSym().setNext(r), i = r)
				}
				null !== i && i.getSym().setNext(e)
			}, Ar.computeNextCCWEdges = function(t, e) {
				for (var i = null, n = null, r = t.getOutEdges().getEdges(), o = r.size() - 1; o >= 0; o--) {
					var s = r.get(o),
						a = s.getSym(),
						l = null;
					s.getLabel() === e && (l = s);
					var u = null;
					a.getLabel() === e && (u = a), null === l && null === u || (null !== u && (n = u), null !== l && (null !== n && (n.setNext(l), n = null), null === i && (i = l)))
				}
				null !== n && (d.isTrue(null !== i), n.setNext(i))
			}, Ar.getDegree = function(t, e) {
				for (var i = 0, n = t.getOutEdges().getEdges().iterator(); n.hasNext();) n.next().getLabel() === e && i++;
				return i
			}, Ar.findIntersectionNodes = function(t, e) {
				var i = t,
					n = null;
				do {
					var r = i.getFromNode();
					Ar.getDegree(r, e) > 1 && (null === n && (n = new E), n.add(r)), i = i.getNext(), d.isTrue(null !== i, "found null DE in ring"), d.isTrue(i === t || !i.isInRing(), "found DE already in ring")
				} while (i !== t);
				return n
			}, e(pr.prototype, {
				getGeometry: function() {
					return null === this.geomFactory && (this.geomFactory = new Wt), this.polygonize(), this.extractOnlyPolygonal ? this.geomFactory.buildGeometry(this.polyList) : this.geomFactory.createGeometryCollection(Wt.toGeometryArray(this.polyList))
				},
				getInvalidRingLines: function() {
					return this.polygonize(), this.invalidRingLines
				},
				findValidRings: function(t, e, i) {
					for (var n = t.iterator(); n.hasNext();) {
						var r = n.next();
						r.isValid() ? e.add(r) : i.add(r.getLineString())
					}
				},
				polygonize: function() {
					if (null !== this.polyList) return null;
					if (this.polyList = new E, null === this.graph) return null;
					this.dangles = this.graph.deleteDangles(), this.cutEdges = this.graph.deleteCutEdges();
					var t = this.graph.getEdgeRings(),
						e = new E;
					this.invalidRingLines = new E, this.isCheckingRingsValid ? this.findValidRings(t, e, this.invalidRingLines) : e = t, this.findShellsAndHoles(e), pr.assignHolesToShells(this.holeList, this.shellList), Jo.sort(this.shellList, new dr.EnvelopeComparator);
					var i = !0;
					this.extractOnlyPolygonal && (pr.findDisjointShells(this.shellList), i = !1), this.polyList = pr.extractPolygons(this.shellList, i)
				},
				getDangles: function() {
					return this.polygonize(), this.dangles
				},
				getCutEdges: function() {
					return this.polygonize(), this.cutEdges
				},
				getPolygons: function() {
					return this.polygonize(), this.polyList
				},
				add: function() {
					if (R(arguments[0], g)) for (var t = arguments[0], e = t.iterator(); e.hasNext();) {
						var i = e.next();
						this.add(i)
					} else if (arguments[0] instanceof Ct) {
						var n = arguments[0];
						this.geomFactory = n.getFactory(), null === this.graph && (this.graph = new Ar(this.geomFactory)), this.graph.addEdge(n)
					} else if (arguments[0] instanceof U) {
						var r = arguments[0];
						r.apply(this.lineStringAdder)
					}
				},
				setCheckRingsValid: function(t) {
					this.isCheckingRingsValid = t
				},
				findShellsAndHoles: function(t) {
					this.holeList = new E, this.shellList = new E;
					for (var e = t.iterator(); e.hasNext();) {
						var i = e.next();
						i.computeHole(), i.isHole() ? this.holeList.add(i) : this.shellList.add(i)
					}
				},
				interfaces_: function() {
					return []
				},
				getClass: function() {
					return pr
				}
			}), pr.findOuterShells = function(t) {
				for (var e = t.iterator(); e.hasNext();) {
					var i = e.next(),
						n = i.getOuterHole();
					null === n || n.isProcessed() || (i.setIncluded(!0), n.setProcessed(!0))
				}
			}, pr.extractPolygons = function(t, e) {
				for (var i = new E, n = t.iterator(); n.hasNext();) {
					var r = n.next();
					(e || r.isIncluded()) && i.add(r.getPolygon())
				}
				return i
			}, pr.assignHolesToShells = function(t, e) {
				for (var i = t.iterator(); i.hasNext();) {
					var n = i.next();
					pr.assignHoleToShell(n, e)
				}
			}, pr.assignHoleToShell = function(t, e) {
				var i = dr.findEdgeRingContaining(t, e);
				null !== i && i.addHole(t)
			}, pr.findDisjointShells = function(t) {
				pr.findOuterShells(t);
				var e = null;
				do {
					e = !1;
					for (var i = t.iterator(); i.hasNext();) {
						var n = i.next();
						n.isIncludedSet() || (n.updateIncluded(), n.isIncludedSet() || (e = !0))
					}
				} while (e)
			}, e(gr.prototype, {
				filter: function(t) {
					t instanceof Ct && this.p.add(t)
				},
				interfaces_: function() {
					return [k]
				},
				getClass: function() {
					return gr
				}
			}), pr.LineStringAdder = gr;
			var fs = Object.freeze({
				Polygonizer: pr
			});
			e(mr.prototype, {
				createEdgeEndForNext: function(t, e, i, n) {
					var r = i.segmentIndex + 1;
					if (r >= t.getNumPoints() && null === n) return null;
					var o = t.getCoordinate(r);
					null !== n && n.segmentIndex === i.segmentIndex && (o = n.coord);
					var s = new ai(t, i.coord, o, new ti(t.getLabel()));
					e.add(s)
				},
				createEdgeEndForPrev: function(t, e, i, n) {
					var r = i.segmentIndex;
					if (0 === i.dist) {
						if (0 === r) return null;
						r--
					}
					var o = t.getCoordinate(r);
					null !== n && n.segmentIndex >= r && (o = n.coord);
					var s = new ti(t.getLabel());
					s.flip();
					var a = new ai(t, i.coord, o, s);
					e.add(a)
				},
				computeEdgeEnds: function() {
					if (1 === arguments.length) {
						for (var t = arguments[0], e = new E, i = t; i.hasNext();) {
							var n = i.next();
							this.computeEdgeEnds(n, e)
						}
						return e
					}
					if (2 === arguments.length) {
						var r = arguments[0],
							o = arguments[1],
							s = r.getEdgeIntersectionList();
						s.addEndpoints();
						var a = s.iterator(),
							l = null,
							u = null;
						if (!a.hasNext()) return null;
						var h = a.next();
						do {
							l = u, u = h, h = null, a.hasNext() && (h = a.next()), null !== u && (this.createEdgeEndForPrev(r, o, u, l), this.createEdgeEndForNext(r, o, u, h))
						} while (null !== u)
					}
				},
				interfaces_: function() {
					return []
				},
				getClass: function() {
					return mr
				}
			}), h(vr, ai), e(vr.prototype, {
				insert: function(t) {
					this.edgeEnds.add(t)
				},
				print: function(t) {
					t.println("EdgeEndBundle--\x3e Label: " + this.label);
					for (var e = this.iterator(); e.hasNext();) e.next().print(t), t.println()
				},
				iterator: function() {
					return this.edgeEnds.iterator()
				},
				getEdgeEnds: function() {
					return this.edgeEnds
				},
				computeLabelOn: function(t, e) {
					for (var i = 0, n = !1, r = this.iterator(); r.hasNext();)(o = r.next().getLabel().getLocation(t)) === T.BOUNDARY && i++, o === T.INTERIOR && (n = !0);
					var o = T.NONE;
					n && (o = T.INTERIOR), i > 0 && (o = Bi.determineBoundary(e, i)), this.label.setLocation(t, o)
				},
				computeLabelSide: function(t, e) {
					for (var i = this.iterator(); i.hasNext();) {
						var n = i.next();
						if (n.getLabel().isArea()) {
							var r = n.getLabel().getLocation(t, e);
							if (r === T.INTERIOR) return this.label.setLocation(t, e, T.INTERIOR), null;
							r === T.EXTERIOR && this.label.setLocation(t, e, T.EXTERIOR)
						}
					}
				},
				getLabel: function() {
					return this.label
				},
				computeLabelSides: function(t) {
					this.computeLabelSide(t, Qe.LEFT), this.computeLabelSide(t, Qe.RIGHT)
				},
				updateIM: function(t) {
					Ui.updateIM(this.label, t)
				},
				computeLabel: function(t) {
					for (var e = !1, i = this.iterator(); i.hasNext();) i.next().getLabel().isArea() && (e = !0);
					this.label = e ? new ti(T.NONE, T.NONE, T.NONE) : new ti(T.NONE);
					for (var n = 0; 2 > n; n++) this.computeLabelOn(n, t), e && this.computeLabelSides(n)
				},
				interfaces_: function() {
					return []
				},
				getClass: function() {
					return vr
				}
			}), h(yr, gi), e(yr.prototype, {
				updateIM: function(t) {
					for (var e = this.iterator(); e.hasNext();) e.next().updateIM(t)
				},
				insert: function(t) {
					var e = this.edgeMap.get(t);
					null === e ? (e = new vr(t), this.insertEdgeEnd(t, e)) : e.insert(t)
				},
				interfaces_: function() {
					return []
				},
				getClass: function() {
					return yr
				}
			}), h(_r, oi), e(_r.prototype, {
				updateIMFromEdges: function(t) {
					this.edges.updateIM(t)
				},
				computeIM: function(t) {
					t.setAtLeastIfValid(this.label.getLocation(0), this.label.getLocation(1), 0)
				},
				interfaces_: function() {
					return []
				},
				getClass: function() {
					return _r
				}
			}), h(Er, ui), e(Er.prototype, {
				createNode: function(t) {
					return new _r(t, new yr)
				},
				interfaces_: function() {
					return []
				},
				getClass: function() {
					return Er
				}
			}), e(xr.prototype, {
				insertEdgeEnds: function(t) {
					for (var e = t.iterator(); e.hasNext();) {
						var i = e.next();
						this.nodes.add(i)
					}
				},
				computeProperIntersectionIM: function(t, e) {
					var i = this.arg[0].getGeometry().getDimension(),
						n = this.arg[1].getGeometry().getDimension(),
						r = t.hasProperIntersection(),
						o = t.hasProperInteriorIntersection();
					2 === i && 2 === n ? r && e.setAtLeast("212101212") : 2 === i && 1 === n ? (r && e.setAtLeast("FFF0FFFF2"), o && e.setAtLeast("1FFFFF1FF")) : 1 === i && 2 === n ? (r && e.setAtLeast("F0FFFFFF2"), o && e.setAtLeast("1F1FFFFFF")) : 1 === i && 1 === n && o && e.setAtLeast("0FFFFFFFF")
				},
				labelIsolatedEdges: function(t, e) {
					for (var i = this.arg[t].getEdgeIterator(); i.hasNext();) {
						var n = i.next();
						n.isIsolated() && (this.labelIsolatedEdge(n, e, this.arg[e].getGeometry()), this.isolatedEdges.add(n))
					}
				},
				labelIsolatedEdge: function(t, e, i) {
					if (i.getDimension() > 0) {
						var n = this.ptLocator.locate(t.getCoordinate(), i);
						t.getLabel().setAllLocations(e, n)
					} else t.getLabel().setAllLocations(e, T.EXTERIOR)
				},
				computeIM: function() {
					var t = new ee;
					if (t.set(T.EXTERIOR, T.EXTERIOR, 2), !this.arg[0].getGeometry().getEnvelopeInternal().intersects(this.arg[1].getGeometry().getEnvelopeInternal())) return this.computeDisjointIM(t), t;
					this.arg[0].computeSelfNodes(this.li, !1), this.arg[1].computeSelfNodes(this.li, !1);
					var e = this.arg[0].computeEdgeIntersections(this.arg[1], this.li, !1);
					this.computeIntersectionNodes(0), this.computeIntersectionNodes(1), this.copyNodesAndLabels(0), this.copyNodesAndLabels(1), this.labelIsolatedNodes(), this.computeProperIntersectionIM(e, t);
					var i = new mr,
						n = i.computeEdgeEnds(this.arg[0].getEdgeIterator());
					this.insertEdgeEnds(n);
					var r = i.computeEdgeEnds(this.arg[1].getEdgeIterator());
					return this.insertEdgeEnds(r), this.labelNodeEdges(), this.labelIsolatedEdges(0, 1), this.labelIsolatedEdges(1, 0), this.updateIM(t), t
				},
				labelNodeEdges: function() {
					for (var t = this.nodes.iterator(); t.hasNext();) t.next().getEdges().computeLabelling(this.arg)
				},
				copyNodesAndLabels: function(t) {
					for (var e = this.arg[t].getNodeIterator(); e.hasNext();) {
						var i = e.next();
						this.nodes.addNode(i.getCoordinate()).setLabel(t, i.getLabel().getLocation(t))
					}
				},
				labelIntersectionNodes: function(t) {
					for (var e = this.arg[t].getEdgeIterator(); e.hasNext();) for (var i = e.next(), n = i.getLabel().getLocation(t), r = i.getEdgeIntersectionList().iterator(); r.hasNext();) {
						var o = r.next(),
							s = this.nodes.find(o.coord);
						s.getLabel().isNull(t) && (n === T.BOUNDARY ? s.setLabelBoundary(t) : s.setLabel(t, T.INTERIOR))
					}
				},
				labelIsolatedNode: function(t, e) {
					var i = this.ptLocator.locate(t.getCoordinate(), this.arg[e].getGeometry());
					t.getLabel().setAllLocations(e, i)
				},
				computeIntersectionNodes: function(t) {
					for (var e = this.arg[t].getEdgeIterator(); e.hasNext();) for (var i = e.next(), n = i.getLabel().getLocation(t), r = i.getEdgeIntersectionList().iterator(); r.hasNext();) {
						var o = r.next(),
							s = this.nodes.addNode(o.coord);
						n === T.BOUNDARY ? s.setLabelBoundary(t) : s.getLabel().isNull(t) && s.setLabel(t, T.INTERIOR)
					}
				},
				labelIsolatedNodes: function() {
					for (var t = this.nodes.iterator(); t.hasNext();) {
						var e = t.next(),
							i = e.getLabel();
						d.isTrue(i.getGeometryCount() > 0, "node with empty label found"), e.isIsolated() && (i.isNull(0) ? this.labelIsolatedNode(e, 0) : this.labelIsolatedNode(e, 1))
					}
				},
				updateIM: function(t) {
					for (var e = this.isolatedEdges.iterator(); e.hasNext();) e.next().updateIM(t);
					for (var i = this.nodes.iterator(); i.hasNext();) {
						var n = i.next();
						n.updateIM(t), n.updateIMFromEdges(t)
					}
				},
				computeDisjointIM: function(t) {
					var e = this.arg[0].getGeometry();
					e.isEmpty() || (t.set(T.INTERIOR, T.EXTERIOR, e.getDimension()), t.set(T.BOUNDARY, T.EXTERIOR, e.getBoundaryDimension()));
					var i = this.arg[1].getGeometry();
					i.isEmpty() || (t.set(T.EXTERIOR, T.INTERIOR, i.getDimension()), t.set(T.EXTERIOR, T.BOUNDARY, i.getBoundaryDimension()))
				},
				interfaces_: function() {
					return []
				},
				getClass: function() {
					return xr
				}
			}), e(Cr.prototype, {
				isContainedInBoundary: function(t) {
					if (t instanceof Rt) return !1;
					if (t instanceof St) return this.isPointContainedInBoundary(t);
					if (t instanceof Ct) return this.isLineStringContainedInBoundary(t);
					for (var e = 0; e < t.getNumGeometries(); e++) {
						var i = t.getGeometryN(e);
						if (!this.isContainedInBoundary(i)) return !1
					}
					return !0
				},
				isLineSegmentContainedInBoundary: function(t, e) {
					if (t.equals(e)) return this.isPointContainedInBoundary(t);
					if (t.x === e.x) {
						if (t.x === this.rectEnv.getMinX() || t.x === this.rectEnv.getMaxX()) return !0
					} else if (t.y === e.y && (t.y === this.rectEnv.getMinY() || t.y === this.rectEnv.getMaxY())) return !0;
					return !1
				},
				isLineStringContainedInBoundary: function(t) {
					for (var e = t.getCoordinateSequence(), i = new f, n = new f, r = 0; r < e.size() - 1; r++) if (e.getCoordinate(r, i), e.getCoordinate(r + 1, n), !this.isLineSegmentContainedInBoundary(i, n)) return !1;
					return !0
				},
				isPointContainedInBoundary: function() {
					if (arguments[0] instanceof St) {
						var t = arguments[0];
						return this.isPointContainedInBoundary(t.getCoordinate())
					}
					if (arguments[0] instanceof f) {
						var e = arguments[0];
						return e.x === this.rectEnv.getMinX() || e.x === this.rectEnv.getMaxX() || e.y === this.rectEnv.getMinY() || e.y === this.rectEnv.getMaxY()
					}
				},
				contains: function(t) {
					return !!this.rectEnv.contains(t.getEnvelopeInternal()) && !this.isContainedInBoundary(t)
				},
				interfaces_: function() {
					return []
				},
				getClass: function() {
					return Cr
				}
			}), Cr.contains = function(t, e) {
				return new Cr(t).contains(e)
			}, e(Ir.prototype, {
				intersects: function(t, e) {
					var i = new C(t, e);
					if (!this.rectEnv.intersects(i)) return !1;
					if (this.rectEnv.intersects(t)) return !0;
					if (this.rectEnv.intersects(e)) return !0;
					if (t.compareTo(e) > 0) {
						var n = t;
						t = e, e = n
					}
					var r = !1;
					return e.y > t.y && (r = !0), r ? this.li.computeIntersection(t, e, this.diagDown0, this.diagDown1) : this.li.computeIntersection(t, e, this.diagUp0, this.diagUp1), !! this.li.hasIntersection()
				},
				interfaces_: function() {
					return []
				},
				getClass: function() {
					return Ir
				}
			}), e(Sr.prototype, {
				applyTo: function(t) {
					for (var e = 0; e < t.getNumGeometries() && !this._isDone; e++) {
						var i = t.getGeometryN(e);
						if (i instanceof dt) this.applyTo(i);
						else if (this.visit(i), this.isDone()) return this._isDone = !0, null
					}
				},
				interfaces_: function() {
					return []
				},
				getClass: function() {
					return Sr
				}
			}), e(Tr.prototype, {
				intersects: function(t) {
					if (!this.rectEnv.intersects(t.getEnvelopeInternal())) return !1;
					var e = new Rr(this.rectEnv);
					if (e.applyTo(t), e.intersects()) return !0;
					var i = new wr(this.rectangle);
					if (i.applyTo(t), i.containsPoint()) return !0;
					var n = new Lr(this.rectangle);
					return n.applyTo(t), !! n.intersects()
				},
				interfaces_: function() {
					return []
				},
				getClass: function() {
					return Tr
				}
			}), Tr.intersects = function(t, e) {
				return new Tr(t).intersects(e)
			}, h(Rr, Sr), e(Rr.prototype, {
				isDone: function() {
					return !0 === this._intersects
				},
				visit: function(t) {
					var e = t.getEnvelopeInternal();
					return this.rectEnv.intersects(e) ? this.rectEnv.contains(e) ? (this._intersects = !0, null) : e.getMinX() >= this.rectEnv.getMinX() && e.getMaxX() <= this.rectEnv.getMaxX() ? (this._intersects = !0, null) : e.getMinY() >= this.rectEnv.getMinY() && e.getMaxY() <= this.rectEnv.getMaxY() ? (this._intersects = !0, null) : void 0 : null
				},
				intersects: function() {
					return this._intersects
				},
				interfaces_: function() {
					return []
				},
				getClass: function() {
					return Rr
				}
			}), h(wr, Sr), e(wr.prototype, {
				isDone: function() {
					return !0 === this._containsPoint
				},
				visit: function(t) {
					if (!(t instanceof Rt)) return null;
					var e = t.getEnvelopeInternal();
					if (!this.rectEnv.intersects(e)) return null;
					for (var i = new f, n = 0; 4 > n; n++) if (this.rectSeq.getCoordinate(n, i), e.contains(i) && pi.containsPointInPolygon(i, t)) return this._containsPoint = !0, null
				},
				containsPoint: function() {
					return this._containsPoint
				},
				interfaces_: function() {
					return []
				},
				getClass: function() {
					return wr
				}
			}), h(Lr, Sr), e(Lr.prototype, {
				intersects: function() {
					return this.hasIntersection
				},
				isDone: function() {
					return !0 === this.hasIntersection
				},
				visit: function(t) {
					var e = t.getEnvelopeInternal();
					if (!this.rectEnv.intersects(e)) return null;
					var i = Li.getLines(t);
					this.checkIntersectionWithLineStrings(i)
				},
				checkIntersectionWithLineStrings: function(t) {
					for (var e = t.iterator(); e.hasNext();) {
						var i = e.next();
						if (this.checkIntersectionWithSegments(i), this.hasIntersection) return null
					}
				},
				checkIntersectionWithSegments: function(t) {
					for (var e = t.getCoordinateSequence(), i = 1; i < e.size(); i++) if (e.getCoordinate(i - 1, this.p0), e.getCoordinate(i, this.p1), this.rectIntersector.intersects(this.p0, this.p1)) return this.hasIntersection = !0, null
				},
				interfaces_: function() {
					return []
				},
				getClass: function() {
					return Lr
				}
			}), h(Nr, ji), e(Nr.prototype, {
				getIntersectionMatrix: function() {
					return this._relate.computeIM()
				},
				interfaces_: function() {
					return []
				},
				getClass: function() {
					return Nr
				}
			}), Nr.covers = function(t, e) {
				return !!t.getEnvelopeInternal().covers(e.getEnvelopeInternal()) && ( !! t.isRectangle() || Nr.relate(t, e).isCovers())
			}, Nr.intersects = function(t, e) {
				return !!t.getEnvelopeInternal().intersects(e.getEnvelopeInternal()) && (t.isRectangle() ? Tr.intersects(t, e) : e.isRectangle() ? Tr.intersects(e, t) : Nr.relate(t, e).isIntersects())
			}, Nr.touches = function(t, e) {
				return !!t.getEnvelopeInternal().intersects(e.getEnvelopeInternal()) && Nr.relate(t, e).isTouches(t.getDimension(), e.getDimension())
			}, Nr.within = function(t, e) {
				return e.contains(t)
			}, Nr.coveredBy = function(t, e) {
				return Nr.covers(e, t)
			}, Nr.relate = function() {
				if (2 === arguments.length) {
					var t = arguments[0],
						e = arguments[1];
					return new Nr(t, e).getIntersectionMatrix()
				}
				if (3 === arguments.length) {
					if ("string" == typeof arguments[2] && arguments[0] instanceof U && arguments[1] instanceof U) {
						var i = arguments[0],
							n = arguments[1],
							r = arguments[2];
						return Nr.relateWithCheck(i, n).matches(r)
					}
					if (R(arguments[2], j) && arguments[0] instanceof U && arguments[1] instanceof U) {
						var o = arguments[0],
							s = arguments[1],
							a = arguments[2];
						return new Nr(o, s, a).getIntersectionMatrix()
					}
				}
			}, Nr.overlaps = function(t, e) {
				return !!t.getEnvelopeInternal().intersects(e.getEnvelopeInternal()) && Nr.relate(t, e).isOverlaps(t.getDimension(), e.getDimension())
			}, Nr.disjoint = function(t, e) {
				return !t.intersects(e)
			}, Nr.relateWithCheck = function(t, e) {
				return t.checkNotGeometryCollection(t), t.checkNotGeometryCollection(e), Nr.relate(t, e)
			}, Nr.crosses = function(t, e) {
				return !!t.getEnvelopeInternal().intersects(e.getEnvelopeInternal()) && Nr.relate(t, e).isCrosses(t.getDimension(), e.getDimension())
			}, Nr.contains = function(t, e) {
				return !!t.getEnvelopeInternal().contains(e.getEnvelopeInternal()) && (t.isRectangle() ? Cr.contains(t, e) : Nr.relate(t, e).isContains())
			};
			var As = Object.freeze({
				RelateOp: Nr
			});
			e(Pr.prototype, {
				extractElements: function(t, e) {
					if (null === t) return null;
					for (var i = 0; i < t.getNumGeometries(); i++) {
						var n = t.getGeometryN(i);
						this.skipEmpty && n.isEmpty() || e.add(n)
					}
				},
				combine: function() {
					for (var t = new E, e = this.inputGeoms.iterator(); e.hasNext();) {
						var i = e.next();
						this.extractElements(i, t)
					}
					return 0 === t.size() ? null !== this.geomFactory ? this.geomFactory.createGeometryCollection(null) : null : this.geomFactory.buildGeometry(t)
				},
				interfaces_: function() {
					return []
				},
				getClass: function() {
					return Pr
				}
			}), Pr.combine = function() {
				if (1 === arguments.length) {
					var t = arguments[0];
					return new Pr(t).combine()
				}
				if (2 === arguments.length) {
					var e = arguments[0],
						i = arguments[1];
					return new Pr(Pr.createList(e, i)).combine()
				}
				if (3 === arguments.length) {
					var n = arguments[0],
						r = arguments[1],
						o = arguments[2];
					return new Pr(Pr.createList(n, r, o)).combine()
				}
			}, Pr.extractFactory = function(t) {
				return t.isEmpty() ? null : t.iterator().next().getFactory()
			}, Pr.createList = function() {
				if (2 === arguments.length) {
					var t = arguments[0],
						e = arguments[1];
					return (i = new E).add(t), i.add(e), i
				}
				if (3 === arguments.length) {
					var i, n = arguments[0],
						r = arguments[1],
						o = arguments[2];
					return (i = new E).add(n), i.add(r), i.add(o), i
				}
			}, e(Or.prototype, {
				union: function() {
					for (var t = new me, e = new at, i = 0; i < this.pointGeom.getNumGeometries(); i++) {
						var n = this.pointGeom.getGeometryN(i).getCoordinate();
						t.locate(n, this.otherGeom) === T.EXTERIOR && e.add(n)
					}
					if (0 === e.size()) return this.otherGeom;
					var r, o = W.toCoordinateArray(e);
					return r = 1 === o.length ? this.geomFact.createPoint(o[0]) : this.geomFact.createMultiPointFromCoords(o), Pr.combine(r, this.otherGeom)
				},
				interfaces_: function() {
					return []
				},
				getClass: function() {
					return Or
				}
			}), Or.union = function(t, e) {
				return new Or(t, e).union()
			}, e(Mr.prototype, {
				filter: function(t) {
					-1 !== this.sortIndex && t.getSortIndex() !== this.sortIndex || this.comps.add(t)
				},
				interfaces_: function() {
					return [ht]
				},
				getClass: function() {
					return Mr
				}
			}), Mr.extract = function() {
				if (2 === arguments.length) {
					var t = arguments[0],
						e = arguments[1];
					return Mr.extract(t, e, new E)
				}
				if (3 === arguments.length) {
					var i = arguments[0],
						n = arguments[1],
						r = arguments[2];
					return i.getSortIndex() === n ? r.add(i) : i instanceof dt && i.apply(new Mr(n, r)), r
				}
			}, e(br.prototype, {
				reduceToGeometries: function(t) {
					for (var e = new E, i = t.iterator(); i.hasNext();) {
						var n = i.next(),
							r = null;
						R(n, v) ? r = this.unionTree(n) : n instanceof U && (r = n), e.add(r)
					}
					return e
				},
				extractByEnvelope: function(t, e, i) {
					for (var n = new E, r = 0; r < e.getNumGeometries(); r++) {
						var o = e.getGeometryN(r);
						o.getEnvelopeInternal().intersects(t) ? n.add(o) : i.add(o)
					}
					return this.geomFactory.buildGeometry(n)
				},
				unionOptimized: function(t, e) {
					var i = t.getEnvelopeInternal(),
						n = e.getEnvelopeInternal();
					if (!i.intersects(n)) return Pr.combine(t, e);
					if (t.getNumGeometries() <= 1 && e.getNumGeometries() <= 1) return this.unionActual(t, e);
					var r = i.intersection(n);
					return this.unionUsingEnvelopeIntersection(t, e, r)
				},
				union: function() {
					if (null === this.inputPolys) throw new IllegalStateException("union() method cannot be called twice");
					if (this.inputPolys.isEmpty()) return null;
					this.geomFactory = this.inputPolys.iterator().next().getFactory();
					for (var t = new Ne(br.STRTREE_NODE_CAPACITY), e = this.inputPolys.iterator(); e.hasNext();) {
						var i = e.next();
						t.insert(i.getEnvelopeInternal(), i)
					}
					this.inputPolys = null;
					var n = t.itemsTree();
					return this.unionTree(n)
				},
				binaryUnion: function() {
					if (1 === arguments.length) {
						var t = arguments[0];
						return this.binaryUnion(t, 0, t.size())
					}
					if (3 === arguments.length) {
						var e = arguments[0],
							i = arguments[1],
							n = arguments[2];
						if (1 >= n - i) {
							var r = br.getGeometry(e, i);
							return this.unionSafe(r, null)
						}
						if (n - i == 2) return this.unionSafe(br.getGeometry(e, i), br.getGeometry(e, i + 1));
						var o = Math.trunc((n + i) / 2),
							s = (r = this.binaryUnion(e, i, o), this.binaryUnion(e, o, n));
						return this.unionSafe(r, s)
					}
				},
				repeatedUnion: function(t) {
					for (var e = null, i = t.iterator(); i.hasNext();) {
						var n = i.next();
						e = null === e ? n.copy() : e.union(n)
					}
					return e
				},
				unionSafe: function(t, e) {
					return null === t && null === e ? null : null === t ? e.copy() : null === e ? t.copy() : this.unionOptimized(t, e)
				},
				unionActual: function(t, e) {
					return br.restrictToPolygons(t.union(e))
				},
				unionTree: function(t) {
					var e = this.reduceToGeometries(t);
					return this.binaryUnion(e)
				},
				unionUsingEnvelopeIntersection: function(t, e, i) {
					var n = new E,
						r = this.extractByEnvelope(i, t, n),
						o = this.extractByEnvelope(i, e, n),
						s = this.unionActual(r, o);
					return n.add(s), Pr.combine(n)
				},
				bufferUnion: function() {
					if (1 === arguments.length) {
						var t = arguments[0];
						return t.get(0).getFactory().buildGeometry(t).buffer(0)
					}
					if (2 === arguments.length) {
						var e = arguments[0],
							i = arguments[1];
						return e.getFactory().createGeometryCollection([e, i]).buffer(0)
					}
				},
				interfaces_: function() {
					return []
				},
				getClass: function() {
					return br
				}
			}), br.restrictToPolygons = function(t) {
				if (R(t, Tt)) return t;
				var e = qn.getPolygons(t);
				return 1 === e.size() ? e.get(0) : t.getFactory().createMultiPolygon(Wt.toPolygonArray(e))
			}, br.getGeometry = function(t, e) {
				return e >= t.size() ? null : t.get(e)
			}, br.union = function(t) {
				return new br(t).union()
			}, br.STRTREE_NODE_CAPACITY = 4, e(Fr.prototype, {
				unionNoOpt: function(t) {
					var e = this.geomFact.createPoint();
					return Wi.overlayOp(t, e, zi.UNION)
				},
				unionWithNull: function(t, e) {
					return null === t && null === e ? null : null === e ? t : null === t ? e : t.union(e)
				},
				extract: function() {
					if (R(arguments[0], g)) for (var t = arguments[0], e = t.iterator(); e.hasNext();) {
						var i = e.next();
						this.extract(i)
					} else if (arguments[0] instanceof U) {
						var n = arguments[0];
						null === this.geomFact && (this.geomFact = n.getFactory()), Mr.extract(n, U.SORTINDEX_POLYGON, this.polygons), Mr.extract(n, U.SORTINDEX_LINESTRING, this.lines), Mr.extract(n, U.SORTINDEX_POINT, this.points)
					}
				},
				union: function() {
					if (null === this.geomFact) return null;
					var t = null;
					if (this.points.size() > 0) {
						var e = this.geomFact.buildGeometry(this.points);
						t = this.unionNoOpt(e)
					}
					var i = null;
					if (this.lines.size() > 0) {
						var n = this.geomFact.buildGeometry(this.lines);
						i = this.unionNoOpt(n)
					}
					var r = null;
					this.polygons.size() > 0 && (r = br.union(this.polygons));
					var o = this.unionWithNull(i, r),
						s = null;
					return s = null === t ? o : null === o ? t : Or.union(t, o), null === s ? this.geomFact.createGeometryCollection() : s
				},
				interfaces_: function() {
					return []
				},
				getClass: function() {
					return Fr
				}
			}), Fr.union = function() {
				if (1 === arguments.length) {
					if (R(arguments[0], g)) {
						var t = arguments[0];
						return new Fr(t).union()
					}
					if (arguments[0] instanceof U) {
						var e = arguments[0];
						return new Fr(e).union()
					}
				} else if (2 === arguments.length) {
					var i = arguments[0],
						n = arguments[1];
					return new Fr(i, n).union()
				}
			};
			var ps = Object.freeze({
				UnaryUnionOp: Fr
			});
			e(Dr.prototype, {
				visitInteriorRing: function(t, e) {
					var i = t.getCoordinates(),
						n = i[0],
						r = Dr.findDifferentPoint(i, n),
						o = e.findEdgeInSameDirection(n, r),
						s = e.findEdgeEnd(o),
						a = null;
					s.getLabel().getLocation(0, Qe.RIGHT) === T.INTERIOR ? a = s : s.getSym().getLabel().getLocation(0, Qe.RIGHT) === T.INTERIOR && (a = s.getSym()), d.isTrue(null !== a, "unable to find dirEdge with Interior on RHS"), this.visitLinkedDirectedEdges(a)
				},
				visitShellInteriors: function(t, e) {
					if (t instanceof Rt) {
						var i = t;
						this.visitInteriorRing(i.getExteriorRing(), e)
					}
					if (t instanceof Nt) for (var n = t, r = 0; r < n.getNumGeometries(); r++) i = n.getGeometryN(r), this.visitInteriorRing(i.getExteriorRing(), e)
				},
				getCoordinate: function() {
					return this.disconnectedRingcoord
				},
				setInteriorEdgesInResult: function(t) {
					for (var e = t.getEdgeEnds().iterator(); e.hasNext();) {
						var i = e.next();
						i.getLabel().getLocation(0, Qe.RIGHT) === T.INTERIOR && i.setInResult(!0)
					}
				},
				visitLinkedDirectedEdges: function(t) {
					var e = t,
						i = t;
					do {
						d.isTrue(null !== i, "found null Directed Edge"), i.setVisited(!0), i = i.getNext()
					} while (i !== e)
				},
				buildEdgeRings: function(t) {
					for (var e = new E, i = t.iterator(); i.hasNext();) {
						var n = i.next();
						if (n.isInResult() && null === n.getEdgeRing()) {
							var r = new ni(n, this.geometryFactory);
							r.linkDirectedEdgesForMinimalEdgeRings();
							var o = r.buildMinimalRings();
							e.addAll(o)
						}
					}
					return e
				},
				hasUnvisitedShellEdge: function(t) {
					for (var e = 0; e < t.size(); e++) {
						var i = t.get(e);
						if (!i.isHole()) {
							var n = i.getEdges(),
								r = n.get(0);
							if (r.getLabel().getLocation(0, Qe.RIGHT) === T.INTERIOR) for (var o = 0; o < n.size(); o++) if (!(r = n.get(o)).isVisited()) return this.disconnectedRingcoord = r.getCoordinate(), !0
						}
					}
					return !1
				},
				isInteriorsConnected: function() {
					var t = new E;
					this.geomGraph.computeSplitEdges(t);
					var e = new hi(new vi);
					e.addEdges(t), this.setInteriorEdgesInResult(e), e.linkResultDirectedEdges();
					var i = this.buildEdgeRings(e.getEdgeEnds());
					return this.visitShellInteriors(this.geomGraph.getGeometry(), e), !this.hasUnvisitedShellEdge(i)
				},
				interfaces_: function() {
					return []
				},
				getClass: function() {
					return Dr
				}
			}), Dr.findDifferentPoint = function(t, e) {
				for (var i = 0; i < t.length; i++) if (!t[i].equals(e)) return t[i];
				return null
			}, e(Gr.prototype, {
				hasChildren: function() {
					for (var t = 0; 2 > t; t++) if (null !== this.subnode[t]) return !0;
					return !1
				},
				isPrunable: function() {
					return !(this.hasChildren() || this.hasItems())
				},
				addAllItems: function(t) {
					t.addAll(this.items);
					for (var e = 0; 2 > e; e++) null !== this.subnode[e] && this.subnode[e].addAllItems(t);
					return t
				},
				size: function() {
					for (var t = 0, e = 0; 2 > e; e++) null !== this.subnode[e] && (t += this.subnode[e].size());
					return t + this.items.size()
				},
				addAllItemsFromOverlapping: function(t, e) {
					return null === t || this.isSearchMatch(t) ? (e.addAll(this.items), null !== this.subnode[0] && this.subnode[0].addAllItemsFromOverlapping(t, e), void(null !== this.subnode[1] && this.subnode[1].addAllItemsFromOverlapping(t, e))) : null
				},
				hasItems: function() {
					return !this.items.isEmpty()
				},
				remove: function(t, e) {
					if (!this.isSearchMatch(t)) return !1;
					for (var i = !1, n = 0; 2 > n; n++) if (null !== this.subnode[n] && (i = this.subnode[n].remove(t, e))) {
						this.subnode[n].isPrunable() && (this.subnode[n] = null);
						break
					}
					return i || (i = this.items.remove(e))
				},
				getItems: function() {
					return this.items
				},
				depth: function() {
					for (var t = 0, e = 0; 2 > e; e++) if (null !== this.subnode[e]) {
						var i = this.subnode[e].depth();
						i > t && (t = i)
					}
					return t + 1
				},
				nodeSize: function() {
					for (var t = 0, e = 0; 2 > e; e++) null !== this.subnode[e] && (t += this.subnode[e].nodeSize());
					return t + 1
				},
				add: function(t) {
					this.items.add(t)
				},
				interfaces_: function() {
					return []
				},
				getClass: function() {
					return Gr
				}
			}), Gr.getSubnodeIndex = function(t, e) {
				var i = -1;
				return t.min >= e && (i = 1), t.max <= e && (i = 0), i
			}, e(kr.prototype, {
				expandToInclude: function(t) {
					t.max > this.max && (this.max = t.max), t.min < this.min && (this.min = t.min)
				},
				getWidth: function() {
					return this.max - this.min
				},
				overlaps: function() {
					if (1 === arguments.length) {
						var t = arguments[0];
						return this.overlaps(t.min, t.max)
					}
					if (2 === arguments.length) {
						var e = arguments[0],
							i = arguments[1];
						return !(this.min > i || this.max < e)
					}
				},
				getMin: function() {
					return this.min
				},
				toString: function() {
					return "[" + this.min + ", " + this.max + "]"
				},
				contains: function() {
					if (1 === arguments.length) {
						if (arguments[0] instanceof kr) {
							var t = arguments[0];
							return this.contains(t.min, t.max)
						}
						if ("number" == typeof arguments[0]) {
							var e = arguments[0];
							return e >= this.min && e <= this.max
						}
					} else if (2 === arguments.length) {
						var i = arguments[0],
							n = arguments[1];
						return i >= this.min && n <= this.max
					}
				},
				init: function(t, e) {
					this.min = t, this.max = e, t > e && (this.min = e, this.max = t)
				},
				getMax: function() {
					return this.max
				},
				interfaces_: function() {
					return []
				},
				getClass: function() {
					return kr
				}
			}), e(Ur.prototype, {
				getInterval: function() {
					return this.interval
				},
				getLevel: function() {
					return this.level
				},
				computeKey: function(t) {
					for (this.level = Ur.computeLevel(t), this.interval = new kr, this.computeInterval(this.level, t); !this.interval.contains(t);) this.level += 1, this.computeInterval(this.level, t)
				},
				computeInterval: function(t, e) {
					var i = cn.powerOf2(t);
					this.pt = Math.floor(e.getMin() / i) * i, this.interval.init(this.pt, this.pt + i)
				},
				getPoint: function() {
					return this.pt
				},
				interfaces_: function() {
					return []
				},
				getClass: function() {
					return Ur
				}
			}), Ur.computeLevel = function(t) {
				var e = t.getWidth();
				return cn.exponent(e) + 1
			}, h(Br, Gr), e(Br.prototype, {
				getInterval: function() {
					return this.interval
				},
				find: function(t) {
					var e = Gr.getSubnodeIndex(t, this.centre);
					return -1 === e ? this : null !== this.subnode[e] ? this.subnode[e].find(t) : this
				},
				insert: function(t) {
					d.isTrue(null === this.interval || this.interval.contains(t.interval));
					var e = Gr.getSubnodeIndex(t.interval, this.centre);
					if (t.level === this.level - 1) this.subnode[e] = t;
					else {
						var i = this.createSubnode(e);
						i.insert(t), this.subnode[e] = i
					}
				},
				isSearchMatch: function(t) {
					return t.overlaps(this.interval)
				},
				getSubnode: function(t) {
					return null === this.subnode[t] && (this.subnode[t] = this.createSubnode(t)), this.subnode[t]
				},
				getNode: function(t) {
					var e = Gr.getSubnodeIndex(t, this.centre);
					return -1 !== e ? this.getSubnode(e).getNode(t) : this
				},
				createSubnode: function(t) {
					var e = 0,
						i = 0;
					switch (t) {
					case 0:
						e = this.interval.getMin(), i = this.centre;
						break;
					case 1:
						e = this.centre, i = this.interval.getMax()
					}
					return new Br(new kr(e, i), this.level - 1)
				},
				interfaces_: function() {
					return []
				},
				getClass: function() {
					return Br
				}
			}), Br.createNode = function(t) {
				var e = new Ur(t);
				return new Br(e.getInterval(), e.getLevel())
			}, Br.createExpanded = function(t, e) {
				var i = new kr(e);
				null !== t && i.expandToInclude(t.interval);
				var n = Br.createNode(i);
				return null !== t && n.insert(t), n
			}, h(jr, Gr), e(jr.prototype, {
				insert: function(t, e) {
					var i = Gr.getSubnodeIndex(t, jr.origin);
					if (-1 === i) return this.add(e), null;
					var n = this.subnode[i];
					if (null === n || !n.getInterval().contains(t)) {
						var r = Br.createExpanded(n, t);
						this.subnode[i] = r
					}
					this.insertContained(this.subnode[i], t, e)
				},
				isSearchMatch: function(t) {
					return !0
				},
				insertContained: function(t, e, i) {
					d.isTrue(t.getInterval().contains(e)), (An.isZeroWidth(e.getMin(), e.getMax()) ? t.find(e) : t.getNode(e)).add(i)
				},
				interfaces_: function() {
					return []
				},
				getClass: function() {
					return jr
				}
			}), jr.origin = 0, e(Vr.prototype, {
				size: function() {
					return null !== this.root ? this.root.size() : 0
				},
				insert: function(t, e) {
					this.collectStats(t);
					var i = Vr.ensureExtent(t, this.minExtent);
					this.root.insert(i, e)
				},
				query: function() {
					if (1 === arguments.length) {
						if ("number" == typeof arguments[0]) {
							var t = arguments[0];
							return this.query(new kr(t, t))
						}
						if (arguments[0] instanceof kr) {
							var e = arguments[0],
								i = new E;
							return this.query(e, i), i
						}
					} else if (2 === arguments.length) {
						var n = arguments[0],
							r = arguments[1];
						this.root.addAllItemsFromOverlapping(n, r)
					}
				},
				iterator: function() {
					var t = new E;
					return this.root.addAllItems(t), t.iterator()
				},
				remove: function(t, e) {
					var i = Vr.ensureExtent(t, this.minExtent);
					return this.root.remove(i, e)
				},
				collectStats: function(t) {
					var e = t.getWidth();
					e < this.minExtent && e > 0 && (this.minExtent = e)
				},
				depth: function() {
					return null !== this.root ? this.root.depth() : 0
				},
				nodeSize: function() {
					return null !== this.root ? this.root.nodeSize() : 0
				},
				interfaces_: function() {
					return []
				},
				getClass: function() {
					return Vr
				}
			}), Vr.ensureExtent = function(t, e) {
				var i = t.getMin(),
					n = t.getMax();
				return i !== n ? t : (i === n && (n = (i -= e / 2) + e / 2), new kr(i, n))
			}, e(Yr.prototype, {
				isInside: function(t) {},
				interfaces_: function() {
					return []
				},
				getClass: function() {
					return Yr
				}
			}), e(zr.prototype, {
				testLineSegment: function(t, e) {
					var i, n, r, o, s = e.p0,
						a = e.p1;
					i = s.x - t.x, n = s.y - t.y, r = a.x - t.x, o = a.y - t.y, (n > 0 && 0 >= o || o > 0 && 0 >= n) && Jt.signOfDet2x2(i, n, r, o) / (o - n) > 0 && this.crossings++
				},
				buildIndex: function() {
					this.tree = new Vr;
					for (var t = W.removeRepeatedPoints(this.ring.getCoordinates()), e = je.getChains(t), i = 0; i < e.size(); i++) {
						var n = e.get(i),
							r = n.getEnvelope();
						this.interval.min = r.getMinY(), this.interval.max = r.getMaxY(), this.tree.insert(this.interval, n)
					}
				},
				testMonotoneChain: function(t, e, i) {
					i.select(t, e)
				},
				isInside: function(t) {
					this.crossings = 0;
					var e = new C(r.NEGATIVE_INFINITY, r.POSITIVE_INFINITY, t.y, t.y);
					this.interval.min = t.y, this.interval.max = t.y;
					for (var i = this.tree.query(this.interval), n = new Xr(this, t), o = i.iterator(); o.hasNext();) {
						var s = o.next();
						this.testMonotoneChain(e, n, s)
					}
					return this.crossings % 2 == 1
				},
				interfaces_: function() {
					return [Yr]
				},
				getClass: function() {
					return zr
				}
			}), h(Xr, jn), e(Xr.prototype, {
				select: function() {
					if (1 !== arguments.length) return jn.prototype.select.apply(this, arguments);
					var t = arguments[0];
					this.mcp.testLineSegment(this.p, t)
				},
				interfaces_: function() {
					return []
				},
				getClass: function() {
					return Xr
				}
			}), zr.MCSelecter = Xr, e(Wr.prototype, {
				insertEdgeEnds: function(t) {
					for (var e = t.iterator(); e.hasNext();) {
						var i = e.next();
						this.nodes.add(i)
					}
				},
				getNodeIterator: function() {
					return this.nodes.iterator()
				},
				copyNodesAndLabels: function(t, e) {
					for (var i = t.getNodeIterator(); i.hasNext();) {
						var n = i.next();
						this.nodes.addNode(n.getCoordinate()).setLabel(e, n.getLabel().getLocation(e))
					}
				},
				build: function(t) {
					this.computeIntersectionNodes(t, 0), this.copyNodesAndLabels(t, 0);
					var e = (new mr).computeEdgeEnds(t.getEdgeIterator());
					this.insertEdgeEnds(e)
				},
				computeIntersectionNodes: function(t, e) {
					for (var i = t.getEdgeIterator(); i.hasNext();) for (var n = i.next(), r = n.getLabel().getLocation(e), o = n.getEdgeIntersectionList().iterator(); o.hasNext();) {
						var s = o.next(),
							a = this.nodes.addNode(s.coord);
						r === T.BOUNDARY ? a.setLabelBoundary(e) : a.getLabel().isNull(e) && a.setLabel(e, T.INTERIOR)
					}
				},
				interfaces_: function() {
					return []
				},
				getClass: function() {
					return Wr
				}
			}), e(qr.prototype, {
				isNodeEdgeAreaLabelsConsistent: function() {
					for (var t = this.nodeGraph.getNodeIterator(); t.hasNext();) {
						var e = t.next();
						if (!e.getEdges().isAreaLabelsConsistent(this.geomGraph)) return this.invalidPoint = e.getCoordinate().copy(), !1
					}
					return !0
				},
				getInvalidPoint: function() {
					return this.invalidPoint
				},
				hasDuplicateRings: function() {
					for (var t = this.nodeGraph.getNodeIterator(); t.hasNext();) for (var e = t.next().getEdges().iterator(); e.hasNext();) {
						var i = e.next();
						if (i.getEdgeEnds().size() > 1) return this.invalidPoint = i.getEdge().getCoordinate(0), !0
					}
					return !1
				},
				isNodeConsistentArea: function() {
					var t = this.geomGraph.computeSelfNodes(this.li, !0, !0);
					return t.hasProperIntersection() ? (this.invalidPoint = t.getProperIntersectionPoint(), !1) : (this.nodeGraph.build(this.geomGraph), this.isNodeEdgeAreaLabelsConsistent())
				},
				interfaces_: function() {
					return []
				},
				getClass: function() {
					return qr
				}
			}), e(Hr.prototype, {
				buildIndex: function() {
					this.index = new Ne;
					for (var t = 0; t < this.rings.size(); t++) {
						var e = this.rings.get(t),
							i = e.getEnvelopeInternal();
						this.index.insert(i, e)
					}
				},
				getNestedPoint: function() {
					return this.nestedPt
				},
				isNonNested: function() {
					this.buildIndex();
					for (var t = 0; t < this.rings.size(); t++) for (var e = this.rings.get(t), i = e.getCoordinates(), n = this.index.query(e.getEnvelopeInternal()), r = 0; r < n.size(); r++) {
						var o = n.get(r),
							s = o.getCoordinates();
						if (e !== o && e.getEnvelopeInternal().intersects(o.getEnvelopeInternal())) {
							var a = Kr.findPtNotNode(i, o, this.graph);
							if (null !== a && $t.isPointInRing(a, s)) return this.nestedPt = a, !1
						}
					}
					return !0
				},
				add: function(t) {
					this.rings.add(t), this.totalEnv.expandToInclude(t.getEnvelopeInternal())
				},
				interfaces_: function() {
					return []
				},
				getClass: function() {
					return Hr
				}
			}), e(Zr.prototype, {
				getErrorType: function() {
					return this.errorType
				},
				getMessage: function() {
					return Zr.errMsg[this.errorType]
				},
				getCoordinate: function() {
					return this.pt
				},
				toString: function() {
					var t = "";
					return null !== this.pt && (t = " at or near point " + this.pt), this.getMessage() + t
				},
				interfaces_: function() {
					return []
				},
				getClass: function() {
					return Zr
				}
			}), Zr.ERROR = 0, Zr.REPEATED_POINT = 1, Zr.HOLE_OUTSIDE_SHELL = 2, Zr.NESTED_HOLES = 3, Zr.DISCONNECTED_INTERIOR = 4, Zr.SELF_INTERSECTION = 5, Zr.RING_SELF_INTERSECTION = 6, Zr.NESTED_SHELLS = 7, Zr.DUPLICATE_RINGS = 8, Zr.TOO_FEW_POINTS = 9, Zr.INVALID_COORDINATE = 10, Zr.RING_NOT_CLOSED = 11, Zr.errMsg = ["Topology Validation Error", "Repeated Point", "Hole lies outside shell", "Holes are nested", "Interior is disconnected", "Self-intersection", "Ring Self-intersection", "Nested shells", "Duplicate Rings", "Too few distinct points in geometry component", "Invalid Coordinate", "Ring is not closed"], e(Kr.prototype, {
				checkInvalidCoordinates: function() {
					if (arguments[0] instanceof Array) {
						for (var t = arguments[0], e = 0; e < t.length; e++) if (!Kr.isValid(t[e])) return this.validErr = new Zr(Zr.INVALID_COORDINATE, t[e]), null
					} else if (arguments[0] instanceof Rt) {
						var i = arguments[0];
						if (this.checkInvalidCoordinates(i.getExteriorRing().getCoordinates()), null !== this.validErr) return null;
						for (e = 0; e < i.getNumInteriorRing(); e++) if (this.checkInvalidCoordinates(i.getInteriorRingN(e).getCoordinates()), null !== this.validErr) return null
					}
				},
				checkHolesNotNested: function(t, e) {
					for (var i = new Hr(e), n = 0; n < t.getNumInteriorRing(); n++) {
						var r = t.getInteriorRingN(n);
						i.add(r)
					}
					i.isNonNested() || (this.validErr = new Zr(Zr.NESTED_HOLES, i.getNestedPoint()))
				},
				checkConsistentArea: function(t) {
					var e = new qr(t);
					return e.isNodeConsistentArea() ? void(e.hasDuplicateRings() && (this.validErr = new Zr(Zr.DUPLICATE_RINGS, e.getInvalidPoint()))) : (this.validErr = new Zr(Zr.SELF_INTERSECTION, e.getInvalidPoint()), null)
				},
				isValid: function() {
					return this.checkValid(this.parentGeometry), null === this.validErr
				},
				checkShellInsideHole: function(t, e, i) {
					var n = t.getCoordinates(),
						r = e.getCoordinates(),
						o = Kr.findPtNotNode(n, e, i);
					if (null !== o && !$t.isPointInRing(o, r)) return o;
					var s = Kr.findPtNotNode(r, t, i);
					return null !== s ? $t.isPointInRing(s, n) ? s : null : (d.shouldNeverReachHere("points in shell and hole appear to be equal"), null)
				},
				checkNoSelfIntersectingRings: function(t) {
					for (var e = t.getEdgeIterator(); e.hasNext();) {
						var i = e.next();
						if (this.checkNoSelfIntersectingRing(i.getEdgeIntersectionList()), null !== this.validErr) return null
					}
				},
				checkConnectedInteriors: function(t) {
					var e = new Dr(t);
					e.isInteriorsConnected() || (this.validErr = new Zr(Zr.DISCONNECTED_INTERIOR, e.getCoordinate()))
				},
				checkNoSelfIntersectingRing: function(t) {
					for (var e = new at, i = !0, n = t.iterator(); n.hasNext();) {
						var r = n.next();
						if (i) i = !1;
						else {
							if (e.contains(r.coord)) return this.validErr = new Zr(Zr.RING_SELF_INTERSECTION, r.coord), null;
							e.add(r.coord)
						}
					}
				},
				checkHolesInShell: function(t, e) {
					for (var i = t.getExteriorRing(), n = new zr(i), r = 0; r < t.getNumInteriorRing(); r++) {
						var o = t.getInteriorRingN(r),
							s = Kr.findPtNotNode(o.getCoordinates(), i, e);
						if (null === s) return null;
						if (!n.isInside(s)) return this.validErr = new Zr(Zr.HOLE_OUTSIDE_SHELL, s), null
					}
				},
				checkTooFewPoints: function(t) {
					return t.hasTooFewPoints() ? (this.validErr = new Zr(Zr.TOO_FEW_POINTS, t.getInvalidPoint()), null) : void 0
				},
				getValidationError: function() {
					return this.checkValid(this.parentGeometry), this.validErr
				},
				checkValid: function() {
					if (arguments[0] instanceof St) {
						var t = arguments[0];
						this.checkInvalidCoordinates(t.getCoordinates())
					} else if (arguments[0] instanceof wt) {
						var e = arguments[0];
						this.checkInvalidCoordinates(e.getCoordinates())
					} else if (arguments[0] instanceof Lt) {
						var i = arguments[0];
						if (this.checkInvalidCoordinates(i.getCoordinates()), null !== this.validErr) return null;
						if (this.checkClosedRing(i), null !== this.validErr) return null;
						var n = new Bi(0, i);
						if (this.checkTooFewPoints(n), null !== this.validErr) return null;
						var r = new Kt;
						n.computeSelfNodes(r, !0, !0), this.checkNoSelfIntersectingRings(n)
					} else if (arguments[0] instanceof Ct) {
						var o = arguments[0];
						if (this.checkInvalidCoordinates(o.getCoordinates()), null !== this.validErr) return null;
						n = new Bi(0, o), this.checkTooFewPoints(n)
					} else if (arguments[0] instanceof Rt) {
						var s = arguments[0];
						if (this.checkInvalidCoordinates(s), null !== this.validErr) return null;
						if (this.checkClosedRings(s), null !== this.validErr) return null;
						if (n = new Bi(0, s), this.checkTooFewPoints(n), null !== this.validErr) return null;
						if (this.checkConsistentArea(n), null !== this.validErr) return null;
						if (!this.isSelfTouchingRingFormingHoleValid && (this.checkNoSelfIntersectingRings(n), null !== this.validErr)) return null;
						if (this.checkHolesInShell(s, n), null !== this.validErr) return null;
						if (this.checkHolesNotNested(s, n), null !== this.validErr) return null;
						this.checkConnectedInteriors(n)
					} else if (arguments[0] instanceof Nt) {
						for (var a = arguments[0], l = 0; l < a.getNumGeometries(); l++) {
							var u = a.getGeometryN(l);
							if (this.checkInvalidCoordinates(u), null !== this.validErr) return null;
							if (this.checkClosedRings(u), null !== this.validErr) return null
						}
						if (n = new Bi(0, a), this.checkTooFewPoints(n), null !== this.validErr) return null;
						if (this.checkConsistentArea(n), null !== this.validErr) return null;
						if (!this.isSelfTouchingRingFormingHoleValid && (this.checkNoSelfIntersectingRings(n), null !== this.validErr)) return null;
						for (l = 0; l < a.getNumGeometries(); l++) if (u = a.getGeometryN(l), this.checkHolesInShell(u, n), null !== this.validErr) return null;
						for (l = 0; l < a.getNumGeometries(); l++) if (u = a.getGeometryN(l), this.checkHolesNotNested(u, n), null !== this.validErr) return null;
						if (this.checkShellsNotNested(a, n), null !== this.validErr) return null;
						this.checkConnectedInteriors(n)
					} else if (arguments[0] instanceof dt) {
						var h = arguments[0];
						for (l = 0; l < h.getNumGeometries(); l++) {
							var c = h.getGeometryN(l);
							if (this.checkValid(c), null !== this.validErr) return null
						}
					} else if (arguments[0] instanceof U) {
						var d = arguments[0];
						if (this.validErr = null, d.isEmpty()) return null;
						if (d instanceof St) this.checkValid(d);
						else if (d instanceof wt) this.checkValid(d);
						else if (d instanceof Lt) this.checkValid(d);
						else if (d instanceof Ct) this.checkValid(d);
						else if (d instanceof Rt) this.checkValid(d);
						else if (d instanceof Nt) this.checkValid(d);
						else {
							if (!(d instanceof dt)) throw new UnsupportedOperationException(d.getClass().getName());
							this.checkValid(d)
						}
					}
				},
				setSelfTouchingRingFormingHoleValid: function(t) {
					this.isSelfTouchingRingFormingHoleValid = t
				},
				checkShellNotNested: function(t, e, i) {
					var n = t.getCoordinates(),
						r = e.getExteriorRing(),
						o = r.getCoordinates(),
						s = Kr.findPtNotNode(n, r, i);
					if (null === s) return null;
					if (!$t.isPointInRing(s, o)) return null;
					if (e.getNumInteriorRing() <= 0) return this.validErr = new Zr(Zr.NESTED_SHELLS, s), null;
					for (var a = null, l = 0; l < e.getNumInteriorRing(); l++) {
						var u = e.getInteriorRingN(l);
						if (null === (a = this.checkShellInsideHole(t, u, i))) return null
					}
					this.validErr = new Zr(Zr.NESTED_SHELLS, a)
				},
				checkClosedRings: function(t) {
					if (this.checkClosedRing(t.getExteriorRing()), null !== this.validErr) return null;
					for (var e = 0; e < t.getNumInteriorRing(); e++) if (this.checkClosedRing(t.getInteriorRingN(e)), null !== this.validErr) return null
				},
				checkClosedRing: function(t) {
					if (!t.isClosed()) {
						var e = null;
						t.getNumPoints() >= 1 && (e = t.getCoordinateN(0)), this.validErr = new Zr(Zr.RING_NOT_CLOSED, e)
					}
				},
				checkShellsNotNested: function(t, e) {
					for (var i = 0; i < t.getNumGeometries(); i++) for (var n = t.getGeometryN(i).getExteriorRing(), r = 0; r < t.getNumGeometries(); r++) if (i !== r) {
						var o = t.getGeometryN(r);
						if (this.checkShellNotNested(n, o, e), null !== this.validErr) return null
					}
				},
				interfaces_: function() {
					return []
				},
				getClass: function() {
					return Kr
				}
			}), Kr.findPtNotNode = function(t, e, i) {
				for (var n = i.findEdge(e).getEdgeIntersectionList(), r = 0; r < t.length; r++) {
					var o = t[r];
					if (!n.isIntersection(o)) return o
				}
				return null
			}, Kr.isValid = function() {
				if (arguments[0] instanceof U) {
					var t = arguments[0],
						e = new Kr(t);
					return e.isValid()
				}
				if (arguments[0] instanceof f) {
					var i = arguments[0];
					return !(r.isNaN(i.x) || r.isInfinite(i.x) || r.isNaN(i.y) || r.isInfinite(i.y))
				}
			};
			var gs = Object.freeze({
				IsValidOp: Kr
			}),
				ms = Object.freeze({
					BoundaryOp: At,
					IsSimpleOp: In,
					buffer: us,
					distance: hs,
					linemerge: cs,
					overlay: ds,
					polygonize: fs,
					relate: As,
					union: ps,
					valid: gs
				});
			h(Jr, Pt.CoordinateOperation), e(Jr.prototype, {
				editCoordinates: function(t, e) {
					if (0 === t.length) return null;
					for (var i = new Array(t.length).fill(null), n = 0; n < t.length; n++) {
						var r = new f(t[n]);
						this.targetPM.makePrecise(r), i[n] = r
					}
					var o = new x(i, !1).toCoordinateArray(),
						s = 0;
					e instanceof Ct && (s = 2), e instanceof Lt && (s = 4);
					var a = i;
					return this.removeCollapsed && (a = null), o.length < s ? a : o
				},
				interfaces_: function() {
					return []
				},
				getClass: function() {
					return Jr
				}
			}), e(Qr.prototype, {
				fixPolygonalTopology: function(t) {
					var e = t;
					this.changePrecisionModel || (e = this.changePM(t, this.targetPM));
					var i = e.buffer(0),
						n = i;
					return this.changePrecisionModel || (n = t.getFactory().createGeometry(i)), n
				},
				reducePointwise: function(t) {
					var e = null;
					e = this.changePrecisionModel ? new Pt(this.createFactory(t.getFactory(), this.targetPM)) : new Pt;
					var i = this.removeCollapsed;
					return t.getDimension() >= 2 && (i = !0), e.edit(t, new Jr(this.targetPM, i))
				},
				changePM: function(t, e) {
					return this.createEditor(t.getFactory(), e).edit(t, new Pt.NoOpGeometryOperation)
				},
				setRemoveCollapsedComponents: function(t) {
					this.removeCollapsed = t
				},
				createFactory: function(t, e) {
					return new Wt(e, t.getSRID(), t.getCoordinateSequenceFactory())
				},
				setChangePrecisionModel: function(t) {
					this.changePrecisionModel = t
				},
				reduce: function(t) {
					var e = this.reducePointwise(t);
					return this.isPointwise ? e : R(e, Tt) ? e.isValid() ? e : this.fixPolygonalTopology(e) : e
				},
				setPointwise: function(t) {
					this.isPointwise = t
				},
				createEditor: function(t, e) {
					return t.getPrecisionModel() === e ? new Pt : new Pt(this.createFactory(t, e))
				},
				interfaces_: function() {
					return []
				},
				getClass: function() {
					return Qr
				}
			}), Qr.reduce = function(t, e) {
				return new Qr(e).reduce(t)
			}, Qr.reducePointwise = function(t, e) {
				var i = new Qr(e);
				return i.setPointwise(!0), i.reduce(t)
			};
			var vs = Object.freeze({
				GeometryPrecisionReducer: Qr
			});
			e($r.prototype, {
				simplifySection: function(t, e) {
					if (t + 1 === e) return null;
					this.seg.p0 = this.pts[t], this.seg.p1 = this.pts[e];
					for (var i = -1, n = t, r = t + 1; e > r; r++) {
						var o = this.seg.distance(this.pts[r]);
						o > i && (i = o, n = r)
					}
					if (i <= this.distanceTolerance) for (r = t + 1; e > r; r++) this.usePt[r] = !1;
					else this.simplifySection(t, n), this.simplifySection(n, e)
				},
				setDistanceTolerance: function(t) {
					this.distanceTolerance = t
				},
				simplify: function() {
					this.usePt = new Array(this.pts.length).fill(null);
					for (var t = 0; t < this.pts.length; t++) this.usePt[t] = !0;
					this.simplifySection(0, this.pts.length - 1);
					var e = new x;
					for (t = 0; t < this.pts.length; t++) this.usePt[t] && e.add(new f(this.pts[t]));
					return e.toCoordinateArray()
				},
				interfaces_: function() {
					return []
				},
				getClass: function() {
					return $r
				}
			}), $r.simplify = function(t, e) {
				var i = new $r(t);
				return i.setDistanceTolerance(e), i.simplify()
			}, e(to.prototype, {
				setEnsureValid: function(t) {
					this.isEnsureValidTopology = t
				},
				getResultGeometry: function() {
					return this.inputGeom.isEmpty() ? this.inputGeom.copy() : new eo(this.isEnsureValidTopology, this.distanceTolerance).transform(this.inputGeom)
				},
				setDistanceTolerance: function(t) {
					if (0 > t) throw new n("Tolerance must be non-negative");
					this.distanceTolerance = t
				},
				interfaces_: function() {
					return []
				},
				getClass: function() {
					return to
				}
			}), to.simplify = function(t, e) {
				var i = new to(t);
				return i.setDistanceTolerance(e), i.getResultGeometry()
			}, h(eo, le), e(eo.prototype, {
				transformPolygon: function(t, e) {
					if (t.isEmpty()) return null;
					var i = le.prototype.transformPolygon.call(this, t, e);
					return e instanceof Nt ? i : this.createValidArea(i)
				},
				createValidArea: function(t) {
					return this.isEnsureValidTopology ? t.buffer(0) : t
				},
				transformCoordinates: function(t, e) {
					var i, n = t.toCoordinateArray();
					return i = 0 === n.length ? new Array(0).fill(null) : $r.simplify(n, this.distanceTolerance), this.factory.getCoordinateSequenceFactory().create(i)
				},
				transformMultiPolygon: function(t, e) {
					var i = le.prototype.transformMultiPolygon.call(this, t, e);
					return this.createValidArea(i)
				},
				transformLinearRing: function(t, e) {
					var i = e instanceof Rt,
						n = le.prototype.transformLinearRing.call(this, t, e);
					return !i || n instanceof Lt ? n : null
				},
				interfaces_: function() {
					return []
				},
				getClass: function() {
					return eo
				}
			}), to.DPTransformer = eo, h(io, te), e(io.prototype, {
				getIndex: function() {
					return this.index
				},
				getParent: function() {
					return this.parent
				},
				interfaces_: function() {
					return []
				},
				getClass: function() {
					return io
				}
			}), e(no.prototype, {
				addToResult: function(t) {
					this.resultSegs.add(t)
				},
				asLineString: function() {
					return this.parentLine.getFactory().createLineString(no.extractCoordinates(this.resultSegs))
				},
				getResultSize: function() {
					var t = this.resultSegs.size();
					return 0 === t ? 0 : t + 1
				},
				getParent: function() {
					return this.parentLine
				},
				getSegment: function(t) {
					return this.segs[t]
				},
				getParentCoordinates: function() {
					return this.parentLine.getCoordinates()
				},
				getMinimumSize: function() {
					return this.minimumSize
				},
				asLinearRing: function() {
					return this.parentLine.getFactory().createLinearRing(no.extractCoordinates(this.resultSegs))
				},
				getSegments: function() {
					return this.segs
				},
				init: function() {
					var t = this.parentLine.getCoordinates();
					this.segs = new Array(t.length - 1).fill(null);
					for (var e = 0; e < t.length - 1; e++) {
						var i = new io(t[e], t[e + 1], this.parentLine, e);
						this.segs[e] = i
					}
				},
				getResultCoordinates: function() {
					return no.extractCoordinates(this.resultSegs)
				},
				interfaces_: function() {
					return []
				},
				getClass: function() {
					return no
				}
			}), no.extractCoordinates = function(t) {
				for (var e = new Array(t.size() + 1).fill(null), i = null, n = 0; n < t.size(); n++) i = t.get(n), e[n] = i.p0;
				return e[e.length - 1] = i.p1, e
			}, e(ro.prototype, {
				remove: function(t) {
					this.index.remove(new C(t.p0, t.p1), t)
				},
				add: function() {
					if (arguments[0] instanceof no) for (var t = arguments[0], e = t.getSegments(), i = 0; i < e.length; i++) {
						var n = e[i];
						this.add(n)
					} else if (arguments[0] instanceof te) {
						var r = arguments[0];
						this.index.insert(new C(r.p0, r.p1), r)
					}
				},
				query: function(t) {
					var e = new C(t.p0, t.p1),
						i = new oo(t);
					return this.index.query(e, i), i.getItems()
				},
				interfaces_: function() {
					return []
				},
				getClass: function() {
					return ro
				}
			}), e(oo.prototype, {
				visitItem: function(t) {
					var e = t;
					C.intersects(e.p0, e.p1, this.querySeg.p0, this.querySeg.p1) && this.items.add(t)
				},
				getItems: function() {
					return this.items
				},
				interfaces_: function() {
					return [Ie]
				},
				getClass: function() {
					return oo
				}
			}), e(so.prototype, {
				flatten: function(t, e) {
					var i = new te(this.linePts[t], this.linePts[e]);
					return this.remove(this.line, t, e), this.outputIndex.add(i), i
				},
				hasBadIntersection: function(t, e, i) {
					return !!this.hasBadOutputIntersection(i) || !! this.hasBadInputIntersection(t, e, i)
				},
				setDistanceTolerance: function(t) {
					this.distanceTolerance = t
				},
				simplifySection: function(t, e, i) {
					i += 1;
					var n = new Array(2).fill(null);
					if (t + 1 === e) {
						var r = this.line.getSegment(t);
						return this.line.addToResult(r), null
					}
					var o = !0;
					this.line.getResultSize() < this.line.getMinimumSize() && i + 1 < this.line.getMinimumSize() && (o = !1);
					var s = new Array(1).fill(null),
						a = this.findFurthestPoint(this.linePts, t, e, s);
					s[0] > this.distanceTolerance && (o = !1);
					var l = new te;
					if (l.p0 = this.linePts[t], l.p1 = this.linePts[e], n[0] = t, n[1] = e, this.hasBadIntersection(this.line, n, l) && (o = !1), o) return r = this.flatten(t, e), this.line.addToResult(r), null;
					this.simplifySection(t, a, i), this.simplifySection(a, e, i)
				},
				hasBadOutputIntersection: function(t) {
					for (var e = this.outputIndex.query(t).iterator(); e.hasNext();) {
						var i = e.next();
						if (this.hasInteriorIntersection(i, t)) return !0
					}
					return !1
				},
				findFurthestPoint: function(t, e, i, n) {
					var r = new te;
					r.p0 = t[e], r.p1 = t[i];
					for (var o = -1, s = e, a = e + 1; i > a; a++) {
						var l = t[a],
							u = r.distance(l);
						u > o && (o = u, s = a)
					}
					return n[0] = o, s
				},
				simplify: function(t) {
					this.line = t, this.linePts = t.getParentCoordinates(), this.simplifySection(0, this.linePts.length - 1, 0)
				},
				remove: function(t, e, i) {
					for (var n = e; i > n; n++) {
						var r = t.getSegment(n);
						this.inputIndex.remove(r)
					}
				},
				hasInteriorIntersection: function(t, e) {
					return this.li.computeIntersection(t.p0, t.p1, e.p0, e.p1), this.li.isInteriorIntersection()
				},
				hasBadInputIntersection: function(t, e, i) {
					for (var n = this.inputIndex.query(i).iterator(); n.hasNext();) {
						var r = n.next();
						if (this.hasInteriorIntersection(r, i)) {
							if (so.isInLineSection(t, e, r)) continue;
							return !0
						}
					}
					return !1
				},
				interfaces_: function() {
					return []
				},
				getClass: function() {
					return so
				}
			}), so.isInLineSection = function(t, e, i) {
				if (i.getParent() !== t.getParent()) return !1;
				var n = i.getIndex();
				return n >= e[0] && n < e[1]
			}, e(ao.prototype, {
				setDistanceTolerance: function(t) {
					this.distanceTolerance = t
				},
				simplify: function(t) {
					for (var e = t.iterator(); e.hasNext();) this.inputIndex.add(e.next());
					for (e = t.iterator(); e.hasNext();) {
						var i = new so(this.inputIndex, this.outputIndex);
						i.setDistanceTolerance(this.distanceTolerance), i.simplify(e.next())
					}
				},
				interfaces_: function() {
					return []
				},
				getClass: function() {
					return ao
				}
			}), e(lo.prototype, {
				getResultGeometry: function() {
					return this.inputGeom.isEmpty() ? this.inputGeom.copy() : (this.linestringMap = new Yt, this.inputGeom.apply(new ho(this)), this.lineSimplifier.simplify(this.linestringMap.values()), new uo(this.linestringMap).transform(this.inputGeom))
				},
				setDistanceTolerance: function(t) {
					if (0 > t) throw new n("Tolerance must be non-negative");
					this.lineSimplifier.setDistanceTolerance(t)
				},
				interfaces_: function() {
					return []
				},
				getClass: function() {
					return lo
				}
			}), lo.simplify = function(t, e) {
				var i = new lo(t);
				return i.setDistanceTolerance(e), i.getResultGeometry()
			}, h(uo, le), e(uo.prototype, {
				transformCoordinates: function(t, e) {
					if (0 === t.size()) return null;
					if (e instanceof Ct) {
						var i = this.linestringMap.get(e);
						return this.createCoordinateSequence(i.getResultCoordinates())
					}
					return le.prototype.transformCoordinates.call(this, t, e)
				},
				interfaces_: function() {
					return []
				},
				getClass: function() {
					return uo
				}
			}), e(ho.prototype, {
				filter: function(t) {
					if (t instanceof Ct) {
						var e = t;
						if (e.isEmpty()) return null;
						var i = e.isClosed() ? 4 : 2,
							n = new no(e, i);
						this.tps.linestringMap.put(e, n)
					}
				},
				interfaces_: function() {
					return [k]
				},
				getClass: function() {
					return ho
				}
			}), lo.LineStringTransformer = uo, lo.LineStringMapBuilderFilter = ho;
			var ys = Object.freeze({
				DouglasPeuckerSimplifier: to,
				TopologyPreservingSimplifier: lo
			});
			e(co.prototype, {
				splitAt: function() {
					if (1 === arguments.length) {
						var t = arguments[0],
							e = this.minimumLen / this.segLen;
						if (t.distance(this.seg.p0) < this.minimumLen) return this.splitPt = this.seg.pointAlong(e), null;
						if (t.distance(this.seg.p1) < this.minimumLen) return this.splitPt = co.pointAlongReverse(this.seg, e), null;
						this.splitPt = t
					} else if (2 === arguments.length) {
						var i = arguments[0],
							n = arguments[1],
							r = this.getConstrainedLength(i),
							o = r / this.segLen;
						n.equals2D(this.seg.p0) ? this.splitPt = this.seg.pointAlong(o) : this.splitPt = co.pointAlongReverse(this.seg, o)
					}
				},
				setMinimumLength: function(t) {
					this.minimumLen = t
				},
				getConstrainedLength: function(t) {
					return t < this.minimumLen ? this.minimumLen : t
				},
				getSplitPoint: function() {
					return this.splitPt
				},
				interfaces_: function() {
					return []
				},
				getClass: function() {
					return co
				}
			}), co.pointAlongReverse = function(t, e) {
				var i = new f;
				return i.x = t.p1.x - e * (t.p1.x - t.p0.x), i.y = t.p1.y - e * (t.p1.y - t.p0.y), i
			}, e(fo.prototype, {
				findSplitPoint: function(t, e) {},
				interfaces_: function() {
					return []
				},
				getClass: function() {
					return fo
				}
			}), e(Ao.prototype, {
				findSplitPoint: function(t, e) {
					var i = t.getLineSegment(),
						n = i.getLength() / 2,
						r = new co(i),
						o = Ao.projectedSplitPoint(t, e),
						s = 2 * o.distance(e) * .8;
					return s > n && (s = n), r.setMinimumLength(s), r.splitAt(o), r.getSplitPoint()
				},
				interfaces_: function() {
					return [fo]
				},
				getClass: function() {
					return Ao
				}
			}), Ao.projectedSplitPoint = function(t, e) {
				return t.getLineSegment().project(e)
			}, e(po.prototype, {
				interfaces_: function() {
					return []
				},
				getClass: function() {
					return po
				}
			}), po.triArea = function(t, e, i) {
				return (e.x - t.x) * (i.y - t.y) - (e.y - t.y) * (i.x - t.x)
			}, po.isInCircleDDNormalized = function(t, e, i, n) {
				var r = O.valueOf(t.x).selfSubtract(n.x),
					o = O.valueOf(t.y).selfSubtract(n.y),
					s = O.valueOf(e.x).selfSubtract(n.x),
					a = O.valueOf(e.y).selfSubtract(n.y),
					l = O.valueOf(i.x).selfSubtract(n.x),
					u = O.valueOf(i.y).selfSubtract(n.y),
					h = r.multiply(a).selfSubtract(s.multiply(o)),
					c = s.multiply(u).selfSubtract(l.multiply(a)),
					d = l.multiply(o).selfSubtract(r.multiply(u)),
					f = r.multiply(r).selfAdd(o.multiply(o)),
					A = s.multiply(s).selfAdd(a.multiply(a)),
					p = l.multiply(l).selfAdd(u.multiply(u));
				return f.selfMultiply(c).selfAdd(A.selfMultiply(d)).selfAdd(p.selfMultiply(h)).doubleValue() > 0
			}, po.checkRobustInCircle = function(t, e, i, n) {
				var r = po.isInCircleNonRobust(t, e, i, n),
					o = po.isInCircleDDSlow(t, e, i, n),
					s = po.isInCircleCC(t, e, i, n),
					a = Qi.circumcentre(t, e, i);
				F.out.println("p radius diff a = " + Math.abs(n.distance(a) - t.distance(a)) / t.distance(a)), r === o && r === s || (F.out.println("inCircle robustness failure (double result = " + r + ", DD result = " + o + ", CC result = " + s + ")"), F.out.println(Ht.toLineString(new Dt([t, e, i, n]))), F.out.println("Circumcentre = " + Ht.toPoint(a) + " radius = " + t.distance(a)), F.out.println("p radius diff a = " + Math.abs(n.distance(a) / t.distance(a) - 1)), F.out.println("p radius diff b = " + Math.abs(n.distance(a) / e.distance(a) - 1)), F.out.println("p radius diff c = " + Math.abs(n.distance(a) / i.distance(a) - 1)), F.out.println())
			}, po.isInCircleDDFast = function(t, e, i, n) {
				var r = O.sqr(t.x).selfAdd(O.sqr(t.y)).selfMultiply(po.triAreaDDFast(e, i, n)),
					o = O.sqr(e.x).selfAdd(O.sqr(e.y)).selfMultiply(po.triAreaDDFast(t, i, n)),
					s = O.sqr(i.x).selfAdd(O.sqr(i.y)).selfMultiply(po.triAreaDDFast(t, e, n)),
					a = O.sqr(n.x).selfAdd(O.sqr(n.y)).selfMultiply(po.triAreaDDFast(t, e, i));
				return r.selfSubtract(o).selfAdd(s).selfSubtract(a).doubleValue() > 0
			}, po.isInCircleCC = function(t, e, i, n) {
				var r = Qi.circumcentre(t, e, i),
					o = t.distance(r);
				return 0 >= n.distance(r) - o
			}, po.isInCircleNormalized = function(t, e, i, n) {
				var r = t.x - n.x,
					o = t.y - n.y,
					s = e.x - n.x,
					a = e.y - n.y,
					l = i.x - n.x,
					u = i.y - n.y;
				return (r * r + o * o) * (s * u - l * a) + (s * s + a * a) * (l * o - r * u) + (l * l + u * u) * (r * a - s * o) > 0
			}, po.isInCircleDDSlow = function(t, e, i, n) {
				var r = O.valueOf(n.x),
					o = O.valueOf(n.y),
					s = O.valueOf(t.x),
					a = O.valueOf(t.y),
					l = O.valueOf(e.x),
					u = O.valueOf(e.y),
					h = O.valueOf(i.x),
					c = O.valueOf(i.y),
					d = s.multiply(s).add(a.multiply(a)).multiply(po.triAreaDDSlow(l, u, h, c, r, o)),
					f = l.multiply(l).add(u.multiply(u)).multiply(po.triAreaDDSlow(s, a, h, c, r, o)),
					A = h.multiply(h).add(c.multiply(c)).multiply(po.triAreaDDSlow(s, a, l, u, r, o)),
					p = r.multiply(r).add(o.multiply(o)).multiply(po.triAreaDDSlow(s, a, l, u, h, c));
				return d.subtract(f).add(A).subtract(p).doubleValue() > 0
			}, po.isInCircleNonRobust = function(t, e, i, n) {
				return (t.x * t.x + t.y * t.y) * po.triArea(e, i, n) - (e.x * e.x + e.y * e.y) * po.triArea(t, i, n) + (i.x * i.x + i.y * i.y) * po.triArea(t, e, n) - (n.x * n.x + n.y * n.y) * po.triArea(t, e, i) > 0
			}, po.isInCircleRobust = function(t, e, i, n) {
				return po.isInCircleNormalized(t, e, i, n)
			}, po.triAreaDDSlow = function(t, e, i, n, r, o) {
				return i.subtract(t).multiply(o.subtract(e)).subtract(n.subtract(e).multiply(r.subtract(t)))
			}, po.triAreaDDFast = function(t, e, i) {
				var n = O.valueOf(e.x).selfSubtract(t.x).selfMultiply(O.valueOf(i.y).selfSubtract(t.y)),
					r = O.valueOf(e.y).selfSubtract(t.y).selfMultiply(O.valueOf(i.x).selfSubtract(t.x));
				return n.selfSubtract(r)
			}, e(go.prototype, {
				circleCenter: function(t, e) {
					var i, n = new go(this.getX(), this.getY()),
						r = new D(this.bisector(n, t), this.bisector(t, e)),
						o = null;
					try {
						o = new go(r.getX(), r.getY())
					} catch (i) {
						if (!(i instanceof S)) throw i;
						F.err.println("a: " + n + "  b: " + t + "  c: " + e), F.err.println(i)
					}
					return o
				},
				dot: function(t) {
					return this.p.x * t.getX() + this.p.y * t.getY()
				},
				magn: function() {
					return Math.sqrt(this.p.x * this.p.x + this.p.y * this.p.y)
				},
				getZ: function() {
					return this.p.z
				},
				bisector: function(t, e) {
					var i = e.getX() - t.getX(),
						n = e.getY() - t.getY(),
						r = new D(t.getX() + i / 2, t.getY() + n / 2, 1),
						o = new D(t.getX() - n + i / 2, t.getY() + i + n / 2, 1);
					return new D(r, o)
				},
				equals: function() {
					if (1 === arguments.length) {
						var t = arguments[0];
						return this.p.x === t.getX() && this.p.y === t.getY()
					}
					if (2 === arguments.length) {
						var e = arguments[0],
							i = arguments[1];
						return this.p.distance(e.getCoordinate()) < i
					}
				},
				getCoordinate: function() {
					return this.p
				},
				isInCircle: function(t, e, i) {
					return po.isInCircleRobust(t.p, e.p, i.p, this.p)
				},
				interpolateZValue: function(t, e, i) {
					var n = t.getX(),
						r = t.getY(),
						o = e.getX() - n,
						s = i.getX() - n,
						a = e.getY() - r,
						l = i.getY() - r,
						u = o * l - s * a,
						h = this.getX() - n,
						c = this.getY() - r,
						d = (l * h - s * c) / u,
						f = (-a * h + o * c) / u;
					return t.getZ() + d * (e.getZ() - t.getZ()) + f * (i.getZ() - t.getZ())
				},
				midPoint: function(t) {
					return new go((this.p.x + t.getX()) / 2, (this.p.y + t.getY()) / 2, (this.p.z + t.getZ()) / 2)
				},
				rightOf: function(t) {
					return this.isCCW(t.dest(), t.orig())
				},
				isCCW: function(t, e) {
					return (t.p.x - this.p.x) * (e.p.y - this.p.y) - (t.p.y - this.p.y) * (e.p.x - this.p.x) > 0
				},
				getX: function() {
					return this.p.x
				},
				crossProduct: function(t) {
					return this.p.x * t.getY() - this.p.y * t.getX()
				},
				setZ: function(t) {
					this.p.z = t
				},
				times: function(t) {
					return new go(t * this.p.x, t * this.p.y)
				},
				cross: function() {
					return new go(this.p.y, -this.p.x)
				},
				leftOf: function(t) {
					return this.isCCW(t.orig(), t.dest())
				},
				toString: function() {
					return "POINT (" + this.p.x + " " + this.p.y + ")"
				},
				sub: function(t) {
					return new go(this.p.x - t.getX(), this.p.y - t.getY())
				},
				getY: function() {
					return this.p.y
				},
				classify: function(t, e) {
					var i = this,
						n = e.sub(t),
						r = i.sub(t),
						o = n.crossProduct(r);
					return o > 0 ? go.LEFT : 0 > o ? go.RIGHT : n.getX() * r.getX() < 0 || n.getY() * r.getY() < 0 ? go.BEHIND : n.magn() < r.magn() ? go.BEYOND : t.equals(i) ? go.ORIGIN : e.equals(i) ? go.DESTINATION : go.BETWEEN
				},
				sum: function(t) {
					return new go(this.p.x + t.getX(), this.p.y + t.getY())
				},
				distance: function(t, e) {
					return Math.sqrt(Math.pow(e.getX() - t.getX(), 2) + Math.pow(e.getY() - t.getY(), 2))
				},
				circumRadiusRatio: function(t, e) {
					var i = this.circleCenter(t, e),
						n = this.distance(i, t),
						r = this.distance(this, t),
						o = this.distance(t, e);
					return r > o && (r = o), r > (o = this.distance(e, this)) && (r = o), n / r
				},
				interfaces_: function() {
					return []
				},
				getClass: function() {
					return go
				}
			}), go.interpolateZ = function() {
				if (3 === arguments.length) {
					var t = arguments[0],
						e = arguments[1],
						i = arguments[2],
						n = e.distance(i),
						r = t.distance(e),
						o = i.z - e.z,
						s = e.z + o * (r / n);
					return s
				}
				if (4 === arguments.length) {
					var a = arguments[0],
						l = arguments[1],
						u = arguments[2],
						h = arguments[3],
						c = l.x,
						d = l.y,
						f = u.x - c,
						A = h.x - c,
						p = u.y - d,
						g = h.y - d,
						m = f * g - A * p,
						v = a.x - c,
						y = a.y - d,
						_ = (g * v - A * y) / m,
						E = (-p * v + f * y) / m,
						x = l.z + _ * (u.z - l.z) + E * (h.z - l.z);
					return x
				}
			}, go.LEFT = 0, go.RIGHT = 1, go.BEYOND = 2, go.BEHIND = 3, go.BETWEEN = 4, go.ORIGIN = 5, go.DESTINATION = 6, h(mo, go), e(mo.prototype, {
				getConstraint: function() {
					return this.constraint
				},
				setOnConstraint: function(t) {
					this._isOnConstraint = t
				},
				merge: function(t) {
					t._isOnConstraint && (this._isOnConstraint = !0, this.constraint = t.constraint)
				},
				isOnConstraint: function() {
					return this._isOnConstraint
				},
				setConstraint: function(t) {
					this._isOnConstraint = !0, this.constraint = t
				},
				interfaces_: function() {
					return []
				},
				getClass: function() {
					return mo
				}
			}), e(vo.prototype, {
				equalsNonOriented: function(t) {
					return !!this.equalsOriented(t) || !! this.equalsOriented(t.sym())
				},
				toLineSegment: function() {
					return new te(this.vertex.getCoordinate(), this.dest().getCoordinate())
				},
				dest: function() {
					return this.sym().orig()
				},
				oNext: function() {
					return this.next
				},
				equalsOriented: function(t) {
					return !(!this.orig().getCoordinate().equals2D(t.orig().getCoordinate()) || !this.dest().getCoordinate().equals2D(t.dest().getCoordinate()))
				},
				dNext: function() {
					return this.sym().oNext().sym()
				},
				lPrev: function() {
					return this.next.sym()
				},
				rPrev: function() {
					return this.sym().oNext()
				},
				rot: function() {
					return this._rot
				},
				oPrev: function() {
					return this._rot.next._rot
				},
				sym: function() {
					return this._rot._rot
				},
				setOrig: function(t) {
					this.vertex = t
				},
				lNext: function() {
					return this.invRot().oNext().rot()
				},
				getLength: function() {
					return this.orig().getCoordinate().distance(this.dest().getCoordinate())
				},
				invRot: function() {
					return this._rot.sym()
				},
				setDest: function(t) {
					this.sym().setOrig(t)
				},
				setData: function(t) {
					this.data = t
				},
				getData: function() {
					return this.data
				},
				delete: function() {
					this._rot = null
				},
				orig: function() {
					return this.vertex
				},
				rNext: function() {
					return this._rot.next.invRot()
				},
				toString: function() {
					var t = this.vertex.getCoordinate(),
						e = this.dest().getCoordinate();
					return Ht.toLineString(t, e)
				},
				isLive: function() {
					return null !== this._rot
				},
				getPrimary: function() {
					return this.orig().getCoordinate().compareTo(this.dest().getCoordinate()) <= 0 ? this : this.sym()
				},
				dPrev: function() {
					return this.invRot().oNext().invRot()
				},
				setNext: function(t) {
					this.next = t
				},
				interfaces_: function() {
					return []
				},
				getClass: function() {
					return vo
				}
			}), vo.makeEdge = function(t, e) {
				var i = new vo,
					n = new vo,
					r = new vo,
					o = new vo;
				i._rot = n, n._rot = r, r._rot = o, o._rot = i, i.setNext(i), n.setNext(o), r.setNext(r), o.setNext(n);
				var s = i;
				return s.setOrig(t), s.setDest(e), s
			}, vo.swap = function(t) {
				var e = t.oPrev(),
					i = t.sym().oPrev();
				vo.splice(t, e), vo.splice(t.sym(), i), vo.splice(t, e.lNext()), vo.splice(t.sym(), i.lNext()), t.setOrig(e.dest()), t.setDest(i.dest())
			}, vo.splice = function(t, e) {
				var i = t.oNext().rot(),
					n = e.oNext().rot(),
					r = e.oNext(),
					o = t.oNext(),
					s = n.oNext(),
					a = i.oNext();
				t.setNext(r), e.setNext(o), i.setNext(s), n.setNext(a)
			}, vo.connect = function(t, e) {
				var i = vo.makeEdge(t.dest(), e.orig());
				return vo.splice(i, t.lNext()), vo.splice(i.sym(), e), i
			}, e(yo.prototype, {
				insertSite: function(t) {
					var e = this.subdiv.locate(t);
					if (this.subdiv.isVertexOfEdge(e, t)) return e;
					this.subdiv.isOnEdge(e, t.getCoordinate()) && (e = e.oPrev(), this.subdiv.delete(e.oNext()));
					var i = this.subdiv.makeEdge(e.orig(), t);
					vo.splice(i, e);
					var n = i;
					do {
						e = (i = this.subdiv.connect(e, i.sym())).oPrev()
					} while (e.lNext() !== n);
					for (;;) {
						var r = e.oPrev();
						if (r.dest().rightOf(e) && t.isInCircle(e.orig(), r.dest(), e.dest())) vo.swap(e), e = e.oPrev();
						else {
							if (e.oNext() === n) return i;
							e = e.oNext().lPrev()
						}
					}
				},
				insertSites: function(t) {
					for (var e = t.iterator(); e.hasNext();) {
						var i = e.next();
						this.insertSite(i)
					}
				},
				interfaces_: function() {
					return []
				},
				getClass: function() {
					return yo
				}
			}), e(_o.prototype, {
				locate: function(t) {},
				interfaces_: function() {
					return []
				},
				getClass: function() {
					return _o
				}
			}), e(Eo.prototype, {
				init: function() {
					this.lastEdge = this.findEdge()
				},
				locate: function(t) {
					this.lastEdge.isLive() || this.init();
					var e = this.subdiv.locateFromEdge(t, this.lastEdge);
					return this.lastEdge = e, e
				},
				findEdge: function() {
					return this.subdiv.getEdges().iterator().next()
				},
				interfaces_: function() {
					return [_o]
				},
				getClass: function() {
					return Eo
				}
			}), h(xo, u), e(xo.prototype, {
				getSegment: function() {
					return this.seg
				},
				interfaces_: function() {
					return []
				},
				getClass: function() {
					return xo
				}
			}), xo.msgWithSpatial = function(t, e) {
				return null !== e ? t + " [ " + e + " ]" : t
			}, e(Co.prototype, {
				visit: function(t) {},
				interfaces_: function() {
					return []
				},
				getClass: function() {
					return Co
				}
			}), e(Io.prototype, {
				getTriangleVertices: function(t) {
					var e = new Ro;
					return this.visitTriangles(e, t), e.getTriangleVertices()
				},
				isFrameVertex: function(t) {
					return !!t.equals(this.frameVertex[0]) || !! t.equals(this.frameVertex[1]) || !! t.equals(this.frameVertex[2])
				},
				isVertexOfEdge: function(t, e) {
					return !(!e.equals(t.orig(), this.tolerance) && !e.equals(t.dest(), this.tolerance))
				},
				connect: function(t, e) {
					var i = vo.connect(t, e);
					return this.quadEdges.add(i), i
				},
				getVoronoiCellPolygon: function(t, e) {
					var i = new E,
						n = t;
					do {
						var r = t.rot().orig().getCoordinate();
						i.add(r), t = t.oPrev()
					} while (t !== n);
					var o = new x;
					o.addAll(i, !1), o.closeRing(), o.size() < 4 && (F.out.println(o), o.add(o.get(o.size() - 1), !0));
					var s = o.toCoordinateArray(),
						a = e.createPolygon(e.createLinearRing(s), null),
						l = n.orig();
					return a.setUserData(l.getCoordinate()), a
				},
				setLocator: function(t) {
					this.locator = t
				},
				initSubdiv: function() {
					var t = this.makeEdge(this.frameVertex[0], this.frameVertex[1]),
						e = this.makeEdge(this.frameVertex[1], this.frameVertex[2]);
					vo.splice(t.sym(), e);
					var i = this.makeEdge(this.frameVertex[2], this.frameVertex[0]);
					return vo.splice(e.sym(), i), vo.splice(i.sym(), t), t
				},
				isFrameBorderEdge: function(t) {
					var e = new Array(3).fill(null);
					Io.getTriangleEdges(t, e);
					var i = new Array(3).fill(null);
					Io.getTriangleEdges(t.sym(), i);
					var n = t.lNext().dest();
					if (this.isFrameVertex(n)) return !0;
					var r = t.sym().lNext().dest();
					return !!this.isFrameVertex(r)
				},
				makeEdge: function(t, e) {
					var i = vo.makeEdge(t, e);
					return this.quadEdges.add(i), i
				},
				visitTriangles: function(t, e) {
					this.visitedKey++;
					var i = new re;
					i.push(this.startingEdge);
					for (var n = new Q; !i.empty();) {
						var r = i.pop();
						if (!n.contains(r)) {
							var o = this.fetchTriangleToVisit(r, i, e, n);
							null !== o && t.visit(o)
						}
					}
				},
				isFrameEdge: function(t) {
					return !(!this.isFrameVertex(t.orig()) && !this.isFrameVertex(t.dest()))
				},
				isOnEdge: function(t, e) {
					return this.seg.setCoordinates(t.orig().getCoordinate(), t.dest().getCoordinate()), this.seg.distance(e) < this.edgeCoincidenceTolerance
				},
				getEnvelope: function() {
					return new C(this.frameEnv)
				},
				createFrame: function(t) {
					var e, i = t.getWidth(),
						n = t.getHeight();
					e = i > n ? 10 * i : 10 * n, this.frameVertex[0] = new go((t.getMaxX() + t.getMinX()) / 2, t.getMaxY() + e), this.frameVertex[1] = new go(t.getMinX() - e, t.getMinY() - e), this.frameVertex[2] = new go(t.getMaxX() + e, t.getMinY() - e), this.frameEnv = new C(this.frameVertex[0].getCoordinate(), this.frameVertex[1].getCoordinate()), this.frameEnv.expandToInclude(this.frameVertex[2].getCoordinate())
				},
				getTriangleCoordinates: function(t) {
					var e = new wo;
					return this.visitTriangles(e, t), e.getTriangles()
				},
				getVertices: function(t) {
					for (var e = new Q, i = this.quadEdges.iterator(); i.hasNext();) {
						var n = i.next(),
							r = n.orig();
						!t && this.isFrameVertex(r) || e.add(r);
						var o = n.dest();
						!t && this.isFrameVertex(o) || e.add(o)
					}
					return e
				},
				fetchTriangleToVisit: function(t, e, i, n) {
					var r = t,
						o = 0,
						s = !1;
					do {
						this.triEdges[o] = r, this.isFrameEdge(r) && (s = !0);
						var a = r.sym();
						n.contains(a) || e.push(a), n.add(r), o++, r = r.lNext()
					} while (r !== t);
					return s && !i ? null : this.triEdges
				},
				getEdges: function() {
					if (0 === arguments.length) return this.quadEdges;
					if (1 === arguments.length) {
						for (var t = arguments[0], e = this.getPrimaryEdges(!1), i = new Array(e.size()).fill(null), n = 0, r = e.iterator(); r.hasNext();) {
							var o = r.next();
							i[n++] = t.createLineString([o.orig().getCoordinate(), o.dest().getCoordinate()])
						}
						return t.createMultiLineString(i)
					}
				},
				getVertexUniqueEdges: function(t) {
					for (var e = new E, i = new Q, n = this.quadEdges.iterator(); n.hasNext();) {
						var r = n.next(),
							o = r.orig();
						i.contains(o) || (i.add(o), !t && this.isFrameVertex(o) || e.add(r));
						var s = r.sym(),
							a = s.orig();
						i.contains(a) || (i.add(a), !t && this.isFrameVertex(a) || e.add(s))
					}
					return e
				},
				getTriangleEdges: function(t) {
					var e = new To;
					return this.visitTriangles(e, t), e.getTriangleEdges()
				},
				getPrimaryEdges: function(t) {
					this.visitedKey++;
					var e = new E,
						i = new re;
					i.push(this.startingEdge);
					for (var n = new Q; !i.empty();) {
						var r = i.pop();
						if (!n.contains(r)) {
							var o = r.getPrimary();
							!t && this.isFrameEdge(o) || e.add(o), i.push(r.oNext()), i.push(r.sym().oNext()), n.add(r), n.add(r.sym())
						}
					}
					return e
				},
				delete: function(t) {
					vo.splice(t, t.oPrev()), vo.splice(t.sym(), t.sym().oPrev());
					var e = t.sym(),
						i = t.rot(),
						n = t.rot().sym();
					this.quadEdges.remove(t), this.quadEdges.remove(e), this.quadEdges.remove(i), this.quadEdges.remove(n), t.delete(), e.delete(), i.delete(), n.delete()
				},
				locateFromEdge: function(t, e) {
					for (var i = 0, n = this.quadEdges.size(), r = e;;) {
						if (++i > n) throw new xo(r.toLineSegment());
						if (t.equals(r.orig()) || t.equals(r.dest())) break;
						if (t.rightOf(r)) r = r.sym();
						else if (t.rightOf(r.oNext())) {
							if (t.rightOf(r.dPrev())) break;
							r = r.dPrev()
						} else r = r.oNext()
					}
					return r
				},
				getTolerance: function() {
					return this.tolerance
				},
				getVoronoiCellPolygons: function(t) {
					this.visitTriangles(new So, !0);
					for (var e = new E, i = this.getVertexUniqueEdges(!1).iterator(); i.hasNext();) {
						var n = i.next();
						e.add(this.getVoronoiCellPolygon(n, t))
					}
					return e
				},
				getVoronoiDiagram: function(t) {
					var e = this.getVoronoiCellPolygons(t);
					return t.createGeometryCollection(Wt.toGeometryArray(e))
				},
				getTriangles: function(t) {
					for (var e = this.getTriangleCoordinates(!1), i = new Array(e.size()).fill(null), n = 0, r = e.iterator(); r.hasNext();) {
						var o = r.next();
						i[n++] = t.createPolygon(t.createLinearRing(o), null)
					}
					return t.createGeometryCollection(i)
				},
				insertSite: function(t) {
					var e = this.locate(t);
					if (t.equals(e.orig(), this.tolerance) || t.equals(e.dest(), this.tolerance)) return e;
					var i = this.makeEdge(e.orig(), t);
					vo.splice(i, e);
					var n = i;
					do {
						e = (i = this.connect(e, i.sym())).oPrev()
					} while (e.lNext() !== n);
					return n
				},
				locate: function() {
					if (1 === arguments.length) {
						if (arguments[0] instanceof go) {
							var t = arguments[0];
							return this.locator.locate(t)
						}
						if (arguments[0] instanceof f) {
							var e = arguments[0];
							return this.locator.locate(new go(e))
						}
					} else if (2 === arguments.length) {
						var i = arguments[0],
							n = arguments[1],
							r = this.locator.locate(new go(i));
						if (null === r) return null;
						var o = r;
						r.dest().getCoordinate().equals2D(i) && (o = r.sym());
						var s = o;
						do {
							if (s.dest().getCoordinate().equals2D(n)) return s;
							s = s.oNext()
						} while (s !== o);
						return null
					}
				},
				interfaces_: function() {
					return []
				},
				getClass: function() {
					return Io
				}
			}), Io.getTriangleEdges = function(t, e) {
				if (e[0] = t, e[1] = e[0].lNext(), e[2] = e[1].lNext(), e[2].lNext() !== e[0]) throw new n("Edges do not form a triangle")
			}, e(So.prototype, {
				visit: function(t) {
					for (var e = t[0].orig().getCoordinate(), i = t[1].orig().getCoordinate(), n = t[2].orig().getCoordinate(), r = new go(Qi.circumcentre(e, i, n)), o = 0; 3 > o; o++) t[o].rot().setOrig(r)
				},
				interfaces_: function() {
					return [Co]
				},
				getClass: function() {
					return So
				}
			}), e(To.prototype, {
				getTriangleEdges: function() {
					return this.triList
				},
				visit: function(t) {
					this.triList.add(t.clone())
				},
				interfaces_: function() {
					return [Co]
				},
				getClass: function() {
					return To
				}
			}), e(Ro.prototype, {
				visit: function(t) {
					this.triList.add([t[0].orig(), t[1].orig(), t[2].orig()])
				},
				getTriangleVertices: function() {
					return this.triList
				},
				interfaces_: function() {
					return [Co]
				},
				getClass: function() {
					return Ro
				}
			}), e(wo.prototype, {
				checkTriangleSize: function(t) {
					t.length >= 2 ? Ht.toLineString(t[0], t[1]) : t.length >= 1 && Ht.toPoint(t[0])
				},
				visit: function(t) {
					this.coordList.clear();
					for (var e = 0; 3 > e; e++) {
						var i = t[e].orig();
						this.coordList.add(i.getCoordinate())
					}
					if (this.coordList.size() > 0) {
						this.coordList.closeRing();
						var n = this.coordList.toCoordinateArray();
						if (4 !== n.length) return null;
						this.triCoords.add(n)
					}
				},
				getTriangles: function() {
					return this.triCoords
				},
				interfaces_: function() {
					return [Co]
				},
				getClass: function() {
					return wo
				}
			}), Io.TriangleCircumcentreVisitor = So, Io.TriangleEdgesListVisitor = To, Io.TriangleVertexListVisitor = Ro, Io.TriangleCoordinatesVisitor = wo, Io.EDGE_COINCIDENCE_TOL_FACTOR = 1e3, e(Lo.prototype, {
				getLineSegment: function() {
					return this.ls
				},
				getEndZ: function() {
					return this.ls.getCoordinate(1).z
				},
				getStartZ: function() {
					return this.ls.getCoordinate(0).z
				},
				intersection: function(t) {
					return this.ls.intersection(t.getLineSegment())
				},
				getStart: function() {
					return this.ls.getCoordinate(0)
				},
				getEnd: function() {
					return this.ls.getCoordinate(1)
				},
				getEndY: function() {
					return this.ls.getCoordinate(1).y
				},
				getStartX: function() {
					return this.ls.getCoordinate(0).x
				},
				equalsTopo: function(t) {
					return this.ls.equalsTopo(t.getLineSegment())
				},
				getStartY: function() {
					return this.ls.getCoordinate(0).y
				},
				setData: function(t) {
					this.data = t
				},
				getData: function() {
					return this.data
				},
				getEndX: function() {
					return this.ls.getCoordinate(1).x
				},
				toString: function() {
					return this.ls.toString()
				},
				interfaces_: function() {
					return []
				},
				getClass: function() {
					return Lo
				}
			}), e(No.prototype, {
				visit: function(t) {},
				interfaces_: function() {
					return []
				},
				getClass: function() {
					return No
				}
			}), e(Po.prototype, {
				isRepeated: function() {
					return this.count > 1
				},
				getRight: function() {
					return this.right
				},
				getCoordinate: function() {
					return this.p
				},
				setLeft: function(t) {
					this.left = t
				},
				getX: function() {
					return this.p.x
				},
				getData: function() {
					return this.data
				},
				getCount: function() {
					return this.count
				},
				getLeft: function() {
					return this.left
				},
				getY: function() {
					return this.p.y
				},
				increment: function() {
					this.count = this.count + 1
				},
				setRight: function(t) {
					this.right = t
				},
				interfaces_: function() {
					return []
				},
				getClass: function() {
					return Po
				}
			}), e(Oo.prototype, {
				insert: function() {
					if (1 === arguments.length) {
						var t = arguments[0];
						return this.insert(t, null)
					}
					if (2 === arguments.length) {
						var e = arguments[0],
							i = arguments[1];
						if (null === this.root) return this.root = new Po(e, i), this.root;
						if (this.tolerance > 0) {
							var n = this.findBestMatchNode(e);
							if (null !== n) return n.increment(), n
						}
						return this.insertExact(e, i)
					}
				},
				query: function() {
					var t = arguments,
						e = this;
					if (1 === arguments.length) {
						var i = arguments[0],
							n = new E;
						return this.query(i, n), n
					}
					if (2 === arguments.length) if (arguments[0] instanceof C && R(arguments[1], v))!
					function() {
						var i = t[0],
							n = t[1];
						e.queryNode(e.root, i, !0, {
							interfaces_: function() {
								return [No]
							},
							visit: function(t) {
								n.add(t)
							}
						})
					}();
					else if (arguments[0] instanceof C && R(arguments[1], No)) {
						var r = arguments[0],
							o = arguments[1];
						this.queryNode(this.root, r, !0, o)
					}
				},
				queryNode: function(t, e, i, n) {
					if (null === t) return null;
					var r = null,
						o = null,
						s = null;
					i ? (r = e.getMinX(), o = e.getMaxX(), s = t.getX()) : (r = e.getMinY(), o = e.getMaxY(), s = t.getY());
					var a = o >= s;
					s > r && this.queryNode(t.getLeft(), e, !i, n), e.contains(t.getCoordinate()) && n.visit(t), a && this.queryNode(t.getRight(), e, !i, n)
				},
				findBestMatchNode: function(t) {
					var e = new Mo(t, this.tolerance);
					return this.query(e.queryEnvelope(), e), e.getNode()
				},
				isEmpty: function() {
					return null === this.root
				},
				insertExact: function(t, e) {
					for (var i = this.root, n = this.root, r = !0, o = !0; null !== i;) {
						if (null !== i && t.distance(i.getCoordinate()) <= this.tolerance) return i.increment(), i;
						o = r ? t.x < i.getX() : t.y < i.getY(), n = i, i = o ? i.getLeft() : i.getRight(), r = !r
					}
					this.numberOfNodes = this.numberOfNodes + 1;
					var s = new Po(t, e);
					return o ? n.setLeft(s) : n.setRight(s), s
				},
				interfaces_: function() {
					return []
				},
				getClass: function() {
					return Oo
				}
			}), Oo.toCoordinates = function() {
				if (1 === arguments.length) {
					var t = arguments[0];
					return Oo.toCoordinates(t, !1)
				}
				if (2 === arguments.length) {
					for (var e = arguments[0], i = arguments[1], n = new x, r = e.iterator(); r.hasNext();) for (var o = r.next(), s = i ? o.getCount() : 1, a = 0; s > a; a++) n.add(o.getCoordinate(), !0);
					return n.toCoordinateArray()
				}
			}, e(Mo.prototype, {
				visit: function(t) {
					var e = this.p.distance(t.getCoordinate());
					if (!(e <= this.tolerance)) return null;
					var i = !1;
					(null === this.matchNode || e < this.matchDist || null !== this.matchNode && e === this.matchDist && t.getCoordinate().compareTo(this.matchNode.getCoordinate()) < 1) && (i = !0), i && (this.matchNode = t, this.matchDist = e)
				},
				queryEnvelope: function() {
					var t = new C(this.p);
					return t.expandBy(this.tolerance), t
				},
				getNode: function() {
					return this.matchNode
				},
				interfaces_: function() {
					return [No]
				},
				getClass: function() {
					return Mo
				}
			}), Oo.BestMatchVisitor = Mo, e(bo.prototype, {
				getInitialVertices: function() {
					return this.initialVertices
				},
				getKDT: function() {
					return this.kdt
				},
				enforceConstraints: function() {
					this.addConstraintVertices();
					var t = 0,
						e = 0;
					do {
						e = this.enforceGabriel(this.segments), t++
					} while (e > 0 && t < bo.MAX_SPLIT_ITER)
				},
				insertSites: function(t) {
					for (var e = t.iterator(); e.hasNext();) {
						var i = e.next();
						this.insertSite(i)
					}
				},
				getVertexFactory: function() {
					return this.vertexFactory
				},
				getPointArray: function() {
					for (var t = new Array(this.initialVertices.size() + this.segVertices.size()).fill(null), e = 0, i = this.initialVertices.iterator(); i.hasNext();) {
						var n = i.next();
						t[e++] = n.getCoordinate()
					}
					for (var r = this.segVertices.iterator(); r.hasNext();) n = r.next(), t[e++] = n.getCoordinate();
					return t
				},
				setConstraints: function(t, e) {
					this.segments = t, this.segVertices = e
				},
				computeConvexHull: function() {
					var t = new Wt,
						e = new se(this.getPointArray(), t);
					this.convexHull = e.getConvexHull()
				},
				addConstraintVertices: function() {
					this.computeConvexHull(), this.insertSites(this.segVertices)
				},
				findNonGabrielPoint: function(t) {
					var e = t.getStart(),
						i = t.getEnd(),
						n = new f((e.x + i.x) / 2, (e.y + i.y) / 2),
						o = e.distance(n),
						s = new C(n);
					s.expandBy(o);
					for (var a = this.kdt.query(s), l = null, u = r.MAX_VALUE, h = a.iterator(); h.hasNext();) {
						var c = h.next().getCoordinate();
						if (!c.equals2D(e) && !c.equals2D(i)) {
							var d = n.distance(c);
							o > d && (null === l || u > d) && (l = c, u = d)
						}
					}
					return l
				},
				getConstraintSegments: function() {
					return this.segments
				},
				setSplitPointFinder: function(t) {
					this.splitFinder = t
				},
				getConvexHull: function() {
					return this.convexHull
				},
				getTolerance: function() {
					return this.tolerance
				},
				enforceGabriel: function(t) {
					for (var e = new E, i = 0, n = new E, r = t.iterator(); r.hasNext();) {
						var o = r.next(),
							s = this.findNonGabrielPoint(o);
						if (null !== s) {
							this.splitPt = this.splitFinder.findSplitPoint(o, s);
							var a = this.createVertex(this.splitPt, o),
								l = (this.insertSite(a), new Lo(o.getStartX(), o.getStartY(), o.getStartZ(), a.getX(), a.getY(), a.getZ(), o.getData())),
								u = new Lo(a.getX(), a.getY(), a.getZ(), o.getEndX(), o.getEndY(), o.getEndZ(), o.getData());
							e.add(l), e.add(u), n.add(o), i += 1
						}
					}
					return t.removeAll(n), t.addAll(e), i
				},
				createVertex: function() {
					if (1 === arguments.length) {
						var t = arguments[0],
							e = null;
						return null !== this.vertexFactory ? this.vertexFactory.createVertex(t, null) : new mo(t)
					}
					if (2 === arguments.length) {
						var i = arguments[0],
							n = arguments[1];
						return e = null, (e = null !== this.vertexFactory ? this.vertexFactory.createVertex(i, n) : new mo(i)).setOnConstraint(!0), e
					}
				},
				getSubdivision: function() {
					return this.subdiv
				},
				computeBoundingBox: function() {
					var t = bo.computeVertexEnvelope(this.initialVertices),
						e = bo.computeVertexEnvelope(this.segVertices),
						i = new C(t);
					i.expandToInclude(e);
					var n = .2 * i.getWidth(),
						r = .2 * i.getHeight(),
						o = Math.max(n, r);
					this.computeAreaEnv = new C(i), this.computeAreaEnv.expandBy(o)
				},
				setVertexFactory: function(t) {
					this.vertexFactory = t
				},
				formInitialDelaunay: function() {
					this.computeBoundingBox(), this.subdiv = new Io(this.computeAreaEnv, this.tolerance), this.subdiv.setLocator(new Eo(this.subdiv)), this.incDel = new yo(this.subdiv), this.insertSites(this.initialVertices)
				},
				insertSite: function() {
					if (arguments[0] instanceof mo) {
						var t = arguments[0],
							e = this.kdt.insert(t.getCoordinate(), t);
						if (e.isRepeated()) {
							var i = e.getData();
							return i.merge(t), i
						}
						return this.incDel.insertSite(t), t
					}
					if (arguments[0] instanceof f) {
						var n = arguments[0];
						this.insertSite(this.createVertex(n))
					}
				},
				interfaces_: function() {
					return []
				},
				getClass: function() {
					return bo
				}
			}), bo.computeVertexEnvelope = function(t) {
				for (var e = new C, i = t.iterator(); i.hasNext();) {
					var n = i.next();
					e.expandToInclude(n.getCoordinate())
				}
				return e
			}, bo.MAX_SPLIT_ITER = 99, e(Fo.prototype, {
				create: function() {
					if (null !== this.subdiv) return null;
					var t = Fo.envelope(this.siteCoords),
						e = Fo.toVertices(this.siteCoords);
					this.subdiv = new Io(t, this.tolerance), new yo(this.subdiv).insertSites(e)
				},
				setTolerance: function(t) {
					this.tolerance = t
				},
				setSites: function() {
					if (arguments[0] instanceof U) {
						var t = arguments[0];
						this.siteCoords = Fo.extractUniqueCoordinates(t)
					} else if (R(arguments[0], g)) {
						var e = arguments[0];
						this.siteCoords = Fo.unique(W.toCoordinateArray(e))
					}
				},
				getEdges: function(t) {
					return this.create(), this.subdiv.getEdges(t)
				},
				getSubdivision: function() {
					return this.create(), this.subdiv
				},
				getTriangles: function(t) {
					return this.create(), this.subdiv.getTriangles(t)
				},
				interfaces_: function() {
					return []
				},
				getClass: function() {
					return Fo
				}
			}), Fo.extractUniqueCoordinates = function(t) {
				if (null === t) return new x;
				var e = t.getCoordinates();
				return Fo.unique(e)
			}, Fo.envelope = function(t) {
				for (var e = new C, i = t.iterator(); i.hasNext();) {
					var n = i.next();
					e.expandToInclude(n)
				}
				return e
			}, Fo.unique = function(t) {
				var e = W.copyDeep(t);
				return lt.sort(e), new x(e, !1)
			}, Fo.toVertices = function(t) {
				for (var e = new E, i = t.iterator(); i.hasNext();) {
					var n = i.next();
					e.add(new go(n))
				}
				return e
			}, e(Do.prototype, {
				createSiteVertices: function(t) {
					for (var e = new E, i = t.iterator(); i.hasNext();) {
						var n = i.next();
						this.constraintVertexMap.containsKey(n) || e.add(new mo(n))
					}
					return e
				},
				create: function() {
					if (null !== this.subdiv) return null;
					var t = Fo.envelope(this.siteCoords),
						e = new E;
					null !== this.constraintLines && (t.expandToInclude(this.constraintLines.getEnvelopeInternal()), this.createVertices(this.constraintLines), e = Do.createConstraintSegments(this.constraintLines));
					var i = new bo(this.createSiteVertices(this.siteCoords), this.tolerance);
					i.setConstraints(e, new E(this.constraintVertexMap.values())), i.formInitialDelaunay(), i.enforceConstraints(), this.subdiv = i.getSubdivision()
				},
				setTolerance: function(t) {
					this.tolerance = t
				},
				setConstraints: function(t) {
					this.constraintLines = t
				},
				setSites: function(t) {
					this.siteCoords = Fo.extractUniqueCoordinates(t)
				},
				getEdges: function(t) {
					return this.create(), this.subdiv.getEdges(t)
				},
				getSubdivision: function() {
					return this.create(), this.subdiv
				},
				getTriangles: function(t) {
					return this.create(), this.subdiv.getTriangles(t)
				},
				createVertices: function(t) {
					for (var e = t.getCoordinates(), i = 0; i < e.length; i++) {
						var n = new mo(e[i]);
						this.constraintVertexMap.put(e[i], n)
					}
				},
				interfaces_: function() {
					return []
				},
				getClass: function() {
					return Do
				}
			}), Do.createConstraintSegments = function() {
				if (1 === arguments.length) {
					for (var t = arguments[0], e = Li.getLines(t), i = new E, n = e.iterator(); n.hasNext();) {
						var r = n.next();
						Do.createConstraintSegments(r, i)
					}
					return i
				}
				if (2 === arguments.length) {
					var o = arguments[0],
						s = arguments[1],
						a = o.getCoordinates();
					for (n = 1; n < a.length; n++) s.add(new Lo(a[n - 1], a[n]))
				}
			}, e(Go.prototype, {
				create: function() {
					if (null !== this.subdiv) return null;
					var t = Fo.envelope(this.siteCoords);
					this.diagramEnv = t;
					var e = Math.max(this.diagramEnv.getWidth(), this.diagramEnv.getHeight());
					this.diagramEnv.expandBy(e), null !== this.clipEnv && this.diagramEnv.expandToInclude(this.clipEnv);
					var i = Fo.toVertices(this.siteCoords);
					this.subdiv = new Io(t, this.tolerance), new yo(this.subdiv).insertSites(i)
				},
				getDiagram: function(t) {
					this.create();
					var e = this.subdiv.getVoronoiDiagram(t);
					return Go.clipGeometryCollection(e, this.diagramEnv)
				},
				setTolerance: function(t) {
					this.tolerance = t
				},
				setSites: function() {
					if (arguments[0] instanceof U) {
						var t = arguments[0];
						this.siteCoords = Fo.extractUniqueCoordinates(t)
					} else if (R(arguments[0], g)) {
						var e = arguments[0];
						this.siteCoords = Fo.unique(W.toCoordinateArray(e))
					}
				},
				setClipEnvelope: function(t) {
					this.clipEnv = t
				},
				getSubdivision: function() {
					return this.create(), this.subdiv
				},
				interfaces_: function() {
					return []
				},
				getClass: function() {
					return Go
				}
			}), Go.clipGeometryCollection = function(t, e) {
				for (var i = t.getFactory().toGeometry(e), n = new E, r = 0; r < t.getNumGeometries(); r++) {
					var o = t.getGeometryN(r),
						s = null;
					e.contains(o.getEnvelopeInternal()) ? s = o : e.intersects(o.getEnvelopeInternal()) && (s = i.intersection(o)).setUserData(o.getUserData()), null === s || s.isEmpty() || n.add(s)
				}
				return t.getFactory().createGeometryCollection(Wt.toGeometryArray(n))
			};
			var _s = Object.freeze({
				ConformingDelaunayTriangulationBuilder: Do,
				DelaunayTriangulationBuilder: Fo,
				VoronoiDiagramBuilder: Go
			});
			e(ko.prototype, {
				interfaces_: function() {
					return []
				},
				getClass: function() {
					return ko
				}
			}), ko.union = function(t, e) {
				if (t.isEmpty() || e.isEmpty()) {
					if (t.isEmpty() && e.isEmpty()) return zi.createEmptyResult(zi.UNION, t, e, t.getFactory());
					if (t.isEmpty()) return e.copy();
					if (e.isEmpty()) return t.copy()
				}
				return t.checkNotGeometryCollection(t), t.checkNotGeometryCollection(e), Wi.overlayOp(t, e, zi.UNION)
			}, e(U.prototype, {
				equalsTopo: function(t) {
					return !!this.getEnvelopeInternal().equals(t.getEnvelopeInternal()) && Nr.relate(this, t).isEquals(this.getDimension(), t.getDimension())
				},
				union: function() {
					if (0 === arguments.length) return Fr.union(this);
					if (1 === arguments.length) {
						var t = arguments[0];
						return ko.union(this, t)
					}
				},
				isValid: function() {
					return Kr.isValid(this)
				},
				intersection: function(t) {
					if (this.isEmpty() || t.isEmpty()) return zi.createEmptyResult(zi.INTERSECTION, this, t, this.factory);
					if (this.isGeometryCollection()) {
						var e = t;
						return Je.map(this, {
							interfaces_: function() {
								return [MapOp]
							},
							map: function(t) {
								return t.intersection(e)
							}
						})
					}
					return this.checkNotGeometryCollection(this), this.checkNotGeometryCollection(t), Wi.overlayOp(this, t, zi.INTERSECTION)
				},
				covers: function(t) {
					return Nr.covers(this, t)
				},
				coveredBy: function(t) {
					return Nr.coveredBy(this, t)
				},
				touches: function(t) {
					return Nr.touches(this, t)
				},
				intersects: function(t) {
					return Nr.intersects(this, t)
				},
				within: function(t) {
					return Nr.within(this, t)
				},
				overlaps: function(t) {
					return Nr.overlaps(this, t)
				},
				disjoint: function(t) {
					return Nr.disjoint(this, t)
				},
				crosses: function(t) {
					return Nr.crosses(this, t)
				},
				buffer: function() {
					if (1 === arguments.length) {
						var t = arguments[0];
						return Wn.bufferOp(this, t)
					}
					if (2 === arguments.length) {
						var e = arguments[0],
							i = arguments[1];
						return Wn.bufferOp(this, e, i)
					}
					if (3 === arguments.length) {
						var n = arguments[0],
							r = arguments[1],
							o = arguments[2];
						return Wn.bufferOp(this, n, r, o)
					}
				},
				convexHull: function() {
					return new se(this).getConvexHull()
				},
				relate: function() {
					for (var t = arguments.length, e = Array(t), i = 0; t > i; i++) e[i] = arguments[i];
					return Nr.relate.apply(Nr, [this].concat(e))
				},
				getCentroid: function() {
					if (this.isEmpty()) return this.factory.createPoint();
					var t = ie.getCentroid(this);
					return this.createPointFromInternalCoord(t, this)
				},
				getInteriorPoint: function() {
					if (this.isEmpty()) return this.factory.createPoint();
					var t = null,
						e = this.getDimension();
					return t = 0 === e ? new Ki(this).getInteriorPoint() : 1 === e ? new Zi(this).getInteriorPoint() : new qi(this).getInteriorPoint(), this.createPointFromInternalCoord(t, this)
				},
				symDifference: function(t) {
					if (this.isEmpty() || t.isEmpty()) {
						if (this.isEmpty() && t.isEmpty()) return zi.createEmptyResult(zi.SYMDIFFERENCE, this, t, this.factory);
						if (this.isEmpty()) return t.copy();
						if (t.isEmpty()) return this.copy()
					}
					return this.checkNotGeometryCollection(this), this.checkNotGeometryCollection(t), Wi.overlayOp(this, t, zi.SYMDIFFERENCE)
				},
				createPointFromInternalCoord: function(t, e) {
					return e.getPrecisionModel().makePrecise(t), e.getFactory().createPoint(t)
				},
				toText: function() {
					return (new Ht).write(this)
				},
				toString: function() {
					this.toText()
				},
				contains: function(t) {
					return Nr.contains(this, t)
				},
				difference: function(t) {
					return this.isEmpty() ? zi.createEmptyResult(zi.DIFFERENCE, this, t, this.factory) : t.isEmpty() ? this.copy() : (this.checkNotGeometryCollection(this), this.checkNotGeometryCollection(t), Wi.overlayOp(this, t, zi.DIFFERENCE))
				},
				isSimple: function() {
					return new In(this).isSimple()
				},
				isWithinDistance: function(t, e) {
					return !(this.getEnvelopeInternal().distance(t.getEnvelopeInternal()) > e) && Jn.isWithinDistance(this, t, e)
				},
				distance: function(t) {
					return Jn.distance(this, t)
				},
				isEquivalentClass: function(t) {
					return this.getClass() === t.getClass()
				}
			}), t.version = "1.1.2 (248dab8)", t.algorithm = Qo, t.densify = $o, t.dissolve = ts, t.geom = Ko, t.index = ns, t.io = as, t.noding = ls, t.operation = ms, t.precision = vs, t.simplify = ys, t.triangulate = _s
		}(e)
	}, function(t, e, i) {
		"use strict";
		i.r(e);
		var n = i(0),
			r = i(10),
			o = i(43),
			s = i(37),
			a = i(16),
			l = i(3),
			u = i(5),
			h = i(53),
			c = i(8),
			d = function(t) {
				var e = t || {};
				this.ulElement_ = document.createElement("UL"), this.logoLi_ = document.createElement("LI"), this.ulElement_.appendChild(this.logoLi_), this.logoLi_.style.display = "none", this.collapsed_ = void 0 === e.collapsed || e.collapsed, this.collapsible_ = void 0 === e.collapsible || e.collapsible, this.collapsible_ || (this.collapsed_ = !1);
				var i = void 0 !== e.className ? e.className : "ol-attribution",
					n = void 0 !== e.tipLabel ? e.tipLabel : "Attributions",
					r = void 0 !== e.collapseLabel ? e.collapseLabel : "»";
				"string" == typeof r ? (this.collapseLabel_ = document.createElement("span"), this.collapseLabel_.textContent = r) : this.collapseLabel_ = r;
				var a = void 0 !== e.label ? e.label : "i";
				"string" == typeof a ? (this.label_ = document.createElement("span"), this.label_.textContent = a) : this.label_ = a;
				var h = this.collapsible_ && !this.collapsed_ ? this.collapseLabel_ : this.label_,
					c = document.createElement("button");
				c.setAttribute("type", "button"), c.title = n, c.appendChild(h), l.a.listen(c, u.a.CLICK, this.handleClick_, this);
				var f = i + " " + s.a.CLASS_UNSELECTABLE + " " + s.a.CLASS_CONTROL + (this.collapsed_ && this.collapsible_ ? " ol-collapsed" : "") + (this.collapsible_ ? "" : " ol-uncollapsible"),
					A = document.createElement("div");
				A.className = f, A.appendChild(this.ulElement_), A.appendChild(c);
				var p = e.render ? e.render : d.render;
				o.
			default.call(this, {
					element: A,
					render: p,
					target: e.target
				}), this.renderedAttributions_ = [], this.renderedVisible_ = !0, this.logoElements_ = {}
			};
		n.
	default.inherits(d, o.
	default), d.prototype.getSourceAttributions_ = function(t) {
			for (var e = {}, i = [], n = t.layerStatesArray, r = t.viewState.resolution, o = 0, s = n.length; o < s; ++o) {
				var a = n[o];
				if (h.a.visibleAtResolution(a, r)) {
					var l = a.layer.getSource();
					if (l) {
						var u = l.getAttributions2();
						if (u) {
							var c = u(t);
							if (c) if (Array.isArray(c)) for (var d = 0, f = c.length; d < f; ++d) c[d] in e || (i.push(c[d]), e[c[d]] = !0);
							else c in e || (i.push(c), e[c] = !0)
						}
					}
				}
			}
			return i
		}, d.render = function(t) {
			this.updateElement_(t.frameState)
		}, d.prototype.updateElement_ = function(t) {
			if (t) {
				var e = this.getSourceAttributions_(t);
				if (!r.a.equals(e, this.renderedAttributions_)) {
					for (; this.ulElement_.lastChild !== this.logoLi_;) this.ulElement_.removeChild(this.ulElement_.lastChild);
					for (var i = 0, n = e.length; i < n; ++i) {
						var o = document.createElement("LI");
						o.innerHTML = e[i], this.ulElement_.appendChild(o)
					}
					0 === e.length && this.renderedAttributions_.length > 0 ? this.element.classList.add("ol-logo-only") : 0 === this.renderedAttributions_.length && e.length > 0 && this.element.classList.remove("ol-logo-only");
					var s = e.length > 0 || !c.a.isEmpty(t.logos);
					this.renderedVisible_ != s && (this.element.style.display = s ? "" : "none", this.renderedVisible_ = s), this.renderedAttributions_ = e, this.insertLogos_(t)
				}
			} else this.renderedVisible_ && (this.element.style.display = "none", this.renderedVisible_ = !1)
		}, d.prototype.insertLogos_ = function(t) {
			var e, i, n, r, o = t.logos,
				s = this.logoElements_;
			for (e in s) e in o || (a.a.removeNode(s[e]), delete s[e]);
			for (r in o) {
				var l = o[r];
				l instanceof HTMLElement && (this.logoLi_.appendChild(l), s[r] = l), r in s || ((i = new Image).src = r, "" === l ? n = i : ((n = document.createElement("a")).href = l, n.appendChild(i)), this.logoLi_.appendChild(n), s[r] = n)
			}
			this.logoLi_.style.display = c.a.isEmpty(o) ? "none" : ""
		}, d.prototype.handleClick_ = function(t) {
			t.preventDefault(), this.handleToggle_()
		}, d.prototype.handleToggle_ = function() {
			this.element.classList.toggle("ol-collapsed"), this.collapsed_ ? a.a.replaceNode(this.collapseLabel_, this.label_) : a.a.replaceNode(this.label_, this.collapseLabel_), this.collapsed_ = !this.collapsed_
		}, d.prototype.getCollapsible = function() {
			return this.collapsible_
		}, d.prototype.setCollapsible = function(t) {
			this.collapsible_ !== t && (this.collapsible_ = t, this.element.classList.toggle("ol-uncollapsible"), !t && this.collapsed_ && this.handleToggle_())
		}, d.prototype.setCollapsed = function(t) {
			this.collapsible_ && this.collapsed_ !== t && this.handleToggle_()
		}, d.prototype.getCollapsed = function() {
			return this.collapsed_
		}, e.
	default = d
	}, function(t, e, i) {
		"use strict";
		i.r(e);
		var n = i(0),
			r = i(3),
			o = i(5),
			s = i(43),
			a = i(37),
			l = i(39),
			u = function(t) {
				var e = t || {},
					i = void 0 !== e.className ? e.className : "ol-zoom",
					n = void 0 !== e.delta ? e.delta : 1,
					l = void 0 !== e.zoomInLabel ? e.zoomInLabel : "+",
					h = void 0 !== e.zoomOutLabel ? e.zoomOutLabel : "−",
					c = void 0 !== e.zoomInTipLabel ? e.zoomInTipLabel : "Zoom in",
					d = void 0 !== e.zoomOutTipLabel ? e.zoomOutTipLabel : "Zoom out",
					f = document.createElement("button");
				f.className = i + "-in", f.setAttribute("type", "button"), f.title = c, f.appendChild("string" == typeof l ? document.createTextNode(l) : l), r.a.listen(f, o.a.CLICK, u.prototype.handleClick_.bind(this, n));
				var A = document.createElement("button");
				A.className = i + "-out", A.setAttribute("type", "button"), A.title = d, A.appendChild("string" == typeof h ? document.createTextNode(h) : h), r.a.listen(A, o.a.CLICK, u.prototype.handleClick_.bind(this, -n));
				var p = i + " " + a.a.CLASS_UNSELECTABLE + " " + a.a.CLASS_CONTROL,
					g = document.createElement("div");
				g.className = p, g.appendChild(f), g.appendChild(A), s.
			default.call(this, {
					element: g,
					target: e.target
				}), this.duration_ = void 0 !== e.duration ? e.duration:
				250
			};
		n.
	default.inherits(u, s.
	default), u.prototype.handleClick_ = function(t, e) {
			e.preventDefault(), this.zoomByDelta_(t)
		}, u.prototype.zoomByDelta_ = function(t) {
			var e = this.getMap().getView();
			if (e) {
				var i = e.getResolution();
				if (i) {
					var n = e.constrainResolution(i, t);
					this.duration_ > 0 ? (e.getAnimating() && e.cancelAnimations(), e.animate({
						resolution: n,
						duration: this.duration_,
						easing: l.
					default.easeOut
					})) : e.setResolution(n)
				}
			}
		}, e.
	default = u
	}, function(t, e, i) {
		"use strict";
		i.r(e);
		var n = i(0),
			r = i(39),
			o = i(28),
			s = i(1),
			a = i(140),
			l = function(t) {
				var e = t || {},
					i = e.condition ? e.condition : o.
				default.shiftKeyOnly;
				this.duration_ = void 0 !== e.duration ? e.duration:
				200, this.out_ = void 0 !== e.out && e.out, a.
			default.call(this, {
					condition: i,
					className: e.className || "ol-dragzoom"
				})
			};
		n.
	default.inherits(l, a.
	default), l.prototype.onBoxEnd = function() {
			var t = this.getMap(),
				e = t.getView(),
				i = t.getSize(),
				n = this.getGeometry().getExtent();
			if (this.out_) {
				var o = e.calculateExtent(i),
					a = s.
				default.createOrUpdateFromCoordinates([t.getPixelFromCoordinate(s.
				default.getBottomLeft(n)), t.getPixelFromCoordinate(s.
				default.getTopRight(n))]),
					l = e.getResolutionForExtent(a, i);
				s.
			default.scaleFromCenter(o, 1 / l), n = o
			}
			var u = e.constrainResolution(e.getResolutionForExtent(n, i)),
				h = s.
			default.getCenter(n);
			h = e.constrainCenter(h), e.animate({
				resolution: u,
				center: h,
				duration: this.duration_,
				easing: r.
			default.easeOut
			})
		}, e.
	default = l
	}, function(t, e, i) {
		"use strict";
		i.r(e);
		var n = i(0),
			r = i(10),
			o = i(9),
			s = i(120),
			a = function(t) {
				this.matrixIds_ = t.matrixIds, s.a.call(this, {
					extent: t.extent,
					origin: t.origin,
					origins: t.origins,
					resolutions: t.resolutions,
					tileSize: t.tileSize,
					tileSizes: t.tileSizes,
					sizes: t.sizes
				})
			};
		n.
	default.inherits(a, s.a), a.prototype.getMatrixId = function(t) {
			return this.matrixIds_[t]
		}, a.prototype.getMatrixIds = function() {
			return this.matrixIds_
		}, a.createFromCapabilitiesMatrixSet = function(t, e, i) {
			var n = [],
				s = [],
				l = [],
				u = [],
				h = [],
				c = void 0 !== i ? i : [],
				d = t.SupportedCRS,
				f = o.
			default.get(d.replace(/urn:ogc:def:crs:(\w+):(.*:)?(\w+)$/, "$1:$3")) || o.
			default.get(d),
				A = f.getMetersPerUnit(),
				p = "ne" == f.getAxisOrientation().substr(0, 2);
			return t.TileMatrix.sort((function(t, e) {
				return e.ScaleDenominator - t.ScaleDenominator
			})), t.TileMatrix.forEach((function(t, e, i) {
				if (!(c.length > 0) || r.a.find(c, (function(e, i, n) {
					return t.Identifier == e.TileMatrix
				}))) {
					s.push(t.Identifier);
					var o = 28e-5 * t.ScaleDenominator / A,
						a = t.TileWidth,
						d = t.TileHeight;
					p ? l.push([t.TopLeftCorner[1], t.TopLeftCorner[0]]) : l.push(t.TopLeftCorner), n.push(o), u.push(a == d ? a : [a, d]), h.push([t.MatrixWidth, -t.MatrixHeight])
				}
			})), new a({
				extent: e,
				origins: l,
				resolutions: n,
				matrixIds: s,
				tileSizes: u,
				sizes: h
			})
		}, e.
	default = a
	}, function(t, e, i) {
		"use strict";
		i.r(e);
		var n = {
			all: function(t, e) {
				return [[-1 / 0, -1 / 0, 1 / 0, 1 / 0]]
			},
			bbox: function(t, e) {
				return [t]
			},
			tile: function(t) {
				return function(e, i) {
					var n = t.getZForResolution(i),
						r = t.getTileRangeForExtentAndZ(e, n),
						o = [],
						s = [n, 0, 0];
					for (s[1] = r.minX; s[1] <= r.maxX; ++s[1]) for (s[2] = r.minY; s[2] <= r.maxY; ++s[2]) o.push(t.getTileCoordExtent(s));
					return o
				}
			}
		};
		e.
	default = n
	}, function(t, e, i) {
		"use strict";
		i.r(e);
		var n = i(0),
			r = i(3),
			o = i(5),
			s = i(1),
			a = i(60),
			l = i(4),
			u = i(8),
			h = function(t) {
				a.a.call(this), this.geometries_ = t || null, this.listenGeometriesChange_()
			};
		n.
	default.inherits(h, a.a), h.cloneGeometries_ = function(t) {
			var e, i, n = [];
			for (e = 0, i = t.length; e < i; ++e) n.push(t[e].clone());
			return n
		}, h.prototype.unlistenGeometriesChange_ = function() {
			var t, e;
			if (this.geometries_) for (t = 0, e = this.geometries_.length; t < e; ++t) r.a.unlisten(this.geometries_[t], o.a.CHANGE, this.changed, this)
		}, h.prototype.listenGeometriesChange_ = function() {
			var t, e;
			if (this.geometries_) for (t = 0, e = this.geometries_.length; t < e; ++t) r.a.listen(this.geometries_[t], o.a.CHANGE, this.changed, this)
		}, h.prototype.clone = function() {
			var t = new h(null);
			return t.setGeometries(this.geometries_), t
		}, h.prototype.closestPointXY = function(t, e, i, n) {
			if (n < s.
		default.closestSquaredDistanceXY(this.getExtent(), t, e)) return n;
			var r, o, a = this.geometries_;
			for (r = 0, o = a.length; r < o; ++r) n = a[r].closestPointXY(t, e, i, n);
			return n
		}, h.prototype.containsXY = function(t, e) {
			var i, n, r = this.geometries_;
			for (i = 0, n = r.length; i < n; ++i) if (r[i].containsXY(t, e)) return !0;
			return !1
		}, h.prototype.computeExtent = function(t) {
			s.
		default.createOrUpdateEmpty(t);
			for (var e = this.geometries_, i = 0, n = e.length; i < n; ++i) s.
		default.extend(t, e[i].getExtent());
			return t
		}, h.prototype.getGeometries = function() {
			return h.cloneGeometries_(this.geometries_)
		}, h.prototype.getGeometriesArray = function() {
			return this.geometries_
		}, h.prototype.getSimplifiedGeometry = function(t) {
			if (this.simplifiedGeometryRevision != this.getRevision() && (u.a.clear(this.simplifiedGeometryCache), this.simplifiedGeometryMaxMinSquaredTolerance = 0, this.simplifiedGeometryRevision = this.getRevision()), t < 0 || 0 !== this.simplifiedGeometryMaxMinSquaredTolerance && t < this.simplifiedGeometryMaxMinSquaredTolerance) return this;
			var e = t.toString();
			if (this.simplifiedGeometryCache.hasOwnProperty(e)) return this.simplifiedGeometryCache[e];
			var i, n, r = [],
				o = this.geometries_,
				s = !1;
			for (i = 0, n = o.length; i < n; ++i) {
				var a = o[i],
					l = a.getSimplifiedGeometry(t);
				r.push(l), l !== a && (s = !0)
			}
			if (s) {
				var c = new h(null);
				return c.setGeometriesArray(r), this.simplifiedGeometryCache[e] = c, c
			}
			return this.simplifiedGeometryMaxMinSquaredTolerance = t, this
		}, h.prototype.getType = function() {
			return l.a.GEOMETRY_COLLECTION
		}, h.prototype.intersectsExtent = function(t) {
			var e, i, n = this.geometries_;
			for (e = 0, i = n.length; e < i; ++e) if (n[e].intersectsExtent(t)) return !0;
			return !1
		}, h.prototype.isEmpty = function() {
			return 0 === this.geometries_.length
		}, h.prototype.rotate = function(t, e) {
			for (var i = this.geometries_, n = 0, r = i.length; n < r; ++n) i[n].rotate(t, e);
			this.changed()
		}, h.prototype.scale = function(t, e, i) {
			var n = i;
			n || (n = s.
		default.getCenter(this.getExtent()));
			for (var r = this.geometries_, o = 0, a = r.length; o < a; ++o) r[o].scale(t, e, n);
			this.changed()
		}, h.prototype.setGeometries = function(t) {
			this.setGeometriesArray(h.cloneGeometries_(t))
		}, h.prototype.setGeometriesArray = function(t) {
			this.unlistenGeometriesChange_(), this.geometries_ = t, this.listenGeometriesChange_(), this.changed()
		}, h.prototype.applyTransform = function(t) {
			var e, i, n = this.geometries_;
			for (e = 0, i = n.length; e < i; ++e) n[e].applyTransform(t);
			this.changed()
		}, h.prototype.translate = function(t, e) {
			var i, n, r = this.geometries_;
			for (i = 0, n = r.length; i < n; ++i) r[i].translate(t, e);
			this.changed()
		}, h.prototype.disposeInternal = function() {
			this.unlistenGeometriesChange_(), a.a.prototype.disposeInternal.call(this)
		}, e.
	default = h
	}, function(t, e, i) {
		"use strict";
		i.r(e);
		var n = i(0),
			r = i(11),
			o = {
				createExtent: function(t) {
					return function(e) {
						return e ? [r.a.clamp(e[0], t[0], t[2]), r.a.clamp(e[1], t[1], t[3])] : void 0
					}
				},
				none: function(t) {
					return t
				}
			},
			s = o,
			a = i(14),
			l = i(10),
			u = {
				createSnapToResolutions: function(t) {
					return function(e, i, n) {
						if (void 0 !== e) {
							var o = l.a.linearFindNearest(t, e, n);
							o = r.a.clamp(o + i, 0, t.length - 1);
							var s = Math.floor(o);
							if (o != s && s < t.length - 1) {
								var a = t[s] / t[s + 1];
								return t[s] / Math.pow(a, o - s)
							}
							return t[s]
						}
					}
				},
				createSnapToPower: function(t, e, i) {
					return function(n, r, o) {
						if (void 0 !== n) {
							var s = -o / 2 + .5,
								a = Math.floor(Math.log(e / n) / Math.log(t) + s),
								l = Math.max(a + r, 0);
							return void 0 !== i && (l = Math.min(l, i)), e / Math.pow(t, l)
						}
					}
				}
			},
			h = u,
			c = i(90),
			d = i(22),
			f = i(54),
			A = i(15),
			p = i(19),
			g = i(39),
			m = i(1),
			v = i(4),
			y = i(31),
			_ = i(40),
			E = i(8),
			x = i(9),
			C = i(47),
			I = function(t) {
				a.a.call(this);
				var e = E.a.assign({}, t);
				this.hints_ = [0, 0], this.animations_ = [], this.updateAnimationKey_, this.updateAnimations_ = this.updateAnimations_.bind(this), this.projection_ = x.
			default.createProjection(e.projection, "EPSG:3857"), this.applyOptions_(e)
			};
		n.
	default.inherits(I, a.a), I.prototype.applyOptions_ = function(t) {
			var e = {};
			e[f.a.CENTER] = void 0 !== t.center ? t.center : null;
			var i = I.createResolutionConstraint_(t);
			this.maxResolution_ = i.maxResolution, this.minResolution_ = i.minResolution, this.zoomFactor_ = i.zoomFactor, this.resolutions_ = t.resolutions, this.minZoom_ = i.minZoom;
			var n = I.createCenterConstraint_(t),
				o = i.constraint,
				s = I.createRotationConstraint_(t);
			this.constraints_ = {
				center: n,
				resolution: o,
				rotation: s
			}, void 0 !== t.resolution ? e[f.a.RESOLUTION] = t.resolution : void 0 !== t.zoom && (e[f.a.RESOLUTION] = this.constrainResolution(this.maxResolution_, t.zoom - this.minZoom_), this.resolutions_ && (e[f.a.RESOLUTION] = r.a.clamp(Number(this.getResolution() || e[f.a.RESOLUTION]), this.minResolution_, this.maxResolution_))), e[f.a.ROTATION] = void 0 !== t.rotation ? t.rotation : 0, this.setProperties(e), this.options_ = t
		}, I.prototype.getUpdatedOptions_ = function(t) {
			var e = E.a.assign({}, this.options_);
			return void 0 !== e.resolution ? e.resolution = this.getResolution() : e.zoom = this.getZoom(), e.center = this.getCenter(), e.rotation = this.getRotation(), E.a.assign({}, e, t)
		}, I.prototype.animate = function(t) {
			var e, i = arguments.length;
			if (i > 1 && "function" == typeof arguments[i - 1] && (e = arguments[i - 1], --i), !this.isDef()) {
				var n = arguments[i - 1];
				return n.center && this.setCenter(n.center), void 0 !== n.zoom && this.setZoom(n.zoom), void 0 !== n.rotation && this.setRotation(n.rotation), void(e && e(!0))
			}
			for (var o = Date.now(), s = this.getCenter().slice(), a = this.getResolution(), l = this.getRotation(), u = [], h = 0; h < i; ++h) {
				var c = arguments[h],
					f = {
						start: o,
						complete: !1,
						anchor: c.anchor,
						duration: void 0 !== c.duration ? c.duration : 1e3,
						easing: c.easing || g.
					default.inAndOut
					};
				if (c.center && (f.sourceCenter = s, f.targetCenter = c.center, s = f.targetCenter), void 0 !== c.zoom ? (f.sourceResolution = a, f.targetResolution = this.constrainResolution(this.maxResolution_, c.zoom - this.minZoom_, 0), a = f.targetResolution) : c.resolution && (f.sourceResolution = a, f.targetResolution = c.resolution, a = f.targetResolution), void 0 !== c.rotation) {
					f.sourceRotation = l;
					var A = r.a.modulo(c.rotation - l + Math.PI, 2 * Math.PI) - Math.PI;
					f.targetRotation = l + A, l = f.targetRotation
				}
				f.callback = e, I.isNoopAnimation(f) ? f.complete = !0 : o += f.duration, u.push(f)
			}
			this.animations_.push(u), this.setHint(d.a.ANIMATING, 1), this.updateAnimations_()
		}, I.prototype.getAnimating = function() {
			return this.hints_[d.a.ANIMATING] > 0
		}, I.prototype.getInteracting = function() {
			return this.hints_[d.a.INTERACTING] > 0
		}, I.prototype.cancelAnimations = function() {
			this.setHint(d.a.ANIMATING, -this.hints_[d.a.ANIMATING]);
			for (var t = 0, e = this.animations_.length; t < e; ++t) {
				var i = this.animations_[t];
				i[0].callback && i[0].callback(!1)
			}
			this.animations_.length = 0
		}, I.prototype.updateAnimations_ = function() {
			if (void 0 !== this.updateAnimationKey_ && (cancelAnimationFrame(this.updateAnimationKey_), this.updateAnimationKey_ = void 0), this.getAnimating()) {
				for (var t = Date.now(), e = !1, i = this.animations_.length - 1; i >= 0; --i) {
					for (var n = this.animations_[i], o = !0, s = 0, a = n.length; s < a; ++s) {
						var l = n[s];
						if (!l.complete) {
							var u = t - l.start,
								h = l.duration > 0 ? u / l.duration : 1;
							h >= 1 ? (l.complete = !0, h = 1) : o = !1;
							var c = l.easing(h);
							if (l.sourceCenter) {
								var A = l.sourceCenter[0],
									p = l.sourceCenter[1],
									g = A + c * (l.targetCenter[0] - A),
									m = p + c * (l.targetCenter[1] - p);
								this.set(f.a.CENTER, [g, m])
							}
							if (l.sourceResolution && l.targetResolution) {
								var v = 1 === c ? l.targetResolution : l.sourceResolution + c * (l.targetResolution - l.sourceResolution);
								l.anchor && this.set(f.a.CENTER, this.calculateCenterZoom(v, l.anchor)), this.set(f.a.RESOLUTION, v)
							}
							if (void 0 !== l.sourceRotation && void 0 !== l.targetRotation) {
								var y = 1 === c ? r.a.modulo(l.targetRotation + Math.PI, 2 * Math.PI) - Math.PI : l.sourceRotation + c * (l.targetRotation - l.sourceRotation);
								l.anchor && this.set(f.a.CENTER, this.calculateCenterRotate(y, l.anchor)), this.set(f.a.ROTATION, y)
							}
							if (e = !0, !l.complete) break
						}
					}
					if (o) {
						this.animations_[i] = null, this.setHint(d.a.ANIMATING, -1);
						var _ = n[0].callback;
						_ && _(!0)
					}
				}
				this.animations_ = this.animations_.filter(Boolean), e && void 0 === this.updateAnimationKey_ && (this.updateAnimationKey_ = requestAnimationFrame(this.updateAnimations_))
			}
		}, I.prototype.calculateCenterRotate = function(t, e) {
			var i, n = this.getCenter();
			return void 0 !== n && (i = [n[0] - e[0], n[1] - e[1]], p.
		default.rotate(i, t - this.getRotation()), p.
		default.add(i, e)), i
		}, I.prototype.calculateCenterZoom = function(t, e) {
			var i, n = this.getCenter(),
				r = this.getResolution();
			void 0 !== n && void 0 !== r && (i = [e[0] - t * (e[0] - n[0]) / r, e[1] - t * (e[1] - n[1]) / r]);
			return i
		}, I.prototype.getSizeFromViewport_ = function() {
			var t = [100, 100],
				e = '.ol-viewport[data-view="' + n.
			default.getUid(this) + '"]',
				i = document.querySelector(e);
			if (i) {
				var r = getComputedStyle(i);
				t[0] = parseInt(r.width, 10), t[1] = parseInt(r.height, 10)
			}
			return t
		}, I.prototype.constrainCenter = function(t) {
			return this.constraints_.center(t)
		}, I.prototype.constrainResolution = function(t, e, i) {
			var n = e || 0,
				r = i || 0;
			return this.constraints_.resolution(t, n, r)
		}, I.prototype.constrainRotation = function(t, e) {
			var i = e || 0;
			return this.constraints_.rotation(t, i)
		}, I.prototype.getCenter = function() {
			return this.get(f.a.CENTER)
		}, I.prototype.getConstraints = function() {
			return this.constraints_
		}, I.prototype.getHints = function(t) {
			return void 0 !== t ? (t[0] = this.hints_[0], t[1] = this.hints_[1], t) : this.hints_.slice()
		}, I.prototype.calculateExtent = function(t) {
			var e = t || this.getSizeFromViewport_(),
				i = this.getCenter();
			A.a.assert(i, 1);
			var n = this.getResolution();
			A.a.assert(void 0 !== n, 2);
			var r = this.getRotation();
			return A.a.assert(void 0 !== r, 3), m.
		default.getForViewAndSize(i, n, r, e)
		}, I.prototype.getMaxResolution = function() {
			return this.maxResolution_
		}, I.prototype.getMinResolution = function() {
			return this.minResolution_
		}, I.prototype.getMaxZoom = function() {
			return this.getZoomForResolution(this.minResolution_)
		}, I.prototype.setMaxZoom = function(t) {
			this.applyOptions_(this.getUpdatedOptions_({
				maxZoom: t
			}))
		}, I.prototype.getMinZoom = function() {
			return this.getZoomForResolution(this.maxResolution_)
		}, I.prototype.setMinZoom = function(t) {
			this.applyOptions_(this.getUpdatedOptions_({
				minZoom: t
			}))
		}, I.prototype.getProjection = function() {
			return this.projection_
		}, I.prototype.getResolution = function() {
			return this.get(f.a.RESOLUTION)
		}, I.prototype.getResolutions = function() {
			return this.resolutions_
		}, I.prototype.getResolutionForExtent = function(t, e) {
			var i = e || this.getSizeFromViewport_(),
				n = m.
			default.getWidth(t) / i[0],
				r = m.
			default.getHeight(t) / i[1];
			return Math.max(n, r)
		}, I.prototype.getResolutionForValueFunction = function(t) {
			var e = t || 2,
				i = this.maxResolution_,
				n = this.minResolution_,
				r = Math.log(i / n) / Math.log(e);
			return function(t) {
				return i / Math.pow(e, t * r)
			}
		}, I.prototype.getRotation = function() {
			return this.get(f.a.ROTATION)
		}, I.prototype.getValueForResolutionFunction = function(t) {
			var e = t || 2,
				i = this.maxResolution_,
				n = this.minResolution_,
				r = Math.log(i / n) / Math.log(e);
			return function(t) {
				return Math.log(i / t) / Math.log(e) / r
			}
		}, I.prototype.getState = function() {
			var t = this.getCenter(),
				e = this.getProjection(),
				i = this.getResolution(),
				n = this.getRotation();
			return {
				center: t.slice(),
				projection: void 0 !== e ? e : null,
				resolution: i,
				rotation: n,
				zoom: this.getZoom()
			}
		}, I.prototype.getZoom = function() {
			var t, e = this.getResolution();
			return void 0 !== e && (t = this.getZoomForResolution(e)), t
		}, I.prototype.getZoomForResolution = function(t) {
			var e, i, n = this.minZoom_ || 0;
			if (this.resolutions_) {
				var r = l.a.linearFindNearest(this.resolutions_, t, 1);
				n = r, e = this.resolutions_[r], i = r == this.resolutions_.length - 1 ? 2 : e / this.resolutions_[r + 1]
			} else e = this.maxResolution_, i = this.zoomFactor_;
			return n + Math.log(e / t) / Math.log(i)
		}, I.prototype.getResolutionForZoom = function(t) {
			return this.constrainResolution(this.maxResolution_, t - this.minZoom_, 0)
		}, I.prototype.fit = function(t, e) {
			var i, r = e || {},
				o = r.size;
			o || (o = this.getSizeFromViewport_()), t instanceof _.a ? t.getType() === v.a.CIRCLE ? (t = t.getExtent(), (i = y.
		default.fromExtent(t)).rotate(this.getRotation(), m.
		default.getCenter(t))) : i = t : (A.a.assert(Array.isArray(t), 24), A.a.assert(!m.
		default.isEmpty(t), 25), i = y.
		default.fromExtent(t));
			var s, a = void 0 !== r.padding ? r.padding : [0, 0, 0, 0],
				l = void 0 === r.constrainResolution || r.constrainResolution,
				u = void 0 !== r.nearest && r.nearest;
			s = void 0 !== r.minResolution ? r.minResolution : void 0 !== r.maxZoom ? this.constrainResolution(this.maxResolution_, r.maxZoom - this.minZoom_, 0) : 0;
			for (var h = i.getFlatCoordinates(), c = this.getRotation(), d = Math.cos(-c), f = Math.sin(-c), p = 1 / 0, g = 1 / 0, E = -1 / 0, x = -1 / 0, C = i.getStride(), I = 0, S = h.length; I < S; I += C) {
				var T = h[I] * d - h[I + 1] * f,
					R = h[I] * f + h[I + 1] * d;
				p = Math.min(p, T), g = Math.min(g, R), E = Math.max(E, T), x = Math.max(x, R)
			}
			var w = this.getResolutionForExtent([p, g, E, x], [o[0] - a[1] - a[3], o[1] - a[0] - a[2]]);
			if (w = isNaN(w) ? s : Math.max(w, s), l) {
				var L = this.constrainResolution(w, 0, 0);
				!u && L < w && (L = this.constrainResolution(L, -1, 0)), w = L
			}
			f = -f;
			var N = (p + E) / 2,
				P = (g + x) / 2,
				O = [(N += (a[1] - a[3]) / 2 * w) * d - (P += (a[0] - a[2]) / 2 * w) * f, P * d + N * f],
				M = r.callback ? r.callback : n.
			default.nullFunction;
			void 0 !== r.duration ? this.animate({
				resolution: w,
				center: O,
				duration: r.duration,
				easing: r.easing
			}, M):
			(this.setResolution(w), this.setCenter(O), setTimeout(M.bind(void 0, !0), 0))
		}, I.prototype.centerOn = function(t, e, i) {
			var n = this.getRotation(),
				r = Math.cos(-n),
				o = Math.sin(-n),
				s = t[0] * r - t[1] * o,
				a = t[1] * r + t[0] * o,
				l = this.getResolution(),
				u = (s += (e[0] / 2 - i[0]) * l) * r - (a += (i[1] - e[1] / 2) * l) * (o = -o),
				h = a * r + s * o;
			this.setCenter([u, h])
		}, I.prototype.isDef = function() {
			return !!this.getCenter() && void 0 !== this.getResolution()
		}, I.prototype.rotate = function(t, e) {
			if (void 0 !== e) {
				var i = this.calculateCenterRotate(t, e);
				this.setCenter(i)
			}
			this.setRotation(t)
		}, I.prototype.setCenter = function(t) {
			this.set(f.a.CENTER, t), this.getAnimating() && this.cancelAnimations()
		}, I.prototype.setHint = function(t, e) {
			return this.hints_[t] += e, this.changed(), this.hints_[t]
		}, I.prototype.setResolution = function(t) {
			this.set(f.a.RESOLUTION, t), this.getAnimating() && this.cancelAnimations()
		}, I.prototype.setRotation = function(t) {
			this.set(f.a.ROTATION, t), this.getAnimating() && this.cancelAnimations()
		}, I.prototype.setZoom = function(t) {
			this.setResolution(this.getResolutionForZoom(t))
		}, I.createCenterConstraint_ = function(t) {
			return void 0 !== t.extent ? s.createExtent(t.extent) : s.none
		}, I.createResolutionConstraint_ = function(t) {
			var e, i, r, o = void 0 !== t.minZoom ? t.minZoom : n.
		default.DEFAULT_MIN_ZOOM,
				s = void 0 !== t.maxZoom ? t.maxZoom:
				28,
				a = void 0 !== t.zoomFactor ? t.zoomFactor : 2;
			if (void 0 !== t.resolutions) {
				var l = t.resolutions;
				i = l[o], r = void 0 !== l[s] ? l[s] : l[l.length - 1], e = h.createSnapToResolutions(l)
			} else {
				var u = x.
			default.createProjection(t.projection, "EPSG:3857"),
					c = u.getExtent(),
					d = (c ? Math.max(m.
				default.getWidth(c), m.
				default.getHeight(c)) : 360 * x.
				default.METERS_PER_UNIT[C.a.DEGREES] / u.getMetersPerUnit()) / n.
				default.DEFAULT_TILE_SIZE / Math.pow(2, n.
				default.DEFAULT_MIN_ZOOM),
					f = d / Math.pow(2, 28 - n.
				default.DEFAULT_MIN_ZOOM);
				void 0 !== (i = t.maxResolution) ? o = 0:
				i = d / Math.pow(a, o), void 0 === (r = t.minResolution) && (r = void 0 !== t.maxZoom ? void 0 !== t.maxResolution ? i / Math.pow(a, s) : d / Math.pow(a, s) : f), s = o + Math.floor(Math.log(i / r) / Math.log(a)), r = i / Math.pow(a, s - o), e = h.createSnapToPower(a, i, s - o)
			}
			return {
				constraint: e,
				maxResolution: i,
				minResolution: r,
				minZoom: o,
				zoomFactor: a
			}
		}, I.createRotationConstraint_ = function(t) {
			if (void 0 === t.enableRotation || t.enableRotation) {
				var e = t.constrainRotation;
				return void 0 === e || !0 === e ? c.a.createSnapToZero() : !1 === e ? c.a.none : "number" == typeof e ? c.a.createSnapToN(e) : c.a.none
			}
			return c.a.disable
		}, I.isNoopAnimation = function(t) {
			return !(t.sourceCenter && t.targetCenter && !p.
		default.equals(t.sourceCenter, t.targetCenter)) && (t.sourceResolution === t.targetResolution && t.sourceRotation === t.targetRotation)
		};
		e.
	default = I
	}, function(t, e, i) {
		"use strict";
		i.r(e);
		var n = i(27),
			r = i(144),
			o = i(3),
			s = i(5),
			a = i(0),
			l = i(43),
			u = i(37),
			h = i(39),
			c = function(t) {
				var e = t || {},
					i = void 0 !== e.className ? e.className : "ol-rotate",
					n = void 0 !== e.label ? e.label : "⇧";
				this.label_ = null, "string" == typeof n ? (this.label_ = document.createElement("span"), this.label_.className = "ol-compass", this.label_.textContent = n) : (this.label_ = n, this.label_.classList.add("ol-compass"));
				var r = e.tipLabel ? e.tipLabel : "Reset rotation",
					a = document.createElement("button");
				a.className = i + "-reset", a.setAttribute("type", "button"), a.title = r, a.appendChild(this.label_), o.a.listen(a, s.a.CLICK, c.prototype.handleClick_, this);
				var h = i + " " + u.a.CLASS_UNSELECTABLE + " " + u.a.CLASS_CONTROL,
					d = document.createElement("div");
				d.className = h, d.appendChild(a);
				var f = e.render ? e.render : c.render;
				this.callResetNorth_ = e.resetNorth ? e.resetNorth : void 0, l.
			default.call(this, {
					element: d,
					render: f,
					target: e.target
				}), this.duration_ = void 0 !== e.duration ? e.duration:
				250, this.autoHide_ = void 0 === e.autoHide || e.autoHide, this.rotation_ = void 0, this.autoHide_ && this.element.classList.add(u.a.CLASS_HIDDEN)
			};
		a.
	default.inherits(c, l.
	default), c.prototype.handleClick_ = function(t) {
			t.preventDefault(), void 0 !== this.callResetNorth_ ? this.callResetNorth_() : this.resetNorth_()
		}, c.prototype.resetNorth_ = function() {
			var t = this.getMap().getView();
			t && void 0 !== t.getRotation() && (this.duration_ > 0 ? t.animate({
				rotation: 0,
				duration: this.duration_,
				easing: h.
			default.easeOut
			}) : t.setRotation(0))
		}, c.render = function(t) {
			var e = t.frameState;
			if (e) {
				var i = e.viewState.rotation;
				if (i != this.rotation_) {
					var n = "rotate(" + i + "rad)";
					if (this.autoHide_) {
						var r = this.element.classList.contains(u.a.CLASS_HIDDEN);
						r || 0 !== i ? r && 0 !== i && this.element.classList.remove(u.a.CLASS_HIDDEN) : this.element.classList.add(u.a.CLASS_HIDDEN)
					}
					this.label_.style.msTransform = n, this.label_.style.webkitTransform = n, this.label_.style.transform = n
				}
				this.rotation_ = i
			}
		};
		var d = c,
			f = i(145),
			A = {
				defaults: function(t) {
					var e = t || {},
						i = new n.
					default;
					return (void 0 === e.zoom || e.zoom) && i.push(new f.
				default (e.zoomOptions)), (void 0 === e.rotate || e.rotate) && i.push(new d(e.rotateOptions)), (void 0 === e.attribution || e.attribution) && i.push(new r.
				default (e.attributionOptions)), i
				}
			};
		e.
	default = A
	}, function(t, e, i) {
		"use strict";
		Object.defineProperty(e, "__esModule", {
			value: !0
		});
		var n = {},
			r = !1,
			o = 30;
		e.mapList = n, e.crossLength = o, e.setMapLinked = function(t) {
			var i = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 30;
			if (r = t, e.crossLength = o = i, "boolean" == typeof r && !r) for (var s in n) n[s].getCrossLayer().getSource().clear()
		}, e.getMapLinked = function() {
			return r
		}, e.getMapById = function(t) {
			if (n.hasOwnProperty(t)) return n[t]
		}, e.removeMapById = function(t) {
			n.hasOwnProperty(t) && delete n[t]
		}
	}, function(t, e, i) {
		"use strict";
		Object.defineProperty(e, "__esModule", {
			value: !0
		}), e.ServiceLayer = void 0;
		var n = a(i(161)),
			r = a(i(162)),
			o = a(i(175)),
			s = a(i(215));

		function a(t) {
			return t && t.__esModule ? t : {
			default:
				t
			}
		}
		e.ServiceLayer = function(t) {
			var e = t.getCurrMap();
			this.serviceObj = {};
			this.addWmsLayer = function(t) {
				var i = new n.
			default ({
					source: new r.
				default ({
						url: t.url,
						params: t.params
					})
				});
				t.minShowZoom && t.maxShowZoom && (i.setMinResolution(e.getView().getResolutionForZoom(t.maxShowZoom)), i.setMaxResolution(e.getView().getResolutionForZoom(t.minShowZoom))), e.addLayer(i), this.serviceObj[t.serviceId] = i
			}, this.removeWmsLayer = function(t) {
				this.serviceObj.hasOwnProperty(t) && e.removeLayer(this.serviceObj[t])
			};
			this.showImageLayer = function(t, e) {
				for (var i = 0; i < t.length; i++) this.serviceObj[t[i]].setVisible(e)
			}, this.addImageLayer = function(t) {
				var i = new o.
			default ({
					source: new s.
				default ({
						url: t.url,
						crossOrigin: "",
						projection: t.projection ? t.projection : "EPSG:4326",
						imageExtent: t.imageExtent
					})
				});
				t.minShowZoom && t.maxShowZoom && (i.setMinResolution(e.getView().getResolutionForZoom(t.maxShowZoom)), i.setMaxResolution(e.getView().getResolutionForZoom(t.minShowZoom))), e.addLayer(i), this.serviceObj[t.serviceId] = i
			}, this.removeImageLayer = function(t) {
				for (var i = 0; i < t.length; i++) e.removeLayer(this.serviceObj[t[i]])
			}
		}
	}, function(t, e, i) {
		"use strict";
		Object.defineProperty(e, "__esModule", {
			value: !0
		}), e.DataServerLayer = e.DataServerType = void 0;
		var n = y(i(0)),
			r = y(i(33)),
			o = y(i(30)),
			s = y(i(68)),
			a = y(i(100)),
			l = y(i(34)),
			u = y(i(36)),
			h = y(i(38)),
			c = y(i(86)),
			d = y(i(214)),
			f = y(i(219)),
			A = y(i(99)),
			p = y(i(148)),
			g = i(87),
			m = i(124),
			v = function(t) {
				if (t && t.__esModule) return t;
				var e = {};
				if (null != t) for (var i in t) Object.prototype.hasOwnProperty.call(t, i) && (e[i] = t[i]);
				return e.
			default = t, e
			}(i(55));

		function y(t) {
			return t && t.__esModule ? t : {
			default:
				t
			}
		}
		var _ = {
			GEOSERVER: "GEOSERVER",
			WFSSERVER: "WFSSERVER"
		},
			E = function(t) {
				g.BaseLayer.call(this, t), this.isRef = !v.isDefAndNotNull(t.isRef) || t.isRef, this.type = g.LayerType.DATASERVER;
				var e = {
					radius: 5
				};
				v.mixin(e, this.layerOptions);
				var i = new s.
			default ({
					radius: e.radius,
					fill: null,
					stroke: new u.
				default ({
						color: e.strokeColor,
						width: e.strokeWidth
					})
				}),
					n = {
						Point: new l.
					default ({
							image: i
						}),
						LineString:
						new l.
					default ({
							stroke: new u.
						default ({
								color: e.strokeColor,
								width: e.strokeWidth
							})
						}),
						MultiLineString:
						new l.
					default ({
							stroke: new u.
						default ({
								color: e.strokeColor,
								width: e.strokeWidth
							})
						}),
						MultiPoint:
						new l.
					default ({
							image: i
						}),
						MultiPolygon:
						new l.
					default ({
							stroke: new u.
						default ({
								color: e.strokeColor,
								width: e.strokeWidth
							}),
							fill:
							new h.
						default ({
								color: e.fillColor
							})
						}),
						Polygon:
						new l.
					default ({
							stroke: new u.
						default ({
								color: e.strokeColor,
								width: e.strokeWidth
							}),
							fill:
							new h.
						default ({
								color: e.fillColor
							}),
							text:
							null
						}),
						GeometryCollection:
						new l.
					default ({
							stroke: new u.
						default ({
								color: e.strokeColor,
								width: e.strokeWidth
							}),
							fill:
							new h.
						default ({
								color: e.fillColor
							}),
							image:
							new s.
						default ({
								radius: e.radius,
								fill: null,
								stroke: new u.
							default ({
									color: e.strokeColor
								})
							})
						}),
						Circle:
						new l.
					default ({
							stroke: new u.
						default ({
								color: e.strokeColor,
								width: e.strokeWidth
							}),
							fill:
							new h.
						default ({
								color: e.fillColor
							})
						})
					};
				if (this.sourceObj = null, C = this, _.WFSSERVER === t.serverType) {
					var y = this.gisMapObj.getCurrProjection();
					if (this.isRef) this.sourceObj = new o.
				default ({
						format: new d.
					default ({
							featureNS: t.featureNS,
							featureType: t.featureType,
							gmlFormat: new A.
						default ({
								featureNS: t.featureNS,
								featureType: t.featureType,
								srsName: y
							})
						}),
						// url:


						// function(e) {
						// 	return t.url + "&SERVICE=WFS&VERSION=1.1.0&REQUEST=GetFeature&TYPENAME=" + t.featureType.join(",") + "&SRS=" + y + "&BBOX=" + e.join(",")
						// },
						strategy: p.
					default.bbox
					});
					else {
						this.sourceObj = new o.
					default ({
							wrapX: !1
						});
						// var E = "";
						// E = t.isSpliceUrl ? t.url + "&SERVICE=WFS&VERSION=1.1.0&REQUEST=GetFeature&TYPENAME=" + t.featureType.join(",") + "&SRS=" + t.dataProjection:
						// t.url, m.GisUtil.loadJson(E, "text", (function(i) {
						// 	for (var n = new d.
						// default ({
						// 		featureNS: t.featureNS,
						// 		featureType: t.featureType,
						// 		gmlFormat: new A.
						// 	default ({
						// 			featureNS: t.featureNS,
						// 			featureType: t.featureType
						// 		})
						// 	}).readFeatures(i, {
						// 		dataProjection: t.dataProjection,
						// 		featureProjection: y
						// 	}), r = 0; r < n.length; r++) {
						// 		var o = n[r],
						// 			s = o.get("icon") || "/image/safePark/icon/default.png",
						// 			a = o.get("name") || "",
						// 			l = {
						// 				type: "ICON"
						// 			};
						// 		v.mixin(l, e), v.mixin(l, {
						// 			isBox: !0,
						// 			label: a,
						// 			src: s,
						// 			scale: .4,
						// 			anchor: [31, 31],
						// 			labOffsetY: 18,
						// 			labFillColor: "#D9F0FF",
						// 			labStrokeColor: "#243142",
						// 			labStrokeWidth: 2,
						// 			selFillColor: "#ACD1F3",
						// 			selLabFillColor: "#D9F0FF",
						// 			selLabStrokeColor: "#243142",
						// 			selLabStrokeWidth: 2
						// 		}), o.set("property", l)
						// 	}
						// 	C.sourceObj.addFeatures(n)
						// }))
					}
				} else _.GEOSERVER === t.serverType && ("[object String]" === Object.prototype.toString.call(t.url) ? this.sourceObj = new o.
			default ({
					url: t.url,
					format: new f.
				default ({
						defaultDataProjection: t.dataProjection,
						featureProjection: this.gisMapObj.getCurrProjection()
					})
				}):
				this.sourceObj = new o.
			default ({
					features: new f.
				default ({
						defaultDataProjection: t.url.crs ? t.url.crs.properties.name : t.dataProjection,
						featureProjection: this.gisMapObj.getCurrProjection()
					}).readFeatures(t.url)
				}));
				var x = {},
					C = this;
				this.layerVector = new r.
			default ({
					source: this.sourceObj,
					style: function(t, i) {
						var r = t.get("icon") || "",
							o = C.layerOptions.labOffsetY,
							s = t.get("display") || "",
							d = t.getGeometry().getType(),
							f = null,
							A = C.gisMapObj.getCurrMap().getView().getZoomForResolution(i),
							p = 0;
						if (s.indexOf(A) >= 0 && (p = 1), "Point" === d && r) if (1 == p) {
							var g = t.get("name") || "",
								m = t.get("property");
							f = x[m.src + m.label], f || (f = new l.
						default ({
								image: new a.
							default ({
									anchor: m.anchor,
									src: m.src,
									scale: m.scale,
									anchorXUnits: "pixels",
									anchorYUnits: "pixels"
								}),
								text:
								new c.
							default ({
									text: g,
									fill: new h.
								default ({
										color: m.labFillColor
									}),
									stroke:
									new u.
								default ({
										color: m.labStrokeColor,
										width: m.labStrokeWidth
									}),
									offsetX:
									0,
									offsetY: m.labOffsetY
								})
							}), x[m.src + m.label] = f)
						} else f = void 0;
						else {
							var v = e.fillColor;
							g = t.get("label") || "";
							f = x[d + v + g + o], f || (f = n[d].clone(), f.setFill(new h.
						default ({
								color: v
							})), f.setText(new c.
						default ({
								text: g,
								fill: new h.
							default ({
									color: e.labFillColor
								}),
								offsetX:
								0,
								offsetY: o
							})), x[d + v + g + o] = f)
						}
						return f
					}
				}), this.gisMapObj.addLayer(this)
			};
		n.
	default.inherits(E, g.BaseLayer), E.prototype.refreshLayer = function() {}, e.DataServerType = _, e.DataServerLayer = E
	}, function(t, e, i) {
		"use strict";
		t.exports = function(t) {
			var e = [];
			return e.toString = function() {
				return this.map((function(e) {
					var i = function(t, e) {
							var i = t[1] || "",
								n = t[3];
							if (!n) return i;
							if (e && "function" == typeof btoa) {
								var r = (s = n, a = btoa(unescape(encodeURIComponent(JSON.stringify(s)))), l = "sourceMappingURL=data:application/json;charset=utf-8;base64,".concat(a), "/*# ".concat(l, " */")),
									o = n.sources.map((function(t) {
										return "/*# sourceURL=".concat(n.sourceRoot).concat(t, " */")
									}));
								return [i].concat(o).concat([r]).join("\n")
							}
							var s, a, l;
							return [i].join("\n")
						}(e, t);
					return e[2] ? "@media ".concat(e[2], " {").concat(i, "}") : i
				})).join("")
			}, e.i = function(t, i) {
				"string" == typeof t && (t = [
					[null, t, ""]
				]);
				for (var n = 0; n < t.length; n++) {
					var r = [].concat(t[n]);
					i && (r[2] ? r[2] = "".concat(i, " and ").concat(r[2]) : r[2] = i), e.push(r)
				}
			}, e
		}
	}, function(t, e, i) {
		var n, r, o = {},
			s = (n = function() {
				return window && document && document.all && !window.atob
			}, function() {
				return void 0 === r && (r = n.apply(this, arguments)), r
			}),
			a = function(t) {
				return document.querySelector(t)
			},
			l = function(t) {
				var e = {};
				return function(t) {
					if ("function" == typeof t) return t();
					if (void 0 === e[t]) {
						var i = a.call(this, t);
						if (window.HTMLIFrameElement && i instanceof window.HTMLIFrameElement) try {
							i = i.contentDocument.head
						} catch (t) {
							i = null
						}
						e[t] = i
					}
					return e[t]
				}
			}(),
			u = null,
			h = 0,
			c = [],
			d = i(178);

		function f(t, e) {
			for (var i = 0; i < t.length; i++) {
				var n = t[i],
					r = o[n.id];
				if (r) {
					r.refs++;
					for (var s = 0; s < r.parts.length; s++) r.parts[s](n.parts[s]);
					for (; s < n.parts.length; s++) r.parts.push(y(n.parts[s], e))
				} else {
					var a = [];
					for (s = 0; s < n.parts.length; s++) a.push(y(n.parts[s], e));
					o[n.id] = {
						id: n.id,
						refs: 1,
						parts: a
					}
				}
			}
		}
		function A(t, e) {
			for (var i = [], n = {}, r = 0; r < t.length; r++) {
				var o = t[r],
					s = e.base ? o[0] + e.base : o[0],
					a = {
						css: o[1],
						media: o[2],
						sourceMap: o[3]
					};
				n[s] ? n[s].parts.push(a) : i.push(n[s] = {
					id: s,
					parts: [a]
				})
			}
			return i
		}
		function p(t, e) {
			var i = l(t.insertInto);
			if (!i) throw new Error("Couldn't find a style target. This probably means that the value for the 'insertInto' parameter is invalid.");
			var n = c[c.length - 1];
			if ("top" === t.insertAt) n ? n.nextSibling ? i.insertBefore(e, n.nextSibling) : i.appendChild(e) : i.insertBefore(e, i.firstChild), c.push(e);
			else if ("bottom" === t.insertAt) i.appendChild(e);
			else {
				if ("object" != typeof t.insertAt || !t.insertAt.before) throw new Error("[Style Loader]\n\n Invalid value for parameter 'insertAt' ('options.insertAt') found.\n Must be 'top', 'bottom', or Object.\n (https://github.com/webpack-contrib/style-loader#insertat)\n");
				var r = l(t.insertInto + " " + t.insertAt.before);
				i.insertBefore(e, r)
			}
		}
		function g(t) {
			if (null === t.parentNode) return !1;
			t.parentNode.removeChild(t);
			var e = c.indexOf(t);
			e >= 0 && c.splice(e, 1)
		}
		function m(t) {
			var e = document.createElement("style");
			return void 0 === t.attrs.type && (t.attrs.type = "text/css"), v(e, t.attrs), p(t, e), e
		}
		function v(t, e) {
			Object.keys(e).forEach((function(i) {
				t.setAttribute(i, e[i])
			}))
		}
		function y(t, e) {
			var i, n, r, o;
			if (e.transform && t.css) {
				if (!(o = e.transform(t.css))) return function() {};
				t.css = o
			}
			if (e.singleton) {
				var s = h++;
				i = u || (u = m(e)), n = x.bind(null, i, s, !1), r = x.bind(null, i, s, !0)
			} else t.sourceMap && "function" == typeof URL && "function" == typeof URL.createObjectURL && "function" == typeof URL.revokeObjectURL && "function" == typeof Blob && "function" == typeof btoa ? (i = function(t) {
				var e = document.createElement("link");
				return void 0 === t.attrs.type && (t.attrs.type = "text/css"), t.attrs.rel = "stylesheet", v(e, t.attrs), p(t, e), e
			}(e), n = I.bind(null, i, e), r = function() {
				g(i), i.href && URL.revokeObjectURL(i.href)
			}) : (i = m(e), n = C.bind(null, i), r = function() {
				g(i)
			});
			return n(t), function(e) {
				if (e) {
					if (e.css === t.css && e.media === t.media && e.sourceMap === t.sourceMap) return;
					n(t = e)
				} else r()
			}
		}
		t.exports = function(t, e) {
			if ("undefined" != typeof DEBUG && DEBUG && "object" != typeof document) throw new Error("The style-loader cannot be used in a non-browser environment");
			(e = e || {}).attrs = "object" == typeof e.attrs ? e.attrs : {}, e.singleton || "boolean" == typeof e.singleton || (e.singleton = s()), e.insertInto || (e.insertInto = "head"), e.insertAt || (e.insertAt = "bottom");
			var i = A(t, e);
			return f(i, e), function(t) {
				for (var n = [], r = 0; r < i.length; r++) {
					var s = i[r];
					(a = o[s.id]).refs--, n.push(a)
				}
				t && f(A(t, e), e);
				for (r = 0; r < n.length; r++) {
					var a;
					if (0 === (a = n[r]).refs) {
						for (var l = 0; l < a.parts.length; l++) a.parts[l]();
						delete o[a.id]
					}
				}
			}
		};
		var _, E = (_ = [], function(t, e) {
			return _[t] = e, _.filter(Boolean).join("\n")
		});

		function x(t, e, i, n) {
			var r = i ? "" : n.css;
			if (t.styleSheet) t.styleSheet.cssText = E(e, r);
			else {
				var o = document.createTextNode(r),
					s = t.childNodes;
				s[e] && t.removeChild(s[e]), s.length ? t.insertBefore(o, s[e]) : t.appendChild(o)
			}
		}
		function C(t, e) {
			var i = e.css,
				n = e.media;
			if (n && t.setAttribute("media", n), t.styleSheet) t.styleSheet.cssText = i;
			else {
				for (; t.firstChild;) t.removeChild(t.firstChild);
				t.appendChild(document.createTextNode(i))
			}
		}
		function I(t, e, i) {
			var n = i.css,
				r = i.sourceMap,
				o = void 0 === e.convertToAbsoluteUrls && r;
			(e.convertToAbsoluteUrls || o) && (n = d(n)), r && (n += "\n/*# sourceMappingURL=data:application/json;base64," + btoa(unescape(encodeURIComponent(JSON.stringify(r)))) + " */");
			var s = new Blob([n], {
				type: "text/css"
			}),
				a = t.href;
			t.href = URL.createObjectURL(s), a && URL.revokeObjectURL(a)
		}
	}, function(t, e, i) {
		"use strict";
		i.r(e);
		var n = i(0),
			r = i(27),
			o = i(42),
			s = i(19),
			a = i(3),
			l = i(5),
			u = i(1),
			h = i(20),
			c = i(4),
			d = i(31),
			f = i(23),
			A = i(8),
			p = i(30),
			g = i(74),
			m = i(84),
			v = function(t) {
				f.a.call(this, {
					handleEvent: v.handleEvent_,
					handleDownEvent: h.a.TRUE,
					handleUpEvent: v.handleUpEvent_
				});
				var e = t || {};
				this.source_ = e.source ? e.source : null, this.vertex_ = void 0 === e.vertex || e.vertex, this.edge_ = void 0 === e.edge || e.edge, this.features_ = e.features ? e.features : null, this.featuresListenerKeys_ = [], this.featureChangeListenerKeys_ = {}, this.indexedFeaturesExtents_ = {}, this.pendingFeatures_ = {}, this.pixelCoordinate_ = null, this.pixelTolerance_ = void 0 !== e.pixelTolerance ? e.pixelTolerance : 10, this.sortByDistance_ = v.sortByDistance.bind(this), this.rBush_ = new m.a, this.SEGMENT_WRITERS_ = {
					Point: this.writePointGeometry_,
					LineString: this.writeLineStringGeometry_,
					LinearRing: this.writeLineStringGeometry_,
					Polygon: this.writePolygonGeometry_,
					MultiPoint: this.writeMultiPointGeometry_,
					MultiLineString: this.writeMultiLineStringGeometry_,
					MultiPolygon: this.writeMultiPolygonGeometry_,
					GeometryCollection: this.writeGeometryCollectionGeometry_,
					Circle: this.writeCircleGeometry_
				}
			};
		n.
	default.inherits(v, f.a), v.prototype.addFeature = function(t, e) {
			var i = void 0 === e || e,
				r = n.
			default.getUid(t),
				o = t.getGeometry();
			if (o) {
				var s = this.SEGMENT_WRITERS_[o.getType()];
				s && (this.indexedFeaturesExtents_[r] = o.getExtent(u.
			default.createEmpty()), s.call(this, t, o))
			}
			i && (this.featureChangeListenerKeys_[r] = a.a.listen(t, l.a.CHANGE, this.handleFeatureChange_, this))
		}, v.prototype.forEachFeatureAdd_ = function(t) {
			this.addFeature(t)
		}, v.prototype.forEachFeatureRemove_ = function(t) {
			this.removeFeature(t)
		}, v.prototype.getFeatures_ = function() {
			var t;
			return this.features_ ? t = this.features_ : this.source_ && (t = this.source_.getFeatures()), t
		}, v.prototype.handleFeatureAdd_ = function(t) {
			var e;
			t instanceof p.
		default.Event ? e = t.feature:
			t instanceof r.
		default.Event && (e = t.element), this.addFeature(e)
		}, v.prototype.handleFeatureRemove_ = function(t) {
			var e;
			t instanceof p.
		default.Event ? e = t.feature:
			t instanceof r.
		default.Event && (e = t.element), this.removeFeature(e)
		}, v.prototype.handleFeatureChange_ = function(t) {
			var e = t.target;
			if (this.handlingDownUpSequence) {
				var i = n.
			default.getUid(e);
				i in this.pendingFeatures_ || (this.pendingFeatures_[i] = e)
			} else this.updateFeature_(e)
		}, v.prototype.removeFeature = function(t, e) {
			var i = void 0 === e || e,
				r = n.
			default.getUid(t),
				o = this.indexedFeaturesExtents_[r];
			if (o) {
				var s, l = this.rBush_,
					u = [];
				for (l.forEachInExtent(o, (function(e) {
					t === e.feature && u.push(e)
				})), s = u.length - 1; s >= 0; --s) l.remove(u[s])
			}
			i && (a.a.unlistenByKey(this.featureChangeListenerKeys_[r]), delete this.featureChangeListenerKeys_[r])
		}, v.prototype.setMap = function(t) {
			var e = this.getMap(),
				i = this.featuresListenerKeys_,
				n = this.getFeatures_();
			e && (i.forEach(a.a.unlistenByKey), i.length = 0, n.forEach(this.forEachFeatureRemove_, this)), f.a.prototype.setMap.call(this, t), t && (this.features_ ? i.push(a.a.listen(this.features_, o.a.ADD, this.handleFeatureAdd_, this), a.a.listen(this.features_, o.a.REMOVE, this.handleFeatureRemove_, this)) : this.source_ && i.push(a.a.listen(this.source_, g.a.ADDFEATURE, this.handleFeatureAdd_, this), a.a.listen(this.source_, g.a.REMOVEFEATURE, this.handleFeatureRemove_, this)), n.forEach(this.forEachFeatureAdd_, this))
		}, v.prototype.shouldStopEvent = h.a.FALSE, v.prototype.snapTo = function(t, e, i) {
			var n = i.getCoordinateFromPixel([t[0] - this.pixelTolerance_, t[1] + this.pixelTolerance_]),
				r = i.getCoordinateFromPixel([t[0] + this.pixelTolerance_, t[1] - this.pixelTolerance_]),
				o = u.
			default.boundingExtent([n, r]),
				a = this.rBush_.getInExtent(o);
			this.vertex_ && !this.edge_ && (a = a.filter((function(t) {
				return t.feature.getGeometry().getType() !== c.a.CIRCLE
			})));
			var l, h, d, f, A = !1,
				p = null,
				g = null;
			if (a.length > 0) {
				this.pixelCoordinate_ = e, a.sort(this.sortByDistance_);
				var m = a[0].segment,
					v = a[0].feature.getGeometry().getType() === c.a.CIRCLE;
				this.vertex_ && !this.edge_ ? (l = i.getPixelFromCoordinate(m[0]), h = i.getPixelFromCoordinate(m[1]), d = s.
			default.squaredDistance(t, l), f = s.
			default.squaredDistance(t, h), Math.sqrt(Math.min(d, f)) <= this.pixelTolerance_ && (A = !0, p = d > f ? m[1] : m[0], g = i.getPixelFromCoordinate(p))) : this.edge_ && (p = v ? s.
			default.closestOnCircle(e, a[0].feature.getGeometry()):
				s.
			default.closestOnSegment(e, m), g = i.getPixelFromCoordinate(p), s.
			default.distance(t, g) <= this.pixelTolerance_ && (A = !0, this.vertex_ && !v && (l = i.getPixelFromCoordinate(m[0]), h = i.getPixelFromCoordinate(m[1]), d = s.
			default.squaredDistance(g, l), f = s.
			default.squaredDistance(g, h), Math.sqrt(Math.min(d, f)) <= this.pixelTolerance_ && (p = d > f ? m[1] : m[0], g = i.getPixelFromCoordinate(p))))), A && (g = [Math.round(g[0]), Math.round(g[1])])
			}
			return ({
				snapped: A,
				vertex: p,
				vertexPixel: g
			})
		}, v.prototype.updateFeature_ = function(t) {
			this.removeFeature(t, !1), this.addFeature(t, !1)
		}, v.prototype.writeCircleGeometry_ = function(t, e) {
			var i, n, r, o, s = d.
		default.fromCircle(e).getCoordinates()[0];
			for (i = 0, n = s.length - 1; i < n; ++i) o = {
				feature: t,
				segment: r = s.slice(i, i + 2)
			}, this.rBush_.insert(u.
		default.boundingExtent(r), o)
		}, v.prototype.writeGeometryCollectionGeometry_ = function(t, e) {
			var i, n = e.getGeometriesArray();
			for (i = 0; i < n.length; ++i) {
				var r = this.SEGMENT_WRITERS_[n[i].getType()];
				r && r.call(this, t, n[i])
			}
		}, v.prototype.writeLineStringGeometry_ = function(t, e) {
			var i, n, r, o, s = e.getCoordinates();
			for (i = 0, n = s.length - 1; i < n; ++i) o = {
				feature: t,
				segment: r = s.slice(i, i + 2)
			}, this.rBush_.insert(u.
		default.boundingExtent(r), o)
		}, v.prototype.writeMultiLineStringGeometry_ = function(t, e) {
			var i, n, r, o, s, a, l, h = e.getCoordinates();
			for (o = 0, s = h.length; o < s; ++o) for (n = 0, r = (i = h[o]).length - 1; n < r; ++n) l = {
				feature: t,
				segment: a = i.slice(n, n + 2)
			}, this.rBush_.insert(u.
		default.boundingExtent(a), l)
		}, v.prototype.writeMultiPointGeometry_ = function(t, e) {
			var i, n, r, o, s = e.getCoordinates();
			for (n = 0, r = s.length; n < r; ++n) o = {
				feature: t,
				segment: [i = s[n], i]
			}, this.rBush_.insert(e.getExtent(), o)
		}, v.prototype.writeMultiPolygonGeometry_ = function(t, e) {
			var i, n, r, o, s, a, l, h, c, d, f = e.getCoordinates();
			for (a = 0, l = f.length; a < l; ++a) for (o = 0, s = (h = f[a]).length; o < s; ++o) for (n = 0, r = (i = h[o]).length - 1; n < r; ++n) d = {
				feature: t,
				segment: c = i.slice(n, n + 2)
			}, this.rBush_.insert(u.
		default.boundingExtent(c), d)
		}, v.prototype.writePointGeometry_ = function(t, e) {
			var i = e.getCoordinates(),
				n = {
					feature: t,
					segment: [i, i]
				};
			this.rBush_.insert(e.getExtent(), n)
		}, v.prototype.writePolygonGeometry_ = function(t, e) {
			var i, n, r, o, s, a, l, h = e.getCoordinates();
			for (o = 0, s = h.length; o < s; ++o) for (n = 0, r = (i = h[o]).length - 1; n < r; ++n) l = {
				feature: t,
				segment: a = i.slice(n, n + 2)
			}, this.rBush_.insert(u.
		default.boundingExtent(a), l)
		}, v.handleEvent_ = function(t) {
			var e = this.snapTo(t.pixel, t.coordinate, t.map);
			return e.snapped && (t.coordinate = e.vertex.slice(0, 2), t.pixel = e.vertexPixel), f.a.handleEvent.call(this, t)
		}, v.handleUpEvent_ = function(t) {
			var e = A.a.getValues(this.pendingFeatures_);
			return e.length && (e.forEach(this.updateFeature_, this), this.pendingFeatures_ = {}), !1
		}, v.sortByDistance = function(t, e) {
			return s.
		default.squaredDistanceToSegment(this.pixelCoordinate_, t.segment) - s.
		default.squaredDistanceToSegment(this.pixelCoordinate_, e.segment)
		}, e.
	default = v
	}, function(t, e, i) {
		"use strict";
		i.r(e);
		var n = i(0),
			r = i(15),
			o = i(26),
			s = i(19),
			a = i(5),
			l = i(1),
			u = i(25),
			h = i(30),
			c = function(t) {
				h.
			default.call(this, {
					attributions: t.attributions,
					extent: t.extent,
					logo: t.logo,
					projection: t.projection,
					wrapX: t.wrapX
				}), this.resolution = void 0, this.distance = void 0 !== t.distance ? t.distance:
				20, this.features = [], this.geometryFunction = t.geometryFunction ||
				function(t) {
					var e = t.getGeometry();
					return r.a.assert(e instanceof u.
				default, 10), e
				}, this.source = t.source, this.source.on(a.a.CHANGE, c.prototype.refresh, this)
			};
		n.
	default.inherits(c, h.
	default), c.prototype.getDistance = function() {
			return this.distance
		}, c.prototype.getSource = function() {
			return this.source
		}, c.prototype.loadFeatures = function(t, e, i) {
			this.source.loadFeatures(t, e, i), e !== this.resolution && (this.clear(), this.resolution = e, this.cluster(), this.addFeatures(this.features))
		}, c.prototype.setDistance = function(t) {
			this.distance = t, this.refresh()
		}, c.prototype.refresh = function() {
			this.clear(), this.cluster(), this.addFeatures(this.features), h.
		default.prototype.refresh.call(this)
		}, c.prototype.cluster = function() {
			if (void 0 !== this.resolution) {
				this.features.length = 0;
				for (var t = l.
			default.createEmpty(), e = this.distance * this.resolution, i = this.source.getFeatures(), r = {}, o = 0, s = i.length; o < s; o++) {
					var a = i[o];
					if (!(n.
				default.getUid(a).toString() in r)) {
						var u = this.geometryFunction(a);
						if (u) {
							var h = u.getCoordinates();
							l.
						default.createOrUpdateFromCoordinate(h, t), l.
						default.buffer(t, e, t);
							var c = this.source.getFeaturesInExtent(t);
							c = c.filter((function(t) {
								var e = n.
							default.getUid(t).toString();
								return !(e in r) && (r[e] = !0, !0)
							})), this.features.push(this.createCluster(c))
						}
					}
				}
			}
		}, c.prototype.createCluster = function(t) {
			for (var e = [0, 0], i = t.length - 1; i >= 0; --i) {
				var n = this.geometryFunction(t[i]);
				n ? s.
			default.add(e, n.getCoordinates()):
				t.splice(i, 1)
			}
			s.
		default.scale(e, 1 / t.length);
			var r = new o.
		default (new u.
		default (e));
			return r.set("features", t), r
		}, e.
	default = c
	}, function(t, e, i) {
		"use strict";
		i.r(e);
		var n = i(0),
			r = i(33),
			o = i(30),
			s = i(39),
			a = i(1),
			l = i(25),
			u = i(117),
			h = function(t) {
				var e = t || {};
				r.
			default.call(this, e), this.oldcluster = new o.
			default, this.clusters = [], this.animation = {
					start: !1
				}, this.set("animationDuration", "number" == typeof e.animationDuration ? e.animationDuration : 700), this.set("animationMethod", e.animationMethod || s.
			default.easeOut), this.getSource().on("change", this.saveCluster.bind(this)), this.on("precompose", this.animate.bind(this)), this.on("postcompose", this.postanimate.bind(this))
			};
		n.
	default.inherits(h, r.
	default), h.prototype.saveCluster = function() {
			if (this.oldcluster) {
				if (this.oldcluster.clear(), !this.get("animationDuration")) return;
				var t = this.getSource().getFeatures();
				t.length && t[0].get("features") && (this.oldcluster.addFeatures(this.clusters), this.clusters = t.slice(0), this.sourceChanged = !0)
			}
		}, h.prototype.getClusterForFeature = function(t, e) {
			for (var i = 0; e[i]; i++) {
				var n = e[i].get("features");
				if (n && n.length) for (var r, o = 0; r = n[o]; o++) if (t === r) return e[i]
			}
			return !1
		}, h.prototype.stopAnimation = function() {
			this.animation.start = !1, this.animation.cA = [], this.animation.cB = []
		}, h.prototype.animate = function(t) {
			var e = this.get("animationDuration");
			if (e) {
				var i = t.frameState.viewState.resolution,
					n = this.animation,
					r = t.frameState.time;
				if (n.resolution != i && this.sourceChanged) {
					var o = t.frameState.extent;
					n.resolution < i ? (o = a.
				default.buffer(o, 100 * i), n.cA = this.oldcluster.getFeaturesInExtent(o), n.cB = this.getSource().getFeaturesInExtent(o), n.revers = !1) : (o = a.
				default.buffer(o, 100 * i), n.cA = this.getSource().getFeaturesInExtent(o), n.cB = this.oldcluster.getFeaturesInExtent(o), n.revers = !0), n.clusters = [];
					for (var s, h = 0; s = n.cA[h]; h++) {
						var c = s.get("features");
						if (c && c.length)(g = this.getClusterForFeature(c[0], n.cB)) && n.clusters.push({
							f: s,
							pt: g.getGeometry().getCoordinates()
						})
					}
					if (n.resolution = i, this.sourceChanged = !1, !n.clusters.length || n.clusters.length > 1e3) return void this.stopAnimation();
					r = n.start = (new Date).getTime()
				}
				if (n.start) {
					var d = t.vectorContext,
						f = (r - n.start) / e;
					f > 1 && (this.stopAnimation(), f = 1), f = this.get("animationMethod")(f);
					var A = this.getStyle(),
						p = "function" == typeof A ? A : A.length ?
					function() {
						return A
					} : function() {
						return [A]
					};
					t.context.save(), t.context.globalAlpha = this.getOpacity();
					var g, m = t.frameState.pixelRatio;
					for (h = 0; g = n.clusters[h]; h++) {
						var v = g.f.getGeometry().getCoordinates(),
							y = v[0] - g.pt[0],
							_ = v[1] - g.pt[1];
						n.revers ? (v[0] = g.pt[0] + f * y, v[1] = g.pt[1] + f * _) : (v[0] = v[0] - f * y, v[1] = v[1] - f * _);
						for (var E, x = p(g.f, i, !0), C = new l.
					default (v), I = 0; E = x[I]; I++) {
							var S, T = !u.
						default.prototype.getFeaturesAtPixel && E.getImage();
							T && (S = T.getScale(), T.setScale(S * m)), d.setStyle ? 1 !== g.f.get("features").length || y || _ ? (d.setStyle(E), d.drawGeometry(C)):
							d.drawFeature(g.f.get("features")[0], E) : (d.setImageStyle(T), d.setTextStyle(E.getText()), d.drawPointGeometry(C)), T && T.setScale(S)
						}
					}
					t.context.restore(), t.frameState.animate = !0, t.context.save(), t.context.beginPath(), t.context.rect(0, 0, 0, 0), t.context.clip(), this.clip_ = !0
				}
			}
		}, h.prototype.postanimate = function(t) {
			this.clip_ && (t.context.restore(), this.clip_ = !1)
		}, e.
	default = h
	}, function(t, e) {
		function i(t, e) {
			return {
				type: "Feature",
				properties: e || {},
				geometry: t
			}
		}
		t.exports.feature = i, t.exports.point = function(t, e) {
			if (!Array.isArray(t)) throw new Error("Coordinates must be an array");
			if (t.length < 2) throw new Error("Coordinates must be at least 2 numbers long");
			return i({
				type: "Point",
				coordinates: t.slice()
			}, e)
		}, t.exports.polygon = function(t, e) {
			if (!t) throw new Error("No coordinates passed");
			for (var n = 0; n < t.length; n++) {
				var r = t[n];
				if (r.length < 4) throw new Error("Each LinearRing of a Polygon must have 4 or more Positions.");
				for (var o = 0; o < r[r.length - 1].length; o++) if (r[r.length - 1][o] !== r[0][o]) throw new Error("First and last Position are not equivalent.")
			}
			return i({
				type: "Polygon",
				coordinates: t
			}, e)
		}, t.exports.lineString = function(t, e) {
			if (!t) throw new Error("No coordinates passed");
			return i({
				type: "LineString",
				coordinates: t
			}, e)
		}, t.exports.featureCollection = function(t) {
			return {
				type: "FeatureCollection",
				features: t
			}
		}, t.exports.multiLineString = function(t, e) {
			if (!t) throw new Error("No coordinates passed");
			return i({
				type: "MultiLineString",
				coordinates: t
			}, e)
		}, t.exports.multiPoint = function(t, e) {
			if (!t) throw new Error("No coordinates passed");
			return i({
				type: "MultiPoint",
				coordinates: t
			}, e)
		}, t.exports.multiPolygon = function(t, e) {
			if (!t) throw new Error("No coordinates passed");
			return i({
				type: "MultiPolygon",
				coordinates: t
			}, e)
		}, t.exports.geometryCollection = function(t, e) {
			return i({
				type: "GeometryCollection",
				geometries: t
			}, e)
		};
		var n = {
			miles: 3960,
			nauticalmiles: 3441.145,
			degrees: 57.2957795,
			radians: 1,
			inches: 250905600,
			yards: 6969600,
			meters: 6373e3,
			metres: 6373e3,
			kilometers: 6373,
			kilometres: 6373
		};
		t.exports.radiansToDistance = function(t, e) {
			var i = n[e || "kilometers"];
			if (void 0 === i) throw new Error("Invalid unit");
			return t * i
		}, t.exports.distanceToRadians = function(t, e) {
			var i = n[e || "kilometers"];
			if (void 0 === i) throw new Error("Invalid unit");
			return t / i
		}, t.exports.distanceToDegrees = function(t, e) {
			var i = n[e || "kilometers"];
			if (void 0 === i) throw new Error("Invalid unit");
			return t / i * 57.2958
		}
	}, function(t, e, i) {
		"use strict";
		i.r(e);
		var n = i(0),
			r = i(51),
			o = i(53),
			s = {
				PRELOAD: "preload",
				USE_INTERIM_TILES_ON_ERROR: "useInterimTilesOnError"
			},
			a = i(8),
			l = function(t) {
				var e = t || {},
					i = a.a.assign({}, e);
				delete i.preload, delete i.useInterimTilesOnError, o.a.call(this, i), this.setPreload(void 0 !== e.preload ? e.preload : 0), this.setUseInterimTilesOnError(void 0 === e.useInterimTilesOnError || e.useInterimTilesOnError), this.type = r.a.TILE
			};
		n.
	default.inherits(l, o.a), l.prototype.getPreload = function() {
			return this.get(s.PRELOAD)
		}, l.prototype.getSource, l.prototype.setPreload = function(t) {
			this.set(s.PRELOAD, t)
		}, l.prototype.getUseInterimTilesOnError = function() {
			return this.get(s.USE_INTERIM_TILES_ON_ERROR)
		}, l.prototype.setUseInterimTilesOnError = function(t) {
			this.set(s.USE_INTERIM_TILES_ON_ERROR, t)
		};
		e.
	default = l
	}, function(t, e, i) {
		"use strict";
		i.r(e);
		var n = i(0),
			r = i(15),
			o = i(1),
			s = i(8),
			a = i(11),
			l = i(9),
			u = i(107),
			h = i(48),
			c = i(71),
			d = {
				CARMENTA_SERVER: "carmentaserver",
				GEOSERVER: "geoserver",
				MAPSERVER: "mapserver",
				QGIS: "qgis"
			},
			f = i(49),
			A = i(85),
			p = i(113),
			g = function(t) {
				var e = t || {},
					i = e.params || {},
					n = !("TRANSPARENT" in i) || i.TRANSPARENT;
				c.a.call(this, {
					attributions: e.attributions,
					cacheSize: e.cacheSize,
					crossOrigin: e.crossOrigin,
					logo: e.logo,
					opaque: !n,
					projection: e.projection,
					reprojectionErrorThreshold: e.reprojectionErrorThreshold,
					tileClass: e.tileClass,
					tileGrid: e.tileGrid,
					tileLoadFunction: e.tileLoadFunction,
					url: e.url,
					urls: e.urls,
					wrapX: void 0 === e.wrapX || e.wrapX,
					transition: e.transition
				}), this.gutter_ = void 0 !== e.gutter ? e.gutter : 0, this.params_ = i, this.v13_ = !0, this.serverType_ = e.serverType, this.hidpi_ = void 0 === e.hidpi || e.hidpi, this.tmpExtent_ = o.
			default.createEmpty(), this.updateV13_(), this.setKey(this.getKeyForParams_())
			};
		n.
	default.inherits(g, c.a), g.prototype.getGetFeatureInfoUrl = function(t, e, i, r) {
			var a = l.
		default.get(i),
				c = this.getProjection(),
				d = this.getTileGrid();
			d || (d = this.getTileGridForProjection(a));
			var f = d.getTileCoordForCoordAndResolution(t, e);
			if (!(d.getResolutions().length <= f[0])) {
				var A = d.getResolution(f[0]),
					p = d.getTileCoordExtent(f, this.tmpExtent_),
					g = h.a.toSize(d.getTileSize(f[0]), this.tmpSize),
					m = this.gutter_;
				0 !== m && (g = h.a.buffer(g, m, this.tmpSize), p = o.
			default.buffer(p, A * m, p)), c && c !== a && (A = u.a.calculateSourceResolution(c, a, t, A), p = l.
			default.transformExtent(p, a, c), t = l.
			default.transform(t, a, c));
				var v = {
					SERVICE: "WMS",
					VERSION: n.
				default.DEFAULT_WMS_VERSION,
					REQUEST:
					"GetFeatureInfo",
					FORMAT: "image/png",
					TRANSPARENT: !0,
					QUERY_LAYERS: this.params_.LAYERS
				};
				s.a.assign(v, this.params_, r);
				var y = Math.floor((t[0] - p[0]) / A),
					_ = Math.floor((p[3] - t[1]) / A);
				return v[this.v13_ ? "I" : "X"] = y, v[this.v13_ ? "J" : "Y"] = _, this.getRequestUrl_(f, g, p, 1, c || a, v)
			}
		}, g.prototype.getGutterInternal = function() {
			return this.gutter_
		}, g.prototype.getParams = function() {
			return this.params_
		}, g.prototype.getRequestUrl_ = function(t, e, i, n, o, s) {
			var l = this.urls;
			if (l) {
				if (s.WIDTH = e[0], s.HEIGHT = e[1], s[this.v13_ ? "CRS" : "SRS"] = o.getCode(), "STYLES" in this.params_ || (s.STYLES = ""), 1 != n) switch (this.serverType_) {
				case d.GEOSERVER:
					var u = 90 * n + .5 | 0;
					"FORMAT_OPTIONS" in s ? s.FORMAT_OPTIONS += ";dpi:" + u : s.FORMAT_OPTIONS = "dpi:" + u;
					break;
				case d.MAPSERVER:
					s.MAP_RESOLUTION = 90 * n;
					break;
				case d.CARMENTA_SERVER:
				case d.QGIS:
					s.DPI = 90 * n;
					break;
				default:
					r.a.assert(!1, 52)
				}
				var h, c, A = o.getAxisOrientation(),
					g = i;
				if (this.v13_ && "ne" == A.substr(0, 2)) h = i[0], g[0] = i[1], g[1] = h, h = i[2], g[2] = i[3], g[3] = h;
				if (s.BBOX = g.join(","), 1 == l.length) c = l[0];
				else c = l[a.a.modulo(f.a.hash(t), l.length)];
				return p.a.appendParams(c, s)
			}
		}, g.prototype.getTilePixelRatio = function(t) {
			return this.hidpi_ && void 0 !== this.serverType_ ? t : 1
		}, g.prototype.getKeyForParams_ = function() {
			var t = 0,
				e = [];
			for (var i in this.params_) e[t++] = i + "-" + this.params_[i];
			return e.join("/")
		}, g.prototype.fixedTileUrlFunction = function(t, e, i) {
			var r = this.getTileGrid();
			if (r || (r = this.getTileGridForProjection(i)), !(r.getResolutions().length <= t[0])) {
				1 == e || this.hidpi_ && void 0 !== this.serverType_ || (e = 1);
				var a = r.getResolution(t[0]),
					l = r.getTileCoordExtent(t, this.tmpExtent_),
					u = h.a.toSize(r.getTileSize(t[0]), this.tmpSize),
					c = this.gutter_;
				0 !== c && (u = h.a.buffer(u, c, this.tmpSize), l = o.
			default.buffer(l, a * c, l)), 1 != e && (u = h.a.scale(u, e, this.tmpSize));
				var d = {
					SERVICE: "WMS",
					VERSION: n.
				default.DEFAULT_WMS_VERSION,
					REQUEST:
					"GetMap",
					FORMAT: "image/png",
					TRANSPARENT: !0
				};
				return s.a.assign(d, this.params_), this.getRequestUrl_(t, u, l, e, i, d)
			}
		}, g.prototype.updateParams = function(t) {
			s.a.assign(this.params_, t), this.updateV13_(), this.setKey(this.getKeyForParams_())
		}, g.prototype.updateV13_ = function() {
			var t = this.params_.VERSION || n.
		default.DEFAULT_WMS_VERSION;
			this.v13_ = A.a.compareVersions(t, "1.3") >= 0
		};
		e.
	default = g
	}, function(t, e, i) {
		"use strict";
		Object.defineProperty(e, "__esModule", {
			value: !0
		}), e.util = e.layers = e.mapManage = e.maptools = e.setI18n = void 0;
		var n = i(164);
		Object.keys(n).forEach((function(t) {
			"default" !== t && "__esModule" !== t && Object.defineProperty(e, t, {
				enumerable: !0,
				get: function() {
					return n[t]
				}
			})
		}));
		var r = i(63);
		Object.keys(r).forEach((function(t) {
			"default" !== t && "__esModule" !== t && Object.defineProperty(e, t, {
				enumerable: !0,
				get: function() {
					return r[t]
				}
			})
		})), i(176), i(179);
		var o = i(115),
			s = i(152),
			a = h(i(181)),
			l = h(i(195)),
			u = h(i(207));

		function h(t) {
			if (t && t.__esModule) return t;
			var e = {};
			if (null != t) for (var i in t) Object.prototype.hasOwnProperty.call(t, i) && (e[i] = t[i]);
			return e.
		default = t, e
		}
		var c = {
			setMapLinked: s.setMapLinked,
			getMapLinked: s.getMapLinked,
			getMapById: s.getMapById,
			removeMapById: s.removeMapById
		};
		e.setI18n = o.setI18n, e.maptools = a, e.mapManage = c, e.layers = l, e.util = u
	}, function(t, e, i) {
		"use strict";
		Object.defineProperty(e, "__esModule", {
			value: !0
		}), e.GisMap = void 0;
		var n = X(i(165)),
			r = X(i(19)),
			o = X(i(140)),
			s = X(i(28)),
			a = X(i(27)),
			l = X(i(119)),
			u = X(i(9)),
			h = X(i(1)),
			c = X(i(161)),
			d = X(i(150)),
			f = X(i(117)),
			A = X(i(151)),
			p = X(i(144)),
			g = X(i(216)),
			m = X(i(167)),
			v = X(i(168)),
			y = X(i(145)),
			_ = X(i(138)),
			E = X(i(169)),
			x = X(i(162)),
			C = X(i(170)),
			I = X(i(217)),
			S = X(i(218)),
			T = X(i(147)),
			R = X(i(110)),
			w = X(i(171)),
			L = X(i(146)),
			N = X(i(33)),
			P = X(i(30)),
			O = X(i(26)),
			M = X(i(94)),
			b = X(i(34)),
			F = X(i(36)),
			D = i(63),
			G = z(i(55)),
			k = X(i(172)),
			U = z(i(142)),
			B = i(115),
			j = z(i(152)),
			V = i(80),
			Y = i(174);

		function z(t) {
			if (t && t.__esModule) return t;
			var e = {};
			if (null != t) for (var i in t) Object.prototype.hasOwnProperty.call(t, i) && (e[i] = t[i]);
			return e.
		default = t, e
		}
		function X(t) {
			return t && t.__esModule ? t : {
			default:
				t
			}
		}
		e.GisMap = function() {
			var t = null,
				e = null,
				i = 0,
				z = null,
				X = new c.
			default,
				W = new c.
			default,
				q = new N.
			default ({
					source: new P.
				default ({
						wrapX: !1
					}),
					style:
					new b.
				default ({
						stroke: new F.
					default ({
							color: "rgba(0,60,136,0.8)",
							width: 2
						})
					}),
					zIndex:
					10
				}),
				H = new a.
			default,
				Z = null,
				K = null,
				J = !1,
				Q = null,
				$ = !1,
				tt = !1,
				et = null,
				it = null,
				nt = !1,
				rt = null,
				ot = null,
				st = null,
				at = document.createElement("div"),
				lt = new R.
			default ({
					element: at,
					offset: [-10, -15],
					positioning: "center-left"
				}),
				ut = null,
				ht = null,
				ct = function(t, e) {
					return $ ? e ? u.
				default.transformExtent(t, D.MapConstant.defaultProjection, Z):
					u.
				default.transform(t, D.MapConstant.defaultProjection, Z):
					t
				},
				dt = function(t, e) {
					return $ ? e ? u.
				default.transformExtent(t, Z, D.MapConstant.defaultProjection):
					u.
				default.transform(t, Z, D.MapConstant.defaultProjection):
					t
				},
				ft = null,
				At = function(e) {
					nt && lt.setPosition(e.coordinate);
					var i = t.forEachFeatureAtPixel(e.pixel, (function(t, e) {
						return {
							feature: t,
							layer: e
						}
					}));
					if (t.getTarget().style.cursor = i && i.hasOwnProperty("feature") ? "pointer" : "", i && i.layer && i.layer.get("iGisProperty") && i.layer.get("iGisProperty").isHover) {
						ft = i.feature, U.switchSelFea({
							mapId: e.target.getTarget().id,
							layerType: i.layer.get("iGisProperty").type,
							featureArr: i.feature,
							selType: "hover"
						});
						var n = i.layer.get("iGisProperty").hoverEvent;
						if (n && G.isFunction(n)) n({
							feature: i.feature,
							hoverCoord: dt(e.coordinate)
						})
					} else ft && (U.switchSelFea({
						mapId: e.target.getTarget().id,
						selType: "hover"
					}), ft = null);
					if (j.getMapLinked()) {
						var r = j.crossLength,
							o = e.pixel,
							s = t.getCoordinateFromPixel([o[0] + r / 2, o[1]]),
							a = t.getCoordinateFromPixel([o[0] - r / 2, o[1]]),
							l = t.getCoordinateFromPixel([o[0], o[1] + r / 2]),
							u = t.getCoordinateFromPixel([o[0], o[1] - r / 2]);
						for (var h in s = dt(s), a = dt(a), l = dt(l), u = dt(u), tt && (s = V.GPSTrans.gcj_decrypt_exactArr(s), a = V.GPSTrans.gcj_decrypt_exactArr(a), l = V.GPSTrans.gcj_decrypt_exactArr(l), u = V.GPSTrans.gcj_decrypt_exactArr(u)), j.mapList) {
							var c = j.mapList[h],
								d = s,
								f = a,
								A = l,
								p = u;
							if (c.getIsGCJProjection() && (d = V.GPSTrans.gcj_encryptArr(s), f = V.GPSTrans.gcj_encryptArr(a), A = V.GPSTrans.gcj_encryptArr(l), p = V.GPSTrans.gcj_encryptArr(u)), d = c.transform(d), f = c.transform(f), A = c.transform(A), p = c.transform(p), c.getCrossLayer().getSource().getFeatures().length > 0) c.getCrossLayer().getSource().getFeatures()[0].getGeometry().setCoordinates([
								[d, f],
								[A, p]
							]);
							else {
								var g = new O.
							default ({
									geometry: new M.
								default ([
										[d, f],
										[A, p]
									])
								});
								c.getCrossLayer().getSource().addFeature(g)
							}
						}
					}
				},
				pt = function(t) {
					var e = _t(),
						i = t.map.getView().getZoom();
					J && (document.getElementById("floorInfo").style.display = i >= 18 ? "block" : "none");
					var n = dt(t.map.getView().getCenter());
					if (e ? H.forEach((function(t) {
						i >= t.layerOptions.minShowZoom && i <= t.layerOptions.maxShowZoom && t.isRef && t.getVisible() && t.refreshLayerByData()
					}), this) : H.forEach((function(t) {
						t.isRef && i >= t.layerOptions.minShowZoom && i <= t.layerOptions.maxShowZoom && t.getVisible() && t.refreshLayer()
					}), this), j.getMapLinked()) for (var r in j.mapList) {
						var o = j.mapList[r];
						n.toString() != o.getMapCenter().toString() && o.setMapCenter(n), i != o.getMapZoom() && o.setMapZoom(i)
					}
				},
				gt = function(e) {
					var i = t.forEachFeatureAtPixel(e.pixel, (function(t, e) {
						return {
							feature: t,
							layer: e
						}
					}));
					if (U.switchSelFea({
						mapId: e.target.getTarget().id,
						selType: "click"
					}), i && i.layer && i.layer.get("iGisProperty")) {
						var n = i.layer.get("iGisProperty").clickEvent;
						if (n && G.isFunction(n)) n({
							feature: i.feature,
							clickCoord: dt(e.coordinate)
						})
					} else(nt || G.isFunction(rt)) && (lt.setPosition(void 0), rt(dt(e.coordinate)))
				},
				mt = function() {
					t.getViewport().oncontextmenu = function(e) {
						e.preventDefault();
						var i = t.getEventCoordinate(e);
						G.isFunction(ot) && ot(dt(i))
					}
				},
				vt = function(t) {
					var e = [];
					if ("big" == t.zoomType ? (e.push(new v.
				default), e.push(new y.
				default ({
						zoomOutTipLabel: "" == t.zoomOutLabel ? "Zoom out" : t.zoomOutLabel,
						zoomInTipLabel: "" == t.zoomInLabel ? "Zoom in" : t.zoomInLabel
					}))) : "small" == t.zoomType && e.push(new y.
				default ({
						zoomOutTipLabel: "" == t.zoomOutLabel ? "Zoom out" : t.zoomOutLabel,
						zoomInTipLabel: "" == t.zoomInLabel ? "Zoom in" : t.zoomInLabel
					})), t.isOverview && e.push(new w.
				default ({
						view: new d.
					default ({
							projection: Z
						})
					})), e.push(new p.
				default ({
						collapsible: !1
					})), t.isScaleLine && e.push(new g.
				default ({
						units: t.units ? t.units : D.MapConstant.defaultUnits
					})), t.isZoomLevel && e.push(new k.
				default (t)), t.isMousePosition) {
						if (t.isDMSLonLat) var i = new m.
					default ({
							className: "my-mouse-position",
							projection: D.MapConstant.defaultProjection,
							coordinateFormat: function(t) {
								var e = t[0],
									i = t[1];
								return e >= 180 || e <= -180 || i >= 90 || i <= -90 ? B.I18n.mousePositionMsg : r.
							default.toStringHDMS(t)
							}
						});
						else i = new m.
					default ({
							className: "my-mouse-position",
							coordinateFormat: function(t) {
								var e = t[0],
									i = t[1];
								return e >= 180 || e <= -180 || i >= 90 || i <= -90 ? B.I18n.mousePositionMsg : r.
							default.toStringXY(t, 6)
							},
							projection: D.MapConstant.defaultProjection
						});
						e.push(i)
					}
					return e
				},
				yt = function(t) {
					var i = !! t.wrapX && t.wrapX,
						r = new _.
					default,
						o = null;
					if (D.MapType.OPENSTREET_MAP === K) r = new E.
				default ({
						wrapX: i,
						attributions: new l.
					default ({
							html: '© <a href="http://www.openstreetmap.org/copyright" target="_blank">OpenStreetMap</a> contributors'
						})
					});
					else if (D.MapType.XYZ_MAP === K) r = new _.
				default ({
						url: t.url,
						wrapX: i,
						attributions: new l.
					default ({
							html: G.isDef(t.attributions) ? t.attributions : ""
						})
					}), t.douLayer && (o = new _.
				default ({
						url: t.url2,
						wrapX: i
					}));
					else if (D.MapType.WMS_MAP === K) r = new x.
				default ({
						url: t.url,
						wrapX: i,
						params: t.layerParams,
						attributions: new l.
					default ({
							html: G.isDef(t.attributions) ? t.attributions : ""
						})
					});
					else if (D.MapType.ARCGIS_MAP === K) r = new C.
				default ({
						url: t.url,
						wrapX: i,
						attributions: new l.
					default ({
							html: G.isDef(t.attributions) ? t.attributions : ""
						})
					});
					else if (D.MapType.BING_MAP === K) r = new S.
				default ({
						key: t.url,
						imagerySet: t.imagerySet || "Road",
						wrapX: i,
						attributions: new l.
					default ({
							html: G.isDef(t.attributions) ? t.attributions : ""
						})
					});
					else if (D.MapType.WMTS_MAP === K) {
						for (var s = u.
					default.get(t.projection).getExtent(), a = t.maxZoom ? t.maxZoom:
						D.MapConstant.defaultMaxZoom, c = new Array(a), d = new Array(a), f = h.
					default.getWidth(s) / 256, A = 0; A < a; ++A) c[A] = f / Math.pow(2, A), d[A] = A;
						r = new I.
					default ({
							url: t.url,
							layer: t.layerName,
							matrixSet: t.matrixSet,
							format: t.format || "image/png",
							tileGrid: new T.
						default ({
								origin: h.
							default.getTopLeft(s),
								resolutions:
								c,
								matrixIds: d
							}),
							style:
							"default",
							wrapX: i,
							attributions: new l.
						default ({
								html: G.isDef(t.attributions) ? t.attributions : ""
							})
						})
					} else D.OutMapType.GAODE_ROADNET_MAP === K ? e = new n.
				default.Map(t.divId + "outMap", {
						resizeEnable: !0,
						showIndoorMap: !1,
						expandZoomRange: !0,
						dragEnable: !0,
						doubleClickZoom: !1,
						keyboardEnable: !1,
						jogEnable: !1,
						scrollWheel: !0
					}):
					D.OutMapType.GAODE_SATELLITE_MAP === K && (e = new n.
				default.Map(t.divId + "outMap", {
						resizeEnable: !0,
						showIndoorMap: !1,
						expandZoomRange: !0,
						dragEnable: !0,
						doubleClickZoom: !1,
						keyboardEnable: !1,
						jogEnable: !1,
						scrollWheel: !0,
						layers: [new n.
					default.TileLayer.Satellite, new n.
					default.TileLayer.RoadNet]
					}));
					return {
						source: r,
						sourceTwo: o
					}
				},
				_t = function() {
					var e = !1,
						n = et.getZoom(),
						r = et.calculateExtent(t.getSize());
					return n !== i ? e = !0 : h.
				default.containsExtent(z, r) || (e = !0), e
				},
				Et = function(e) {
					null != e && (t.removeLayer(e.layerVector), H.remove(e))
				},
				xt = function(t) {
					var e = dt(et.getCenter());
					return J && t ? Q.getFloorInfo(et.getCenter()) : e
				},
				Ct = function() {
					return et.getZoom()
				};
			this.getCrossLayer = function() {
				return q
			}, this.getCurrMap = function() {
				return t
			}, this.getIndoorMapObj = function() {
				return Q
			}, this.getGetFeatureInfoUrlByBaseWmsLayer = function(e, i) {
				return X.getSource().getGetFeatureInfoUrl(e, t.getView().getResolution(), Z, i)
			}, this.getTransformInd = function() {
				return $
			}, this.getIsGCJProjection = function() {
				return tt
			}, this.setIsGCJProjection = function(t) {
				tt = t
			}, this.getCurrProjection = function() {
				return Z
			}, this.setAddMouseElement = function(t, e) {
				nt = t, at.innerHTML = e
			}, this.addCustomClickEvent = function(t) {
				rt = t
			}, this.addCustomRightClickEvent = function(t) {
				ot = t
			}, this.trafficLayer = function() {
				(ut = new n.
			default.TileLayer.Traffic({
					zIndex: 10
				})).setMap(e)
			}, this.trafficLayerShow = function(t) {
				t ? ut.show() : ut.hide()
			}, this.createMap = function(i) {
				Z = i.projection, K = i.mapType, $ = D.MapConstant.defaultProjection !== Z;
				var n = document.getElementById(i.divId + "outMap");
				if (n) n.innerHTML = "";
				else {
					var r = document.createElement("div"),
						o = document.getElementById(i.divId);
					o.style.position = "relative", r.id = i.divId + "outMap", r.classList.add("outMap"), G.domAppendChild(o, r)
				}
				var s, a, l = yt(i);
				X.setSource(l.source), X.setOpacity(i.opacity ? i.opacity : 1), t ? (a = ct(it), s = Ct()) : (a = ct(i.center), s = i.zoom), et = new d.
			default ({
					projection: Z,
					minZoom: i.minZoom ? i.minZoom : D.MapConstant.defaultMinZoom,
					maxZoom: i.maxZoom ? i.maxZoom : D.MapConstant.defaultMaxZoom
				});
				var u = document.getElementById(i.divId + "outMap");
				if (D.OutMapType.hasOwnProperty(K) ? (tt = !0, u && u.classList.add("outMap"), et.on("change:center", (function(t) {
					D.OutMapType.GAODE_ROADNET_MAP !== K && D.OutMapType.GAODE_SATELLITE_MAP !== K || e.setCenter(dt(t.target.getCenter()))
				})), et.on("change:resolution", (function(t) {
					var i = t.target.getZoom();
					/^[1-9]+[0-9]*]*$/.test(i) && e.setZoom(i)
				}))) : (tt = !1, u && u.classList.remove("outMap")), et.setCenter(a), et.setZoom(s), it = xt(), G.isNull(t)) {
					var h = vt(i);
					(t = new f.
				default ({
						layers: [X, q],
						controls: new A.
					default.defaults({
							attribution: !1,
							zoom: !1
						}).extend(h),
						target:
						o,
						logo: !1
					})).on("moveend", pt, this), t.on("singleclick", gt, this), t.on("pointermove", At, this), mt(), t.addOverlay(lt), j.mapList[i.divId] = this
				}
				l.sourceTwo ? (W.setSource(l.sourceTwo), t.addLayer(W)):
				t.removeLayer(W), t.setView(et), (J = i.isIndoor || !1) && (null == Q && (Q = new Y.IndoorMap(this)), Q.addFloor(i.indoorData), i.indoorData.currBuildId && i.indoorData.currFloorId && Q.switchFloor(i.indoorData.currBuildId, i.indoorData.currFloorId))
			}, this.updateSize = function() {
				t.updateSize()
			}, this.transform = ct, this.reTransform = dt, this.getMapCenter = xt, this.setMapCenter = function(t, e, i) {
				et.setCenter(ct(t)), J && e && i && Q.switchFloor(e, i)
			}, this.getMapZoom = Ct, this.setMapZoom = function(t) {
				return et.setZoom(t)
			}, this.getMapMaxZoom = function() {
				return et.getMaxZoom()
			}, this.getMapExtent = function() {
				var e = et.calculateExtent(t.getSize());
				return dt(e, !0)
			}, this.setMapExtent = function(t, e) {
				e ? et.fit(ct(t, !0)) : et.fit(t)
			}, this.getDataExtent = function() {
				var e = et.calculateExtent(t.getSize()),
					n = e[0],
					r = e[1],
					o = e[2],
					s = e[3],
					a = (o - n) / 2,
					l = (s - r) / 2;
				return {
					extent: dt(z = [n - a, r - l, o + a, s + l], !0),
					zoom: i = et.getZoom()
				}
			}, this.getRate = function() {
				return t.getView().getResolution() / t.getView().getMaxResolution()
			}, this.addLayer = function(e) {
				e.layerVector.set("iGisProperty", {
					isHover: e.isHover,
					type: e.type
				}), e.layerVector.setMinResolution(et.getResolutionForZoom(e.layerOptions.maxShowZoom)), e.layerVector.setMaxResolution(et.getResolutionForZoom(e.layerOptions.minShowZoom)), t.addLayer(e.layerVector), H.push(e)
			}, this.removeLayer = Et, this.dragBoxInteraction = function() {
				var e = new L.
			default ({
					condition: s.
				default.always
				});
				t.addInteraction(e), e.on("boxend", (function() {
					t.removeInteraction(e), e = null
				}))
			}, this.addBoxSelection = function(e) {
				G.isNull(st) && (st = new o.
			default ({
					condition: s.
				default.always
				}), t.addInteraction(st)), st.on("boxstart", (function() {
					e.startFunc && e.startFunc()
				})), st.on("boxend", (function() {
					var t = [],
						i = st.getGeometry().getExtent();
					e.layerObj.layerVector.getSource().forEachFeatureIntersectingExtent(i, (function(e) {
						t.push(e)
					})), e.endFunc(t)
				}))
			}, this.removeBoxSelection = function() {
				G.isDefAndNotNull(st) && (t.removeInteraction(st), st = null)
			}, this.destroyMap = function(e) {
				e && (Q.removeIndoor(), Q = null), t.un("moveend", pt, this), t.un("singleclick", gt, this), t.un("pointermove", At, this), H.forEach((function(t) {
					Et(t)
				}), this), H = null, t.removeLayer(X), X = null, t.removeLayer(W), W = null, t.removeLayer(q), q = null, t.removeOverlay(lt), at = null, lt = null, rt = null, ot = null;
				for (var i = t.getTarget(), n = i.childNodes.length - 1; n >= 0; n--) {
					var r = i.childNodes[n];
					i.removeChild(r)
				}
				et = null, t = null
			}, this.showIndoor = function(t, e) {
				t ? (null == ht && (ht = new Y.IndoorMap(this)), ht.addFloor(e), e.currBuildId && e.currFloorId && ht.switchFloor(e.currBuildId, e.currFloorId)) : (ht.removeIndoor(), ht = null)
			}
		}
	}, function(e, i) {
		e.exports = t
	}, function(t, e, i) {
		t.exports = function() {
			"use strict";

			function t(t, e, i) {
				var n = t[e];
				t[e] = t[i], t[i] = n
			}
			function e(t, e) {
				return t < e ? -1 : t > e ? 1 : 0
			}
			return function(i, n, r, o, s) {
				!
				function e(i, n, r, o, s) {
					for (; o > r;) {
						if (o - r > 600) {
							var a = o - r + 1,
								l = n - r + 1,
								u = Math.log(a),
								h = .5 * Math.exp(2 * u / 3),
								c = .5 * Math.sqrt(u * h * (a - h) / a) * (l - a / 2 < 0 ? -1 : 1),
								d = Math.max(r, Math.floor(n - l * h / a + c)),
								f = Math.min(o, Math.floor(n + (a - l) * h / a + c));
							e(i, n, d, f, s)
						}
						var A = i[n],
							p = r,
							g = o;
						for (t(i, r, n), s(i[o], A) > 0 && t(i, r, o); p < g;) {
							for (t(i, p, g), p++, g--; s(i[p], A) < 0;) p++;
							for (; s(i[g], A) > 0;) g--
						}
						0 === s(i[r], A) ? t(i, r, g) : (g++, t(i, g, o)), g <= n && (r = g + 1), n <= g && (o = g - 1)
					}
				}(i, n, r || 0, o || i.length - 1, s || e)
			}
		}()
	}, function(t, e, i) {
		"use strict";
		i.r(e);
		var n = i(0),
			r = i(3),
			o = i(5),
			s = i(14),
			a = i(43),
			l = i(9),
			u = function(t) {
				var e = t || {},
					i = document.createElement("DIV");
				i.className = void 0 !== e.className ? e.className : "ol-mouse-position";
				var n = e.render ? e.render : u.render;
				a.
			default.call(this, {
					element: i,
					render: n,
					target: e.target
				}), r.a.listen(this, s.a.getChangeEventType(u.Property_.PROJECTION), this.handleProjectionChanged_, this), e.coordinateFormat && this.setCoordinateFormat(e.coordinateFormat), e.projection && this.setProjection(e.projection), this.undefinedHTML_ = void 0 !== e.undefinedHTML ? e.undefinedHTML:
				"", this.renderedHTML_ = i.innerHTML, this.mapProjection_ = null, this.transform_ = null, this.lastMouseMovePixel_ = null
			};
		n.
	default.inherits(u, a.
	default), u.render = function(t) {
			var e = t.frameState;
			e ? this.mapProjection_ != e.viewState.projection && (this.mapProjection_ = e.viewState.projection, this.transform_ = null) : this.mapProjection_ = null, this.updateHTML_(this.lastMouseMovePixel_)
		}, u.prototype.handleProjectionChanged_ = function() {
			this.transform_ = null
		}, u.prototype.getCoordinateFormat = function() {
			return this.get(u.Property_.COORDINATE_FORMAT)
		}, u.prototype.getProjection = function() {
			return this.get(u.Property_.PROJECTION)
		}, u.prototype.handleMouseMove = function(t) {
			var e = this.getMap();
			this.lastMouseMovePixel_ = e.getEventPixel(t), this.updateHTML_(this.lastMouseMovePixel_)
		}, u.prototype.handleMouseOut = function(t) {
			this.updateHTML_(null), this.lastMouseMovePixel_ = null
		}, u.prototype.setMap = function(t) {
			if (a.
		default.prototype.setMap.call(this, t), t) {
				var e = t.getViewport();
				this.listenerKeys.push(r.a.listen(e, o.a.MOUSEMOVE, this.handleMouseMove, this), r.a.listen(e, o.a.MOUSEOUT, this.handleMouseOut, this))
			}
		}, u.prototype.setCoordinateFormat = function(t) {
			this.set(u.Property_.COORDINATE_FORMAT, t)
		}, u.prototype.setProjection = function(t) {
			this.set(u.Property_.PROJECTION, l.
		default.get(t))
		}, u.prototype.updateHTML_ = function(t) {
			var e = this.undefinedHTML_;
			if (t && this.mapProjection_) {
				if (!this.transform_) {
					var i = this.getProjection();
					this.transform_ = i ? l.
				default.getTransformFromProjections(this.mapProjection_, i):
					l.
				default.identityTransform
				}
				var n = this.getMap().getCoordinateFromPixel(t);
				if (n) {
					this.transform_(n, n);
					var r = this.getCoordinateFormat();
					e = r ? r(n) : n.toString()
				}
			}
			this.renderedHTML_ && e == this.renderedHTML_ || (this.element.innerHTML = e, this.renderedHTML_ = e)
		}, u.Property_ = {
			PROJECTION: "projection",
			COORDINATE_FORMAT: "coordinateFormat"
		}, e.
	default = u
	}, function(t, e, i) {
		"use strict";
		i.r(e);
		var n = i(0),
			r = i(22),
			o = i(43),
			s = i(37),
			a = i(39),
			l = i(3),
			u = i(21),
			h = i(5),
			c = i(11),
			d = i(66),
			f = i(128),
			A = function(t) {
				var e = t || {};
				this.currentResolution_ = void 0, this.direction_ = A.Direction_.VERTICAL, this.dragging_, this.heightLimit_ = 0, this.widthLimit_ = 0, this.previousX_, this.previousY_, this.thumbSize_ = null, this.sliderInitialized_ = !1, this.duration_ = void 0 !== e.duration ? e.duration : 200;
				var i = void 0 !== e.className ? e.className : "ol-zoomslider",
					n = document.createElement("button");
				n.setAttribute("type", "button"), n.className = i + "-thumb " + s.a.CLASS_UNSELECTABLE;
				var r = document.createElement("div");
				r.className = i + " " + s.a.CLASS_UNSELECTABLE + " " + s.a.CLASS_CONTROL, r.appendChild(n), this.dragger_ = new f.a(r), l.a.listen(this.dragger_, d.a.POINTERDOWN, this.handleDraggerStart_, this), l.a.listen(this.dragger_, d.a.POINTERMOVE, this.handleDraggerDrag_, this), l.a.listen(this.dragger_, d.a.POINTERUP, this.handleDraggerEnd_, this), l.a.listen(r, h.a.CLICK, this.handleContainerClick_, this), l.a.listen(n, h.a.CLICK, u.a.stopPropagation);
				var a = e.render ? e.render : A.render;
				o.
			default.call(this, {
					element: r,
					render: a
				})
			};
		n.
	default.inherits(A, o.
	default), A.prototype.disposeInternal = function() {
			this.dragger_.dispose(), o.
		default.prototype.disposeInternal.call(this)
		}, A.Direction_ = {
			VERTICAL: 0,
			HORIZONTAL: 1
		}, A.prototype.setMap = function(t) {
			o.
		default.prototype.setMap.call(this, t), t && t.render()
		}, A.prototype.initSlider_ = function() {
			var t = this.element,
				e = t.offsetWidth,
				i = t.offsetHeight,
				n = t.firstElementChild,
				r = getComputedStyle(n),
				o = n.offsetWidth + parseFloat(r.marginRight) + parseFloat(r.marginLeft),
				s = n.offsetHeight + parseFloat(r.marginTop) + parseFloat(r.marginBottom);
			this.thumbSize_ = [o, s], e > i ? (this.direction_ = A.Direction_.HORIZONTAL, this.widthLimit_ = e - o) : (this.direction_ = A.Direction_.VERTICAL, this.heightLimit_ = i - s), this.sliderInitialized_ = !0
		}, A.render = function(t) {
			if (t.frameState) {
				this.sliderInitialized_ || this.initSlider_();
				var e = t.frameState.viewState.resolution;
				e !== this.currentResolution_ && (this.currentResolution_ = e, this.setThumbPosition_(e))
			}
		}, A.prototype.handleContainerClick_ = function(t) {
			var e = this.getMap().getView(),
				i = this.getRelativePosition_(t.offsetX - this.thumbSize_[0] / 2, t.offsetY - this.thumbSize_[1] / 2),
				n = this.getResolutionForPosition_(i);
			e.animate({
				resolution: e.constrainResolution(n),
				duration: this.duration_,
				easing: a.
			default.easeOut
			})
		}, A.prototype.handleDraggerStart_ = function(t) {
			this.dragging_ || t.originalEvent.target !== this.element.firstElementChild || (this.getMap().getView().setHint(r.a.INTERACTING, 1), this.previousX_ = t.clientX, this.previousY_ = t.clientY, this.dragging_ = !0)
		}, A.prototype.handleDraggerDrag_ = function(t) {
			if (this.dragging_) {
				var e = this.element.firstElementChild,
					i = t.clientX - this.previousX_ + parseInt(e.style.left, 10),
					n = t.clientY - this.previousY_ + parseInt(e.style.top, 10),
					r = this.getRelativePosition_(i, n);
				this.currentResolution_ = this.getResolutionForPosition_(r), this.getMap().getView().setResolution(this.currentResolution_), this.setThumbPosition_(this.currentResolution_), this.previousX_ = t.clientX, this.previousY_ = t.clientY
			}
		}, A.prototype.handleDraggerEnd_ = function(t) {
			if (this.dragging_) {
				var e = this.getMap().getView();
				e.setHint(r.a.INTERACTING, -1), e.animate({
					resolution: e.constrainResolution(this.currentResolution_),
					duration: this.duration_,
					easing: a.
				default.easeOut
				}), this.dragging_ = !1, this.previousX_ = void 0, this.previousY_ = void 0
			}
		}, A.prototype.setThumbPosition_ = function(t) {
			var e = this.getPositionForResolution_(t),
				i = this.element.firstElementChild;
			this.direction_ == A.Direction_.HORIZONTAL ? i.style.left = this.widthLimit_ * e + "px" : i.style.top = this.heightLimit_ * e + "px"
		}, A.prototype.getRelativePosition_ = function(t, e) {
			var i;
			return i = this.direction_ === A.Direction_.HORIZONTAL ? t / this.widthLimit_ : e / this.heightLimit_, c.a.clamp(i, 0, 1)
		}, A.prototype.getResolutionForPosition_ = function(t) {
			return this.getMap().getView().getResolutionForValueFunction()(1 - t)
		}, A.prototype.getPositionForResolution_ = function(t) {
			return 1 - this.getMap().getView().getValueForResolutionFunction()(t)
		}, e.
	default = A
	}, function(t, e, i) {
		"use strict";
		i.r(e);
		var n = i(0),
			r = i(138),
			o = function(t) {
				var e, i = t || {};
				e = void 0 !== i.attributions ? i.attributions : [o.ATTRIBUTION];
				var n = void 0 !== i.crossOrigin ? i.crossOrigin : "anonymous",
					s = void 0 !== i.url ? i.url : "https://{a-c}.tile.openstreetmap.org/{z}/{x}/{y}.png";
				r.
			default.call(this, {
					attributions: e,
					cacheSize: i.cacheSize,
					crossOrigin: n,
					opaque: void 0 === i.opaque || i.opaque,
					maxZoom: void 0 !== i.maxZoom ? i.maxZoom : 19,
					reprojectionErrorThreshold: i.reprojectionErrorThreshold,
					tileLoadFunction: i.tileLoadFunction,
					url: s,
					wrapX: i.wrapX
				})
			};
		n.
	default.inherits(o, r.
	default), o.ATTRIBUTION = '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors.', e.
	default = o
	}, function(t, e, i) {
		"use strict";
		i.r(e);
		var n = i(0),
			r = i(1),
			o = i(11),
			s = i(8),
			a = i(48),
			l = i(71),
			u = i(49),
			h = i(113),
			c = function(t) {
				var e = t || {};
				l.a.call(this, {
					attributions: e.attributions,
					cacheSize: e.cacheSize,
					crossOrigin: e.crossOrigin,
					logo: e.logo,
					projection: e.projection,
					reprojectionErrorThreshold: e.reprojectionErrorThreshold,
					tileGrid: e.tileGrid,
					tileLoadFunction: e.tileLoadFunction,
					url: e.url,
					urls: e.urls,
					wrapX: void 0 === e.wrapX || e.wrapX,
					transition: e.transition
				}), this.params_ = e.params || {}, this.tmpExtent_ = r.
			default.createEmpty(), this.setKey(this.getKeyForParams_())
			};
		n.
	default.inherits(c, l.a), c.prototype.getKeyForParams_ = function() {
			var t = 0,
				e = [];
			for (var i in this.params_) e[t++] = i + "-" + this.params_[i];
			return e.join("/")
		}, c.prototype.getParams = function() {
			return this.params_
		}, c.prototype.getRequestUrl_ = function(t, e, i, n, r, s) {
			var a = this.urls;
			if (a) {
				var l, c = r.getCode().split(":").pop();
				if (s.SIZE = e[0] + "," + e[1], s.BBOX = i.join(","), s.BBOXSR = c, s.IMAGESR = c, s.DPI = Math.round(s.DPI ? s.DPI * n : 90 * n), 1 == a.length) l = a[0];
				else l = a[o.a.modulo(u.a.hash(t), a.length)];
				var d = l.replace(/MapServer\/?$/, "MapServer/export").replace(/ImageServer\/?$/, "ImageServer/exportImage");
				return h.a.appendParams(d, s)
			}
		}, c.prototype.getTilePixelRatio = function(t) {
			return t
		}, c.prototype.fixedTileUrlFunction = function(t, e, i) {
			var n = this.getTileGrid();
			if (n || (n = this.getTileGridForProjection(i)), !(n.getResolutions().length <= t[0])) {
				var r = n.getTileCoordExtent(t, this.tmpExtent_),
					o = a.a.toSize(n.getTileSize(t[0]), this.tmpSize);
				1 != e && (o = a.a.scale(o, e, this.tmpSize));
				var l = {
					F: "image",
					FORMAT: "PNG32",
					TRANSPARENT: !0
				};
				return s.a.assign(l, this.params_), this.getRequestUrl_(t, o, r, e, i, l)
			}
		}, c.prototype.updateParams = function(t) {
			s.a.assign(this.params_, t), this.setKey(this.getKeyForParams_())
		}, e.
	default = c
	}, function(t, e, i) {
		"use strict";
		i.r(e);
		var n = i(0),
			r = i(27),
			o = i(129),
			s = i(89),
			a = i(61),
			l = i(14),
			u = i(77),
			h = i(110),
			c = i(67),
			d = i(54),
			f = i(43),
			A = i(19),
			p = i(37),
			g = i(16),
			m = i(3),
			v = i(5),
			y = i(1),
			_ = function(t) {
				var e = t || {};
				this.collapsed_ = void 0 === e.collapsed || e.collapsed, this.collapsible_ = void 0 === e.collapsible || e.collapsible, this.collapsible_ || (this.collapsed_ = !1);
				var i = void 0 !== e.className ? e.className : "ol-overviewmap",
					n = void 0 !== e.tipLabel ? e.tipLabel : "Overview map",
					s = void 0 !== e.collapseLabel ? e.collapseLabel : "«";
				"string" == typeof s ? (this.collapseLabel_ = document.createElement("span"), this.collapseLabel_.textContent = s) : this.collapseLabel_ = s;
				var a = void 0 !== e.label ? e.label : "»";
				"string" == typeof a ? (this.label_ = document.createElement("span"), this.label_.textContent = a) : this.label_ = a;
				var l = this.collapsible_ && !this.collapsed_ ? this.collapseLabel_ : this.label_,
					u = document.createElement("button");
				u.setAttribute("type", "button"), u.title = n, u.appendChild(l), m.a.listen(u, v.a.CLICK, this.handleClick_, this), this.ovmapDiv_ = document.createElement("DIV"), this.ovmapDiv_.className = "ol-overviewmap-map", this.ovmap_ = new o.a({
					controls: new r.
				default,
					interactions:
					new r.
				default,
					view:
					e.view
				});
				var d = this.ovmap_;
				e.layers && e.layers.forEach((function(t) {
					d.addLayer(t)
				}), this);
				var A = document.createElement("DIV");
				A.className = "ol-overviewmap-box", A.style.boxSizing = "border-box", this.boxOverlay_ = new h.
			default ({
					position: [0, 0],
					positioning: c.a.BOTTOM_LEFT,
					element: A
				}), this.ovmap_.addOverlay(this.boxOverlay_);
				var g = i + " " + p.a.CLASS_UNSELECTABLE + " " + p.a.CLASS_CONTROL + (this.collapsed_ && this.collapsible_ ? " ol-collapsed" : "") + (this.collapsible_ ? "" : " ol-uncollapsible"),
					y = document.createElement("div");
				y.className = g, y.appendChild(this.ovmapDiv_), y.appendChild(u);
				var E = e.render ? e.render:
				_.render;
				f.
			default.call(this, {
					element: y,
					render: E,
					target: e.target
				});
				var x = this,
					C = this.boxOverlay_,
					I = this.boxOverlay_.getElement(),
					S = function(t) {
						var e, i = d.getEventCoordinate({
							clientX: (e = t).clientX - I.offsetWidth / 2,
							clientY: e.clientY + I.offsetHeight / 2
						});
						C.setPosition(i)
					},
					T = function(t) {
						var e = d.getEventCoordinate(t);
						x.getMap().getView().setCenter(e), window.removeEventListener("mousemove", S), window.removeEventListener("mouseup", T)
					};
				I.addEventListener("mousedown", (function() {
					window.addEventListener("mousemove", S), window.addEventListener("mouseup", T)
				}))
			};
		n.
	default.inherits(_, f.
	default), _.prototype.setMap = function(t) {
			var e = this.getMap();
			if (t !== e) {
				if (e) {
					var i = e.getView();
					i && this.unbindView_(i), this.ovmap_.setTarget(null)
				}
				if (f.
			default.prototype.setMap.call(this, t), t) {
					this.ovmap_.setTarget(this.ovmapDiv_), this.listenerKeys.push(m.a.listen(t, u.a.PROPERTYCHANGE, this.handleMapPropertyChange_, this)), 0 === this.ovmap_.getLayers().getLength() && this.ovmap_.setLayerGroup(t.getLayerGroup());
					var n = t.getView();
					n && (this.bindView_(n), n.isDef() && (this.ovmap_.updateSize(), this.resetExtent_()))
				}
			}
		}, _.prototype.handleMapPropertyChange_ = function(t) {
			if (t.key === a.a.VIEW) {
				var e = t.oldValue;
				e && this.unbindView_(e);
				var i = this.getMap().getView();
				this.bindView_(i)
			}
		}, _.prototype.bindView_ = function(t) {
			m.a.listen(t, l.a.getChangeEventType(d.a.ROTATION), this.handleRotationChanged_, this)
		}, _.prototype.unbindView_ = function(t) {
			m.a.unlisten(t, l.a.getChangeEventType(d.a.ROTATION), this.handleRotationChanged_, this)
		}, _.prototype.handleRotationChanged_ = function() {
			this.ovmap_.getView().setRotation(this.getMap().getView().getRotation())
		}, _.render = function(t) {
			this.validateExtent_(), this.updateBox_()
		}, _.prototype.validateExtent_ = function() {
			var t = this.getMap(),
				e = this.ovmap_;
			if (t.isRendered() && e.isRendered()) {
				var i = t.getSize(),
					r = t.getView().calculateExtent(i),
					o = e.getSize(),
					s = e.getView().calculateExtent(o),
					a = e.getPixelFromCoordinate(y.
				default.getTopLeft(r)),
					l = e.getPixelFromCoordinate(y.
				default.getBottomRight(r)),
					u = Math.abs(a[0] - l[0]),
					h = Math.abs(a[1] - l[1]),
					c = o[0],
					d = o[1];
				u < c * n.
			default.OVERVIEWMAP_MIN_RATIO || h < d * n.
			default.OVERVIEWMAP_MIN_RATIO || u > c * n.
			default.OVERVIEWMAP_MAX_RATIO || h > d * n.
			default.OVERVIEWMAP_MAX_RATIO ? this.resetExtent_():
				y.
			default.containsExtent(s, r) || this.recenter_()
			}
		}, _.prototype.resetExtent_ = function() {
			if (0 !== n.
		default.OVERVIEWMAP_MAX_RATIO && 0 !== n.
		default.OVERVIEWMAP_MIN_RATIO) {
				var t = this.getMap(),
					e = this.ovmap_,
					i = t.getSize(),
					r = t.getView().calculateExtent(i),
					o = e.getView(),
					s = Math.log(n.
				default.OVERVIEWMAP_MAX_RATIO / n.
				default.OVERVIEWMAP_MIN_RATIO) / Math.LN2,
					a = 1 / (Math.pow(2, s / 2) * n.
				default.OVERVIEWMAP_MIN_RATIO);
				y.
			default.scaleFromCenter(r, a), o.fit(r)
			}
		}, _.prototype.recenter_ = function() {
			var t = this.getMap(),
				e = this.ovmap_,
				i = t.getView();
			e.getView().setCenter(i.getCenter())
		}, _.prototype.updateBox_ = function() {
			var t = this.getMap(),
				e = this.ovmap_;
			if (t.isRendered() && e.isRendered()) {
				var i = t.getSize(),
					n = t.getView(),
					r = e.getView(),
					o = n.getRotation(),
					s = this.boxOverlay_,
					a = this.boxOverlay_.getElement(),
					l = n.calculateExtent(i),
					u = r.getResolution(),
					h = y.
				default.getBottomLeft(l),
					c = y.
				default.getTopRight(l),
					d = this.calculateCoordinateRotate_(o, h);
				s.setPosition(d), a && (a.style.width = Math.abs((h[0] - c[0]) / u) + "px", a.style.height = Math.abs((c[1] - h[1]) / u) + "px")
			}
		}, _.prototype.calculateCoordinateRotate_ = function(t, e) {
			var i, n = this.getMap().getView().getCenter();
			return n && (i = [e[0] - n[0], e[1] - n[1]], A.
		default.rotate(i, t), A.
		default.add(i, n)), i
		}, _.prototype.handleClick_ = function(t) {
			t.preventDefault(), this.handleToggle_()
		}, _.prototype.handleToggle_ = function() {
			this.element.classList.toggle("ol-collapsed"), this.collapsed_ ? g.a.replaceNode(this.collapseLabel_, this.label_) : g.a.replaceNode(this.label_, this.collapseLabel_), this.collapsed_ = !this.collapsed_;
			var t = this.ovmap_;
			this.collapsed_ || t.isRendered() || (t.updateSize(), this.resetExtent_(), m.a.listenOnce(t, s.a.POSTRENDER, (function(t) {
				this.updateBox_()
			}), this))
		}, _.prototype.getCollapsible = function() {
			return this.collapsible_
		}, _.prototype.setCollapsible = function(t) {
			this.collapsible_ !== t && (this.collapsible_ = t, this.element.classList.toggle("ol-uncollapsible"), !t && this.collapsed_ && this.handleToggle_())
		}, _.prototype.setCollapsed = function(t) {
			this.collapsible_ && this.collapsed_ !== t && this.handleToggle_()
		}, _.prototype.getCollapsed = function() {
			return this.collapsed_
		}, _.prototype.getOverviewMap = function() {
			return this.ovmap_
		}, e.
	default = _
	}, function(t, e, i) {
		"use strict";
		Object.defineProperty(e, "__esModule", {
			value: !0
		});
		var n = a(i(0)),
			r = a(i(43)),
			o = i(115),
			s = function(t) {
				if (t && t.__esModule) return t;
				var e = {};
				if (null != t) for (var i in t) Object.prototype.hasOwnProperty.call(t, i) && (e[i] = t[i]);
				return e.
			default = t, e
			}(i(55));

		function a(t) {
			return t && t.__esModule ? t : {
			default:
				t
			}
		}
		var l = function t(e) {
				var i = s.isDef(e) ? e : {},
					n = s.isDef(i.render) ? i.render : t.render;
				this.element_ = document.createElement("div"), this.element_.className = s.isDef(i.className) ? i.className : "zoomLevel", r.
			default.call(this, {
					render: n,
					element: this.element_,
					target: i.target
				})
			};
		n.
	default.inherits(l, r.
	default), l.render = function() {
			var t = this.map_,
				e = t.getView().getZoom();
			s.isDef(t) && s.isDef(e) && /^[1-9]+[0-9]*]*$/.test(e) && (this.element_.innerHTML = o.I18n.showZoomLabel + " : " + e)
		}, e.
	default = l
	}, function(t, e, i) {
		"use strict";
		Object.defineProperty(e, "__esModule", {
			value: !0
		});
		e.
	default = function() {
			var t = 0,
				e = !1,
				i = !1;
			this.getNextVal = function() {
				var n = 0;
				return e || (e = !0, i || (i = !0, n = t += 1, i = !1, e = !1)), n
			}, this.match = function(e) {
				return t === e || 0 === t
			}
		}
	}, function(t, e, i) {
		"use strict";
		Object.defineProperty(e, "__esModule", {
			value: !0
		}), e.IndoorMap = void 0;
		var n = i(153),
			r = i(154),
			o = i(55),
			s = i(124);
		e.IndoorMap = function(t) {
			var e = t,
				i = null,
				a = null,
				l = null,
				u = null,
				h = {},
				c = {},
				d = function(t, o) {
					var s = [],
						h = [],
						d = [],
						f = !0,
						A = !1,
						p = void 0;
					try {
						for (var g, m = c.buildinfo[Symbol.iterator](); !(f = (g = m.next()).done); f = !0) {
							var v = g.value;
							if (v.hasOwnProperty("wmsLayers") || (v.wmsLayers = ["floor", "region", "subregion"]), t && o && t === v.buildId) {
								var y = !0,
									_ = !1,
									E = void 0;
								try {
									for (var x, C = v.wmsLayers[Symbol.iterator](); !(y = (x = C.next()).done); y = !0) {
										var I = x.value;
										s.push("layer_" + c.parkName + "_" + t + "_" + o + "_" + I)
									}
								} catch (t) {
									_ = !0, E = t
								} finally {
									try {
										!y && C.
										return &&C.
										return ()
									} finally {
										if (_) throw E
									}
								}
							}
							t && o && t === v.buildId && (c.isDoor && h.push("layer_" + c.parkName + "_" + t + "_" + o + "_door"), d.push("layer_" + c.parkName + "_" + t + "_" + o + "_poi"))
						}
					} catch (t) {
						A = !0, p = t
					} finally {
						try {
							!f && m.
							return &&m.
							return ()
						} finally {
							if (A) throw p
						}
					}
					null == i ? i = new n.ServiceLayer(e) : i.removeWmsLayer("indoorWms");
					var S = {
						serviceId: "indoorWms",
						// url: "/WMSServices/loadStdout?serviceName=" + c.wmsServiceName,
						params: {
							VERSION: "1.3.0",
							LAYERS: s
						},
						minShowZoom: 18,
						maxShowZoom: 22
					};
					i.addWmsLayer(S), a && e.removeLayer(a), l && e.removeLayer(l), u && e.removeLayer(u), a = new r.DataServerLayer({
						gisMapObj: e,
						isHover: !0,
						serverType: "WFSSERVER",
						// url: "/WFSServices/loadService?serviceName=" + c.wfsServiceName,
						featureNS: "http://mapserver.gis.umn.edu/mapserver",
						featureType: [],
						dataProjection: "EPSG:4326",
						isRef: !0,
						layerOptions: {
							minShowZoom: 18,
							maxShowZoom: 22,
							strokeColor: c.isDoor ? "rgba(255,255,255,0)" : "#686868",
							strokeWidth: 1.5,
							fillColor: "rgba(255,255,255,0)",
							selFillColor: "transparent",
							selStrokeColor: "rgba(0,252,255,0.8)",
							selStrokeWidth: 4
						}
					}), c.isDoor && (l = new r.DataServerLayer({
						gisMapObj: e,
						isHover: !0,
						serverType: "WFSSERVER",
						// url: "/WFSServices/loadService?serviceName=" + c.wfsServiceName,
						featureNS: "http://mapserver.gis.umn.edu/mapserver",
						featureType: h,
						dataProjection: "EPSG:4326",
						isRef: !0,
						layerOptions: {
							minShowZoom: 18,
							maxShowZoom: 22,
							strokeColor: "#686868",
							strokeWidth: 1.5,
							selStrokeColor: "rgba(0,252,255,0.8)",
							selStrokeWidth: 4
						}
					})), u = new r.DataServerLayer({
						gisMapObj: e,
						isHover: !0,
						serverType: "WFSSERVER",
						// url: "/WFSServices/loadService?serviceName=" + c.wfsServiceName,
						featureNS: "http://mapserver.gis.umn.edu/mapserver",
						featureType: d,
						dataProjection: "EPSG:4326",
						isRef: !1,
						isSpliceUrl: !0,
						layerOptions: {
							minShowZoom: 18,
							maxShowZoom: 22
						}
					})
				},
				f = function() {
					var t = document.getElementById("buildSelObj"),
						e = t.options[t.selectedIndex].value,
						i = document.getElementById("floorBoxs");
					i && document.getElementById("floorInfo").removeChild(i);
					var n = document.createElement("div");
					n.id = "floorBoxs", h[e].map((function(t) {
						var i = document.createElement("li");
						i.innerText = t.floorName, i.setAttribute("id", e + t.floorId), i.addEventListener("click", (function(i) {
							d(e, t.floorId), A(i.target), (0, o.isFunction)(c.switchFloorFunc) && c.switchFloorFunc({
								buildId: e,
								floorId: t.floorId
							})
						})), n.appendChild(i)
					})), document.getElementById("floorInfo").appendChild(n);
					var r = document.getElementById(e + "GroundFloor");
					r && (A(r), document.getElementById(e + "GroundFloor").click())
				},
				A = function(t) {
					for (var e = t.parentNode.children, i = 0, n = e.length; i < n; i++) e[i] === t ? e[i].className = "selected" : e[i].className = ""
				},
				p = function(t, e) {
					for (var i = 0; i < t.options.length; i++) if (t.options[i].value == e) {
						t.options[i].selected = !0;
						break
					}
					t.fireEvent ? t.fireEvent("onchange") : t.onchange && t.onchange()
				};
			this.loadIndoorData = d, this.addFloor = function(t) {
				c = t;
				var i = e.getCurrMap().getTargetElement(),
					n = document.getElementById("floorInfo");
				if (n) for (var r = n.childNodes.length - 1; r >= 0; r--) {
					var o = n.childNodes[r];
					o.onchange = null, n.removeChild(o)
				} else(n = document.createElement("div")).id = "floorInfo";
				var s = document.createElement("select"),
					a = "";
				s.id = "buildSelObj", s.onchange = f, c.buildinfo.map((function(t) {
					a += '<option value="' + t.buildId + '">' + t.buildName + "</option>";
					for (var e = [], i = 0; i < t.floorId.length; i++) e.push({
						floorId: t.floorId[i],
						floorName: t.floorName[i]
					});
					for (var n = [], r = [], o = 0; o < e.length; o++) {
						var s = e[o].floorName.slice(1),
							l = e[o].floorName.slice(0, 1);
						// e[o].value = Number(s), "F" === l ? n.push(e[o]) : "B" === l && r.push(e[o])
						e[o].value = Number(l), Number(l) > 0 ? n.push(e[o]) : r.push(e[o])
					}
					for (var u = 0; u < n.length - 1; u++) for (var c = 0; c < n.length - 1 - u; c++) if (n[c].value > n[c + 1].value) {
						var d = n[c];
						n[c] = n[c + 1], n[c + 1] = d
					}
					for (var f = 0; f < r.length - 1; f++) for (var A = 0; A < r.length - 1 - f; A++) if (r[A].value > r[A + 1].value) {
						var p = r[A];
						r[A] = r[A + 1], r[A + 1] = p
					}
					var g = n.concat(r);
					h[t.buildId] = g
				})), s.innerHTML = a, n.appendChild(s), i.appendChild(n)
			}, this.switchFloor = function(t, e) {
				var i = document.getElementById("buildSelObj");
				p(i, t), document.getElementById(t + e).click()
			}, this.getFloorInfo = function(t) {
				var n = i.serviceObj.indoorWms.getSource().getGetFeatureInfoUrl(t, e.getCurrMap().getView().getResolution(), e.getCurrProjection(), {
					INFO_FORMAT: "text/plain"
				});
				return new Promise((function(i) {
					s.GisUtil.loadJson(n, "text", (function(n) {
						var r = n.substring(n.indexOf("'") + 1, n.indexOf("'", n.indexOf("'") + 1)),
							o = {
								center: e.reTransform(t)
							};
						if (r) {
							var s = r.split("_");
							o.parkName = s[1], o.buildName = s[2], o.floorName = s[3]
						}
						i(o)
					}))
				}))
			}, this.removeIndoor = function() {
				i && (i.removeWmsLayer("indoorWms"), i = null), a && (e.removeLayer(a), a = null), l && (e.removeLayer(l), l = null), u && (e.removeLayer(u), u = null), document.getElementById("buildSelObj").onchange = null, e.getCurrMap().getTargetElement().removeChild(document.getElementById("floorInfo")), h = {}, c = {}, e = null
			}, this.getIndoorLayers = function() {
				return {
					wmsServer: i,
					regionLayer: a,
					doorLayer: l,
					poiLayer: u
				}
			}
		}
	}, function(t, e, i) {
		"use strict";
		i.r(e);
		var n = i(0),
			r = i(51),
			o = i(53),
			s = function(t) {
				var e = t || {};
				o.a.call(this, e), this.type = r.a.IMAGE
			};
		n.
	default.inherits(s, o.a), s.prototype.getSource, e.
	default = s
	}, function(t, e, i) {
		var n = i(177);
		"string" == typeof n && (n = [
			[t.i, n, ""]
		]);
		var r = {
			hmr: !0,
			transform: void 0,
			insertInto: void 0
		};
		i(156)(n, r);
		n.locals && (t.exports = n.locals)
	}, function(t, e, i) {
		(e = i(155)(!1)).push([t.i, '.ol-box {\n  box-sizing: border-box;\n  border-radius: 2px;\n  border: 2px solid blue;\n}\n\n.ol-mouse-position {\n  top: 8px;\n  right: 8px;\n  position: absolute;\n}\n\n.ol-scale-line {\n  background: rgba(0,60,136,0.3);\n  border-radius: 4px;\n  bottom: 22px;\n  left: 8px;\n  padding: 2px;\n  position: absolute;\n}\n.ol-scale-line-inner {\n  border: 1px solid #eee;\n  border-top: none;\n  color: #eee;\n  font-size: 10px;\n  text-align: center;\n  margin: 1px;\n  will-change: contents, width;\n}\n.ol-overlay-container {\n  will-change: left,right,top,bottom;\n}\n\n.ol-unsupported {\n  display: none;\n}\n.ol-viewport, .ol-unselectable {\n  -webkit-touch-callout: none;\n  -webkit-user-select: none;\n  -moz-user-select: none;\n  -ms-user-select: none;\n  user-select: none;\n  -webkit-tap-highlight-color: rgba(0,0,0,0);\n}\n.ol-selectable {\n  -webkit-touch-callout: default;\n  -webkit-user-select: auto;\n  -moz-user-select: auto;\n  -ms-user-select: auto;\n  user-select: auto;\n}\n.ol-grabbing {\n  cursor: -webkit-grabbing;\n  cursor: -moz-grabbing;\n  cursor: grabbing;\n}\n.ol-grab {\n  cursor: move;\n  cursor: -webkit-grab;\n  cursor: -moz-grab;\n  cursor: grab;\n}\n.ol-control {\n  position: absolute;\n  background-color: rgba(255,255,255,0.4);\n  border-radius: 4px;\n  padding: 2px;\n}\n.ol-control:hover {\n  background-color: rgba(255,255,255,0.6);\n}\n.ol-zoom {\n  top: .5em;\n  left: .5em;\n}\n.ol-rotate {\n  top: .5em;\n  right: .5em;\n  transition: opacity .25s linear, visibility 0s linear;\n}\n.ol-rotate.ol-hidden {\n  opacity: 0;\n  visibility: hidden;\n  transition: opacity .25s linear, visibility 0s linear .25s;\n}\n.ol-zoom-extent {\n  top: 4.643em;\n  left: .5em;\n}\n.ol-full-screen {\n  right: .5em;\n  top: .5em;\n}\n@media print {\n  .ol-control {\n    display: none;\n  }\n}\n\n.ol-control button {\n  display: block;\n  margin: 1px;\n  padding: 0;\n  color: white;\n  font-size: 1.14em;\n  font-weight: bold;\n  text-decoration: none;\n  text-align: center;\n  height: 1.375em;\n  width: 1.375em;\n  line-height: .4em;\n  background-color: rgba(0,60,136,0.5);\n  border: none;\n  border-radius: 2px;\n}\n.ol-control button::-moz-focus-inner {\n  border: none;\n  padding: 0;\n}\n.ol-zoom-extent button {\n  line-height: 1.4em;\n}\n.ol-compass {\n  display: block;\n  font-weight: normal;\n  font-size: 1.2em;\n  will-change: transform;\n}\n.ol-touch .ol-control button {\n  font-size: 1.5em;\n}\n.ol-touch .ol-zoom-extent {\n  top: 5.5em;\n}\n.ol-control button:hover,\n.ol-control button:focus {\n  text-decoration: none;\n  background-color: rgba(0,60,136,0.7);\n}\n.ol-zoom .ol-zoom-in {\n  border-radius: 2px 2px 0 0;\n}\n.ol-zoom .ol-zoom-out {\n  border-radius: 0 0 2px 2px;\n}\n\n\n.ol-attribution {\n  text-align: right;\n  bottom: .5em;\n  right: .5em;\n  max-width: calc(100% - 1.3em);\n}\n\n.ol-attribution ul {\n  margin: 0;\n  padding: 0 .5em;\n  font-size: .7rem;\n  line-height: 1.375em;\n  color: #000;\n  text-shadow: 0 0 2px #fff;\n}\n.ol-attribution li {\n  display: inline;\n  list-style: none;\n  line-height: inherit;\n}\n.ol-attribution li:not(:last-child):after {\n  content: " ";\n}\n.ol-attribution img {\n  max-height: 2em;\n  max-width: inherit;\n  vertical-align: middle;\n}\n.ol-attribution ul, .ol-attribution button {\n  display: inline-block;\n}\n.ol-attribution.ol-collapsed ul {\n  display: none;\n}\n.ol-attribution.ol-logo-only ul {\n  display: block;\n}\n.ol-attribution:not(.ol-collapsed) {\n  background: rgba(255,255,255,0.8);\n}\n.ol-attribution.ol-uncollapsible {\n  bottom: 0;\n  display: none;\n  right: 0;\n  border-radius: 4px 0 0;\n  height: 1.1em;\n  line-height: 1em;\n}\n.ol-attribution.ol-logo-only {\n  background: transparent;\n  bottom: .4em;\n  height: 1.1em;\n  line-height: 1em;\n}\n.ol-attribution.ol-uncollapsible img {\n  margin-top: -.2em;\n  max-height: 1.6em;\n}\n.ol-attribution.ol-logo-only button,\n.ol-attribution.ol-uncollapsible button {\n  display: none;\n}\n\n.ol-zoomslider {\n  top: 4.5em;\n  left: .5em;\n  height: 200px;\n}\n.ol-zoomslider button {\n  position: relative;\n  height: 10px;\n}\n\n.ol-touch .ol-zoomslider {\n  top: 5.5em;\n}\n\n.ol-overviewmap {\n  left: 0.5em;\n  bottom: 0.5em;\n}\n.ol-overviewmap.ol-uncollapsible {\n  bottom: 0;\n  left: 0;\n  border-radius: 0 4px 0 0;\n}\n.ol-overviewmap .ol-overviewmap-map,\n.ol-overviewmap button {\n  display: inline-block;\n}\n.ol-overviewmap .ol-overviewmap-map {\n  border: 1px solid #7b98bc;\n  height: 150px;\n  margin: 2px;\n  width: 150px;\n}\n.ol-overviewmap:not(.ol-collapsed) button{\n  bottom: 1px;\n  left: 2px;\n  position: absolute;\n}\n.ol-overviewmap.ol-collapsed .ol-overviewmap-map,\n.ol-overviewmap.ol-uncollapsible button {\n  display: none;\n}\n.ol-overviewmap:not(.ol-collapsed) {\n  background: rgba(255,255,255,0.8);\n}\n.ol-overviewmap-box {\n  border: 2px dotted rgba(0,60,136,0.7);\n}\n\n.ol-overviewmap .ol-overviewmap-box:hover {\n  cursor: move;\n}\n', ""]), t.exports = e
	}, function(t, e) {
		t.exports = function(t) {
			var e = "undefined" != typeof window && window.location;
			if (!e) throw new Error("fixUrls requires window.location");
			if (!t || "string" != typeof t) return t;
			var i = e.protocol + "//" + e.host,
				n = i + e.pathname.replace(/\/[^\/]*$/, "/");
			return t.replace(/url\s*\(((?:[^)(]|\((?:[^)(]+|\([^)(]*\))*\))*)\)/gi, (function(t, e) {
				var r, o = e.trim().replace(/^"(.*)"$/, (function(t, e) {
					return e
				})).replace(/^'(.*)'$/, (function(t, e) {
					return e
				}));
				return /^(#|data:|http:\/\/|https:\/\/|file:\/\/\/|\s*$)/i.test(o) ? t : (r = 0 === o.indexOf("//") ? o : 0 === o.indexOf("/") ? i + o : n + o.replace(/^\.\//, ""), "url(" + JSON.stringify(r) + ")")
			}))
		}
	}, function(t, e, i) {
		var n = i(180);
		"string" == typeof n && (n = [
			[t.i, n, ""]
		]);
		var r = {
			hmr: !0,
			transform: void 0,
			insertInto: void 0
		};
		i(156)(n, r);
		n.locals && (t.exports = n.locals)
	}, function(t, e, i) {
		(e = i(155)(!1)).push([t.i, ".my-mouse-position {\r\n    bottom: 22px;\r\n    right: 8px;\r\n    position: absolute;\r\n    color: #206aff;\r\n    font-weight: bold;\r\n}\r\n\r\n.ol-overviewmap {\r\n    bottom: 2em;\r\n}\r\n\r\n.zoomLevel {\r\n    position: absolute;\r\n    color: #206aff;\r\n    font-weight: bold;\r\n    left: 40%;\r\n    bottom: 22px;\r\n}\r\n\r\n.tooltip {\r\n    position: relative;\r\n    background-color: #FFFFFF;\r\n    border: 1px solid #CCCCCC;\r\n    color: #1A1A1A;\r\n    font-size: 14px;\r\n    padding: 0 4px;\r\n    opacity: 0.8;\r\n    white-space: nowrap;\r\n}\r\n\r\n.deletetip {\r\n    padding: 3px;\r\n}\r\n\r\n.tooltip-static {\r\n    background-color: #FFFFFF;\r\n    color: #1A1A1A;\r\n    border: 1px solid #CCCCCC;\r\n    float: left;\r\n}\r\n\r\n.closetip {\r\n    float: left;\r\n    padding: 3px 5px;\r\n}\r\n\r\n.outMap {\r\n    position: absolute;\r\n    left: 0;\r\n    top: 0;\r\n    right: 0;\r\n    bottom: 0;\r\n}\r\n\r\n#buildSelObj {\r\n    width: 50px;\r\n    height: 30px;\r\n    background-color: teal;\r\n    color: #fff;\r\n    border: 1px solid #59d2d2;\r\n    outline: none;\r\n}\r\n\r\n#floorInfo {\r\n    display: none !important;\r\n    position: absolute;\r\n    transform: translateY(-50%);\r\n    top: 50%;\r\n    right: 10px;\r\n    z-index: 100;\r\n}\r\n\r\n#floorInfo>#floorBoxs {\r\n    display: flex;\r\n    flex-direction: column;\r\n}\r\n\r\n#floorInfo>#floorBoxs>li {\r\n    width: 35px;\r\n    height: 30px;\r\n    margin: -1px auto;\r\n    outline: none;\r\n    cursor: pointer;\r\n    color: #fff;\r\n    border: 1px solid #59d2d2;\r\n    background-color: teal;\r\n    text-align: center;\r\n    list-style: none;\r\n    line-height: 30px;\r\n}\r\n\r\n#floorInfo>#floorBoxs>li.selected {\r\n    color: rgb(87, 193, 177);\r\n    outline-color: rgb(87, 193, 177);\r\n}\r\n\r\n#floorInfo>#floorBoxs>li:hover {\r\n    color: rgb(87, 193, 177);\r\n    outline-color: rgb(87, 193, 177);\r\n}", ""]), t.exports = e
	}, function(t, e, i) {
		"use strict";
		Object.defineProperty(e, "__esModule", {
			value: !0
		});
		var n = i(182);
		Object.keys(n).forEach((function(t) {
			"default" !== t && "__esModule" !== t && Object.defineProperty(e, t, {
				enumerable: !0,
				get: function() {
					return n[t]
				}
			})
		}));
		var r = i(183);
		Object.keys(r).forEach((function(t) {
			"default" !== t && "__esModule" !== t && Object.defineProperty(e, t, {
				enumerable: !0,
				get: function() {
					return r[t]
				}
			})
		}));
		var o = i(184);
		Object.keys(o).forEach((function(t) {
			"default" !== t && "__esModule" !== t && Object.defineProperty(e, t, {
				enumerable: !0,
				get: function() {
					return o[t]
				}
			})
		}));
		var s = i(185);
		Object.keys(s).forEach((function(t) {
			"default" !== t && "__esModule" !== t && Object.defineProperty(e, t, {
				enumerable: !0,
				get: function() {
					return s[t]
				}
			})
		}));
		var a = i(186);
		Object.keys(a).forEach((function(t) {
			"default" !== t && "__esModule" !== t && Object.defineProperty(e, t, {
				enumerable: !0,
				get: function() {
					return a[t]
				}
			})
		}));
		var l = i(187);
		Object.keys(l).forEach((function(t) {
			"default" !== t && "__esModule" !== t && Object.defineProperty(e, t, {
				enumerable: !0,
				get: function() {
					return l[t]
				}
			})
		}));
		var u = i(188);
		Object.keys(u).forEach((function(t) {
			"default" !== t && "__esModule" !== t && Object.defineProperty(e, t, {
				enumerable: !0,
				get: function() {
					return u[t]
				}
			})
		}));
		var h = i(190);
		Object.keys(h).forEach((function(t) {
			"default" !== t && "__esModule" !== t && Object.defineProperty(e, t, {
				enumerable: !0,
				get: function() {
					return h[t]
				}
			})
		}));
		var c = i(191);
		Object.keys(c).forEach((function(t) {
			"default" !== t && "__esModule" !== t && Object.defineProperty(e, t, {
				enumerable: !0,
				get: function() {
					return c[t]
				}
			})
		}));
		var d = i(193);
		Object.keys(d).forEach((function(t) {
			"default" !== t && "__esModule" !== t && Object.defineProperty(e, t, {
				enumerable: !0,
				get: function() {
					return d[t]
				}
			})
		}))
	}, function(t, e, i) {
		"use strict";
		Object.defineProperty(e, "__esModule", {
			value: !0
		}), e.DrawFeature = void 0;
		var n = f(i(33)),
			r = f(i(30)),
			o = f(i(131)),
			s = f(i(157)),
			a = f(i(34)),
			l = f(i(38)),
			u = f(i(36)),
			h = f(i(68)),
			c = function(t) {
				if (t && t.__esModule) return t;
				var e = {};
				if (null != t) for (var i in t) Object.prototype.hasOwnProperty.call(t, i) && (e[i] = t[i]);
				return e.
			default = t, e
			}(i(55)),
			d = i(63);

		function f(t) {
			return t && t.__esModule ? t : {
			default:
				t
			}
		}
		var A = function(t) {
				this.gisMapObj = t.gisMapObj, this.isSnap = t.isSnap || !1, this.snapLayer = t.snapLayer, this.drawObj = null, this.snapObj = null, this.source = new r.
			default ({
					wrapX: !1
				});
				var e = new n.
			default ({
					source: this.source,
					style: new a.
				default ({
						fill: new l.
					default ({
							color: c.isDef(t.fillColor) ? t.fillColor : "rgba(255, 255, 255, 0.4)"
						}),
						stroke:
						new u.
					default ({
							color: c.isDef(t.strokeColor) ? t.strokeColor : "#3399CC",
							width: c.isDef(t.strokeWidth) ? t.strokeWidth : 2
						}),
						image:
						new h.
					default ({
							radius: 5,
							fill: new l.
						default ({
								color: c.isDef(t.strokeColor) ? t.strokeColor : "#3399CC"
							})
						})
					})
				});
				this.gisMapObj.getCurrMap().addLayer(e)
			};
		A.prototype.addDrawFeature = function(t, e) {
			this.drawObj = new o.
		default ({
				source: this.source,
				sides: 7,
				type: "Square" == t ? "Circle" : t,
				geometryFunction: "Square" == t ? o.
			default.createBox():
				""
			}), this.gisMapObj.getCurrMap().addInteraction(this.drawObj);
			var i = this.gisMapObj;
			this.drawObj.on("drawend", (function(t) {
				var n = t.feature.getGeometry().clone();
				i.getTransformInd() && n.transform(i.getCurrProjection(), d.MapConstant.defaultProjection);
				var r = n.getCoordinates();
				c.isDef(r) || (r = {
					radius: 100 * n.getRadius(),
					center: n.getCenter()
				}), c.isFunction(e) && e(r)
			})), 1 == this.isSnap && (this.snapObj = new s.
		default ({
				source: this.snapLayer.sourceObj
			}), this.gisMapObj.getCurrMap().addInteraction(this.snapObj))
		}, A.prototype.removeDrawFeature = function() {
			this.drawObj && (this.source.clear(), this.stopDrawFeature())
		}, A.prototype.stopDrawFeature = function() {
			this.drawObj && (this.gisMapObj.getCurrMap().removeInteraction(this.drawObj), this.drawObj = null), this.snapObj && (this.gisMapObj.getCurrMap().removeInteraction(this.snapObj), this.snapObj = null)
		}, A.prototype.setSnapObjLayer = function(t) {
			this.snapObj && (this.gisMapObj.getCurrMap().removeInteraction(this.snapObj), this.snapObj = new s.
		default ({
				source: t.sourceObj
			}), this.gisMapObj.getCurrMap().addInteraction(this.snapObj))
		}, e.DrawFeature = A
	}, function(t, e, i) {
		"use strict";
		Object.defineProperty(e, "__esModule", {
			value: !0
		}), e.GeoLocation = void 0;
		var n = g(i(33)),
			r = g(i(30)),
			o = g(i(26)),
			s = g(i(34)),
			a = g(i(68)),
			l = g(i(36)),
			u = g(i(38)),
			h = g(i(25)),
			c = g(i(220)),
			d = g(i(101)),
			f = g(i(31)),
			A = i(63),
			p = i(80);

		function g(t) {
			return t && t.__esModule ? t : {
			default:
				t
			}
		}
		e.GeoLocation = function(t) {
			var e = t.gisMapObj,
				i = t.changeFunc,
				g = e.getCurrMap().getView(),
				m = new c.
			default ({
					projection: g.getProjection(),
					tracking: !0
				});
			if (m.on("change", (function() {
				var t = m.getPosition();
				t = e.reTransform(t);
				var n, r = {
					position: t = p.GPSTrans.gcj_decrypt_exactArr(t),
					accuracy: m.getAccuracy(),
					altitude: m.getAltitude(),
					altitudeAccuracy: m.getAltitudeAccuracy(),
					heading: Math.round((n = m.getHeading(), 360 * n / (2 * Math.PI))),
					speed: m.getSpeed()
				};
				i(r)
			})), t.showPosition) {
				var v = new o.
			default,
					y = new o.
				default;
				y.setStyle(new s.
			default ({
					image: new a.
				default ({
						radius: 6,
						fill: new u.
					default ({
							color: t.fillColor || "#3399CC"
						}),
						stroke:
						new l.
					default ({
							color: t.strokeColor || "#fff",
							width: t.strokeWidth || 2
						})
					})
				})), m.on("change:position", (function() {
					var t = m.getPosition(),
						i = [];
					t && (t = e.reTransform(t), i = p.GPSTrans.gcj_decrypt_exactArr(t), t = e.transform(i)), y.setGeometry(t ? new h.
				default (t):
					null);
					var n = new d.
				default (A.MapConstant.mapRadius),
						r = f.
					default.circular(n, i, m.getAccuracy());
					e.getTransformInd() && r.transform(A.MapConstant.defaultProjection, e.getCurrProjection()), v.setGeometry(r)
				})), new n.
			default ({
					map: e.getCurrMap(),
					source: new r.
				default ({
						features: [v, y]
					})
				})
			}
		}
	}, function(t, e, i) {
		"use strict";
		Object.defineProperty(e, "__esModule", {
			value: !0
		}), e.MeasureLine = void 0;
		var n = E(i(101)),
			r = E(i(30)),
			o = E(i(33)),
			s = E(i(34)),
			a = E(i(38)),
			l = E(i(36)),
			u = E(i(68)),
			h = E(i(110)),
			c = E(i(131)),
			d = E(i(9)),
			f = E(i(26)),
			A = E(i(25)),
			p = E(i(58)),
			g = E(i(81)),
			m = i(63),
			v = i(115),
			y = function(t) {
				if (t && t.__esModule) return t;
				var e = {};
				if (null != t) for (var i in t) Object.prototype.hasOwnProperty.call(t, i) && (e[i] = t[i]);
				return e.
			default = t, e
			}(i(55)),
			_ = E(i(130));

		function E(t) {
			return t && t.__esModule ? t : {
			default:
				t
			}
		}
		e.MeasureLine = function(t) {
			var e, i, E, x, C, I, S = y.isDef(t) ? t : {},
				T = S.gisMapObj.getCurrMap(),
				R = S.callBackFunc ? S.callBackFunc : null,
				w = new n.
			default (m.MapConstant.mapRadius),
				L = 0,
				N = [],
				P = [],
				O = new _.
			default,
				M = [],
				b = new _.
			default,
				F = null,
				D = new _.
			default,
				G = [],
				k = new r.
			default,
				U = new o.
			default ({
					source: k,
					style: new s.
				default ({
						fill: new a.
					default ({
							color: "rgba(247,122,59, 1)"
						}),
						stroke:
						new l.
					default ({
							color: "rgba(247,122,59, 1)",
							width: 3
						}),
						image:
						new u.
					default ({
							radius: 4,
							fill: new a.
						default ({
								color: "#FFFFFF"
							}),
							stroke:
							new l.
						default ({
								color: "#FF0000",
								width: 2
							})
						})
					})
				});
			T.addLayer(U);
			var B = function() {
					C && C.parentNode.removeChild(C), (C = document.createElement("div")).className = "tooltip showLength", I = new h.
				default ({
						element: C,
						offset: [0, 5],
						positioning: "top-center"
					}), T.addOverlay(I)
				},
				j = function(t) {
					if (T.getTarget().style.cursor = 'url("data:;base64,AAACAAEAICAAAAMABgCoEAAAFgAAACgAAAAgAAAAQAAAAAEAIAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAAACQAAAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAABcAAAAlAAAAFwAAAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUAAAAXAAAAMwAAAEEAAAAzAAAAFwAAAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAAAFwAAADMuLi//AAAASgAAAEUAAAAzAAAAFwAAAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAABcAAAAzLi4v/+Pj4/8uLi//AAAASgAAAEUAAAAzAAAAFwAAAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUAAAAXAAAAMy4uL//j4+P//////+Pj4/8uLi//AAAASgAAAEUAAAAzAAAAFwAAAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAAAFwAAADMuLi//4+Pj/////////////////+Pj4/8uLi//AAAASgAAAEEAAAAlAAAACQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAABcAAAAzLi4v/+Pj4////////////////////////////+Pj4/8uLi//AAAAMwAAABcAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUAAAAXAAAAMy4uL//j4+P//////////////////////y4uL////////////+Pj4/8uLi//AAAABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAAAFwAAADMuLi//4+Pj/////////////////////////////////y4uL///////Li4v/wAAAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAABcAAAAzLi4v/+Pj4///////////////////////Li4v/////////////////y4uL/8AAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUAAAAXAAAAMy4uL//j4+P///////////8uLi//////////////////Li4v//////8uLi//AAAABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA//8AAP//AAD//wAA//8AAAAAAAAAAAAAAAAAAAAFAAAAFwAAADMuLi//4+Pj//////////////////////8uLi//////////////////Li4v/wAAAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP//AAD//wAA//8AAP//AAD//wAA//8AAAAAAAAAAAAAAAkAAAAlLi4v/+Pj4/////////////////////////////////8uLi///////y4uL/8AAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA//8AAP////////////8AAP//AAD//wAAAAAAAAAAAAAABS4uL//j4+P//////////////////////y4uL/////////////////8uLi//AAAABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD//wAA/////////////wAA//8AAP//AAAAAAAAAAAuLi//4+Pj/////////////////////////////////y4uL///////Li4v/wAAAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP//AAD//wAA//8AAP//AAD//wAA//8AAAAAAAAAAAAAAAAuLi//////////////////Li4v/////////////////y4uL/8AAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP//AAD//wAA//8AAP//AAAAAAAAAAAAAAAAAAAAAAAAAAAuLi//////////////////Li4v//////8uLi//AAAABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAuLi//////////////////Li4v/wAAAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAuLi///////y4uL/8AAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAuLi//AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA//////////////////////////////////////////////////////////////H////g////wH///4A///8AH//+AA///AAP//gAD//wAB//4AA//8AAf/+AAP+HAAH/AwAD/wMAB/8DAA//A4Af/4fAP///4H////D////7//8="), default', !t.dragging) {
						var i = v.I18n.rangeMsg;
						if (e) e.getGeometry() instanceof p.
					default &&(i = v.I18n.continueLineMsg);
						E.innerHTML = i, x.setPosition(t.coordinate)
					}
				},
				V = function(t) {
					if (e) {
						var n = e.getGeometry().getLastCoordinate(),
							r = t.coordinate;
						if (n[0] === r[0] && n[1] === r[1]) {
							var o = new f.
						default ({
								geometry: new A.
							default (t.coordinate)
							});
							k.addFeature(o), M.push(o);
							var s = document.createElement("div");
							s.className = "tooltip click", s.innerHTML = i || "Start";
							var a = new h.
						default ({
								element: s,
								position: t.coordinate,
								offset: [8, 0],
								positioning: "center-left"
							});
							T.addOverlay(a), N.push(a), P.push(a)
						}
					}
				},
				Y = function(t) {
					for (var e = O.get(t), i = b.get(t), n = 0; n < e.length; n++) T.removeOverlay(e[n]);
					for (var r = 0; r < i.length; r++) U.getSource().removeFeature(i[r]);
					T.removeOverlay(D.get(t))
				},
				z = function() {
					T.un("pointermove", j), T.un("click", V), T.getTarget().style.cursor = "", T.removeInteraction(F), T.removeOverlay(x), i = null
				};
			this.addMeasure = function() {
				var t;
				N = [], M = [], O.put(L, N), b.put(L, M), F = new c.
			default ({
					clickTolerance: .1,
					source: k,
					type: "LineString",
					style: new s.
				default ({
						fill: new a.
					default ({
							color: "rgba(247,122,59, 0.5)"
						}),
						stroke:
						new l.
					default ({
							color: "rgba(247,122,59, 0.5)",
							width: 3
						})
					})
				}), T.addInteraction(F), T.on("pointermove", j), T.on("click", V), B(), E && E.parentNode.removeChild(E), (E = document.createElement("div")).className = "tooltip help", x = new h.
			default ({
					element: E,
					offset: [15, 0],
					positioning: "center-left"
				}), T.addOverlay(x), F.on("drawstart", (function(n) {
					e = n.feature;
					var r = n.coordinate;
					t = e.getGeometry().on("change", (function(t) {
						var e = t.target;
						e instanceof p.
					default &&(i = function(t) {
							for (var e = t.getCoordinates(), i = 0, n = T.getView().getProjection(), r = 0, o = e.length - 1; r < o; ++r) {
								var s = d.
							default.transform(e[r], n, "EPSG:4326"),
									a = d.
								default.transform(e[r + 1], n, "EPSG:4326");
								i += w.haversineDistance(s, a)
							}
							return i > 100 ? Math.round(i / 1e3 * 100) / 100 + " km" : Math.round(100 * i) / 100 + " m"
						}(e), r = e.getLastCoordinate()), C.innerHTML = i, I.setPosition(r), P.push(I)
					}))
				}), this), F.on("drawend", (function() {
					M.push(e), C.className = "tooltip deletetip", C.style.cursor = "pointer", C.innerHTML = '<img title="Delete" id = ' + L + ' src = "data:image/gif;base64,R0lGODlhDwAPAJEAAP71+PN9lf///wAAACH5BAEHAAIALAAAAAAPAA8AAAInjI8ZwO1twHpQzvkuxmzz7UShlHEdJVZmSp4QOHYX1UbmyNKywgcFADs=" border="0" width="12" height="12"/>', D.put(L, I), G.push(I), C.childNodes[0].onclick = function(t) {
						var e = t.currentTarget.id;
						Y(e)
					}, e = null, C = null, B(), g.
				default.unByKey(t), setTimeout((function() {
						z()
					}), 100), L++, y.isFunction(R) && R()
				}), this)
			}, this.removeMeasure = function() {
				z(), U.getSource().clear();
				for (var t = 0; t < P.length; t++) T.removeOverlay(P[t]);
				for (var e = 0; e < G.length; e++) T.removeOverlay(G[e]);
				P = [], G = []
			}
		}
	}, function(t, e, i) {
		"use strict";
		Object.defineProperty(e, "__esModule", {
			value: !0
		}), e.MapTips = void 0;
		var n, r = i(110),
			o = (n = r) && n.__esModule ? n : {
			default:
				n
			},
			s = function(t) {
				if (t && t.__esModule) return t;
				var e = {};
				if (null != t) for (var i in t) Object.prototype.hasOwnProperty.call(t, i) && (e[i] = t[i]);
				return e.
			default = t, e
			}(i(55));
		e.MapTips = function(t) {
			var e = t.gisMapObj,
				i = e.getCurrMap(),
				n = new o.
			default ({
					element: t.element,
					offset: s.isArray(t.offset) ? t.offset : [0, 0],
					positioning: s.isDefAndNotNull(t.positioning) ? t.positioning : "top-left",
					stopEvent: !s.isDefAndNotNull(t.stopEvent) || t.stopEvent,
					autoPan: !! s.isDefAndNotNull(t.autoPan) && t.autoPan
				});
			i.addOverlay(n);
			this.setPosition = function(t) {
				if (s.isDef(t)) {
					var i = e.transform(t);
					n.setPosition(i)
				} else n.setPosition(void 0)
			}, this.removeMapTips = function() {
				i.removeOverlay(n)
			}
		}
	}, function(t, e, i) {
		"use strict";
		Object.defineProperty(e, "__esModule", {
			value: !0
		}), e.MeasureArea = void 0;
		var n = v(i(101)),
			r = v(i(30)),
			o = v(i(33)),
			s = v(i(34)),
			a = v(i(38)),
			l = v(i(36)),
			u = v(i(68)),
			h = v(i(110)),
			c = v(i(131)),
			d = v(i(31)),
			f = v(i(81)),
			A = i(63),
			p = i(115),
			g = function(t) {
				if (t && t.__esModule) return t;
				var e = {};
				if (null != t) for (var i in t) Object.prototype.hasOwnProperty.call(t, i) && (e[i] = t[i]);
				return e.
			default = t, e
			}(i(55)),
			m = v(i(130));

		function v(t) {
			return t && t.__esModule ? t : {
			default:
				t
			}
		}
		e.MeasureArea = function(t) {
			var e = g.isDef(t) ? t : {},
				i = e.callBackFunc ? e.callBackFunc : null,
				v = e.gisMapObj.getCurrMap(),
				y = new n.
			default (A.MapConstant.mapRadius),
				_ = null,
				E = null,
				x = null,
				C = null,
				I = null,
				S = [],
				T = new m.
			default,
				R = new m.
			default,
				w = null,
				L = new r.
			default;
			this.settings = {
				drawStrokeColor: "#F9BA9A",
				drawStrokeWidth: 3,
				drawFillColor: "rgba(255,255,255,0.3)",
				strokeColor: "#FD7F44",
				fillColor: "rgba(255, 255, 255, 0.2)",
				strokeWidth: 3
			};
			var N = new o.
		default ({
				source: L,
				style: new s.
			default ({
					fill: new a.
				default ({
						color: this.settings.fillColor
					}),
					stroke:
					new l.
				default ({
						color: this.settings.strokeColor,
						width: this.settings.strokeWidth
					})
				})
			});
			v.addLayer(N);
			var P = function() {
					return C && C.parentNode.removeChild(C), (C = document.createElement("div")).className = "tooltip tooltip-measure", I = new h.
				default ({
						element: C,
						offset: [0, -15],
						positioning: "bottom-center"
					}), v.addOverlay(I), I
				},
				O = function(t) {
					if (v.getTarget().style.cursor = 'url("data:;base64,AAACAAEAICAAAAMABgCoEAAAFgAAACgAAAAgAAAAQAAAAAEAIAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAAACQAAAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAABcAAAAlAAAAFwAAAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUAAAAXAAAAMwAAAEEAAAAzAAAAFwAAAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAAAFwAAADMuLi//AAAASgAAAEUAAAAzAAAAFwAAAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAABcAAAAzLi4v/+Pj4/8uLi//AAAASgAAAEUAAAAzAAAAFwAAAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUAAAAXAAAAMy4uL//j4+P//////+Pj4/8uLi//AAAASgAAAEUAAAAzAAAAFwAAAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAAAFwAAADMuLi//4+Pj/////////////////+Pj4/8uLi//AAAASgAAAEEAAAAlAAAACQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAABcAAAAzLi4v/+Pj4////////////////////////////+Pj4/8uLi//AAAAMwAAABcAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUAAAAXAAAAMy4uL//j4+P//////////////////////y4uL////////////+Pj4/8uLi//AAAABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAAAFwAAADMuLi//4+Pj/////////////////////////////////y4uL///////Li4v/wAAAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAABcAAAAzLi4v/+Pj4///////////////////////Li4v/////////////////y4uL/8AAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUAAAAXAAAAMy4uL//j4+P///////////8uLi//////////////////Li4v//////8uLi//AAAABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA//8AAP//AAD//wAA//8AAAAAAAAAAAAAAAAAAAAFAAAAFwAAADMuLi//4+Pj//////////////////////8uLi//////////////////Li4v/wAAAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP//AAD//wAA//8AAP//AAD//wAA//8AAAAAAAAAAAAAAAkAAAAlLi4v/+Pj4/////////////////////////////////8uLi///////y4uL/8AAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA//8AAP////////////8AAP//AAD//wAAAAAAAAAAAAAABS4uL//j4+P//////////////////////y4uL/////////////////8uLi//AAAABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD//wAA/////////////wAA//8AAP//AAAAAAAAAAAuLi//4+Pj/////////////////////////////////y4uL///////Li4v/wAAAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP//AAD//wAA//8AAP//AAD//wAA//8AAAAAAAAAAAAAAAAuLi//////////////////Li4v/////////////////y4uL/8AAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP//AAD//wAA//8AAP//AAAAAAAAAAAAAAAAAAAAAAAAAAAuLi//////////////////Li4v//////8uLi//AAAABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAuLi//////////////////Li4v/wAAAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAuLi///////y4uL/8AAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAuLi//AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA//////////////////////////////////////////////////////////////H////g////wH///4A///8AH//+AA///AAP//gAD//wAB//4AA//8AAf/+AAP+HAAH/AwAD/wMAB/8DAA//A4Af/4fAP///4H////D////7//8="), default', !t.dragging) {
						var e = p.I18n.helpMsg;
						if (E) E.getGeometry() instanceof d.
					default &&(e = p.I18n.continuePolygonMsg);
						_.innerHTML = e, x.setPosition(t.coordinate)
					}
				},
				M = function() {
					v.removeInteraction(w), v.un("pointermove", O), v.removeOverlay(x)
				};
			this.addMeasure = function() {
				var t;
				w = new c.
			default ({
					clickTolerance: 1e-4,
					source: L,
					type: "Polygon",
					style: new s.
				default ({
						fill: new a.
					default ({
							color: this.settings.drawFillColor
						}),
						stroke:
						new l.
					default ({
							color: this.settings.drawStrokeColor,
							width: this.settings.drawStrokeWidth
						}),
						image:
						new u.
					default ({
							radius: 3,
							stroke: new l.
						default ({
								color: "red",
								width: 3
							}),
							fill:
							new a.
						default ({
								color: "rgba(255, 255, 255, 1)"
							})
						})
					})
				}), v.addInteraction(w), v.on("pointermove", O), S.push(P()), _ && _.parentNode.removeChild(_), (_ = document.createElement("div")).className = "tooltip hidden", x = new h.
			default ({
					element: _,
					offset: [15, 0],
					positioning: "center-left"
				}), v.addOverlay(x), w.on("drawstart", (function(e) {
					E = e.feature;
					var i = e.coordinate;
					t = E.getGeometry().on("change", (function(t) {
						var e, n, r, o, s, a = t.target;
						a instanceof d.
					default &&(n = a, r = v.getView().getProjection(), o = n.clone().transform(r, "EPSG:4326").getLinearRing(0).getCoordinates(), e = (s = Math.abs(y.geodesicArea(o))) > 1e4 ? Math.round(s / 1e6 * 100) / 100 + " km<sup>2</sup>" : Math.round(100 * s) / 100 + " m<sup>2</sup>", i = a.getInteriorPoint().getCoordinates()), C.innerHTML = e, I.setPosition(i)
					}))
				}), this), w.on("drawend", (function() {
					var e = (new Date).getTime();
					E.setId(e);
					var n = document.createElement("div");
					n.innerHTML = '<img title = "Delete" pro = 0 src = "data:image/gif;base64,R0lGODlhDwAPAJEAAP71+PN9lf///wAAACH5BAEHAAIALAAAAAAPAA8AAAInjI8ZwO1twHpQzvkuxmzz7UShlHEdJVZmSp4QOHYX1UbmyNKywgcFADs=" border="0" width="12" height="12"/>', n.className = "tooltip closetip", n.id = e, n.style.cursor = "pointer", C.parentNode.appendChild(n), T.put(e, I), R.put(e, E), n.onclick = function(t) {
						var e = t.currentTarget.id;
						v.removeOverlay(T.get(e)), N.getSource().removeFeature(R.get(e))
					}, C.className = "tooltip tooltip-static", I.setOffset([0, -5]), E = null, C = null, S.push(P()), f.
				default.unByKey(t), setTimeout((function() {
						M()
					}), 100), g.isFunction(i) && i()
				}), this)
			}, this.removeMeasure = function() {
				M(), N.getSource().clear();
				for (var t = 0; t < S.length; t++) v.removeOverlay(S[t])
			}
		}
	}, function(t, e, i) {
		"use strict";
		Object.defineProperty(e, "__esModule", {
			value: !0
		}), e.Animation = void 0;
		var n = y(i(33)),
			r = y(i(30)),
			o = y(i(26)),
			s = y(i(25)),
			a = y(i(105)),
			l = y(i(34)),
			u = y(i(100)),
			h = y(i(68)),
			c = y(i(36)),
			d = y(i(38)),
			f = y(i(1)),
			A = y(i(39)),
			p = i(221),
			g = i(63),
			m = i(124),
			v = i(55);

		function y(t) {
			return t && t.__esModule ? t : {
			default:
				t
			}
		}
		var _ = function(t) {
				this.gisMapObj = t.gisMapObj, this.sourceObj = new r.
			default, this.layerVector = new n.
			default ({
					source: this.sourceObj
				}), this.layerVector.setZIndex(1), this.gisMapObj.getCurrMap().addLayer(this.layerVector)
			};
		_.prototype.startCircleAnimation = function(t, e) {
			var i = new o.
		default (new s.
		default (this.gisMapObj.transform(t))),
				n = this.gisMapObj.getCurrMap();
			return setInterval((function() {
				var t = i.clone();
				t.setStyle(new l.
			default ({
					image: new h.
				default ({
						radius: e,
						stroke: new c.
					default ({
							color: "red",
							width: 2
						})
					})
				})), n.animateFeature(t, new p.ol_featureAnimation_Zoom({
					fade: A.
				default.easeOut,
					duration:
					3e3,
					easing: A.
				default.easeOut
				}))
			}), 500)
		}, _.prototype.stopCircleAnimation = function(t) {
			clearInterval(t)
		}, _.prototype.startSpreadAnimation = function(t, e) {
			var i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : "#FF0000",
				n = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : "rgba(255,0,0,0.1)",
				r = new a.
			default (t);
			e *= 1e3;
			this.gisMapObj.getTransformInd() && r.transform(g.MapConstant.defaultProjection, this.gisMapObj.getCurrProjection());
			var s = new o.
		default (r),
				u = new l.
			default ({
					stroke: new c.
				default ({
						color: i,
						width: 2
					}),
					fill:
					new d.
				default ({
						color: n
					})
				});
			s.setStyle(u), this.sourceObj.addFeature(s);
			var h = function(t) {
					r.setRadius(t)
				},
				f = e / 20,
				A = 1,
				p = setInterval((function() {
					var t = f * A;
					t > e && (t = (f = e / 20) * (A = 1)), h(t), A++
				}), 100);
			return {
				animationObj: p,
				featureObj: s
			}
		}, _.prototype.stopSpreadAnimation = function(t) {
			clearInterval(t.animationObj), this.sourceObj.removeFeature(t.featureObj)
		}, _.prototype.featureMoveAnimation = function(t, e, i, n) {
			var r = new s.
		default (t[0]);
			this.gisMapObj.getTransformInd() && r.transform(g.MapConstant.defaultProjection, this.gisMapObj.getCurrProjection());
			var a = new o.
		default (r),
				h = new l.
			default ({
					image: new u.
				default ({
						src: e,
						rotation: Math.PI / 180 * 45
					})
				});
			a.setStyle(h), this.sourceObj.addFeature(a);
			var c = 0,
				d = this.gisMapObj,
				A = this.sourceObj,
				p = null,
				y = 1e3,
				_ = [],
				E = function() {};
			return {
				start: function() {
					p = setInterval((function() {
						c >= t.length - 1 && !i ? clearInterval(p) : c >= t.length && i && (c = 0);
						var e = [t[c][0], t[c][1]];
						f.
					default.containsXY(d.getMapExtent(), t[c][0], t[c][1]) || d.setMapCenter(e), (0, v.isFunction)(n) && n(e), _.length > 0 && !m.GisUtil.inRing(e, _) && E(e), r.setCoordinates(d.transform(e)), void 0 !== t[c][2] ? h.getImage().setRotation(t[c][2] * (Math.PI / 180)):
						h.getImage().setRotation(0), c++
					}), y)
				},
				stop: function() {
					clearInterval(p), c = 0, A.removeFeature(a)
				},
				pause: function() {
					clearInterval(p)
				},
				setTime: function(t) {
					y = t
				},
				setEnclosure: function(t, e) {
					_ = t, E = e
				}
			}
		}, e.Animation = _
	}, function(t, e, i) {
		"use strict";
		Object.defineProperty(e, "__esModule", {
			value: !0
		}), e.TranslateAndModify = void 0;
		var n = l(i(222)),
			r = l(i(189)),
			o = l(i(157)),
			s = l(i(223)),
			a = l(i(28));

		function l(t) {
			return t && t.__esModule ? t : {
			default:
				t
			}
		}
		var u = function(t) {
				this.gisMapObj = t.gisMapObj
			};
		u.prototype.addTranslateAndModify = function(t, e) {
			"click" == t.conditionType && "move" == t.interactionType ? this.select = new r.
		default ({
				condition: a.
			default.click,
				layers:
				[t.layerObj.layerVector]
			}):
			this.select = new r.
		default ({
				layers: [t.layerObj.layerVector]
			}), this.gisMapObj.getCurrMap().addInteraction(this.select), "move" == t.interactionType ? (this.translate = new s.
		default ({
				features: this.select.getFeatures()
			}), this.gisMapObj.getCurrMap().addInteraction(this.translate), this.translate.on("translateend", (function(t) {
				e(t.features.getArray()[0])
			}))):
			"modify" == t.interactionType && (this.modify = new n.
		default ({
				features: this.select.getFeatures()
			}), this.gisMapObj.getCurrMap().addInteraction(this.modify), this.modify.on("modifyend", (function(t) {
				e(t.features.getArray()[0])
			}), this)), this.snap = new o.
		default ({
				source: t.layerObj.sourceObj
			}), this.gisMapObj.getCurrMap().addInteraction(this.snap)
		}, u.prototype.removeInteraction = function() {
			this.gisMapObj.getCurrMap().removeInteraction(this.select), this.modify && this.gisMapObj.getCurrMap().removeInteraction(this.modify), this.translate && this.gisMapObj.getCurrMap().removeInteraction(this.translate)
		}, e.TranslateAndModify = u
	}, function(t, e, i) {
		"use strict";
		i.r(e);
		var n = i(0),
			r = i(42),
			o = i(10),
			s = i(3),
			a = i(21),
			l = i(28),
			u = i(20),
			h = i(4),
			c = i(29),
			d = i(33),
			f = i(8),
			A = i(30),
			p = i(34),
			g = function(t) {
				c.a.call(this, {
					handleEvent: g.handleEvent
				});
				var e = t || {};
				this.condition_ = e.condition ? e.condition : l.
			default.singleClick, this.addCondition_ = e.addCondition ? e.addCondition:
				l.
			default.never, this.removeCondition_ = e.removeCondition ? e.removeCondition:
				l.
			default.never, this.toggleCondition_ = e.toggleCondition ? e.toggleCondition:
				l.
			default.shiftKeyOnly, this.multi_ = !! e.multi && e.multi, this.filter_ = e.filter ? e.filter:
				u.a.TRUE, this.hitTolerance_ = e.hitTolerance ? e.hitTolerance : 0;
				var i, n = new d.
			default ({
					source: new A.
				default ({
						useSpatialIndex: !1,
						features: e.features,
						wrapX: e.wrapX
					}),
					style:
					e.style ? e.style : g.getDefaultStyleFunction(),
					updateWhileAnimating: !0,
					updateWhileInteracting: !0
				});
				if (this.featureOverlay_ = n, e.layers) if ("function" == typeof e.layers) i = e.layers;
				else {
					var a = e.layers;
					i = function(t) {
						return o.a.includes(a, t)
					}
				} else i = u.a.TRUE;
				this.layerFilter_ = i, this.featureLayerAssociation_ = {};
				var h = this.featureOverlay_.getSource().getFeaturesCollection();
				s.a.listen(h, r.a.ADD, this.addFeature_, this), s.a.listen(h, r.a.REMOVE, this.removeFeature_, this)
			};
		n.
	default.inherits(g, c.a), g.prototype.addFeatureLayerAssociation_ = function(t, e) {
			var i = n.
		default.getUid(t);
			this.featureLayerAssociation_[i] = e
		}, g.prototype.getFeatures = function() {
			return this.featureOverlay_.getSource().getFeaturesCollection()
		}, g.prototype.getHitTolerance = function() {
			return this.hitTolerance_
		}, g.prototype.getLayer = function(t) {
			var e = n.
		default.getUid(t);
			return (this.featureLayerAssociation_[e])
		}, g.handleEvent = function(t) {
			if (!this.condition_(t)) return !0;
			var e = this.addCondition_(t),
				i = this.removeCondition_(t),
				n = this.toggleCondition_(t),
				r = !e && !i && !n,
				s = t.map,
				a = this.featureOverlay_.getSource().getFeaturesCollection(),
				u = [],
				h = [];
			if (r) {
				var c;
				for (f.a.clear(this.featureLayerAssociation_), s.forEachFeatureAtPixel(t.pixel, function(t, e) {
					if (this.filter_(t, e)) return h.push(t), this.addFeatureLayerAssociation_(t, e), !this.multi_
				}.bind(this), {
					layerFilter: this.layerFilter_,
					hitTolerance: this.hitTolerance_
				}), c = a.getLength() - 1; c >= 0; --c) {
					var d = a.item(c),
						A = h.indexOf(d);
					A > -1 ? h.splice(A, 1) : (a.remove(d), u.push(d))
				}
				0 !== h.length && a.extend(h)
			} else {
				var p;
				for (s.forEachFeatureAtPixel(t.pixel, function(t, r) {
					if (this.filter_(t, r)) return !e && !n || o.a.includes(a.getArray(), t) ? (i || n) && o.a.includes(a.getArray(), t) && (u.push(t), this.removeFeatureLayerAssociation_(t)) : (h.push(t), this.addFeatureLayerAssociation_(t, r)), !this.multi_
				}.bind(this), {
					layerFilter: this.layerFilter_,
					hitTolerance: this.hitTolerance_
				}), p = u.length - 1; p >= 0; --p) a.remove(u[p]);
				a.extend(h)
			}
			return (h.length > 0 || u.length > 0) && this.dispatchEvent(new g.Event(g.EventType_.SELECT, h, u, t)), l.
		default.pointerMove(t)
		}, g.prototype.setHitTolerance = function(t) {
			this.hitTolerance_ = t
		}, g.prototype.setMap = function(t) {
			var e = this.getMap(),
				i = this.featureOverlay_.getSource().getFeaturesCollection();
			e && i.forEach(e.unskipFeature, e), c.a.prototype.setMap.call(this, t), this.featureOverlay_.setMap(t), t && i.forEach(t.skipFeature, t)
		}, g.getDefaultStyleFunction = function() {
			var t = p.
		default.createDefaultEditing();
			return o.a.extend(t[h.a.POLYGON], t[h.a.LINE_STRING]), o.a.extend(t[h.a.GEOMETRY_COLLECTION], t[h.a.LINE_STRING]), function(e, i) {
				return e.getGeometry() ? t[e.getGeometry().getType()] : null
			}
		}, g.prototype.addFeature_ = function(t) {
			var e = this.getMap();
			e && e.skipFeature(t.element)
		}, g.prototype.removeFeature_ = function(t) {
			var e = this.getMap();
			e && e.unskipFeature(t.element)
		}, g.prototype.removeFeatureLayerAssociation_ = function(t) {
			var e = n.
		default.getUid(t);
			delete this.featureLayerAssociation_[e]
		}, g.Event = function(t, e, i, n) {
			a.a.call(this, t), this.selected = e, this.deselected = i, this.mapBrowserEvent = n
		}, n.
	default.inherits(g.Event, a.a), g.EventType_ = {
			SELECT: "select"
		}, e.
	default = g
	}, function(t, e, i) {
		"use strict";
		Object.defineProperty(e, "__esModule", {
			value: !0
		}), e.MeasureAngle = void 0;
		var n = y(i(30)),
			r = y(i(33)),
			o = y(i(34)),
			s = y(i(38)),
			a = y(i(36)),
			l = y(i(68)),
			u = y(i(86)),
			h = y(i(110)),
			c = y(i(131)),
			d = y(i(9)),
			f = y(i(26)),
			A = y(i(58)),
			p = y(i(81)),
			g = i(115),
			m = function(t) {
				if (t && t.__esModule) return t;
				var e = {};
				if (null != t) for (var i in t) Object.prototype.hasOwnProperty.call(t, i) && (e[i] = t[i]);
				return e.
			default = t, e
			}(i(55)),
			v = y(i(130));

		function y(t) {
			return t && t.__esModule ? t : {
			default:
				t
			}
		}
		e.MeasureAngle = function(t) {
			var e, i, y, _, E, x = m.isDef(t) ? t : {},
				C = x.gisMapObj.getCurrMap(),
				I = x.callBackFunc ? x.callBackFunc : null,
				S = 0,
				T = [],
				R = [],
				w = new v.
			default,
				L = [],
				N = new v.
			default,
				P = null,
				O = new v.
			default,
				M = [],
				b = new n.
			default,
				F = new r.
			default ({
					source: b,
					style: new o.
				default ({
						fill: new s.
					default ({
							color: "#518bff"
						}),
						stroke:
						new a.
					default ({
							color: "#518bff",
							width: 3
						}),
						image:
						new l.
					default ({
							radius: 4,
							fill: new s.
						default ({
								color: "#FFFFFF"
							}),
							stroke:
							new a.
						default ({
								color: "#FF0000",
								width: 2
							})
						})
					})
				});
			C.addLayer(F);
			var D = function() {
					_ && _.parentNode.removeChild(_), (_ = document.createElement("div")).className = "tooltip showLength", E = new h.
				default ({
						element: _,
						offset: [0, 5],
						positioning: "top-center"
					}), C.addOverlay(E)
				},
				G = function(t) {
					if (C.getTarget().style.cursor = 'url("data:;base64,AAACAAEAICAAAAMABgCoEAAAFgAAACgAAAAgAAAAQAAAAAEAIAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAAACQAAAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAABcAAAAlAAAAFwAAAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUAAAAXAAAAMwAAAEEAAAAzAAAAFwAAAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAAAFwAAADMuLi//AAAASgAAAEUAAAAzAAAAFwAAAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAABcAAAAzLi4v/+Pj4/8uLi//AAAASgAAAEUAAAAzAAAAFwAAAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUAAAAXAAAAMy4uL//j4+P//////+Pj4/8uLi//AAAASgAAAEUAAAAzAAAAFwAAAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAAAFwAAADMuLi//4+Pj/////////////////+Pj4/8uLi//AAAASgAAAEEAAAAlAAAACQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAABcAAAAzLi4v/+Pj4////////////////////////////+Pj4/8uLi//AAAAMwAAABcAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUAAAAXAAAAMy4uL//j4+P//////////////////////y4uL////////////+Pj4/8uLi//AAAABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAAAFwAAADMuLi//4+Pj/////////////////////////////////y4uL///////Li4v/wAAAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAABcAAAAzLi4v/+Pj4///////////////////////Li4v/////////////////y4uL/8AAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUAAAAXAAAAMy4uL//j4+P///////////8uLi//////////////////Li4v//////8uLi//AAAABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA//8AAP//AAD//wAA//8AAAAAAAAAAAAAAAAAAAAFAAAAFwAAADMuLi//4+Pj//////////////////////8uLi//////////////////Li4v/wAAAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP//AAD//wAA//8AAP//AAD//wAA//8AAAAAAAAAAAAAAAkAAAAlLi4v/+Pj4/////////////////////////////////8uLi///////y4uL/8AAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA//8AAP////////////8AAP//AAD//wAAAAAAAAAAAAAABS4uL//j4+P//////////////////////y4uL/////////////////8uLi//AAAABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD//wAA/////////////wAA//8AAP//AAAAAAAAAAAuLi//4+Pj/////////////////////////////////y4uL///////Li4v/wAAAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP//AAD//wAA//8AAP//AAD//wAA//8AAAAAAAAAAAAAAAAuLi//////////////////Li4v/////////////////y4uL/8AAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP//AAD//wAA//8AAP//AAAAAAAAAAAAAAAAAAAAAAAAAAAuLi//////////////////Li4v//////8uLi//AAAABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAuLi//////////////////Li4v/wAAAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAuLi///////y4uL/8AAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAuLi//AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA//////////////////////////////////////////////////////////////H////g////wH///4A///8AH//+AA///AAP//gAD//wAB//4AA//8AAf/+AAP+HAAH/AwAD/wMAB/8DAA//A4Af/4fAP///4H////D////7//8="), default', !t.dragging) {
						var n = g.I18n.rangeMsg;
						if (e) e.getGeometry() instanceof A.
					default &&(n = g.I18n.continueLineMsg);
						i.innerHTML = n, y.setPosition(t.coordinate)
					}
				},
				k = function(t) {
					if (e) {
						var i = e.getGeometry().getLastCoordinate(),
							n = t.coordinate;
						if (i[0] === n[0] && i[1] === n[1]) {
							var r = new f.
						default;
							b.addFeature(r), L.push(r);
							var o = new h.
						default ({
								position: t.coordinate,
								offset: [8, 0],
								positioning: "center-left"
							});
							C.addOverlay(o), T.push(o), R.push(o)
						}
					}
				},
				U = function(t, e, i, n) {
					var r, o, s, a = t,
						l = e,
						u = a[0] - l[0],
						h = a[1] - l[1],
						c = d.
					default.toLonLat(l),
						f = d.
					default.fromLonLat([180, c[1]]),
						p = new A.
					default ([f, l, a]),
						g = j(p),
						m = h / u,
						v = i * (r = m, o = g, s = Math.sqrt(Math.pow(r, 2) / (1 + Math.pow(r, 2))), 360 >= 360 - o && 360 - o >= 180 && (s = -s), s) * .25,
						y = i *
					function(t, e) {
						var i = Math.sqrt(1 / (1 + Math.pow(t, 2)));
						return 270 >= 360 - e && 360 - e >= 90 && (i = -i), i
					}(m, g) * .25;
					n.push([l[0] + y, l[1] + v])
				},
				B = function(t) {
					return Math.PI * t / 180
				},
				j = function(t) {
					var e = t.getCoordinates();
					if (!(e.length - 1 < 2)) {
						var i = d.
					default.toLonLat(e[0]),
							n = d.
						default.toLonLat(e[1]),
							r = d.
						default.toLonLat(e[2]),
							o = B(i[1] - n[1]) * B(r[0] - n[0]) - B(r[1] - n[1]) * B(i[0] - n[0]),
							s = B(i[1] - n[1]) * B(r[1] - n[1]) + B(i[0] - n[0]) * B(r[0] - n[0]),
							a = Math.atan2(o, s) * (180 / Math.PI);
						return a < 0 ? 360 + a:
						a
					}
					return 0
				};
			var V = function(t) {
					for (var e = w.get(t), i = N.get(t), n = 0; n < e.length; n++) C.removeOverlay(e[n]);
					for (var r = 0; r < i.length; r++) F.getSource().removeFeature(i[r]);
					C.removeOverlay(O.get(t))
				},
				Y = function() {
					C.un("pointermove", G), C.un("click", k), C.getTarget().style.cursor = "", C.removeInteraction(P), C.removeOverlay(y)
				};
			this.addMeasure = function() {
				var t;
				T = [], L = [], w.put(S, T), N.put(S, L), P = new c.
			default ({
					clickTolerance: .1,
					source: b,
					type: "LineString",
					style: new o.
				default ({
						fill: new s.
					default ({
							color: "#518bff"
						}),
						stroke:
						new a.
					default ({
							color: "#518bff",
							width: 3
						})
					})
				}), C.addInteraction(P), C.on("pointermove", G), C.on("click", k), D(), i && i.parentNode.removeChild(i), (i = document.createElement("div")).className = "tooltip help", y = new h.
			default ({
					element: i,
					offset: [15, 0],
					positioning: "center-left"
				}), C.addOverlay(y), P.on("drawstart", (function(i) {
					e = i.feature;
					var n = i.coordinate;
					t = e.getGeometry().on("change", (function(t) {
						var e = t.target;
						e instanceof A.
					default &&(n = e.getLastCoordinate()), E.setPosition(n), R.push(E)
					}))
				}), this), P.on("drawend", (function(e) {
					L.push(e.feature);
					var i = e.feature.getGeometry(),
						n = i.getCoordinates().slice(0, 3);
					e.feature.getGeometry().setCoordinates(n);
					var r, h, c, g = j(i),
						v = i.getCoordinates();
					g <= 180 ? (r = v[0], h = v[1], c = v[2]) : (g = 360 - g, r = v[2], h = v[1], c = v[0]);
					var y, x = r[0] - h[0],
						C = r[1] - h[1],
						T = c[0] - h[0],
						R = c[1] - h[1],
						w = Math.sqrt(Math.pow(x, 2) + Math.pow(C, 2)),
						N = Math.sqrt(Math.pow(T, 2) + Math.pow(R, 2));
					if (0 !== (y = w >= N ? N : w)) {
						var P = d.
					default.toLonLat(h),
							F = d.
						default.fromLonLat([P[0], 85]),
							G = [];
						U(r, h, y, G), G.push(h), U(c, h, y, G);
						var k = new A.
					default (G),
							B = new A.
						default ([F, h, G[2]]),
							z = j(B),
							X = j(k),
							W = z - X / 2,
							q = 6.5 *
						function(t) {
							var e = t.getCoordinates(),
								i = e.slice(0, 2),
								n = e.slice(1),
								r = new A.
							default (i),
								o = new A.
							default (n),
								s = r.getLength(),
								a = o.getLength();
							return s <= a ? s:
							a
						}(k) / 7 / 1e5, H = function(t, e, i, n, r, o) {
							var s = o / 10,
								a = 10 * Math.PI / 180,
								l = Math.PI / 2 - (r + o / 2) / 180 * Math.PI,
								u = 0,
								h = 0,
								c = [];
							c.push([e, i]);
							for (var d = 0; d <= s; ++d) u = e + n * Math.cos(l), h = t ? i + n * Math.sin(l) * Math.cos(i * Math.PI / 180) : i + n * Math.sin(l), c.push([u, h]), l += a;
							return c.push([e, i]), c
						}(!1, P[0], P[1], q, W, X), Z = H.slice(1, H.length - 1), K = [];
						Z.forEach((function(t) {
							var e = d.
						default.fromLonLat(t);
							K.push(e)
						}));
						var J = new A.
					default (K),
							Q = new f.
						default ({
								geometry: J
							});
						Q.setStyle(new o.
					default ({
							fill: new s.
						default ({
								color: "#518bff"
							}),
							stroke:
							new a.
						default ({
								color: "#518bff",
								width: 3
							}),
							text:
							new u.
						default ({
								font: "italic bold 16px Calibri,sans-serif",
								text: g.toFixed(2) + "°",
								fill: new s.
							default ({
									color: "#ff0000"
								})
							}),
							image:
							new l.
						default ({
								radius: 7,
								fill: new s.
							default ({
									color: "#518bff"
								})
							})
						})), b.addFeature(Q), e.feature = null, _.className = "tooltip deletetip", _.style.cursor = "pointer", _.innerHTML = '<img title="Delete" id = ' + S + ' src = "data:image/gif;base64,R0lGODlhDwAPAJEAAP71+PN9lf///wAAACH5BAEHAAIALAAAAAAPAA8AAAInjI8ZwO1twHpQzvkuxmzz7UShlHEdJVZmSp4QOHYX1UbmyNKywgcFADs=" border="0" width="12" height="12"/>', O.put(S, E), M.push(E), _.childNodes[0].onclick = function(t) {
							var e = t.currentTarget.id;
							V(e), b.removeFeature(Q)
						}
					}
					e.feature = null, _ = null, D(), p.
				default.unByKey(t), setTimeout((function() {
						Y()
					}), 100), S++, m.isFunction(I) && I()
				}), this)
			}, this.removeMeasure = function() {
				Y(), F.getSource().clear();
				for (var t = 0; t < R.length; t++) C.removeOverlay(R[t]);
				for (var e = 0; e < M.length; e++) C.removeOverlay(M[e]);
				R = [], M = []
			}
		}
	}, function(t, e, i) {
		"use strict";
		Object.defineProperty(e, "__esModule", {
			value: !0
		}), e.EditLayer = void 0;
		var n, r = i(192),
			o = (n = r) && n.__esModule ? n : {
			default:
				n
			};
		var s = function(t) {
				this.gisMapObj = t.gisMapObj
			};
		s.prototype.addEdit = function(t, e) {
			this.interaction = new o.
		default ({
				hitTolerance: 2,
				scale: t.isScale,
				rotate: t.isRotate,
				stretch: t.isStretch,
				translate: t.isTranslate,
				keepAspectRatio: function() {
					return !0
				},
				translateFeature: t.isTranslateFeature,
				layers: t.layerObj.layerVector
			}), this.gisMapObj.getCurrMap().addInteraction(this.interaction), this.interaction.on(["rotateend", "translateend", "scaleend"], (function(t) {
				e(t.feature)
			}))
		}, s.prototype.removeEdit = function() {
			this.gisMapObj.getCurrMap().removeInteraction(this.interaction)
		}, e.EditLayer = s
	}, function(t, e, i) {
		"use strict";
		i.r(e);
		var n = i(0),
			r = i(34),
			o = i(36),
			s = i(30),
			a = i(38),
			l = i(33),
			u = i(25),
			h = i(26),
			c = i(27),
			d = i(23),
			f = i(92),
			A = i(31),
			p = i(1),
			g = function(t) {
				t || (t = {});
				var e = this;
				this.handles_ = new c.
			default, this.overlayLayer_ = new l.
			default ({
					source: new s.
				default ({
						features: this.handles_,
						useSpatialIndex: !1
					}),
					name:
					"Transform overlay",
					displayInLayerSwitcher: !1,
					style: function(t) {
						return e.style[(t.get("handle") || "default") + (t.get("constraint") || "") + (t.get("option") || "")]
					}
				}), d.a.call(this, {
					handleDownEvent: this.handleDownEvent_,
					handleDragEvent: this.handleDragEvent_,
					handleMoveEvent: this.handleMoveEvent_,
					handleUpEvent: this.handleUpEvent_
				}), this.features_ = t.features, this.layers_ = t.layers ? t.layers instanceof Array ? t.layers:
				[t.layers] : null, this.addFn_ = t.addCondition ||
				function() {
					return !1
				}, this.set("translateFeature", !1 !== t.translateFeature), this.set("translate", !1 !== t.translate), this.set("stretch", !1 !== t.stretch), this.set("scale", !1 !== t.scale), this.set("rotate", !1 !== t.rotate), this.set("keepAspectRatio", t.keepAspectRatio ||
				function(t) {
					return t.originalEvent.shiftKey
				}), this.set("modifyCenter", t.modifyCenter ||
				function(t) {
					return t.originalEvent.metaKey || t.originalEvent.ctrlKey
				}), this.set("hitTolerance", t.hitTolerance || 0), this.selection_ = [], this.on("propertychange", (function() {
					this.drawSketch_()
				})), this.setDefaultStyle()
			};
		n.
	default.inherits(g, d.a), g.prototype.Cursors = {
		default:
			"auto", select: "pointer",
			translate: "move",
			rotate: "move",
			rotate0: "move",
			scale: "nesw-resize",
			scale1: "nwse-resize",
			scale2: "nesw-resize",
			scale3: "nwse-resize",
			scalev: "ew-resize",
			scaleh1: "ns-resize",
			scalev2: "ew-resize",
			scaleh3: "ns-resize"
		}, g.prototype.setMap = function(t) {
			this.getMap() && this.getMap().removeLayer(this.overlayLayer_), d.a.prototype.setMap.call(this, t), this.overlayLayer_.setMap(t), null !== t && (this.isTouch = /touch/.test(t.getViewport().className), this.setDefaultStyle())
		}, g.prototype.setActive = function(t) {
			this.select(null), this.overlayLayer_.setVisible(t), d.a.prototype.setActive.call(this, t)
		}, g.prototype.setDefaultStyle = function() {
			var t = new o.
		default ({
				color: [255, 0, 0, 1],
				width: 1
			}),
				e = new o.
			default ({
					color: [255, 0, 0, 1],
					width: 1,
					lineDash: [4, 4]
				}),
				i = new a.
			default ({
					color: [255, 0, 0, .01]
				}),
				n = new a.
			default ({
					color: [255, 255, 255, .8]
				}),
				s = new f.a({
					fill: n,
					stroke: t,
					radius: this.isTouch ? 12 : 6,
					points: 15
				});
			s.getAnchor()[0] = this.isTouch ? -10:
			-5;
			var l = new f.a({
				fill: n,
				stroke: t,
				radius: this.isTouch ? 16 : 8,
				points: 4,
				angle: Math.PI / 4
			}),
				u = new f.a({
					fill: n,
					stroke: t,
					radius: this.isTouch ? 12 : 6,
					points: 4,
					angle: Math.PI / 4
				});

			function h(t, e, i) {
				return [new r.
			default ({
					image: t,
					stroke: e,
					fill: i
				})]
			}
			this.style = {
			default:
				h(l, e, i), translate: h(l, t, n),
				rotate: h(s, t, n),
				rotate0: h(l, t, n),
				scale: h(l, t, n),
				scale1: h(l, t, n),
				scale2: h(l, t, n),
				scale3: h(l, t, n),
				scalev: h(u, t, n),
				scaleh1: h(u, t, n),
				scalev2: h(u, t, n),
				scaleh3: h(u, t, n)
			}, this.drawSketch_()
		}, g.prototype.setStyle = function(t, e) {
			if (e) {
				this.style[t] = e instanceof Array ? e : [e];
				for (var i = 0; i < this.style[t].length; i++) {
					var n = this.style[t][i].getImage();
					n && ("rotate" == t && (n.getAnchor()[0] = -5), this.isTouch && n.setScale(1.8));
					var r = this.style[t][i].getText();
					r && ("rotate" == t && r.setOffsetX(this.isTouch ? 14 : 7), this.isTouch && r.setScale(1.8))
				}
				this.drawSketch_()
			}
		}, g.prototype.getFeatureAtPixel_ = function(t) {
			var e = this;
			return this.getMap().forEachFeatureAtPixel(t, (function(t, i) {
				var n = !1;
				if (!i) {
					if (t === e.bbox_) return !1;
					if (e.handles_.forEach((function(e) {
						e === t && (n = !0)
					})), n) return {
						feature: t,
						handle: t.get("handle"),
						constraint: t.get("constraint"),
						option: t.get("option")
					}
				}
				if (e.layers_) {
					for (var r = 0; r < e.layers_.length; r++) if (e.layers_[r] === i) return {
						feature: t
					};
					return null
				}
				return e.features_ ? (e.features_.forEach((function(e) {
					e === t && (n = !0)
				})), n ? {
					feature: t
				} : null) : {
					feature: t
				}
			}), {
				hitTolerance: this.get("hitTolerance")
			}) || {}
		}, g.prototype.drawSketch_ = function(t) {
			if (this.overlayLayer_.getSource().clear(), this.selection_.length) {
				var e = this.selection_[0].getGeometry().getExtent();
				e = p.
			default.buffer(e, 0);
				for (var i = 1; r = this.selection_[i]; i++) p.
			default.extend(e, r.getGeometry().getExtent());
				if (!0 === t) {
					if (!this.ispt_) {
						this.overlayLayer_.getSource().addFeature(new h.
					default ({
							geometry: new u.
						default (this.center_),
							handle:
							"rotate0"
						}));
						var n = A.
					default.fromExtent(e),
							r = this.bbox_ = new h.
						default (n);
						this.overlayLayer_.getSource().addFeature(r)
					}
				} else {
					if (this.ispt_) {
						var o = this.getMap().getPixelFromCoordinate([e[0], e[1]]);
						e = p.
					default.boundingExtent([this.getMap().getCoordinateFromPixel([o[0] - 10, o[1] - 10]), this.getMap().getCoordinateFromPixel([o[0] + 10, o[1] + 10])])
					}
					n = A.
				default.fromExtent(e), r = this.bbox_ = new h.
				default (n);
					var s = [],
						a = n.getCoordinates()[0];
					if (!this.ispt_) {
						if (s.push(r), this.get("stretch") && this.get("scale")) for (i = 0; i < a.length - 1; i++) r = new h.
					default ({
							geometry: new u.
						default ([(a[i][0] + a[i + 1][0]) / 2, (a[i][1] + a[i + 1][1]) / 2]),
							handle:
							"scale",
							constraint: i % 2 ? "h" : "v",
							option: i
						}), s.push(r);
						if (this.get("scale")) for (i = 0; i < a.length - 1; i++) r = new h.
					default ({
							geometry: new u.
						default (a[i]),
							handle:
							"scale",
							option: i
						}), s.push(r);
						this.get("translate") && !this.get("translateFeature") && (r = new h.
					default ({
							geometry: new u.
						default ([(a[0][0] + a[2][0]) / 2, (a[0][1] + a[2][1]) / 2]),
							handle:
							"translate"
						}), s.push(r))
					}
					this.get("rotate") && (r = new h.
				default ({
						geometry: new u.
					default (a[3]),
						handle:
						"rotate"
					}), s.push(r)), this.overlayLayer_.getSource().addFeatures(s)
				}
			}
		}, g.prototype.select = function(t, e) {
			t ? t.getGeometry && t.getGeometry() && (e ? this.selection_.push(t) : this.selection_ = [t], this.ispt_ = 1 === this.selection_.length && "Point" == this.selection_[0].getGeometry().getType(), this.drawSketch_(), this.dispatchEvent({
				type: "select",
				feature: t,
				features: this.selection_
			})) : this.selection_ = []
		}, g.prototype.handleDownEvent_ = function(t) {
			var e = this.getFeatureAtPixel_(t.pixel),
				i = e.feature;
			if (this.selection_.length && this.selection_.indexOf(i) >= 0 && (this.ispt_ && this.get("translate") || this.get("translateFeature")) && (e.handle = "translate"), e.handle) {
				this.mode_ = e.handle, this.opt_ = e.option, this.constraint_ = e.constraint, this.coordinate_ = t.coordinate, this.pixel_ = t.pixel, this.geoms_ = [];
				for (var n, r = p.
			default.createEmpty(), o = 0; n = this.selection_[o]; o++) this.geoms_.push(n.getGeometry().clone()), r = p.
			default.extend(r, n.getGeometry().getExtent());
				if (this.extent_ = A.
			default.fromExtent(r).getCoordinates()[0], "rotate" === this.mode_) {
					this.center_ = this.getCenter() || p.
				default.getCenter(r);
					var s = t.map.getTargetElement();
					s.style.cursor = this.Cursors.rotate0, this.previousCursor_ = s.style.cursor
				} else this.center_ = p.
			default.getCenter(r);
				return this.angle_ = Math.atan2(this.center_[1] - t.coordinate[1], this.center_[0] - t.coordinate[0]), this.dispatchEvent({
					type: this.mode_ + "start",
					feature: this.selection_[0],
					features: this.selection_,
					pixel: t.pixel,
					coordinate: t.coordinate
				}), !0
			}
			if (i) {
				this.addFn_(t) || (this.selection_ = []);
				var a = this.selection_.indexOf(i);
				a < 0 ? this.selection_.push(i) : this.selection_.splice(a, 1)
			} else this.selection_ = [];
			return this.ispt_ = 1 === this.selection_.length && "Point" == this.selection_[0].getGeometry().getType(), this.drawSketch_(), this.dispatchEvent({
				type: "select",
				feature: i,
				features: this.selection_,
				pixel: t.pixel,
				coordinate: t.coordinate
			}), !1
		}, g.prototype.getFeatures = function() {
			return this.selection_
		}, g.prototype.getCenter = function() {
			return this.get("center")
		}, g.prototype.setCenter = function(t) {
			return this.set("center", t)
		}, g.prototype.handleDragEvent_ = function(t) {
			switch (this.mode_) {
			case "rotate":
				var e = Math.atan2(this.center_[1] - t.coordinate[1], this.center_[0] - t.coordinate[0]);
				if (!this.ispt) for (var i = 0; l = this.selection_[i]; i++) {
					(u = this.geoms_[i].clone()).rotate(e - this.angle_, this.center_), l.setGeometry(u)
				}
				this.drawSketch_(!0), this.dispatchEvent({
					type: "rotating",
					feature: this.selection_[0],
					features: this.selection_,
					angle: e - this.angle_,
					pixel: t.pixel,
					coordinate: t.coordinate
				});
				break;
			case "translate":
				var n = t.coordinate[0] - this.coordinate_[0],
					r = t.coordinate[1] - this.coordinate_[1];
				for (i = 0; l = this.selection_[i]; i++) l.getGeometry().translate(n, r);
				this.handles_.forEach((function(t) {
					t.getGeometry().translate(n, r)
				})), this.coordinate_ = t.coordinate, this.dispatchEvent({
					type: "translating",
					feature: this.selection_[0],
					features: this.selection_,
					delta: [n, r],
					pixel: t.pixel,
					coordinate: t.coordinate
				});
				break;
			case "scale":
				var o = this.center_;
				this.get("modifyCenter")(t) && (o = this.extent_[(Number(this.opt_) + 2) % 4]);
				var s = (t.coordinate[0] - o[0]) / (this.coordinate_[0] - o[0]),
					a = (t.coordinate[1] - o[1]) / (this.coordinate_[1] - o[1]);
				this.constraint_ ? "h" == this.constraint_ ? s = 1 : a = 1 : this.get("keepAspectRatio")(t) && (s = a = Math.min(s, a));
				var l;
				for (i = 0; l = this.selection_[i]; i++) {
					var u;
					(u = this.geoms_[i].clone()).applyTransform((function(t, e, i) {
						if (i < 2) return e;
						for (var n = 0; n < t.length; n += i) 1 != s && (e[n] = o[0] + (t[n] - o[0]) * s), 1 != a && (e[n + 1] = o[1] + (t[n + 1] - o[1]) * a);
						return e
					})), l.setGeometry(u)
				}
				this.drawSketch_(), this.dispatchEvent({
					type: "scaling",
					feature: this.selection_[0],
					features: this.selection_,
					scale: [s, a],
					pixel: t.pixel,
					coordinate: t.coordinate
				})
			}
		}, g.prototype.handleMoveEvent_ = function(t) {
			if (!this.mode_) {
				t.map;
				var e = this.getFeatureAtPixel_(t.pixel),
					i = t.map.getTargetElement();
				if (e.feature) {
					var n = e.handle ? this.Cursors[(e.handle || "default") + (e.constraint || "") + (e.option || "")] : this.Cursors.select;
					void 0 === this.previousCursor_ && (this.previousCursor_ = i.style.cursor), i.style.cursor = n
				} else void 0 !== this.previousCursor_ && (i.style.cursor = this.previousCursor_), this.previousCursor_ = void 0
			}
		}, g.prototype.handleUpEvent_ = function(t) {
			"rotate" === this.mode_ && (t.map.getTargetElement().style.cursor = this.Cursors.
		default, this.previousCursor_ = void 0);
			return this.dispatchEvent({
				type: this.mode_ + "end",
				feature: this.selection_[0],
				features: this.selection_,
				oldgeom: this.geoms_[0],
				oldgeoms: this.geoms_
			}), this.drawSketch_(), this.mode_ = null, !1
		}, e.
	default = g
	}, function(t, e, i) {
		"use strict";
		Object.defineProperty(e, "__esModule", {
			value: !0
		}), e.DrawShapeFeature = void 0;
		var n = s(i(30)),
			r = s(i(33)),
			o = s(i(194));

		function s(t) {
			return t && t.__esModule ? t : {
			default:
				t
			}
		}
		var a = function(t) {
				this.gisMapObj = t.gisMapObj, this.source = new n.
			default ({
					wrapX: !1
				});
				var e = new r.
			default ({
					source: this.source
				});
				this.gisMapObj.getCurrMap().addLayer(e), this.interaction = null
			};
		a.prototype.addCreate = function(t, e) {
			this.interaction = new o.
		default ({
				source: this.source,
				sides: t.sides
			}), this.gisMapObj.getCurrMap().addInteraction(this.interaction), this.interaction.on("drawend", (function(t) {
				e(t.feature)
			}))
		}, a.prototype.removeCreate = function() {
			this.interaction && (this.source.clear(), this.gisMapObj.getCurrMap().removeInteraction(this.interaction))
		}, e.DrawShapeFeature = a
	}, function(t, e, i) {
		"use strict";
		i.r(e);
		var n = i(0),
			r = i(29),
			o = i(34),
			s = i(68),
			a = i(36),
			l = i(38),
			u = i(27),
			h = i(33),
			c = i(30),
			d = i(105),
			f = i(31),
			A = i(58),
			p = i(25),
			g = i(26),
			m = function(t) {
				t || (t = {});
				this.squaredClickTolerance_ = t.clickTolerance ? t.clickTolerance * t.clickTolerance : 36, this.maxCircleCoordinates_ = t.maxCircleCoordinates || 100, this.features_ = t.features, this.source_ = t.source, this.squareFn_ = t.squareCondition, this.centeredFn_ = t.centerCondition, this.canRotate_ = !1 !== t.canRotate, this.geometryName_ = t.geometryName, this.setSides(t.sides);
				var e = [255, 255, 255, 1],
					i = [0, 153, 255, 1],
					n = [new o.
				default ({
						stroke: new a.
					default ({
							color: e,
							width: 5
						})
					}), new o.
				default ({
						image: new s.
					default ({
							radius: 6,
							fill: new l.
						default ({
								color: i
							}),
							stroke:
							new a.
						default ({
								color: e,
								width: 1.5
							})
						}),
						stroke:
						new a.
					default ({
							color: i,
							width: 3
						}),
						fill:
						new l.
					default ({
							color: [255, 255, 255, .5]
						})
					})];
				this.sketch_ = new u.
			default, this.overlayLayer_ = new h.
			default ({
					source: new c.
				default ({
						features: this.sketch_,
						useSpatialIndex: !1
					}),
					name:
					"DrawRegular overlay",
					displayInLayerSwitcher: !1,
					style: t.style || n
				}), r.a.call(this, {
					handleEvent: this.handleEvent_
				})
			};
		n.
	default.inherits(m, r.a), m.prototype.setMap = function(t) {
			this.getMap() && this.getMap().removeLayer(this.overlayLayer_), r.a.prototype.setMap.call(this, t), this.overlayLayer_.setMap(t)
		}, m.prototype.setActive = function(t) {
			this.reset(), r.a.prototype.setActive.call(this, t)
		}, m.prototype.reset = function() {
			this.overlayLayer_.getSource().clear(), this.started_ = !1
		}, m.prototype.setSides = function(t) {
			t = parseInt(t), this.sides_ = t > 2 ? t : 0
		}, m.prototype.canRotate = function(t) {
			return !0 !== t && !1 !== t || (this.canRotate_ = t), this.canRotate_
		}, m.prototype.getSides = function() {
			return this.sides_
		}, m.prototype.startAngle = {
		default:
			Math.PI / 2, 3: -Math.PI / 2,
			4: Math.PI / 4
		}, m.prototype.getGeom_ = function() {
			if (this.overlayLayer_.getSource().clear(), !this.center_) return !1;
			var t;
			if (this.coord_) {
				var e = this.center_,
					i = this.coord_;
				if (!this.sides_ && this.square_ && !this.centered_) {
					e = [(i[0] + e[0]) / 2, (i[1] + e[1]) / 2];
					var n = [i[0] - e[0], i[1] - e[1]],
						r = Math.sqrt(n[0] * n[0] + n[1] * n[1]),
						o = new d.
					default (e, r, "XY"),
						s = this.getMap().getPixelFromCoordinate(e),
						a = Math.max(100, Math.abs(s[0] - this.coordPx_[0]), Math.abs(s[1] - this.coordPx_[1]));
					return a = Math.min(this.maxCircleCoordinates_, Math.round(a / 3)), f.
				default.fromCircle(o, a, 0)
				}
				var l = this.canRotate_ && this.centered_ && this.square_;
				n = [i[0] - e[0], i[1] - e[1]];
				if (this.square_ && !l) {
					var u = Math.max(Math.abs(n[0]), Math.abs(n[1]));
					i[0] = e[0] + (n[0] > 0 ? u : -u), i[1] = e[1] + (n[1] > 0 ? u : -u)
				}
				if ((r = Math.sqrt(n[0] * n[0] + n[1] * n[1])) > 0) {
					var h;
					o = new d.
				default (e, r, "XY");
					if (h = l ? Math.atan2(n[1], n[0]) : this.startAngle[this.sides_] || this.startAngle.
				default, this.sides_) t = f.
				default.fromCircle(o, this.sides_, h);
					else {
						s = this.getMap().getPixelFromCoordinate(this.center_), a = Math.max(100, Math.abs(s[0] - this.coordPx_[0]), Math.abs(s[1] - this.coordPx_[1]));
						a = Math.min(this.maxCircleCoordinates_, Math.round(a / (this.centered_ ? 3 : 5))), t = f.
					default.fromCircle(o, a, 0)
					}
					if (l) return t;
					var c = t.getExtent(),
						A = ((e = this.centered_ ? [2 * this.center_[0] - this.coord_[0], 2 * this.center_[1] - this.coord_[1]] : this.center_)[0] - i[0]) / (c[0] - c[2]),
						g = (e[1] - i[1]) / (c[1] - c[3]);
					if (this.square_) {
						var m = Math.min(Math.abs(A), Math.abs(g));
						A = Math.sign(A) * m, g = Math.sign(g) * m
					}
					var v = [e[0] - c[0] * A, e[1] - c[1] * g];
					return t.applyTransform((function(t, e, i) {
						for (var n = 0; n < t.length; n += i) e[n] = t[n] * A + v[0], e[n + 1] = t[n + 1] * g + v[1];
						return e
					})), t
				}
			}
			return new p.
		default (this.center_)
		}, m.prototype.drawSketch_ = function(t) {
			if (this.overlayLayer_.getSource().clear(), t) {
				this.square_ = this.squareFn_ ? this.squareFn_(t) : t.originalEvent.shiftKey, this.centered_ = this.centeredFn_ ? this.centeredFn_(t) : t.originalEvent.metaKey || t.originalEvent.ctrlKey;
				var e = this.getGeom_();
				if (e) {
					var i = this.feature_;
					return this.geometryName_ && i.setGeometryName(this.geometryName_), i.setGeometry(e), this.overlayLayer_.getSource().addFeature(i), this.coord_ && this.square_ && (this.canRotate_ && this.centered_ && this.coord_ || !this.sides_ && !this.centered_) && this.overlayLayer_.getSource().addFeature(new g.
				default (new A.
				default ([this.center_, this.coord_]))), i
				}
			}
		}, m.prototype.drawPoint_ = function(t, e) {
			e || this.overlayLayer_.getSource().clear(), this.overlayLayer_.getSource().addFeature(new g.
		default (new p.
		default (t)))
		}, m.prototype.handleEvent_ = function(t) {
			switch (t.type) {
			case "pointerdown":
				this.downPx_ = t.pixel, this.start_(t);
				break;
			case "pointerup":
				if (this.started_ && this.coord_)(i = this.downPx_[0] - t.pixel[0]) * i + (n = this.downPx_[1] - t.pixel[1]) * n <= this.squaredClickTolerance_ && ("pointermove" == this.lastEvent ? this.end_(t) : (i = this.upPx_[0] - t.pixel[0]) * i + (n = this.upPx_[1] - t.pixel[1]) * n <= this.squaredClickTolerance_ ? this.end_(t) : (this.handleMoveEvent_(t), this.drawPoint_(t.coordinate, !0)));
				this.upPx_ = t.pixel;
				break;
			case "pointerdrag":
				if (this.started_) {
					var e = this.getMap().getPixelFromCoordinate(this.center_);
					(i = e[0] - t.pixel[0]) * i + (n = e[1] - t.pixel[1]) * n <= this.squaredClickTolerance_ && this.reset()
				}
				break;
			case "pointermove":
				var i, n;
				if (this.started_)(i = this.downPx_[0] - t.pixel[0]) * i + (n = this.downPx_[1] - t.pixel[1]) * n > this.squaredClickTolerance_ && (this.handleMoveEvent_(t), this.lastEvent = t.type);
				break;
			default:
				if (this.lastEvent = t.type, this.started_ && "dblclick" === t.type) return !1
			}
			return !0
		}, m.prototype.finishDrawing = function() {
			this.started_ && this.coord_ && this.end_({
				pixel: this.upPx_,
				coordinate: this.coord_
			})
		}, m.prototype.handleMoveEvent_ = function(t) {
			if (this.started_) {
				this.coord_ = t.coordinate, this.coordPx_ = t.pixel;
				var e = this.drawSketch_(t);
				this.dispatchEvent({
					type: "drawing",
					feature: e,
					pixel: t.pixel,
					startCoordinate: this.center_,
					coordinate: t.coordinate,
					square: this.square_,
					centered: this.centered_
				})
			} else this.drawPoint_(t.coordinate)
		}, m.prototype.start_ = function(t) {
			if (this.started_) this.coord_ = t.coordinate;
			else {
				this.started_ = !0, this.center_ = t.coordinate, this.coord_ = null;
				var e = this.feature_ = new g.
			default;
				this.drawSketch_(t), this.dispatchEvent({
					type: "drawstart",
					feature: e,
					pixel: t.pixel,
					coordinate: t.coordinate
				})
			}
		}, m.prototype.end_ = function(t) {
			if (this.coord_ = t.coordinate, this.started_ = !1, this.coord_ && this.center_[0] != this.coord_[0] && this.center_[1] != this.coord_[1]) {
				var e = this.feature_;
				this.geometryName_ && e.setGeometryName(this.geometryName_), e.setGeometry(this.getGeom_()), this.source_ ? this.source_.addFeature(e) : this.features_ && this.features_.push(e), this.dispatchEvent({
					type: "drawend",
					feature: e,
					pixel: t.pixel,
					coordinate: t.coordinate,
					square: this.square_,
					centered: this.centered_
				})
			} else this.dispatchEvent({
				type: "drawcancel",
				feature: null,
				pixel: t.pixel,
				coordinate: t.coordinate,
				square: this.square_,
				centered: this.centered_
			});
			this.center_ = this.coord_ = null, this.drawSketch_()
		}, e.
	default = m
	}, function(t, e, i) {
		"use strict";
		Object.defineProperty(e, "__esModule", {
			value: !0
		});
		var n = i(196);
		Object.keys(n).forEach((function(t) {
			"default" !== t && "__esModule" !== t && Object.defineProperty(e, t, {
				enumerable: !0,
				get: function() {
					return n[t]
				}
			})
		}));
		var r = i(197);
		Object.keys(r).forEach((function(t) {
			"default" !== t && "__esModule" !== t && Object.defineProperty(e, t, {
				enumerable: !0,
				get: function() {
					return r[t]
				}
			})
		}));
		var o = i(198);
		Object.keys(o).forEach((function(t) {
			"default" !== t && "__esModule" !== t && Object.defineProperty(e, t, {
				enumerable: !0,
				get: function() {
					return o[t]
				}
			})
		}));
		var s = i(154);
		Object.keys(s).forEach((function(t) {
			"default" !== t && "__esModule" !== t && Object.defineProperty(e, t, {
				enumerable: !0,
				get: function() {
					return s[t]
				}
			})
		}));
		var a = i(199);
		Object.keys(a).forEach((function(t) {
			"default" !== t && "__esModule" !== t && Object.defineProperty(e, t, {
				enumerable: !0,
				get: function() {
					return a[t]
				}
			})
		}));
		var l = i(201);
		Object.keys(l).forEach((function(t) {
			"default" !== t && "__esModule" !== t && Object.defineProperty(e, t, {
				enumerable: !0,
				get: function() {
					return l[t]
				}
			})
		}));
		var u = i(203);
		Object.keys(u).forEach((function(t) {
			"default" !== t && "__esModule" !== t && Object.defineProperty(e, t, {
				enumerable: !0,
				get: function() {
					return u[t]
				}
			})
		}));
		var h = i(204);
		Object.keys(h).forEach((function(t) {
			"default" !== t && "__esModule" !== t && Object.defineProperty(e, t, {
				enumerable: !0,
				get: function() {
					return h[t]
				}
			})
		}));
		var c = i(206);
		Object.keys(c).forEach((function(t) {
			"default" !== t && "__esModule" !== t && Object.defineProperty(e, t, {
				enumerable: !0,
				get: function() {
					return c[t]
				}
			})
		}));
		var d = i(142);
		Object.keys(d).forEach((function(t) {
			"default" !== t && "__esModule" !== t && Object.defineProperty(e, t, {
				enumerable: !0,
				get: function() {
					return d[t]
				}
			})
		}));
		var f = i(153);
		Object.keys(f).forEach((function(t) {
			"default" !== t && "__esModule" !== t && Object.defineProperty(e, t, {
				enumerable: !0,
				get: function() {
					return f[t]
				}
			})
		}))
	}, function(t, e, i) {
		"use strict";
		Object.defineProperty(e, "__esModule", {
			value: !0
		}), e.CircleLayer = void 0;
		var n = y(i(0)),
			r = y(i(1)),
			o = y(i(33)),
			s = y(i(30)),
			a = y(i(26)),
			l = y(i(25)),
			u = y(i(105)),
			h = y(i(34)),
			c = y(i(36)),
			d = y(i(38)),
			f = y(i(86)),
			A = y(i(68)),
			p = i(80),
			g = i(63),
			m = i(87),
			v = function(t) {
				if (t && t.__esModule) return t;
				var e = {};
				if (null != t) for (var i in t) Object.prototype.hasOwnProperty.call(t, i) && (e[i] = t[i]);
				return e.
			default = t, e
			}(i(55));

		function y(t) {
			return t && t.__esModule ? t : {
			default:
				t
			}
		}
		var _ = function(t) {
				m.BaseLayer.call(this, t), this.type = m.LayerType.CIRCLE, this.setting = {
					isActual: !1,
					radius: 5,
					minLabShowZoom: 5
				}, v.mixin(this.setting, this.layerOptions);
				var e = {};
				this.sourceObj = new s.
			default, this.layerVector = new o.
			default ({
					source: this.sourceObj,
					style: function(t) {
						return function(t) {
							var i = t.get("property"),
								n = e[i.radius + i.label];
							return n || (n = new h.
						default ({
								image: new A.
							default ({
									radius: i.radius,
									stroke: new c.
								default ({
										color: i.strokeColor
									}),
									fill:
									new d.
								default ({
										color: i.fillColor
									})
								}),
								stroke:
								new c.
							default ({
									color: i.strokeColor
								}),
								fill:
								new d.
							default ({
									color: i.fillColor
								}),
								text:
								new f.
							default ({
									text: i.label,
									fill: new d.
								default ({
										color: i.labFillColor
									}),
									stroke:
									new c.
								default ({
										color: i.labStrokeColor,
										width: i.labStrokeWidth
									}),
									rotation:
									Math.PI / 180 * i.labRotation,
									offsetX: i.labOffsetX,
									offsetY: i.labOffsetY,
									textAlign: i.labTextAlign,
									textBaseline: i.labTextBaseline
								})
							}), e[i.radius + i.label] = n), n
						}(t)
					}
				}), this.gisMapObj.addLayer(this)
			};
		n.
	default.inherits(_, m.BaseLayer), _.prototype.refreshLayer = function() {
			this.sourceObj.clear();
			for (var t = [], e = 0; e < this.data.length; e++) {
				var i = {},
					n = this.data[e];
				v.mixin(i, this.setting), v.mixin(i, n), this.gisMapObj.getMapZoom() < i.minLabShowZoom && (i.label = "");
				var o = i.coord;
				if (this.gisMapObj.getIsGCJProjection() && (o = p.GPSTrans.gcj_encryptArr(o)), !this.isRef || r.
			default.containsXY(this.gisMapObj.getMapExtent(), o[0], o[1])) {
					var s = this.setting.isActual ? new u.
				default (o, .01 * i.radius):
					new l.
				default (o);
					this.gisMapObj.getTransformInd() && s.transform(g.MapConstant.defaultProjection, this.gisMapObj.getCurrProjection());
					var h = new a.
				default ({
						geometry: s,
						property: i
					});
					h.setId(i.id), t.push(h)
				}
			}
			this.sourceObj.addFeatures(t)
		}, e.CircleLayer = _
	}, function(t, e, i) {
		"use strict";
		Object.defineProperty(e, "__esModule", {
			value: !0
		}), e.ClusterCircleLayer = void 0;
		var n = _(i(0)),
			r = _(i(33)),
			o = _(i(30)),
			s = _(i(26)),
			a = _(i(68)),
			l = _(i(25)),
			u = _(i(158)),
			h = _(i(34)),
			c = _(i(36)),
			d = _(i(38)),
			f = _(i(86)),
			A = _(i(1)),
			p = _(i(159)),
			g = i(87),
			m = i(80),
			v = i(63),
			y = function(t) {
				if (t && t.__esModule) return t;
				var e = {};
				if (null != t) for (var i in t) Object.prototype.hasOwnProperty.call(t, i) && (e[i] = t[i]);
				return e.
			default = t, e
			}(i(55));

		function _(t) {
			return t && t.__esModule ? t : {
			default:
				t
			}
		}
		var E = function(t) {
				g.BaseLayer.call(this, t), this.type = g.LayerType.CIRCLECLUSTER, this.setting = {
					distance: 40,
					radius: 5,
					minLabShowZoom: 5,
					clusterRadius: 7,
					clusterStrokeColor: "#3E82F7",
					clusterFillColor: "#F0B267",
					isAnimation: !1
				}, y.mixin(this.setting, this.layerOptions);
				var e = {},
					i = function(t) {
						var i = t.get("features");
						if (i) {
							var n = i.length,
								r = i[0].get("property"),
								o = e[r.src + n.toString()];
							if (!o) {
								var s = null;
								s = n > 1 ? new a.
							default ({
									radius: r.clusterRadius,
									stroke: new c.
								default ({
										color: r.clusterStrokeColor
									}),
									fill:
									new d.
								default ({
										color: r.clusterFillColor
									})
								}):
								new a.
							default ({
									radius: r.radius,
									stroke: new c.
								default ({
										color: r.strokeColor
									}),
									fill:
									new d.
								default ({
										color: r.fillColor
									})
								}), o = [new h.
							default ({
									image: s,
									text: new f.
								default ({
										text: n.toString(),
										fill: new d.
									default ({
											color: r.labFillColor
										}),
										stroke:
										new c.
									default ({
											color: r.labStrokeColor,
											width: r.labStrokeWidth
										})
									})
								})], e[r.src + n.toString()] = o
							}
							return o
						}
					};
				this.sourceObj = new o.
			default, this.clusterSource = new u.
			default ({
					distance: this.setting.distance,
					source: this.sourceObj
				}), this.clusterSource.on("addfeature", (function(t) {
					return t
				})), this.setting.isAnimation ? this.layerVector = new p.
			default ({
					name: "Cluster",
					source: this.clusterSource,
					style: function(t) {
						return i(t)
					}
				}):
				this.layerVector = new r.
			default ({
					source: this.clusterSource,
					style: function(t) {
						return i(t)
					}
				}), this.gisMapObj.addLayer(this)
			};
		n.
	default.inherits(E, g.BaseLayer), E.prototype.refreshLayer = function() {
			this.sourceObj.clear();
			for (var t = [], e = 0; e < this.data.length; e++) {
				var i = {},
					n = this.data[e];
				y.mixin(i, this.setting), y.mixin(i, n), this.gisMapObj.getMapZoom() < i.minLabShowZoom && (i.label = "");
				var r = i.coord;
				if (this.gisMapObj.getIsGCJProjection() && (r = m.GPSTrans.gcj_encryptArr(r)), !this.isRef || A.
			default.containsXY(this.gisMapObj.getMapExtent(), r[0], r[1])) {
					var o = new l.
				default (r);
					this.gisMapObj.getTransformInd() && o.transform(v.MapConstant.defaultProjection, this.gisMapObj.getCurrProjection());
					var a = new s.
				default ({
						geometry: o,
						property: i
					});
					a.setId(i.id), t.push(a)
				}
			}
			this.sourceObj.addFeatures(t)
		}, e.ClusterCircleLayer = E
	}, function(t, e, i) {
		"use strict";
		Object.defineProperty(e, "__esModule", {
			value: !0
		}), e.ClusterIconLayer = void 0;
		var n = _(i(0)),
			r = _(i(33)),
			o = _(i(30)),
			s = _(i(26)),
			a = _(i(25)),
			l = _(i(100)),
			u = _(i(158)),
			h = _(i(34)),
			c = _(i(36)),
			d = _(i(38)),
			f = _(i(86)),
			A = _(i(1)),
			p = _(i(159)),
			g = i(87),
			m = i(80),
			v = i(63),
			y = function(t) {
				if (t && t.__esModule) return t;
				var e = {};
				if (null != t) for (var i in t) Object.prototype.hasOwnProperty.call(t, i) && (e[i] = t[i]);
				return e.
			default = t, e
			}(i(55));

		function _(t) {
			return t && t.__esModule ? t : {
			default:
				t
			}
		}
		var E = function(t) {
				g.BaseLayer.call(this, t), this.type = g.LayerType.ICONCLUSTER, this.setting = {
					distance: 20,
					anchor: [0, 0],
					minLabShowZoom: 5,
					scale: 1,
					clusterAnchor: [0, 0],
					clusterSrc: "",
					clusterScale: 1,
					isAnimation: !1
				}, y.mixin(this.setting, this.layerOptions);
				var e = {},
					i = function(t) {
						var i = t.get("features");
						if (i) {
							var n = i.length,
								r = i[0].get("property"),
								o = 1 == n ? r.label : n + "",
								s = e[r.src + o + n];
							if (!s) {
								var a = null;
								n > 1 ? (o = n + "", a = new l.
							default ({
									anchor: r.clusterAnchor,
									src: r.clusterSrc,
									scale: r.clusterScale
								})) : (o = r.label, a = new l.
							default ({
									anchor: r.anchor,
									src: r.src,
									scale: r.scale
								})), s = [new h.
							default ({
									image: a,
									text: new f.
								default ({
										text: o,
										fill: new d.
									default ({
											color: r.labFillColor
										}),
										stroke:
										new c.
									default ({
											color: r.labStrokeColor,
											width: r.labStrokeWidth
										})
									})
								})], e[r.src + o + n] = s
							}
							return s
						}
					};
				this.sourceObj = new o.
			default, this.clusterSource = new u.
			default ({
					distance: this.setting.distance,
					source: this.sourceObj
				}), this.setting.isAnimation ? this.layerVector = new p.
			default ({
					name: "Cluster",
					source: this.clusterSource,
					style: function(t) {
						return i(t)
					}
				}):
				this.layerVector = new r.
			default ({
					source: this.clusterSource,
					style: function(t) {
						return i(t)
					}
				}), this.gisMapObj.addLayer(this)
			};
		n.
	default.inherits(E, g.BaseLayer), E.prototype.refreshLayer = function() {
			this.sourceObj.clear();
			for (var t = [], e = 0; e < this.data.length; e++) {
				var i = {},
					n = this.data[e];
				y.mixin(i, this.setting), y.mixin(i, n), this.gisMapObj.getMapZoom() < i.minLabShowZoom && (i.label = "");
				var r = i.coord;
				if (this.gisMapObj.getIsGCJProjection() && (r = m.GPSTrans.gcj_encryptArr(r)), !this.isRef || A.
			default.containsXY(this.gisMapObj.getMapExtent(), r[0], r[1])) {
					var o = new a.
				default (r);
					this.gisMapObj.getTransformInd() && o.transform(v.MapConstant.defaultProjection, this.gisMapObj.getCurrProjection());
					var l = new s.
				default ({
						geometry: o,
						type: this.type,
						property: i
					});
					l.setId(i.id), t.push(l)
				}
			}
			this.sourceObj.addFeatures(t)
		}, e.ClusterIconLayer = E
	}, function(t, e, i) {
		"use strict";
		Object.defineProperty(e, "__esModule", {
			value: !0
		}), e.FontLayer = void 0;
		var n = v(i(0)),
			r = v(i(33)),
			o = v(i(30)),
			s = v(i(26)),
			a = v(i(25)),
			l = v(i(34)),
			u = v(i(200)),
			h = v(i(36)),
			c = v(i(38)),
			d = v(i(86)),
			f = v(i(1)),
			A = i(87),
			p = i(80),
			g = i(63),
			m = function(t) {
				if (t && t.__esModule) return t;
				var e = {};
				if (null != t) for (var i in t) Object.prototype.hasOwnProperty.call(t, i) && (e[i] = t[i]);
				return e.
			default = t, e
			}(i(55));

		function v(t) {
			return t && t.__esModule ? t : {
			default:
				t
			}
		}
		var y = function(t) {
				A.BaseLayer.call(this, t), this.type = A.LayerType.FONT, this.setting = {
					radius: 10,
					rotation: 0,
					offsetX: 0,
					offsetY: 0
				}, this.allData = [], this.interval = null, m.mixin(this.setting, this.layerOptions);
				var e = {};
				this.sourceObj = new o.
			default, this.layerVector = new r.
			default ({
					source: this.sourceObj,
					style: function(t) {
						return function(t) {
							var i = t.get("property"),
								n = e[i.label + i.fillColor + i.glyph + i.radius + i.rotation + i.id];
							return n || (n = new l.
						default ({
								image: new u.
							default ({
									glyph: i.glyph,
									radius: i.radius,
									rotation: i.rotation * Math.PI / 180,
									offsetX: i.offsetX,
									offsetY: i.offsetY,
									fill: new c.
								default ({
										color: i.fillColor
									}),
									stroke:
									new h.
								default ({
										color: i.strokeColor,
										width: i.strokeWidth
									})
								}),
								text:
								new d.
							default ({
									font: i.lalFontSize + " " + i.labFontFamily,
									text: i.label,
									fill: new c.
								default ({
										color: i.labFillColor
									}),
									rotation:
									Math.PI / 180 * i.labRotation
								})
							}), e[i.label + i.fillColor + i.glyph + i.radius + i.rotation + i.id] = n), n
						}(t)
					}
				}), this.gisMapObj.addLayer(this)
			};
		n.
	default.inherits(y, A.BaseLayer), y.prototype.refreshLayer = function() {
			this.sourceObj.clear();
			for (var t = [], e = 0; e < this.data.length; e++) {
				var i = {},
					n = this.data[e];
				m.mixin(i, this.setting), m.mixin(i, n);
				var r = i.coord;
				if (this.gisMapObj.getIsGCJProjection() && (r = p.GPSTrans.gcj_encryptArr(r)), !this.isRef || f.
			default.containsXY(this.gisMapObj.getMapExtent(), r[0], r[1])) {
					var o = new a.
				default (r);
					this.gisMapObj.getTransformInd() && o.transform(g.MapConstant.defaultProjection, this.gisMapObj.getCurrProjection());
					var l = new s.
				default ({
						geometry: o,
						property: i
					});
					l.setId(i.id), t.push(l)
				}
			}
			this.sourceObj.addFeatures(t)
		}, y.prototype.startTwinkle = function() {
			this.allData = this.data;
			for (var t = [], e = [], i = !1, n = 0; n < this.allData.length; n++) n % 2 == 0 ? e.push(this.allData[n]) : t.push(this.allData[n]);
			var r = this;
			this.interval = setInterval((function() {
				i ? (r.data = e, i = !1) : (r.data = t, i = !0), r.refreshLayer()
			}), 300)
		}, y.prototype.stoptTwinkle = function() {
			clearInterval(this.interval), this.data = this.allData, this.refreshLayer()
		}, y.addDefs = function(t, e) {
			u.
		default.addDefs(t, e)
		}, e.FontLayer = y
	}, function(t, e, i) {
		"use strict";
		i.r(e);
		var n = i(0),
			r = i(92),
			o = (i(38), i(108)),
			s = i(44),
			a = function(t) {
				var e = 0;
				(t = t || {}).stroke && (e = t.stroke.getWidth()), r.a.call(this, {
					radius: t.radius,
					fill: t.fill,
					rotation: t.rotation,
					rotateWithView: t.rotateWithView
				}), "number" == typeof t.opacity && this.setOpacity(t.opacity), this.color_ = t.color, this.fontSize_ = t.fontSize || 1, this.stroke_ = t.stroke, this.fill_ = t.fill, this.radius_ = t.radius - e, this.form_ = t.form || "none", this.gradient_ = t.gradient, this.offset_ = [t.offsetX ? t.offsetX : 0, t.offsetY ? t.offsetY : 0], this.glyph_ = this.getGlyph(t.glyph) || "", this.renderMarker_()
			};
		n.
	default.inherits(a, r.a), o.a.prototype.getImagePNG = function() {
			var t = this.getImage();
			if (!t) return !1;
			try {
				return t.toDataURL("image/png")
			} catch (t) {
				return !1
			}
		}, a.prototype.defs = {
			fonts: {},
			glyphs: {}
		}, a.addDefs = function(t, e) {
			var i = t;
			if ("string" == typeof t && (i = {
				font: t,
				name: t,
				copyright: ""
			}), i.font && "string" == typeof i.font) {
				var n = i.font;
				for (var r in a.prototype.defs.fonts[n] = i, e) {
					var o = e[r];
					"string" == typeof o && 1 == o.length && (o = {
						char: o
					}), a.prototype.defs.glyphs[r] = {
						font: i.font,
						char: o.char || "" + String.fromCharCode(o.code) || "",
						theme: o.theme || i.name,
						name: o.name || r,
						search: o.search || ""
					}
				}
			} else console.log("bad font def")
		}, a.prototype.clone = function() {
			var t = new a({
				glyph: "",
				color: this.color_,
				fontSize: this.fontSize_,
				stroke: this.stroke_,
				fill: this.fill_,
				radius: this.radius_ + (this.stroke_ ? this.stroke_.getWidth() : 0),
				form: this.form_,
				gradient: this.gradient_,
				offsetX: this.offset_[0],
				offsetY: this.offset_[1],
				opacity: this.getOpacity(),
				rotation: this.getRotation(),
				rotateWithView: this.getRotateWithView()
			});
			return t.setScale(this.getScale()), t.glyph_ = this.glyph_, t.renderMarker_(), t
		}, a.prototype.getFill = function() {
			return this.fill_
		}, a.prototype.getStroke = function() {
			return this.stroke_
		}, a.prototype.getGlyph = function(t) {
			return t ? a.prototype.defs.glyphs[t] || {
				font: "none",
				char: t.charAt(0),
				theme: "none",
				name: "none",
				search: ""
			} : this.glyph_
		}, a.prototype.getGlyphName = function() {
			for (var t in a.prototype.defs.glyphs) if (a.prototype.defs.glyphs[t] === this.glyph_) return t;
			return ""
		}, a.prototype.getFontInfo = function(t) {
			return a.prototype.defs.fonts[t.font]
		}, a.prototype.renderMarker_ = function(t) {
			var e, i = 0;
			this.stroke_ && (e = s.a.asString(this.stroke_.getColor()), i = this.stroke_.getWidth());
			var n = this.getImage(),
				r = {
					strokeStyle: e,
					strokeWidth: i,
					size: n.width
				},
				o = n.getContext("2d");
			o.clearRect(0, 0, n.width, n.height), this.drawMarker_(r, o, 0, 0);
			var a = this.getAnchor();
			a[0] = n.width / 2 - this.offset_[0], a[1] = n.width / 2 - this.offset_[1]
		}, a.prototype.drawPath_ = function(t, e) {
			var i = 2 * this.radius_ + t.strokeWidth + 1,
				n = t.strokeWidth / 2,
				r = t.size / 2,
				o = {
					fac: 1,
					posX: t.size / 2,
					posY: t.size / 2
				};
			switch (e.lineJoin = "round", e.beginPath(), this.form_) {
			case "none":
				o.fac = 1;
				break;
			case "circle":
			case "ban":
				e.arc(r, r, i / 2, 0, 2 * Math.PI, !0);
				break;
			case "poi":
				e.arc(r, r - .4 * this.radius_, .6 * this.radius_, .15 * Math.PI, .85 * Math.PI, !0), e.lineTo(r - .89 * .05 * i, (.95 + .45 * .05) * i + n), e.arc(r, .95 * i + n, .05 * i, .85 * Math.PI, .15 * Math.PI, !0), o = {
					fac: .45,
					posX: r,
					posY: r - .35 * this.radius_
				};
				break;
			case "bubble":
				e.arc(r, r - .2 * this.radius_, .8 * this.radius_, .4 * Math.PI, .6 * Math.PI, !0), e.lineTo(.5 * i + n, i + n), o = {
					fac: .7,
					posX: r,
					posY: r - .2 * this.radius_
				};
				break;
			case "marker":
				e.arc(r, r - .2 * this.radius_, .8 * this.radius_, .25 * Math.PI, .75 * Math.PI, !0), e.lineTo(.5 * i + n, i + n), o = {
					fac: .7,
					posX: r,
					posY: r - .2 * this.radius_
				};
				break;
			case "coma":
				e.moveTo(r + .8 * this.radius_, r - .2 * this.radius_), e.quadraticCurveTo(.95 * i + n, .75 * i + n, .5 * i + n, i + n), e.arc(r, r - .2 * this.radius_, .8 * this.radius_, .45 * Math.PI, 0, !1), o = {
					fac: .7,
					posX: r,
					posY: r - .2 * this.radius_
				};
				break;
			default:
				var s;
				switch (this.form_) {
				case "shield":
					s = [.05, 0, .95, 0, .95, .8, .5, 1, .05, .8, .05, 0], o.posY = .45 * i + n;
					break;
				case "blazon":
					s = [.1, 0, .9, 0, .9, .8, .6, .8, .5, 1, .4, .8, .1, .8, .1, 0], o.fac = .8, o.posY = .4 * i + n;
					break;
				case "bookmark":
					s = [.05, 0, .95, 0, .95, 1, .5, .8, .05, 1, .05, 0], o.fac = .9, o.posY = .4 * i + n;
					break;
				case "hexagon":
					s = [.05, .2, .5, 0, .95, .2, .95, .8, .5, 1, .05, .8, .05, .2], o.fac = .9, o.posY = .5 * i + n;
					break;
				case "diamond":
					s = [.25, 0, .75, 0, 1, .2, 1, .4, .5, 1, 0, .4, 0, .2, .25, 0], o.fac = .75, o.posY = .35 * i + n;
					break;
				case "triangle":
					s = [0, 0, 1, 0, .5, 1, 0, 0], o.fac = .6, o.posY = .3 * i + n;
					break;
				case "sign":
					s = [.5, .05, 1, .95, 0, .95, .5, .05], o.fac = .7, o.posY = .65 * i + n;
					break;
				case "lozenge":
					s = [.5, 0, 1, .5, .5, 1, 0, .5, .5, 0], o.fac = .7;
					break;
				case "square":
				default:
					s = [0, 0, 1, 0, 1, 1, 0, 1, 0, 0]
				}
				for (var a = 0; a < s.length; a += 2) e.lineTo(s[a] * i + n, s[a + 1] * i + n)
			}
			return e.closePath(), o
		}, a.prototype.drawMarker_ = function(t, e, i, n) {
			var r = this.fill_ ? this.fill_.getColor() : "#000",
				o = this.stroke_ ? this.stroke_.getColor() : "#000";
			"none" == this.form_ && this.stroke_ && this.fill_ && (o = this.fill_.getColor(), r = this.stroke_.getColor()), e.setTransform(1, 0, 0, 1, 0, 0), e.translate(i, n);
			var a = this.drawPath_(t, e);
			if (this.fill_) {
				if (this.gradient_ && "none" != this.form_) {
					var l = e.createLinearGradient(0, 0, t.size / 2, t.size);
					l.addColorStop(1, s.a.asString(r)), l.addColorStop(0, s.a.asString(o)), e.fillStyle = l
				} else e.fillStyle = s.a.asString(r);
				e.fill()
			}
			if (this.stroke_ && t.strokeWidth && (e.strokeStyle = t.strokeStyle, e.lineWidth = t.strokeWidth, e.stroke()), this.glyph_.char) {
				e.font = 2 * a.fac * this.radius_ * this.fontSize_ + "px " + this.glyph_.font, e.strokeStyle = e.fillStyle, e.lineWidth = t.strokeWidth * ("none" == this.form_ ? 2 : 1), e.fillStyle = s.a.asString(this.color_ || o), e.textAlign = "center", e.textBaseline = "middle";
				var u = this.glyph_.char;
				t.strokeWidth && "transparent" != o && e.strokeText(u, a.posX, a.posY), e.fillText(u, a.posX, a.posY)
			}
			if ("ban" == this.form_ && this.stroke_ && t.strokeWidth) {
				e.strokeStyle = t.strokeStyle, e.lineWidth = t.strokeWidth;
				var h = this.radius_ + t.strokeWidth,
					c = this.radius_ * Math.cos(Math.PI / 4);
				e.moveTo(h + c, h - c), e.lineTo(h - c, h + c), e.stroke()
			}
		}, a.prototype.getChecksum = function() {
			var t = null !== this.stroke_ ? this.stroke_.getChecksum() : "-",
				e = null !== this.fill_ ? this.fill_.getChecksum() : "-";
			if (null === this.checksums_ || t != this.checksums_[1] || e != this.checksums_[2] || this.radius_ != this.checksums_[3] || this.form_ + "-" + this.glyphs_ != this.checksums_[4]) {
				var i = "c" + t + e + (void 0 !== this.radius_ ? this.radius_.toString() : "-") + this.form_ + "-" + this.glyphs_;
				this.checksums_ = [i, t, e, this.radius_, this.form_ + "-" + this.glyphs_]
			}
			return this.checksums_[0]
		}, e.
	default = a
	}, function(t, e, i) {
		"use strict";
		Object.defineProperty(e, "__esModule", {
			value: !0
		}), e.HeatLayer = void 0;
		var n = f(i(0)),
			r = f(i(1)),
			o = f(i(202)),
			s = f(i(30)),
			a = f(i(26)),
			l = f(i(25)),
			u = i(80),
			h = i(63),
			c = i(87),
			d = function(t) {
				if (t && t.__esModule) return t;
				var e = {};
				if (null != t) for (var i in t) Object.prototype.hasOwnProperty.call(t, i) && (e[i] = t[i]);
				return e.
			default = t, e
			}(i(55));

		function f(t) {
			return t && t.__esModule ? t : {
			default:
				t
			}
		}
		var A = function(t) {
				c.BaseLayer.call(this, t), this.type = c.LayerType.HEAT, this.setting = {
					blur: 15,
					radius: 8,
					gradient: ["#00f", "#0ff", "#0f0", "#ff0", "#f00"]
				}, d.mixin(this.setting, this.layerOptions), this.sourceObj = new s.
			default, this.layerVector = new o.
			default ({
					source: this.sourceObj,
					blur: this.setting.blur,
					radius: this.setting.radius,
					gradient: this.setting.gradient
				}), this.gisMapObj.addLayer(this)
			};
		n.
	default.inherits(A, c.BaseLayer), A.prototype.refreshLayer = function() {
			this.sourceObj.clear();
			for (var t = [], e = 0; e < this.data.length; e++) {
				var i = {},
					n = this.data[e];
				d.mixin(i, this.setting), d.mixin(i, n);
				var o = i.coord;
				if (this.gisMapObj.getIsGCJProjection() && (o = u.GPSTrans.gcj_encryptArr(o)), !this.isRef || r.
			default.containsXY(this.gisMapObj.getMapExtent(), o[0], o[1])) {
					var s = new l.
				default (o);
					this.gisMapObj.getTransformInd() && s.transform(h.MapConstant.defaultProjection, this.gisMapObj.getCurrProjection());
					var c = new a.
				default ({
						geometry: s,
						property: i
					});
					c.setId(i.id), t.push(c)
				}
			}
			this.sourceObj.addFeatures(t)
		}, e.HeatLayer = A
	}, function(t, e, i) {
		"use strict";
		i.r(e);
		var n = i(3),
			r = i(0),
			o = i(14),
			s = i(16),
			a = i(33),
			l = i(11),
			u = i(8),
			h = i(57),
			c = i(100),
			d = i(34),
			f = function(t) {
				var e = t || {},
					i = u.a.assign({}, e);
				delete i.gradient, delete i.radius, delete i.blur, delete i.shadow, delete i.weight, a.
			default.call(this, i), this.gradient_ = null, this.shadow_ = void 0 !== e.shadow ? e.shadow:
				250, this.circleImage_ = void 0, this.styleCache_ = null, n.a.listen(this, o.a.getChangeEventType(f.Property_.GRADIENT), this.handleGradientChanged_, this), this.setGradient(e.gradient ? e.gradient : f.DEFAULT_GRADIENT), this.setBlur(void 0 !== e.blur ? e.blur : 15), this.setRadius(void 0 !== e.radius ? e.radius : 8), n.a.listen(this, o.a.getChangeEventType(f.Property_.BLUR), this.handleStyleChanged_, this), n.a.listen(this, o.a.getChangeEventType(f.Property_.RADIUS), this.handleStyleChanged_, this), this.handleStyleChanged_();
				var r, s = e.weight ? e.weight : "weight";
				r = "string" == typeof s ?
				function(t) {
					return t.get(s)
				} : s, this.setStyle(function(t, e) {
					var i = r(t),
						n = void 0 !== i ? l.a.clamp(i, 0, 1) : 1,
						o = 255 * n | 0,
						s = this.styleCache_[o];
					return s || (s = [new d.
				default ({
						image: new c.
					default ({
							opacity: n,
							src: this.circleImage_
						})
					})], this.styleCache_[o] = s), s
				}.bind(this)), this.setRenderOrder(null), n.a.listen(this, h.a.RENDER, this.handleRender_, this)
			};
		r.
	default.inherits(f, a.
	default), f.DEFAULT_GRADIENT = ["#00f", "#0ff", "#0f0", "#ff0", "#f00"], f.createGradient_ = function(t) {
			for (var e = s.a.createCanvasContext2D(1, 256), i = e.createLinearGradient(0, 0, 1, 256), n = 1 / (t.length - 1), r = 0, o = t.length; r < o; ++r) i.addColorStop(r * n, t[r]);
			return e.fillStyle = i, e.fillRect(0, 0, 1, 256), e.getImageData(0, 0, 1, 256).data
		}, f.prototype.createCircle_ = function() {
			var t = this.getRadius(),
				e = this.getBlur(),
				i = t + e + 1,
				n = 2 * i,
				r = s.a.createCanvasContext2D(n, n);
			r.shadowOffsetX = r.shadowOffsetY = this.shadow_, r.shadowBlur = e, r.shadowColor = "#000", r.beginPath();
			var o = i - this.shadow_;
			return r.arc(o, o, t, 0, 2 * Math.PI, !0), r.fill(), r.canvas.toDataURL()
		}, f.prototype.getBlur = function() {
			return this.get(f.Property_.BLUR)
		}, f.prototype.getGradient = function() {
			return this.get(f.Property_.GRADIENT)
		}, f.prototype.getRadius = function() {
			return this.get(f.Property_.RADIUS)
		}, f.prototype.handleGradientChanged_ = function() {
			this.gradient_ = f.createGradient_(this.getGradient())
		}, f.prototype.handleStyleChanged_ = function() {
			this.circleImage_ = this.createCircle_(), this.styleCache_ = new Array(256), this.changed()
		}, f.prototype.handleRender_ = function(t) {
			var e, i, n, r = t.context,
				o = r.canvas,
				s = r.getImageData(0, 0, o.width, o.height),
				a = s.data;
			for (e = 0, i = a.length; e < i; e += 4)(n = 4 * a[e + 3]) && (a[e] = this.gradient_[n], a[e + 1] = this.gradient_[n + 1], a[e + 2] = this.gradient_[n + 2]);
			r.putImageData(s, 0, 0)
		}, f.prototype.setBlur = function(t) {
			this.set(f.Property_.BLUR, t)
		}, f.prototype.setGradient = function(t) {
			this.set(f.Property_.GRADIENT, t)
		}, f.prototype.setRadius = function(t) {
			this.set(f.Property_.RADIUS, t)
		}, f.Property_ = {
			BLUR: "blur",
			GRADIENT: "gradient",
			RADIUS: "radius"
		}, e.
	default = f
	}, function(t, e, i) {
		"use strict";
		Object.defineProperty(e, "__esModule", {
			value: !0
		}), e.IconLayer = void 0;
		var n = v(i(0)),
			r = v(i(33)),
			o = v(i(30)),
			s = v(i(26)),
			a = v(i(25)),
			l = v(i(34)),
			u = v(i(36)),
			h = v(i(38)),
			c = v(i(86)),
			d = v(i(100)),
			f = v(i(1)),
			A = i(87),
			p = i(80),
			g = i(63),
			m = function(t) {
				if (t && t.__esModule) return t;
				var e = {};
				if (null != t) for (var i in t) Object.prototype.hasOwnProperty.call(t, i) && (e[i] = t[i]);
				return e.
			default = t, e
			}(i(55));

		function v(t) {
			return t && t.__esModule ? t : {
			default:
				t
			}
		}
		var y = function(t) {
				A.BaseLayer.call(this, t), this.type = A.LayerType.ICON, this.setting = {
					src: "",
					sleSrc: this.src,
					anchor: [0, 0],
					minLabShowZoom: 5,
					scale: 1,
					isBox: !1,
					selFillColor: "rgba(142,185,229,0.7)",
					isCanvas: !1,
					width: 10,
					height: 10
				}, m.mixin(this.setting, this.layerOptions);
				var e = {};
				this.sourceObj = new o.
			default, this.layerVector = new r.
			default ({
					source: this.sourceObj,
					style: function(t) {
						return function(t) {
							var i = t.get("property"),
								n = e[i.src + i.label];
							if (!n) {
								var r;
								if (i.isCanvas) {
									var o = new Image(i.width, i.height);
									o.crossOrigin = "anonymous", o.src = i.src;
									var s = document.createElement("canvas");
									s.width = i.width, s.height = i.height;
									var a = s.getContext("2d");
									o.onload = function() {
										a.drawImage(o, 0, 0, i.width, i.height)
									}, r = new d.
								default ({
										img: s,
										imgSize: [i.width, i.height]
									})
								} else r = new d.
							default ({
									anchor: i.anchor,
									src: i.src,
									scale: i.scale,
									anchorXUnits: "pixels",
									anchorYUnits: "pixels",
									rotation: Math.PI / 180 * i.IconRotation
								});
								n = new l.
							default ({
									image: r,
									text: new c.
								default ({
										font: i.lalFontSize + " " + i.labFontFamily,
										text: i.label,
										fill: new h.
									default ({
											color: i.labFillColor
										}),
										stroke:
										new u.
									default ({
											color: i.labStrokeColor,
											width: i.labStrokeWidth
										}),
										offsetX:
										i.labOffsetX,
										offsetY: i.labOffsetY,
										rotation: Math.PI / 180 * i.labRotation,
										textAlign: i.labTextAlign,
										textBaseline: i.labTextBaseline
									})
								}), e[i.src + i.label] = n
							}
							return n
						}(t)
					}
				}), this.gisMapObj.addLayer(this)
			};
		n.
	default.inherits(y, A.BaseLayer), y.prototype.refreshLayer = function() {
			this.sourceObj.clear();
			for (var t = [], e = 0; e < this.data.length; e++) {
				var i = {},
					n = this.data[e];
				m.mixin(i, this.setting), m.mixin(i, n), this.gisMapObj.getMapZoom() < i.minLabShowZoom && (i.label = "");
				var r = i.coord;
				if (this.gisMapObj.getIsGCJProjection() && (r = p.GPSTrans.gcj_encryptArr(r)), !this.isRef || f.
			default.containsXY(this.gisMapObj.getMapExtent(), r[0], r[1])) {
					var o = new a.
				default (r);
					this.gisMapObj.getTransformInd() && o.transform(g.MapConstant.defaultProjection, this.gisMapObj.getCurrProjection());
					var l = new s.
				default ({
						geometry: o,
						property: i
					});
					l.setId(i.id), t.push(l)
				}
			}
			this.sourceObj.addFeatures(t)
		}, e.IconLayer = y
	}, function(t, e, i) {
		"use strict";
		Object.defineProperty(e, "__esModule", {
			value: !0
		}), e.LineLayer = void 0;
		var n = C(i(205)),
			r = C(i(0)),
			o = C(i(33)),
			s = C(i(30)),
			a = C(i(26)),
			l = C(i(25)),
			u = C(i(58)),
			h = C(i(100)),
			c = C(i(149)),
			d = C(i(31)),
			f = C(i(34)),
			A = C(i(36)),
			p = C(i(38)),
			g = C(i(86)),
			m = C(i(1)),
			v = i(87),
			y = i(80),
			_ = i(63),
			E = i(124),
			x = function(t) {
				if (t && t.__esModule) return t;
				var e = {};
				if (null != t) for (var i in t) Object.prototype.hasOwnProperty.call(t, i) && (e[i] = t[i]);
				return e.
			default = t, e
			}(i(55));

		function C(t) {
			return t && t.__esModule ? t : {
			default:
				t
			}
		}
		var I = function(t) {
				v.BaseLayer.call(this, t), this.type = v.LayerType.LINE, this.setting = {
					baseRadius: 10,
					isBorder: !1,
					arrowType: 0,
					isDirect: !1
				}, x.mixin(this.setting, this.layerOptions);
				var e = {};
				this.sourceObj = new s.
			default, this.layerVector = new o.
			default ({
					source: this.sourceObj,
					style: function(t) {
						return function(t) {
							var i = t.get("property"),
								r = e["line" + i.strokeColor + i.strokeWidth + i.rotation];
							return r || (r = i.isBorder ? [new f.
						default ({
								stroke: new A.
							default ({
									color: i.strokeColor,
									width: i.strokeWidth
								}),
								text:
								new g.
							default ({
									text: i.label,
									fill: new p.
								default ({
										color: i.labFillColor
									}),
									stroke:
									new A.
								default ({
										color: i.labStrokeColor,
										width: i.labStrokeWidth
									})
								})
							}), new f.
						default ({
								stroke: new A.
							default ({
									color: i.fillColor,
									width: i.fillWidth
								})
							})] : i.isImg ? new f.
						default ({
								image: new h.
							default ({
									src: n.
								default,
									rotation:
									i.rotation
								})
							}):
							new f.
						default ({
								stroke: new A.
							default ({
									lineDash: i.lineDash,
									color: i.strokeColor,
									width: i.strokeWidth
								}),
								text:
								new g.
							default ({
									text: i.label,
									fill: new p.
								default ({
										color: i.labFillColor
									}),
									stroke:
									new A.
								default ({
										color: i.labStrokeColor,
										width: i.labStrokeWidth
									})
								})
							}), e["line" + i.strokeColor + i.strokeWidth + i.rotation] = r), r
						}(t)
					}
				}), this.gisMapObj.addLayer(this)
			};
		r.
	default.inherits(I, v.BaseLayer), I.prototype.refreshLayer = function() {
			this.sourceObj.clear();
			for (var t = [], e = 1.40625 / Math.pow(2, this.gisMapObj.getCurrMap().getView().getZoom()) * this.setting.baseRadius, i = 0; i < this.data.length; i++) {
				var n = {},
					r = this.data[i];
				x.mixin(n, this.setting), x.mixin(n, r), this.gisMapObj.getMapZoom() < n.minLabShowZoom && (n.label = "");
				var o = n.coord,
					s = [];
				if (this.gisMapObj.getIsGCJProjection()) for (var h = 0; h < o.length; h++) s.push(y.GPSTrans.gcj_encryptArr(o[h]));
				else s = o;
				var f = null;
				if (0 == n.arrowType) {
					if (f = new u.
				default (s), this.setting.isDirect) {
						var A = s[0];
						for (h = 0; h < s.length - 1; h++) {
							var p = E.GisUtil.getLineAngle(s[h], s[h + 1]),
								g = E.GisUtil.getPointInLine(s[h], s[h + 1], p, e);
							if (0 === g.length) {
								var v = E.GisUtil.getLineAngle(A, s[h + 1]);
								E.GisUtil.getPointInLine(A, s[h + 1], v, e).length > 0 && (g.push(s[h + 1]), A = s[h + 1])
							}
							for (var C = 0; C < g.length; C++) if (m.
						default.containsXY(this.gisMapObj.getMapExtent(), g[C][0], g[C][1])) {
								var I = new l.
							default (g[C]);
								this.gisMapObj.getTransformInd() && I.transform(_.MapConstant.defaultProjection, this.gisMapObj.getCurrProjection());
								var S, T = {
									id: n.id + h + C,
									coord: g[C],
									rotation: Math.PI / 180 * p,
									isImg: 1
								};
								(S = new a.
							default ({
									geometry: I,
									property: T
								})).setId(T.id), t.push(S)
							}
						}
					}
				} else {
					var R = s.length,
						w = E.GisUtil.getArrowCoords([s[R - 2], s[R - 1]], e);
					f = 1 == n.arrowType ? new c.
				default ([new u.
				default (s), new u.
				default (w)]):
					new c.
				default ([new u.
				default (s), new d.
				default ([w])])
				}
				this.gisMapObj.getTransformInd() && f.transform(_.MapConstant.defaultProjection, this.gisMapObj.getCurrProjection()), (S = new a.
			default ({
					geometry: f,
					property: n
				})).setId(n.id), t.push(S)
			}
			this.sourceObj.addFeatures(t)
		}, I.prototype.removeFeatureById = function(t, e) {
			var i = this.sourceObj.getFeatureById(t);
			if (i) {
				this.sourceObj.removeFeature(i);
				for (var n = 0; n < this.data.length; n++) if (this.data[n].id == t) {
					this.data.splice(n, 1);
					break
				}
			}
			if (e) {
				var r = this.sourceObj.getFeatures();
				for (n = 0; n < r.length; n++) r[n].getId().indexOf(t) >= 0 && this.sourceObj.removeFeature(r[n])
			}
		}, e.LineLayer = I
	}, function(t, e) {
		t.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAcAAAAHCAYAAADEUlfTAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAA3FpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuNi1jMTQyIDc5LjE2MDkyNCwgMjAxNy8wNy8xMy0wMTowNjozOSAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wTU09Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9tbS8iIHhtbG5zOnN0UmVmPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvc1R5cGUvUmVzb3VyY2VSZWYjIiB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iIHhtcE1NOk9yaWdpbmFsRG9jdW1lbnRJRD0ieG1wLmRpZDpiODExMDI1ZC1jNjY0LTQ2NDYtODIyOC1mMWVmYzBjYTMyZmYiIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6NTQzM0Y3RDM0REFGMTFFODhDNURGRDEwREExMjlDNkYiIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6NTQzM0Y3RDI0REFGMTFFODhDNURGRDEwREExMjlDNkYiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENDIChXaW5kb3dzKSI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOjIwZmRkOTc5LTZlMjAtMmE0My05YzBlLTAyNWY3YjlkNDQ4MCIgc3RSZWY6ZG9jdW1lbnRJRD0ieG1wLmRpZDpiODExMDI1ZC1jNjY0LTQ2NDYtODIyOC1mMWVmYzBjYTMyZmYiLz4gPC9yZGY6RGVzY3JpcHRpb24+IDwvcmRmOlJERj4gPC94OnhtcG1ldGE+IDw/eHBhY2tldCBlbmQ9InIiPz61shBWAAAAYklEQVR42mL4//8/Awj/+PefH4g3gmiYGEyCGYi3APF/KM2MLNkClXgGpZvBkkBGCBD/A+LTQCwCpUH8EJDkVyB+CcQyUFNkoPyvIM5PILaBOQKqwAYkDmKkIUsgKcgACDAAOFykD6YasoQAAAAASUVORK5CYII="
	}, function(t, e, i) {
		"use strict";
		Object.defineProperty(e, "__esModule", {
			value: !0
		}), e.PolygonLayer = void 0;
		var n = g(i(0)),
			r = g(i(33)),
			o = g(i(30)),
			s = g(i(26)),
			a = g(i(31)),
			l = g(i(34)),
			u = g(i(36)),
			h = g(i(38)),
			c = g(i(86)),
			d = i(87),
			f = i(80),
			A = i(63),
			p = function(t) {
				if (t && t.__esModule) return t;
				var e = {};
				if (null != t) for (var i in t) Object.prototype.hasOwnProperty.call(t, i) && (e[i] = t[i]);
				return e.
			default = t, e
			}(i(55));

		function g(t) {
			return t && t.__esModule ? t : {
			default:
				t
			}
		}
		var m = function(t) {
				d.BaseLayer.call(this, t), this.type = d.LayerType.POLYGON, this.fillBgType = t.fillBgType, this.setting = {
					src: ""
				}, p.mixin(this.setting, this.layerOptions);
				var e = {},
					i = null,
					n = null;
				this.sourceObj = new o.
			default, this.layerVector = new r.
			default ({
					source: this.sourceObj,
					style: function(r) {
						return function(r) {
							var o = r.get("property"),
								s = e[o.fillColor + o.strokeColor + o.strokeWidth + o.src + o.label];
							if (!s) {
								if ("img" === t.fillBgType) {
									i || (i = document.createElement("canvas"), n = i.getContext("2d"));
									var a = o.imgAttr;
									i.width = Math.round(a[2]), i.height = Math.round(a[3]), n.drawImage(o.imgObj, a[0], a[1], a[2], a[3], 0, 0, i.width, i.height);
									var d = n.createPattern(i, "repeat");
									s = new l.
								default ({
										fill: new h.
									default ({
											color: d || "#FFFFFF"
										})
									}), e[o.fillColor + o.strokeColor + o.strokeWidth + o.src + o.label] = s
								} else s = new l.
							default ({
									stroke: new u.
								default ({
										color: o.strokeColor,
										width: o.strokeWidth
									}),
									fill:
									new h.
								default ({
										color: o.fillColor
									}),
									text:
									new c.
								default ({
										text: o.label,
										fill: new h.
									default ({
											color: o.labFillColor
										}),
										rotation:
										Math.PI / 180 * o.labRotation,
										textAlign: o.labTextAlign,
										textBaseline: o.labTextBaseline,
										offsetX: o.labOffsetX,
										offsetY: o.labOffsetY
									})
								});
								e[o.fillColor + o.strokeColor + o.strokeWidth + o.src + o.label] = s
							}
							return s
						}(r)
					}
				}), this.gisMapObj.addLayer(this)
			};
		n.
	default.inherits(m, d.BaseLayer), m.prototype.refreshLayer = function() {
			this.sourceObj.clear();
			for (var t = [], e = [], i = 0; i < this.data.length; i++) {
				var n = this;
				if (this.fillBgType) e.push(new Promise((function(t) {
					var e = new Image,
						r = {},
						o = n.data[i];
					p.mixin(r, n.setting), p.mixin(r, o), e.onload = function() {
						r.imgObj = e, r.imgAttr || (r.imgAttr = [0, 0, e.width, e.width]), t(n.createFeature_(r))
					}, e.src = r.src
				}))), Promise.all(e).then((function(t) {
					n.sourceObj.addFeatures(t)
				}));
				else {
					var r = {},
						o = this.data[i];
					p.mixin(r, n.setting), p.mixin(r, o), t.push(this.createFeature_(r)), this.sourceObj.addFeatures(t)
				}
			}
		}, m.prototype.createFeature_ = function(t) {
			var e = t.coord,
				i = [];
			if (this.gisMapObj.getIsGCJProjection()) for (var n = 0; n < e.length; n++) i.push(f.GPSTrans.gcj_encryptArr(e[n]));
			else i = e;
			var r = new a.
		default (i);
			this.gisMapObj.getTransformInd() && r.transform(A.MapConstant.defaultProjection, this.gisMapObj.getCurrProjection());
			var o = new s.
		default ({
				geometry: r,
				property: t
			});
			return o.setId(t.id), o
		}, e.PolygonLayer = m
	}, function(t, e, i) {
		"use strict";
		Object.defineProperty(e, "__esModule", {
			value: !0
		}), e.PolygonCalc = e.HashMap = void 0;
		var n = i(80);
		Object.keys(n).forEach((function(t) {
			"default" !== t && "__esModule" !== t && Object.defineProperty(e, t, {
				enumerable: !0,
				get: function() {
					return n[t]
				}
			})
		}));
		var r = i(124);
		Object.keys(r).forEach((function(t) {
			"default" !== t && "__esModule" !== t && Object.defineProperty(e, t, {
				enumerable: !0,
				get: function() {
					return r[t]
				}
			})
		}));
		var o, s = i(130),
			a = (o = s) && o.__esModule ? o : {
			default:
				o
			},
			l = function(t) {
				if (t && t.__esModule) return t;
				var e = {};
				if (null != t) for (var i in t) Object.prototype.hasOwnProperty.call(t, i) && (e[i] = t[i]);
				return e.
			default = t, e
			}(i(208));
		e.HashMap = a.
	default, e.PolygonCalc = l
	}, function(t, e, i) {
		"use strict";
		Object.defineProperty(e, "__esModule", {
			value: !0
		}), e.addPointDistance = e.addDifference = e.addUnion = e.addIntersect = void 0;
		var n = l(i(209)),
			r = l(i(210)),
			o = l(i(211)),
			s = l(i(212)),
			a = l(i(160));

		function l(t) {
			return t && t.__esModule ? t : {
			default:
				t
			}
		}
		e.addIntersect = function(t, e) {
			var i = new a.
		default.polygon(t),
				r = new a.
			default.polygon(e);
			return new n.
		default (i, r).geometry.coordinates
		}, e.addUnion = function(t, e) {
			var i = new a.
		default.polygon(t),
				n = new a.
			default.polygon(e);
			return new r.
		default (i, n).geometry.coordinates
		}, e.addDifference = function(t, e) {
			var i = new a.
		default.polygon(t),
				n = new a.
			default.polygon(e);
			return new o.
		default (i, n).geometry.coordinates
		}, e.addPointDistance = function(t, e) {
			var i = new a.
		default.point(t),
				n = new a.
			default.point(e);
			return new s.
		default (i, n, "miles")
		}
	}, function(t, e, i) {
		var n = i(143);
		t.exports = function(t, e) {
			var i, r;
			i = "Feature" === t.type ? t.geometry : t, r = "Feature" === e.type ? e.geometry : e;
			var o = new n.io.GeoJSONReader,
				s = o.read(JSON.stringify(i)),
				a = o.read(JSON.stringify(r)),
				l = s.intersection(a);
			if (!l.isEmpty()) return {
				type: "Feature",
				properties: {},
				geometry: (new n.io.GeoJSONWriter).write(l)
			}
		}
	}, function(t, e, i) {
		var n = i(143);
		t.exports = function(t, e) {
			var i = new n.io.GeoJSONReader,
				r = i.read(JSON.stringify(t.geometry)),
				o = i.read(JSON.stringify(e.geometry)),
				s = r.union(o);
			return {
				type: "Feature",
				geometry: s = (new n.io.GeoJSONWriter).write(s),
				properties: t.properties
			}
		}
	}, function(t, e, i) {
		var n = i(143);
		t.exports = function(t, e) {
			var i = JSON.parse(JSON.stringify(t)),
				r = JSON.parse(JSON.stringify(e));
			"Feature" !== i.type && (i = {
				type: "Feature",
				properties: {},
				geometry: i
			}), "Feature" !== r.type && (r = {
				type: "Feature",
				properties: {},
				geometry: r
			});
			var o = new n.io.GeoJSONReader,
				s = o.read(JSON.stringify(i.geometry)),
				a = o.read(JSON.stringify(r.geometry)),
				l = s.difference(a);
			if (!l.isEmpty()) {
				var u = (new n.io.GeoJSONWriter).write(l);
				return i.geometry = l, {
					type: "Feature",
					properties: i.properties,
					geometry: u
				}
			}
		}
	}, function(t, e, i) {
		var n = i(213).getCoord,
			r = i(160).radiansToDistance;
		t.exports = function(t, e, i) {
			var o = Math.PI / 180,
				s = n(t),
				a = n(e),
				l = o * (a[1] - s[1]),
				u = o * (a[0] - s[0]),
				h = o * s[1],
				c = o * a[1],
				d = Math.pow(Math.sin(l / 2), 2) + Math.pow(Math.sin(u / 2), 2) * Math.cos(h) * Math.cos(c);
			return r(2 * Math.atan2(Math.sqrt(d), Math.sqrt(1 - d)), i)
		}
	}, function(t, e) {
		t.exports.geojsonType = function(t, e, i) {
			if (!e || !i) throw new Error("type and name required");
			if (!t || t.type !== e) throw new Error("Invalid input to " + i + ": must be a " + e + ", given " + t.type)
		}, t.exports.collectionOf = function(t, e, i) {
			if (!i) throw new Error(".collectionOf() requires a name");
			if (!t || "FeatureCollection" !== t.type) throw new Error("Invalid input to " + i + ", FeatureCollection required");
			for (var n = 0; n < t.features.length; n++) {
				var r = t.features[n];
				if (!r || "Feature" !== r.type || !r.geometry) throw new Error("Invalid input to " + i + ", Feature with geometry required");
				if (!r.geometry || r.geometry.type !== e) throw new Error("Invalid input to " + i + ": must be a " + e + ", given " + r.geometry.type)
			}
		}, t.exports.featureOf = function(t, e, i) {
			if (!i) throw new Error(".featureOf() requires a name");
			if (!t || "Feature" !== t.type || !t.geometry) throw new Error("Invalid input to " + i + ", Feature with geometry required");
			if (!t.geometry || t.geometry.type !== e) throw new Error("Invalid input to " + i + ": must be a " + e + ", given " + t.geometry.type)
		}, t.exports.getCoord = function(t) {
			if (Array.isArray(t) && "number" == typeof t[0] && "number" == typeof t[1]) return t;
			if (t) {
				if ("Feature" === t.type && t.geometry && "Point" === t.geometry.type && Array.isArray(t.geometry.coordinates)) return t.geometry.coordinates;
				if ("Point" === t.type && Array.isArray(t.coordinates)) return t.coordinates
			}
			throw new Error("A coordinate, feature, or point geometry is required")
		}
	}, function(t, e, i) {
		"use strict";
		i.r(e);
		var n = i(0),
			r = i(15),
			o = i(1),
			s = i(69),
			a = i(32),
			l = i(41),
			u = i(60),
			h = i(8),
			c = i(9),
			d = i(2),
			f = function(t) {
				var e = t || {};
				a.a.call(this, e), this.FEATURE_COLLECTION_PARSERS[a.a.GMLNS].featureMember = d.a.makeArrayPusher(a.a.prototype.readFeaturesInternal), this.schemaLocation = e.schemaLocation ? e.schemaLocation : f.schemaLocation_
			};
		n.
	default.inherits(f, a.a), f.schemaLocation_ = a.a.GMLNS + " http://schemas.opengis.net/gml/2.1.2/feature.xsd", f.prototype.readFlatCoordinates_ = function(t, e) {
			var i = d.a.getAllTextContent(t, !1).replace(/^\s*|\s*$/g, ""),
				n = e[0].srsName,
				r = "enu";
			if (n) {
				var o = c.
			default.get(n);
				o && (r = o.getAxisOrientation())
			}
			for (var s, a, l, u = i.trim().split(/\s+/), h = [], f = 0, A = u.length; f < A; f++) {
				var p = u[f].split(/,+/);
				s = parseFloat(p[0]), a = parseFloat(p[1]), l = 3 === p.length ? parseFloat(p[2]) : 0, "en" === r.substr(0, 2) ? h.push(s, a, l) : h.push(a, s, l)
			}
			return h
		}, f.prototype.readBox_ = function(t, e) {
			var i = d.a.pushParseAndPop([null], this.BOX_PARSERS_, t, e, this);
			return o.
		default.createOrUpdate(i[1][0], i[1][1], i[1][3], i[1][4])
		}, f.prototype.innerBoundaryIsParser_ = function(t, e) {
			var i = d.a.pushParseAndPop(void 0, this.RING_PARSERS, t, e, this);
			i && e[e.length - 1].push(i)
		}, f.prototype.outerBoundaryIsParser_ = function(t, e) {
			var i = d.a.pushParseAndPop(void 0, this.RING_PARSERS, t, e, this);
			i && (e[e.length - 1][0] = i)
		}, f.prototype.GEOMETRY_FLAT_COORDINATES_PARSERS_ = {
			"http://www.opengis.net/gml": {
				coordinates: d.a.makeReplacer(f.prototype.readFlatCoordinates_)
			}
		}, f.prototype.FLAT_LINEAR_RINGS_PARSERS_ = {
			"http://www.opengis.net/gml": {
				innerBoundaryIs: f.prototype.innerBoundaryIsParser_,
				outerBoundaryIs: f.prototype.outerBoundaryIsParser_
			}
		}, f.prototype.BOX_PARSERS_ = {
			"http://www.opengis.net/gml": {
				coordinates: d.a.makeArrayPusher(f.prototype.readFlatCoordinates_)
			}
		}, f.prototype.GEOMETRY_PARSERS_ = {
			"http://www.opengis.net/gml": {
				Point: d.a.makeReplacer(a.a.prototype.readPoint),
				MultiPoint: d.a.makeReplacer(a.a.prototype.readMultiPoint),
				LineString: d.a.makeReplacer(a.a.prototype.readLineString),
				MultiLineString: d.a.makeReplacer(a.a.prototype.readMultiLineString),
				LinearRing: d.a.makeReplacer(a.a.prototype.readLinearRing),
				Polygon: d.a.makeReplacer(a.a.prototype.readPolygon),
				MultiPolygon: d.a.makeReplacer(a.a.prototype.readMultiPolygon),
				Box: d.a.makeReplacer(f.prototype.readBox_)
			}
		}, f.prototype.GEOMETRY_NODE_FACTORY_ = function(t, e, i) {
			var n, r = e[e.length - 1],
				o = r.multiSurface,
				s = r.surface,
				a = r.multiCurve;
			return Array.isArray(t) ? n = "Envelope" : "MultiPolygon" === (n = t.getType()) && !0 === o ? n = "MultiSurface" : "Polygon" === n && !0 === s ? n = "Surface" : "MultiLineString" === n && !0 === a && (n = "MultiCurve"), d.a.createElementNS("http://www.opengis.net/gml", n)
		}, f.prototype.writeFeatureElement = function(t, e, i) {
			var n = e.getId();
			n && t.setAttribute("fid", n);
			var r = i[i.length - 1],
				o = r.featureNS,
				s = e.getGeometryName();
			r.serializers || (r.serializers = {}, r.serializers[o] = {});
			var a = e.getProperties(),
				c = [],
				f = [];
			for (var A in a) {
				var p = a[A];
				null !== p && (c.push(A), f.push(p), A == s || p instanceof u.a ? A in r.serializers[o] || (r.serializers[o][A] = d.a.makeChildAppender(this.writeGeometryElement, this)) : A in r.serializers[o] || (r.serializers[o][A] = d.a.makeChildAppender(l.a.writeStringTextNode)))
			}
			var g = h.a.assign({}, r);
			g.node = t, d.a.pushSerializeAndPop(g, r.serializers, d.a.makeSimpleNodeFactory(void 0, o), f, i, c)
		}, f.prototype.writeGeometryElement = function(t, e, i) {
			var n, r = i[i.length - 1],
				o = h.a.assign({}, r);
			o.node = t, n = Array.isArray(e) ? r.dataProjection ? c.
		default.transformExtent(e, r.featureProjection, r.dataProjection):
			e : s.a.transformWithOptions(e, !0, r), d.a.pushSerializeAndPop(o, f.GEOMETRY_SERIALIZERS_, this.GEOMETRY_NODE_FACTORY_, [n], i, void 0, this)
		}, f.prototype.writeCurveOrLineString_ = function(t, e, i) {
			var n = i[i.length - 1].srsName;
			if ("LineStringSegment" !== t.nodeName && n && t.setAttribute("srsName", n), "LineString" === t.nodeName || "LineStringSegment" === t.nodeName) {
				var r = this.createCoordinatesNode_(t.namespaceURI);
				t.appendChild(r), this.writeCoordinates_(r, e, i)
			} else if ("Curve" === t.nodeName) {
				var o = d.a.createElementNS(t.namespaceURI, "segments");
				t.appendChild(o), this.writeCurveSegments_(o, e, i)
			}
		}, f.prototype.createCoordinatesNode_ = function(t) {
			var e = d.a.createElementNS(t, "coordinates");
			return e.setAttribute("decimal", "."), e.setAttribute("cs", ","), e.setAttribute("ts", " "), e
		}, f.prototype.writeCoordinates_ = function(t, e, i) {
			for (var n, r = i[i.length - 1], o = r.hasZ, s = r.srsName, a = e.getCoordinates(), u = a.length, h = new Array(u), c = 0; c < u; ++c) n = a[c], h[c] = this.getCoords_(n, s, o);
			l.a.writeStringTextNode(t, h.join(" "))
		}, f.prototype.writeCurveSegments_ = function(t, e, i) {
			var n = d.a.createElementNS(t.namespaceURI, "LineStringSegment");
			t.appendChild(n), this.writeCurveOrLineString_(n, e, i)
		}, f.prototype.writeSurfaceOrPolygon_ = function(t, e, i) {
			var n = i[i.length - 1],
				r = n.hasZ,
				o = n.srsName;
			if ("PolygonPatch" !== t.nodeName && o && t.setAttribute("srsName", o), "Polygon" === t.nodeName || "PolygonPatch" === t.nodeName) {
				var s = e.getLinearRings();
				d.a.pushSerializeAndPop({
					node: t,
					hasZ: r,
					srsName: o
				}, f.RING_SERIALIZERS_, this.RING_NODE_FACTORY_, s, i, void 0, this)
			} else if ("Surface" === t.nodeName) {
				var a = d.a.createElementNS(t.namespaceURI, "patches");
				t.appendChild(a), this.writeSurfacePatches_(a, e, i)
			}
		}, f.prototype.RING_NODE_FACTORY_ = function(t, e, i) {
			var n = e[e.length - 1],
				r = n.node,
				o = n.exteriorWritten;
			return void 0 === o && (n.exteriorWritten = !0), d.a.createElementNS(r.namespaceURI, void 0 !== o ? "innerBoundaryIs" : "outerBoundaryIs")
		}, f.prototype.writeSurfacePatches_ = function(t, e, i) {
			var n = d.a.createElementNS(t.namespaceURI, "PolygonPatch");
			t.appendChild(n), this.writeSurfaceOrPolygon_(n, e, i)
		}, f.prototype.writeRing_ = function(t, e, i) {
			var n = d.a.createElementNS(t.namespaceURI, "LinearRing");
			t.appendChild(n), this.writeLinearRing_(n, e, i)
		}, f.prototype.getCoords_ = function(t, e, i) {
			var n = "enu";
			e && (n = c.
		default.get(e).getAxisOrientation());
			var r = "en" === n.substr(0, 2) ? t[0] + "," + t[1] : t[1] + "," + t[0];
			i && (r += "," + (t[2] || 0));
			return r
		}, f.prototype.writeMultiCurveOrLineString_ = function(t, e, i) {
			var n = i[i.length - 1],
				r = n.hasZ,
				o = n.srsName,
				s = n.curve;
			o && t.setAttribute("srsName", o);
			var a = e.getLineStrings();
			d.a.pushSerializeAndPop({
				node: t,
				hasZ: r,
				srsName: o,
				curve: s
			}, f.LINESTRINGORCURVEMEMBER_SERIALIZERS_, this.MULTIGEOMETRY_MEMBER_NODE_FACTORY_, a, i, void 0, this)
		}, f.prototype.writePoint_ = function(t, e, i) {
			var n = i[i.length - 1],
				r = n.hasZ,
				o = n.srsName;
			o && t.setAttribute("srsName", o);
			var s = this.createCoordinatesNode_(t.namespaceURI);
			t.appendChild(s);
			var a = e.getCoordinates(),
				u = this.getCoords_(a, o, r);
			l.a.writeStringTextNode(s, u)
		}, f.prototype.writeMultiPoint_ = function(t, e, i) {
			var n = i[i.length - 1],
				r = n.hasZ,
				o = n.srsName;
			o && t.setAttribute("srsName", o);
			var s = e.getPoints();
			d.a.pushSerializeAndPop({
				node: t,
				hasZ: r,
				srsName: o
			}, f.POINTMEMBER_SERIALIZERS_, d.a.makeSimpleNodeFactory("pointMember"), s, i, void 0, this)
		}, f.prototype.writePointMember_ = function(t, e, i) {
			var n = d.a.createElementNS(t.namespaceURI, "Point");
			t.appendChild(n), this.writePoint_(n, e, i)
		}, f.prototype.writeLineStringOrCurveMember_ = function(t, e, i) {
			var n = this.GEOMETRY_NODE_FACTORY_(e, i);
			n && (t.appendChild(n), this.writeCurveOrLineString_(n, e, i))
		}, f.prototype.writeLinearRing_ = function(t, e, i) {
			var n = i[i.length - 1].srsName;
			n && t.setAttribute("srsName", n);
			var r = this.createCoordinatesNode_(t.namespaceURI);
			t.appendChild(r), this.writeCoordinates_(r, e, i)
		}, f.prototype.writeMultiSurfaceOrPolygon_ = function(t, e, i) {
			var n = i[i.length - 1],
				r = n.hasZ,
				o = n.srsName,
				s = n.surface;
			o && t.setAttribute("srsName", o);
			var a = e.getPolygons();
			d.a.pushSerializeAndPop({
				node: t,
				hasZ: r,
				srsName: o,
				surface: s
			}, f.SURFACEORPOLYGONMEMBER_SERIALIZERS_, this.MULTIGEOMETRY_MEMBER_NODE_FACTORY_, a, i, void 0, this)
		}, f.prototype.writeSurfaceOrPolygonMember_ = function(t, e, i) {
			var n = this.GEOMETRY_NODE_FACTORY_(e, i);
			n && (t.appendChild(n), this.writeSurfaceOrPolygon_(n, e, i))
		}, f.prototype.writeEnvelope = function(t, e, i) {
			var n = i[i.length - 1].srsName;
			n && t.setAttribute("srsName", n);
			var r = [e[0] + " " + e[1], e[2] + " " + e[3]];
			d.a.pushSerializeAndPop({
				node: t
			}, f.ENVELOPE_SERIALIZERS_, d.a.OBJECT_PROPERTY_NODE_FACTORY, r, i, ["lowerCorner", "upperCorner"], this)
		}, f.GEOMETRY_SERIALIZERS_ = {
			"http://www.opengis.net/gml": {
				Curve: d.a.makeChildAppender(f.prototype.writeCurveOrLineString_),
				MultiCurve: d.a.makeChildAppender(f.prototype.writeMultiCurveOrLineString_),
				Point: d.a.makeChildAppender(f.prototype.writePoint_),
				MultiPoint: d.a.makeChildAppender(f.prototype.writeMultiPoint_),
				LineString: d.a.makeChildAppender(f.prototype.writeCurveOrLineString_),
				MultiLineString: d.a.makeChildAppender(f.prototype.writeMultiCurveOrLineString_),
				LinearRing: d.a.makeChildAppender(f.prototype.writeLinearRing_),
				Polygon: d.a.makeChildAppender(f.prototype.writeSurfaceOrPolygon_),
				MultiPolygon: d.a.makeChildAppender(f.prototype.writeMultiSurfaceOrPolygon_),
				Surface: d.a.makeChildAppender(f.prototype.writeSurfaceOrPolygon_),
				MultiSurface: d.a.makeChildAppender(f.prototype.writeMultiSurfaceOrPolygon_),
				Envelope: d.a.makeChildAppender(f.prototype.writeEnvelope)
			}
		}, f.RING_SERIALIZERS_ = {
			"http://www.opengis.net/gml": {
				outerBoundaryIs: d.a.makeChildAppender(f.prototype.writeRing_),
				innerBoundaryIs: d.a.makeChildAppender(f.prototype.writeRing_)
			}
		}, f.POINTMEMBER_SERIALIZERS_ = {
			"http://www.opengis.net/gml": {
				pointMember: d.a.makeChildAppender(f.prototype.writePointMember_)
			}
		}, f.LINESTRINGORCURVEMEMBER_SERIALIZERS_ = {
			"http://www.opengis.net/gml": {
				lineStringMember: d.a.makeChildAppender(f.prototype.writeLineStringOrCurveMember_),
				curveMember: d.a.makeChildAppender(f.prototype.writeLineStringOrCurveMember_)
			}
		}, f.prototype.MULTIGEOMETRY_MEMBER_NODE_FACTORY_ = function(t, e, i) {
			var n = e[e.length - 1].node;
			return d.a.createElementNS("http://www.opengis.net/gml", f.MULTIGEOMETRY_TO_MEMBER_NODENAME_[n.nodeName])
		}, f.MULTIGEOMETRY_TO_MEMBER_NODENAME_ = {
			MultiLineString: "lineStringMember",
			MultiCurve: "curveMember",
			MultiPolygon: "polygonMember",
			MultiSurface: "surfaceMember"
		}, f.SURFACEORPOLYGONMEMBER_SERIALIZERS_ = {
			"http://www.opengis.net/gml": {
				surfaceMember: d.a.makeChildAppender(f.prototype.writeSurfaceOrPolygonMember_),
				polygonMember: d.a.makeChildAppender(f.prototype.writeSurfaceOrPolygonMember_)
			}
		}, f.ENVELOPE_SERIALIZERS_ = {
			"http://www.opengis.net/gml": {
				lowerCorner: d.a.makeChildAppender(l.a.writeStringTextNode),
				upperCorner: d.a.makeChildAppender(l.a.writeStringTextNode)
			}
		};
		var A = f,
			p = i(99),
			g = function(t) {
				this.tagName_ = t
			};
		g.prototype.getTagName = function() {
			return this.tagName_
		};
		var m = g,
			v = function(t, e) {
				m.call(this, t), this.conditions = Array.prototype.slice.call(arguments, 1), r.a.assert(this.conditions.length >= 2, 57)
			};
		n.
	default.inherits(v, m);
		var y = v,
			_ = function(t) {
				var e = ["And"].concat(Array.prototype.slice.call(arguments));
				y.apply(this, e)
			};
		n.
	default.inherits(_, y);
		var E = _,
			x = function(t, e, i) {
				m.call(this, "BBOX"), this.geometryName = t, this.extent = e, this.srsName = i
			};
		n.
	default.inherits(x, m);
		var C = x,
			I = function(t, e, i, n) {
				m.call(this, t), this.geometryName = e || "the_geom", this.geometry = i, this.srsName = n
			};
		n.
	default.inherits(I, m);
		var S = I,
			T = function(t, e, i) {
				S.call(this, "Contains", t, e, i)
			};
		n.
	default.inherits(T, S);
		var R = T,
			w = function(t, e) {
				m.call(this, t), this.propertyName = e
			};
		n.
	default.inherits(w, m);
		var L = w,
			N = function(t, e, i) {
				L.call(this, "During", t), this.begin = e, this.end = i
			};
		n.
	default.inherits(N, L);
		var P = N,
			O = function(t, e, i, n) {
				L.call(this, t, e), this.expression = i, this.matchCase = n
			};
		n.
	default.inherits(O, L);
		var M = O,
			b = function(t, e, i) {
				M.call(this, "PropertyIsEqualTo", t, e, i)
			};
		n.
	default.inherits(b, M);
		var F = b,
			D = function(t, e) {
				M.call(this, "PropertyIsGreaterThan", t, e)
			};
		n.
	default.inherits(D, M);
		var G = D,
			k = function(t, e) {
				M.call(this, "PropertyIsGreaterThanOrEqualTo", t, e)
			};
		n.
	default.inherits(k, M);
		var U = k,
			B = function(t, e, i) {
				S.call(this, "Intersects", t, e, i)
			};
		n.
	default.inherits(B, S);
		var j = B,
			V = function(t, e, i) {
				L.call(this, "PropertyIsBetween", t), this.lowerBoundary = e, this.upperBoundary = i
			};
		n.
	default.inherits(V, L);
		var Y = V,
			z = function(t, e, i, n, r, o) {
				L.call(this, "PropertyIsLike", t), this.pattern = e, this.wildCard = void 0 !== i ? i : "*", this.singleChar = void 0 !== n ? n : ".", this.escapeChar = void 0 !== r ? r : "!", this.matchCase = o
			};
		n.
	default.inherits(z, L);
		var X = z,
			W = function(t) {
				L.call(this, "PropertyIsNull", t)
			};
		n.
	default.inherits(W, L);
		var q = W,
			H = function(t, e) {
				M.call(this, "PropertyIsLessThan", t, e)
			};
		n.
	default.inherits(H, M);
		var Z = H,
			K = function(t, e) {
				M.call(this, "PropertyIsLessThanOrEqualTo", t, e)
			};
		n.
	default.inherits(K, M);
		var J = K,
			Q = function(t) {
				m.call(this, "Not"), this.condition = t
			};
		n.
	default.inherits(Q, m);
		var $ = Q,
			tt = function(t, e, i) {
				M.call(this, "PropertyIsNotEqualTo", t, e, i)
			};
		n.
	default.inherits(tt, M);
		var et = tt,
			it = function(t) {
				var e = ["Or"].concat(Array.prototype.slice.call(arguments));
				y.apply(this, e)
			};
		n.
	default.inherits(it, y);
		var nt = it,
			rt = function(t, e, i) {
				S.call(this, "Within", t, e, i)
			};
		n.
	default.inherits(rt, S);
		var ot = rt,
			st = {
				and: function(t) {
					var e = [null].concat(Array.prototype.slice.call(arguments));
					return new(Function.prototype.bind.apply(E, e))
				},
				or: function(t) {
					var e = [null].concat(Array.prototype.slice.call(arguments));
					return new(Function.prototype.bind.apply(nt, e))
				},
				not: function(t) {
					return new $(t)
				},
				bbox: function(t, e, i) {
					return new C(t, e, i)
				},
				contains: function(t, e, i) {
					return new R(t, e, i)
				},
				intersects: function(t, e, i) {
					return new j(t, e, i)
				},
				within: function(t, e, i) {
					return new ot(t, e, i)
				},
				equalTo: function(t, e, i) {
					return new F(t, e, i)
				},
				notEqualTo: function(t, e, i) {
					return new et(t, e, i)
				},
				lessThan: function(t, e) {
					return new Z(t, e)
				},
				lessThanOrEqualTo: function(t, e) {
					return new J(t, e)
				},
				greaterThan: function(t, e) {
					return new G(t, e)
				},
				greaterThanOrEqualTo: function(t, e) {
					return new U(t, e)
				},
				isNull: function(t) {
					return new q(t)
				},
				between: function(t, e, i) {
					return new Y(t, e, i)
				},
				like: function(t, e, i, n, r, o) {
					return new X(t, e, i, n, r, o)
				},
				during: function(t, e, i) {
					return new P(t, e, i)
				}
			},
			at = st,
			lt = i(123),
			ut = function(t) {
				var e = t || {};
				this.featureType_ = e.featureType, this.featureNS_ = e.featureNS, this.gmlFormat_ = e.gmlFormat ? e.gmlFormat : new p.
			default, this.schemaLocation_ = e.schemaLocation ? e.schemaLocation:
				ut.SCHEMA_LOCATIONS[ut.DEFAULT_VERSION], lt.a.call(this)
			};
		n.
	default.inherits(ut, lt.a), ut.FEATURE_PREFIX = "feature", ut.XMLNS = "http://www.w3.org/2000/xmlns/", ut.OGCNS = "http://www.opengis.net/ogc", ut.WFSNS = "http://www.opengis.net/wfs", ut.FESNS = "http://www.opengis.net/fes", ut.SCHEMA_LOCATIONS = {
			"1.1.0": "http://www.opengis.net/wfs http://schemas.opengis.net/wfs/1.1.0/wfs.xsd",
			"1.0.0": "http://www.opengis.net/wfs http://schemas.opengis.net/wfs/1.0.0/wfs.xsd"
		}, ut.DEFAULT_VERSION = "1.1.0", ut.prototype.getFeatureType = function() {
			return this.featureType_
		}, ut.prototype.setFeatureType = function(t) {
			this.featureType_ = t
		}, ut.prototype.readFeatures, ut.prototype.readFeaturesFromNode = function(t, e) {
			var i = {
				featureType: this.featureType_,
				featureNS: this.featureNS_
			};
			h.a.assign(i, this.getReadOptions(t, e || {}));
			var n = [i];
			this.gmlFormat_.FEATURE_COLLECTION_PARSERS[a.a.GMLNS].featureMember = d.a.makeArrayPusher(a.a.prototype.readFeaturesInternal);
			var r = d.a.pushParseAndPop([], this.gmlFormat_.FEATURE_COLLECTION_PARSERS, t, n, this.gmlFormat_);
			return r || (r = []), r
		}, ut.prototype.readTransactionResponse = function(t) {
			if (d.a.isDocument(t)) return this.readTransactionResponseFromDocument(t);
			if (d.a.isNode(t)) return this.readTransactionResponseFromNode(t);
			if ("string" == typeof t) {
				var e = d.a.parse(t);
				return this.readTransactionResponseFromDocument(e)
			}
		}, ut.prototype.readFeatureCollectionMetadata = function(t) {
			if (d.a.isDocument(t)) return this.readFeatureCollectionMetadataFromDocument(t);
			if (d.a.isNode(t)) return this.readFeatureCollectionMetadataFromNode(t);
			if ("string" == typeof t) {
				var e = d.a.parse(t);
				return this.readFeatureCollectionMetadataFromDocument(e)
			}
		}, ut.prototype.readFeatureCollectionMetadataFromDocument = function(t) {
			for (var e = t.firstChild; e; e = e.nextSibling) if (e.nodeType == Node.ELEMENT_NODE) return this.readFeatureCollectionMetadataFromNode(e)
		}, ut.FEATURE_COLLECTION_PARSERS_ = {
			"http://www.opengis.net/gml": {
				boundedBy: d.a.makeObjectPropertySetter(a.a.prototype.readGeometryElement, "bounds")
			}
		}, ut.prototype.readFeatureCollectionMetadataFromNode = function(t) {
			var e = {},
				i = l.a.readNonNegativeIntegerString(t.getAttribute("numberOfFeatures"));
			return e.numberOfFeatures = i, d.a.pushParseAndPop(e, ut.FEATURE_COLLECTION_PARSERS_, t, [], this.gmlFormat_)
		}, ut.TRANSACTION_SUMMARY_PARSERS_ = {
			"http://www.opengis.net/wfs": {
				totalInserted: d.a.makeObjectPropertySetter(l.a.readNonNegativeInteger),
				totalUpdated: d.a.makeObjectPropertySetter(l.a.readNonNegativeInteger),
				totalDeleted: d.a.makeObjectPropertySetter(l.a.readNonNegativeInteger)
			}
		}, ut.readTransactionSummary_ = function(t, e) {
			return d.a.pushParseAndPop({}, ut.TRANSACTION_SUMMARY_PARSERS_, t, e)
		}, ut.OGC_FID_PARSERS_ = {
			"http://www.opengis.net/ogc": {
				FeatureId: d.a.makeArrayPusher((function(t, e) {
					return t.getAttribute("fid")
				}))
			}
		}, ut.fidParser_ = function(t, e) {
			d.a.parseNode(ut.OGC_FID_PARSERS_, t, e)
		}, ut.INSERT_RESULTS_PARSERS_ = {
			"http://www.opengis.net/wfs": {
				Feature: ut.fidParser_
			}
		}, ut.readInsertResults_ = function(t, e) {
			return d.a.pushParseAndPop([], ut.INSERT_RESULTS_PARSERS_, t, e)
		}, ut.TRANSACTION_RESPONSE_PARSERS_ = {
			"http://www.opengis.net/wfs": {
				TransactionSummary: d.a.makeObjectPropertySetter(ut.readTransactionSummary_, "transactionSummary"),
				InsertResults: d.a.makeObjectPropertySetter(ut.readInsertResults_, "insertIds")
			}
		}, ut.prototype.readTransactionResponseFromDocument = function(t) {
			for (var e = t.firstChild; e; e = e.nextSibling) if (e.nodeType == Node.ELEMENT_NODE) return this.readTransactionResponseFromNode(e)
		}, ut.prototype.readTransactionResponseFromNode = function(t) {
			return d.a.pushParseAndPop({}, ut.TRANSACTION_RESPONSE_PARSERS_, t, [])
		}, ut.QUERY_SERIALIZERS_ = {
			"http://www.opengis.net/wfs": {
				PropertyName: d.a.makeChildAppender(l.a.writeStringTextNode)
			}
		}, ut.writeFeature_ = function(t, e, i) {
			var n = i[i.length - 1],
				r = n.featureType,
				o = n.featureNS,
				s = n.gmlVersion,
				a = d.a.createElementNS(o, r);
			t.appendChild(a), 2 === s ? A.prototype.writeFeatureElement(a, e, i) : p.
		default.prototype.writeFeatureElement(a, e, i)
		}, ut.writeOgcFidFilter_ = function(t, e, i) {
			var n = d.a.createElementNS(ut.OGCNS, "Filter"),
				r = d.a.createElementNS(ut.OGCNS, "FeatureId");
			n.appendChild(r), r.setAttribute("fid", e), t.appendChild(n)
		}, ut.getTypeName_ = function(t, e) {
			var i = (t = t || ut.FEATURE_PREFIX) + ":";
			return 0 === e.indexOf(i) ? e : i + e
		}, ut.writeDelete_ = function(t, e, i) {
			var n = i[i.length - 1];
			r.a.assert(void 0 !== e.getId(), 26);
			var o = n.featureType,
				s = n.featurePrefix,
				a = n.featureNS,
				l = ut.getTypeName_(s, o);
			t.setAttribute("typeName", l), d.a.setAttributeNS(t, ut.XMLNS, "xmlns:" + s, a);
			var u = e.getId();
			void 0 !== u && ut.writeOgcFidFilter_(t, u, i)
		}, ut.writeUpdate_ = function(t, e, i) {
			var n = i[i.length - 1];
			r.a.assert(void 0 !== e.getId(), 27);
			var o = n.featureType,
				s = n.featurePrefix,
				a = n.featureNS,
				l = ut.getTypeName_(s, o),
				h = e.getGeometryName();
			t.setAttribute("typeName", l), d.a.setAttributeNS(t, ut.XMLNS, "xmlns:" + s, a);
			var c = e.getId();
			if (void 0 !== c) {
				for (var f = e.getKeys(), A = [], p = 0, g = f.length; p < g; p++) {
					var m = e.get(f[p]);
					if (void 0 !== m) {
						var v = f[p];
						m instanceof u.a && (v = h), A.push({
							name: v,
							value: m
						})
					}
				}
				d.a.pushSerializeAndPop({
					gmlVersion: n.gmlVersion,
					node: t,
					hasZ: n.hasZ,
					srsName: n.srsName
				}, ut.TRANSACTION_SERIALIZERS_, d.a.makeSimpleNodeFactory("Property"), A, i), ut.writeOgcFidFilter_(t, c, i)
			}
		}, ut.writeProperty_ = function(t, e, i) {
			var n = d.a.createElementNS(ut.WFSNS, "Name"),
				r = i[i.length - 1].gmlVersion;
			if (t.appendChild(n), l.a.writeStringTextNode(n, e.name), void 0 !== e.value && null !== e.value) {
				var o = d.a.createElementNS(ut.WFSNS, "Value");
				t.appendChild(o), e.value instanceof u.a ? 2 === r ? A.prototype.writeGeometryElement(o, e.value, i) : p.
			default.prototype.writeGeometryElement(o, e.value, i):
				l.a.writeStringTextNode(o, e.value)
			}
		}, ut.writeNative_ = function(t, e, i) {
			e.vendorId && t.setAttribute("vendorId", e.vendorId), void 0 !== e.safeToIgnore && t.setAttribute("safeToIgnore", e.safeToIgnore), void 0 !== e.value && l.a.writeStringTextNode(t, e.value)
		}, ut.TRANSACTION_SERIALIZERS_ = {
			"http://www.opengis.net/wfs": {
				Insert: d.a.makeChildAppender(ut.writeFeature_),
				Update: d.a.makeChildAppender(ut.writeUpdate_),
				Delete: d.a.makeChildAppender(ut.writeDelete_),
				Property: d.a.makeChildAppender(ut.writeProperty_),
				Native: d.a.makeChildAppender(ut.writeNative_)
			}
		}, ut.writeQuery_ = function(t, e, i) {
			var n, r = i[i.length - 1],
				o = r.featurePrefix,
				s = r.featureNS,
				a = r.propertyNames,
				l = r.srsName;
			n = o ? ut.getTypeName_(o, e) : e, t.setAttribute("typeName", n), l && t.setAttribute("srsName", l), s && d.a.setAttributeNS(t, ut.XMLNS, "xmlns:" + o, s);
			var u = h.a.assign({}, r);
			u.node = t, d.a.pushSerializeAndPop(u, ut.QUERY_SERIALIZERS_, d.a.makeSimpleNodeFactory("PropertyName"), a, i);
			var c = r.filter;
			if (c) {
				var f = d.a.createElementNS(ut.OGCNS, "Filter");
				t.appendChild(f), ut.writeFilterCondition_(f, c, i)
			}
		}, ut.writeFilterCondition_ = function(t, e, i) {
			var n = {
				node: t
			};
			d.a.pushSerializeAndPop(n, ut.GETFEATURE_SERIALIZERS_, d.a.makeSimpleNodeFactory(e.getTagName()), [e], i)
		}, ut.writeBboxFilter_ = function(t, e, i) {
			i[i.length - 1].srsName = e.srsName, ut.writeOgcPropertyName_(t, e.geometryName), p.
		default.prototype.writeGeometryElement(t, e.extent, i)
		}, ut.writeContainsFilter_ = function(t, e, i) {
			i[i.length - 1].srsName = e.srsName, ut.writeOgcPropertyName_(t, e.geometryName), p.
		default.prototype.writeGeometryElement(t, e.geometry, i)
		}, ut.writeIntersectsFilter_ = function(t, e, i) {
			i[i.length - 1].srsName = e.srsName, ut.writeOgcPropertyName_(t, e.geometryName), p.
		default.prototype.writeGeometryElement(t, e.geometry, i)
		}, ut.writeWithinFilter_ = function(t, e, i) {
			i[i.length - 1].srsName = e.srsName, ut.writeOgcPropertyName_(t, e.geometryName), p.
		default.prototype.writeGeometryElement(t, e.geometry, i)
		}, ut.writeDuringFilter_ = function(t, e, i) {
			var n = d.a.createElementNS(ut.FESNS, "ValueReference");
			l.a.writeStringTextNode(n, e.propertyName), t.appendChild(n);
			var r = d.a.createElementNS(a.a.GMLNS, "TimePeriod");
			t.appendChild(r);
			var o = d.a.createElementNS(a.a.GMLNS, "begin");
			r.appendChild(o), ut.writeTimeInstant_(o, e.begin);
			var s = d.a.createElementNS(a.a.GMLNS, "end");
			r.appendChild(s), ut.writeTimeInstant_(s, e.end)
		}, ut.writeLogicalFilter_ = function(t, e, i) {
			for (var n = {
				node: t
			}, r = e.conditions, o = 0, s = r.length; o < s; ++o) {
				var a = r[o];
				d.a.pushSerializeAndPop(n, ut.GETFEATURE_SERIALIZERS_, d.a.makeSimpleNodeFactory(a.getTagName()), [a], i)
			}
		}, ut.writeNotFilter_ = function(t, e, i) {
			var n = {
				node: t
			},
				r = e.condition;
			d.a.pushSerializeAndPop(n, ut.GETFEATURE_SERIALIZERS_, d.a.makeSimpleNodeFactory(r.getTagName()), [r], i)
		}, ut.writeComparisonFilter_ = function(t, e, i) {
			void 0 !== e.matchCase && t.setAttribute("matchCase", e.matchCase.toString()), ut.writeOgcPropertyName_(t, e.propertyName), ut.writeOgcLiteral_(t, "" + e.expression)
		}, ut.writeIsNullFilter_ = function(t, e, i) {
			ut.writeOgcPropertyName_(t, e.propertyName)
		}, ut.writeIsBetweenFilter_ = function(t, e, i) {
			ut.writeOgcPropertyName_(t, e.propertyName);
			var n = d.a.createElementNS(ut.OGCNS, "LowerBoundary");
			t.appendChild(n), ut.writeOgcLiteral_(n, "" + e.lowerBoundary);
			var r = d.a.createElementNS(ut.OGCNS, "UpperBoundary");
			t.appendChild(r), ut.writeOgcLiteral_(r, "" + e.upperBoundary)
		}, ut.writeIsLikeFilter_ = function(t, e, i) {
			t.setAttribute("wildCard", e.wildCard), t.setAttribute("singleChar", e.singleChar), t.setAttribute("escapeChar", e.escapeChar), void 0 !== e.matchCase && t.setAttribute("matchCase", e.matchCase.toString()), ut.writeOgcPropertyName_(t, e.propertyName), ut.writeOgcLiteral_(t, "" + e.pattern)
		}, ut.writeOgcExpression_ = function(t, e, i) {
			var n = d.a.createElementNS(ut.OGCNS, t);
			l.a.writeStringTextNode(n, i), e.appendChild(n)
		}, ut.writeOgcPropertyName_ = function(t, e) {
			ut.writeOgcExpression_("PropertyName", t, e)
		}, ut.writeOgcLiteral_ = function(t, e) {
			ut.writeOgcExpression_("Literal", t, e)
		}, ut.writeTimeInstant_ = function(t, e) {
			var i = d.a.createElementNS(a.a.GMLNS, "TimeInstant");
			t.appendChild(i);
			var n = d.a.createElementNS(a.a.GMLNS, "timePosition");
			i.appendChild(n), l.a.writeStringTextNode(n, e)
		}, ut.GETFEATURE_SERIALIZERS_ = {
			"http://www.opengis.net/wfs": {
				Query: d.a.makeChildAppender(ut.writeQuery_)
			},
			"http://www.opengis.net/ogc": {
				During: d.a.makeChildAppender(ut.writeDuringFilter_),
				And: d.a.makeChildAppender(ut.writeLogicalFilter_),
				Or: d.a.makeChildAppender(ut.writeLogicalFilter_),
				Not: d.a.makeChildAppender(ut.writeNotFilter_),
				BBOX: d.a.makeChildAppender(ut.writeBboxFilter_),
				Contains: d.a.makeChildAppender(ut.writeContainsFilter_),
				Intersects: d.a.makeChildAppender(ut.writeIntersectsFilter_),
				Within: d.a.makeChildAppender(ut.writeWithinFilter_),
				PropertyIsEqualTo: d.a.makeChildAppender(ut.writeComparisonFilter_),
				PropertyIsNotEqualTo: d.a.makeChildAppender(ut.writeComparisonFilter_),
				PropertyIsLessThan: d.a.makeChildAppender(ut.writeComparisonFilter_),
				PropertyIsLessThanOrEqualTo: d.a.makeChildAppender(ut.writeComparisonFilter_),
				PropertyIsGreaterThan: d.a.makeChildAppender(ut.writeComparisonFilter_),
				PropertyIsGreaterThanOrEqualTo: d.a.makeChildAppender(ut.writeComparisonFilter_),
				PropertyIsNull: d.a.makeChildAppender(ut.writeIsNullFilter_),
				PropertyIsBetween: d.a.makeChildAppender(ut.writeIsBetweenFilter_),
				PropertyIsLike: d.a.makeChildAppender(ut.writeIsLikeFilter_)
			}
		}, ut.writeFilter = function(t) {
			var e = d.a.createElementNS(ut.OGCNS, "Filter");
			return ut.writeFilterCondition_(e, t, []), e
		}, ut.writeGetFeature_ = function(t, e, i) {
			var n = i[i.length - 1],
				r = h.a.assign({}, n);
			r.node = t, d.a.pushSerializeAndPop(r, ut.GETFEATURE_SERIALIZERS_, d.a.makeSimpleNodeFactory("Query"), e, i)
		}, ut.prototype.writeGetFeature = function(t) {
			var e, i = d.a.createElementNS(ut.WFSNS, "GetFeature");
			if (i.setAttribute("service", "WFS"), i.setAttribute("version", "1.1.0"), t && (t.handle && i.setAttribute("handle", t.handle), t.outputFormat && i.setAttribute("outputFormat", t.outputFormat), void 0 !== t.maxFeatures && i.setAttribute("maxFeatures", t.maxFeatures), t.resultType && i.setAttribute("resultType", t.resultType), void 0 !== t.startIndex && i.setAttribute("startIndex", t.startIndex), void 0 !== t.count && i.setAttribute("count", t.count), e = t.filter, t.bbox)) {
				r.a.assert(t.geometryName, 12);
				var n = at.bbox(t.geometryName, t.bbox, t.srsName);
				e = e ? at.and(e, n) : n
			}
			d.a.setAttributeNS(i, "http://www.w3.org/2001/XMLSchema-instance", "xsi:schemaLocation", this.schemaLocation_);
			var o = {
				node: i,
				srsName: t.srsName,
				featureNS: t.featureNS ? t.featureNS : this.featureNS_,
				featurePrefix: t.featurePrefix,
				geometryName: t.geometryName,
				filter: e,
				propertyNames: t.propertyNames ? t.propertyNames : []
			};
			return r.a.assert(Array.isArray(t.featureTypes), 11), ut.writeGetFeature_(i, t.featureTypes, [o]), i
		}, ut.prototype.writeTransaction = function(t, e, i, n) {
			var r, o, s = [],
				a = d.a.createElementNS(ut.WFSNS, "Transaction"),
				l = n.version ? n.version : ut.DEFAULT_VERSION,
				u = "1.0.0" === l ? 2 : 3;
			a.setAttribute("service", "WFS"), a.setAttribute("version", l), n && (r = n.gmlOptions ? n.gmlOptions : {}, n.handle && a.setAttribute("handle", n.handle));
			var c = ut.SCHEMA_LOCATIONS[l];
			d.a.setAttributeNS(a, "http://www.w3.org/2001/XMLSchema-instance", "xsi:schemaLocation", c);
			var f = n.featurePrefix ? n.featurePrefix : ut.FEATURE_PREFIX;
			return t && (o = {
				node: a,
				featureNS: n.featureNS,
				featureType: n.featureType,
				featurePrefix: f,
				gmlVersion: u,
				hasZ: n.hasZ,
				srsName: n.srsName
			}, h.a.assign(o, r), d.a.pushSerializeAndPop(o, ut.TRANSACTION_SERIALIZERS_, d.a.makeSimpleNodeFactory("Insert"), t, s)), e && (o = {
				node: a,
				featureNS: n.featureNS,
				featureType: n.featureType,
				featurePrefix: f,
				gmlVersion: u,
				hasZ: n.hasZ,
				srsName: n.srsName
			}, h.a.assign(o, r), d.a.pushSerializeAndPop(o, ut.TRANSACTION_SERIALIZERS_, d.a.makeSimpleNodeFactory("Update"), e, s)), i && d.a.pushSerializeAndPop({
				node: a,
				featureNS: n.featureNS,
				featureType: n.featureType,
				featurePrefix: f,
				gmlVersion: u,
				srsName: n.srsName
			}, ut.TRANSACTION_SERIALIZERS_, d.a.makeSimpleNodeFactory("Delete"), i, s), n.nativeElements && d.a.pushSerializeAndPop({
				node: a,
				featureNS: n.featureNS,
				featureType: n.featureType,
				featurePrefix: f,
				gmlVersion: u,
				srsName: n.srsName
			}, ut.TRANSACTION_SERIALIZERS_, d.a.makeSimpleNodeFactory("Native"), n.nativeElements, s), a
		}, ut.prototype.readProjection, ut.prototype.readProjectionFromDocument = function(t) {
			for (var e = t.firstChild; e; e = e.nextSibling) if (e.nodeType == Node.ELEMENT_NODE) return this.readProjectionFromNode(e);
			return null
		}, ut.prototype.readProjectionFromNode = function(t) {
			if (t.firstElementChild && t.firstElementChild.firstElementChild) for (var e = (t = t.firstElementChild.firstElementChild).firstElementChild; e; e = e.nextElementSibling) if (0 !== e.childNodes.length && (1 !== e.childNodes.length || 3 !== e.firstChild.nodeType)) {
				var i = [{}];
				return this.gmlFormat_.readGeometryElement(e, i), c.
			default.get(i.pop().srsName)
			}
			return null
		};
		e.
	default = ut
	}, function(t, e, i) {
		"use strict";
		i.r(e);
		var n = i(0),
			r = i(91),
			o = i(17),
			s = i(3),
			a = i(5),
			l = i(1),
			u = function(t, e, i, n, s, a) {
				r.a.call(this, t, e, i, o.a.IDLE), this.src_ = n, this.image_ = new Image, null !== s && (this.image_.crossOrigin = s), this.imageListenerKeys_ = null, this.state = o.a.IDLE, this.imageLoadFunction_ = a
			};
		n.
	default.inherits(u, r.a), u.prototype.getImage = function() {
			return this.image_
		}, u.prototype.handleImageError_ = function() {
			this.state = o.a.ERROR, this.unlistenImage_(), this.changed()
		}, u.prototype.handleImageLoad_ = function() {
			void 0 === this.resolution && (this.resolution = l.
		default.getHeight(this.extent) / this.image_.height), this.state = o.a.LOADED, this.unlistenImage_(), this.changed()
		}, u.prototype.load = function() {
			this.state != o.a.IDLE && this.state != o.a.ERROR || (this.state = o.a.LOADING, this.changed(), this.imageListenerKeys_ = [s.a.listenOnce(this.image_, a.a.ERROR, this.handleImageError_, this), s.a.listenOnce(this.image_, a.a.LOAD, this.handleImageLoad_, this)], this.imageLoadFunction_(this, this.src_))
		}, u.prototype.setImage = function(t) {
			this.image_ = t
		}, u.prototype.unlistenImage_ = function() {
			this.imageListenerKeys_.forEach(s.a.unlistenByKey), this.imageListenerKeys_ = null
		};
		var h = u,
			c = i(16),
			d = i(9),
			f = i(10),
			A = i(21),
			p = i(107),
			g = i(139),
			m = function(t, e, i, s, a, u) {
				this.targetProj_ = e, this.maxSourceExtent_ = t.getExtent();
				var h = e.getExtent(),
					c = h ? l.
				default.getIntersection(i, h):
					i,
					d = l.
				default.getCenter(c),
					f = p.a.calculateSourceResolution(t, e, d, s),
					A = n.
				default.DEFAULT_RASTER_REPROJECTION_ERROR_THRESHOLD;
				this.triangulation_ = new g.a(t, e, c, this.maxSourceExtent_, f * A), this.targetResolution_ = s, this.targetExtent_ = i;
				var m = this.triangulation_.calculateSourceExtent();
				this.sourceImage_ = u(m, f, a), this.sourcePixelRatio_ = this.sourceImage_ ? this.sourceImage_.getPixelRatio():
				1, this.canvas_ = null, this.sourceListenerKey_ = null;
				var v = o.a.LOADED;
				this.sourceImage_ && (v = o.a.IDLE), r.a.call(this, i, s, this.sourcePixelRatio_, v)
			};
		n.
	default.inherits(m, r.a), m.prototype.disposeInternal = function() {
			this.state == o.a.LOADING && this.unlistenSource_(), r.a.prototype.disposeInternal.call(this)
		}, m.prototype.getImage = function() {
			return this.canvas_
		}, m.prototype.getProjection = function() {
			return this.targetProj_
		}, m.prototype.reproject_ = function() {
			var t = this.sourceImage_.getState();
			if (t == o.a.LOADED) {
				var e = l.
			default.getWidth(this.targetExtent_) / this.targetResolution_,
					i = l.
				default.getHeight(this.targetExtent_) / this.targetResolution_;
				this.canvas_ = p.a.render(e, i, this.sourcePixelRatio_, this.sourceImage_.getResolution(), this.maxSourceExtent_, this.targetResolution_, this.targetExtent_, this.triangulation_, [{
					extent: this.sourceImage_.getExtent(),
					image: this.sourceImage_.getImage()
				}], 0)
			}
			this.state = t, this.changed()
		}, m.prototype.load = function() {
			if (this.state == o.a.IDLE) {
				this.state = o.a.LOADING, this.changed();
				var t = this.sourceImage_.getState();
				t == o.a.LOADED || t == o.a.ERROR ? this.reproject_() : (this.sourceListenerKey_ = s.a.listen(this.sourceImage_, a.a.CHANGE, (function(t) {
					var e = this.sourceImage_.getState();
					e != o.a.LOADED && e != o.a.ERROR || (this.unlistenSource_(), this.reproject_())
				}), this), this.sourceImage_.load())
			}
		}, m.prototype.unlistenSource_ = function() {
			s.a.unlistenByKey(this.sourceListenerKey_), this.sourceListenerKey_ = null
		};
		var v = m,
			y = i(97),
			_ = function(t) {
				y.a.call(this, {
					attributions: t.attributions,
					extent: t.extent,
					logo: t.logo,
					projection: t.projection,
					state: t.state
				}), this.resolutions_ = void 0 !== t.resolutions ? t.resolutions : null, this.reprojectedImage_ = null, this.reprojectedRevision_ = 0
			};
		n.
	default.inherits(_, y.a), _.prototype.getResolutions = function() {
			return this.resolutions_
		}, _.prototype.findNearestResolution = function(t) {
			if (this.resolutions_) {
				var e = f.a.linearFindNearest(this.resolutions_, t, 0);
				t = this.resolutions_[e]
			}
			return t
		}, _.prototype.getImage = function(t, e, i, r) {
			var o = this.getProjection();
			if (n.
		default.ENABLE_RASTER_REPROJECTION && o && r && !d.
		default.equivalent(o, r)) {
				if (this.reprojectedImage_) {
					if (this.reprojectedRevision_ == this.getRevision() && d.
				default.equivalent(this.reprojectedImage_.getProjection(), r) && this.reprojectedImage_.getResolution() == e && l.
				default.equals(this.reprojectedImage_.getExtent(), t)) return this.reprojectedImage_;
					this.reprojectedImage_.dispose(), this.reprojectedImage_ = null
				}
				return this.reprojectedImage_ = new v(o, r, t, e, i, function(t, e, i) {
					return this.getImageInternal(t, e, i, o)
				}.bind(this)), this.reprojectedRevision_ = this.getRevision(), this.reprojectedImage_
			}
			return o && (r = o), this.getImageInternal(t, e, i, r)
		}, _.prototype.getImageInternal = function(t, e, i, n) {}, _.prototype.handleImageChange = function(t) {
			var e = t.target;
			switch (e.getState()) {
			case o.a.LOADING:
				this.dispatchEvent(new _.Event(_.EventType_.IMAGELOADSTART, e));
				break;
			case o.a.LOADED:
				this.dispatchEvent(new _.Event(_.EventType_.IMAGELOADEND, e));
				break;
			case o.a.ERROR:
				this.dispatchEvent(new _.Event(_.EventType_.IMAGELOADERROR, e))
			}
		}, _.defaultImageLoadFunction = function(t, e) {
			t.getImage().src = e
		}, _.Event = function(t, e) {
			A.a.call(this, t), this.image = e
		}, n.
	default.inherits(_.Event, A.a), _.EventType_ = {
			IMAGELOADSTART: "imageloadstart",
			IMAGELOADEND: "imageloadend",
			IMAGELOADERROR: "imageloaderror"
		};
		var E = _,
			x = function(t) {
				var e = t.imageExtent,
					i = void 0 !== t.crossOrigin ? t.crossOrigin : null,
					n = void 0 !== t.imageLoadFunction ? t.imageLoadFunction : E.defaultImageLoadFunction;
				E.call(this, {
					attributions: t.attributions,
					logo: t.logo,
					projection: d.
				default.get(t.projection)
				}), this.image_ = new h(e, void 0, 1, t.url, i, n), this.imageSize_ = t.imageSize ? t.imageSize : null, s.a.listen(this.image_, a.a.CHANGE, this.handleImageChange, this)
			};
		n.
	default.inherits(x, E), x.prototype.getImageInternal = function(t, e, i, n) {
			return l.
		default.intersects(t, this.image_.getExtent()) ? this.image_:
			null
		}, x.prototype.handleImageChange = function(t) {
			if (this.image_.getState() == o.a.LOADED) {
				var e, i, n = this.image_.getExtent(),
					r = this.image_.getImage();
				this.imageSize_ ? (e = this.imageSize_[0], i = this.imageSize_[1]) : (e = r.width, i = r.height);
				var s = l.
			default.getHeight(n) / i,
					a = Math.ceil(l.
				default.getWidth(n) / s);
				if (a != e) {
					var u = c.a.createCanvasContext2D(a, i),
						h = u.canvas;
					u.drawImage(r, 0, 0, e, i, 0, 0, h.width, h.height), this.image_.setImage(h)
				}
			}
			E.prototype.handleImageChange.call(this, t)
		};
		e.
	default = x
	}, function(t, e, i) {
		"use strict";
		i.r(e);
		var n = i(0),
			r = i(14),
			o = i(15),
			s = i(43),
			a = {
				DEGREES: "degrees",
				IMPERIAL: "imperial",
				NAUTICAL: "nautical",
				METRIC: "metric",
				US: "us"
			},
			l = i(37),
			u = i(3),
			h = i(9),
			c = i(47),
			d = function(t) {
				var e = t || {},
					i = void 0 !== e.className ? e.className : "ol-scale-line";
				this.innerElement_ = document.createElement("DIV"), this.innerElement_.className = i + "-inner", this.element_ = document.createElement("DIV"), this.element_.className = i + " " + l.a.CLASS_UNSELECTABLE, this.element_.appendChild(this.innerElement_), this.viewState_ = null, this.minWidth_ = void 0 !== e.minWidth ? e.minWidth : 64, this.renderedVisible_ = !1, this.renderedWidth_ = void 0, this.renderedHTML_ = "";
				var n = e.render ? e.render : d.render;
				s.
			default.call(this, {
					element: this.element_,
					render: n,
					target: e.target
				}), u.a.listen(this, r.a.getChangeEventType(d.Property_.UNITS), this.handleUnitsChanged_, this), this.setUnits(e.units || a.METRIC)
			};
		n.
	default.inherits(d, s.
	default), d.LEADING_DIGITS = [1, 2, 5], d.prototype.getUnits = function() {
			return this.get(d.Property_.UNITS)
		}, d.render = function(t) {
			var e = t.frameState;
			this.viewState_ = e ? e.viewState : null, this.updateElement_()
		}, d.prototype.handleUnitsChanged_ = function() {
			this.updateElement_()
		}, d.prototype.setUnits = function(t) {
			this.set(d.Property_.UNITS, t)
		}, d.prototype.updateElement_ = function() {
			var t = this.viewState_;
			if (t) {
				var e = t.center,
					i = t.projection,
					n = this.getUnits(),
					r = n == a.DEGREES ? c.a.DEGREES : c.a.METERS,
					s = h.
				default.getPointResolution(i, t.resolution, e, r),
					l = this.minWidth_ * s,
					u = "";
				if (n == a.DEGREES) {
					var f = h.
				default.METERS_PER_UNIT[c.a.DEGREES];
					i.getUnits() == c.a.DEGREES ? l *= f:
					s /= f, l < f / 60 ? (u = "″", s *= 3600) : l < f ? (u = "′", s *= 60) : u = "°"
				} else n == a.IMPERIAL ? l < .9144 ? (u = "in", s /= .0254):
				l < 1609.344 ? (u = "ft", s /= .3048) : (u = "mi", s /= 1609.344) : n == a.NAUTICAL ? (s /= 1852, u = "nm") : n == a.METRIC ? l < .001 ? (u = "μm", s *= 1e6) : l < 1 ? (u = "mm", s *= 1e3) : l < 1e3 ? u = "m" : (u = "km", s /= 1e3) : n == a.US ? l < .9144 ? (u = "in", s *= 39.37) : l < 1609.344 ? (u = "ft", s /= .30480061) : (u = "mi", s /= 1609.3472) : o.a.assert(!1, 33);
				for (var A, p, g = 3 * Math.floor(Math.log(this.minWidth_ * s) / Math.log(10));;) {
					if (A = d.LEADING_DIGITS[(g % 3 + 3) % 3] * Math.pow(10, Math.floor(g / 3)), p = Math.round(A / s), isNaN(p)) return this.element_.style.display = "none", void(this.renderedVisible_ = !1);
					if (p >= this.minWidth_) break;
					++g
				}
				var m = A + " " + u;
				this.renderedHTML_ != m && (this.innerElement_.innerHTML = m, this.renderedHTML_ = m), this.renderedWidth_ != p && (this.innerElement_.style.width = p + "px", this.renderedWidth_ = p), this.renderedVisible_ || (this.element_.style.display = "", this.renderedVisible_ = !0)
			} else this.renderedVisible_ && (this.element_.style.display = "none", this.renderedVisible_ = !1)
		}, d.Property_ = {
			UNITS: "units"
		};
		e.
	default = d
	}, function(t, e, i) {
		"use strict";
		i.r(e);
		var n = i(0),
			r = i(79),
			o = i(10),
			s = i(1),
			a = i(8),
			l = i(9),
			u = i(71),
			h = {
				KVP: "KVP",
				REST: "REST"
			},
			c = i(147),
			d = i(113),
			f = function(t) {
				this.version_ = void 0 !== t.version ? t.version : "1.0.0", this.format_ = void 0 !== t.format ? t.format : "image/jpeg", this.dimensions_ = void 0 !== t.dimensions ? t.dimensions : {}, this.layer_ = t.layer, this.matrixSet_ = t.matrixSet, this.style_ = t.style;
				var e = t.urls;
				void 0 === e && void 0 !== t.url && (e = r.a.expandUrl(t.url)), this.requestEncoding_ = void 0 !== t.requestEncoding ? t.requestEncoding : h.KVP;
				var i = this.requestEncoding_,
					n = t.tileGrid,
					o = {
						layer: this.layer_,
						style: this.style_,
						tilematrixset: this.matrixSet_
					};
				i == h.KVP && a.a.assign(o, {
					Service: "WMTS",
					Request: "GetTile",
					Version: this.version_,
					Format: this.format_
				});
				var s = this.dimensions_;
				this.createFromWMTSTemplate_ = function(t) {
					return t = i == h.KVP ? d.a.appendParams(t, o) : t.replace(/\{(\w+?)\}/g, (function(t, e) {
						return e.toLowerCase() in o ? o[e.toLowerCase()] : t
					})), function(e, r, o) {
						if (e) {
							var l = {
								TileMatrix: n.getMatrixId(e[0]),
								TileCol: e[1],
								TileRow: -e[2] - 1
							};
							a.a.assign(l, s);
							var u = t;
							return u = i == h.KVP ? d.a.appendParams(u, l) : u.replace(/\{(\w+?)\}/g, (function(t, e) {
								return l[e]
							}))
						}
					}
				};
				var l = e && e.length > 0 ? r.a.createFromTileUrlFunctions(e.map(this.createFromWMTSTemplate_)) : r.a.nullTileUrlFunction;
				u.a.call(this, {
					attributions: t.attributions,
					cacheSize: t.cacheSize,
					crossOrigin: t.crossOrigin,
					logo: t.logo,
					projection: t.projection,
					reprojectionErrorThreshold: t.reprojectionErrorThreshold,
					tileClass: t.tileClass,
					tileGrid: n,
					tileLoadFunction: t.tileLoadFunction,
					tilePixelRatio: t.tilePixelRatio,
					tileUrlFunction: l,
					urls: e,
					wrapX: void 0 !== t.wrapX && t.wrapX,
					transition: t.transition
				}), this.setKey(this.getKeyForDimensions_())
			};
		n.
	default.inherits(f, u.a), f.prototype.setUrls = function(t) {
			this.urls = t;
			var e = t.join("\n");
			this.setTileUrlFunction(this.fixedTileUrlFunction ? this.fixedTileUrlFunction.bind(this) : r.a.createFromTileUrlFunctions(t.map(this.createFromWMTSTemplate_.bind(this))), e)
		}, f.prototype.getDimensions = function() {
			return this.dimensions_
		}, f.prototype.getFormat = function() {
			return this.format_
		}, f.prototype.getLayer = function() {
			return this.layer_
		}, f.prototype.getMatrixSet = function() {
			return this.matrixSet_
		}, f.prototype.getRequestEncoding = function() {
			return this.requestEncoding_
		}, f.prototype.getStyle = function() {
			return this.style_
		}, f.prototype.getVersion = function() {
			return this.version_
		}, f.prototype.getKeyForDimensions_ = function() {
			var t = 0,
				e = [];
			for (var i in this.dimensions_) e[t++] = i + "-" + this.dimensions_[i];
			return e.join("/")
		}, f.prototype.updateDimensions = function(t) {
			a.a.assign(this.dimensions_, t), this.setKey(this.getKeyForDimensions_())
		}, f.optionsFromCapabilities = function(t, e) {
			var i = t.Contents.Layer,
				n = o.a.find(i, (function(t, i, n) {
					return t.Identifier == e.layer
				}));
			if (null === n) return null;
			var r, a, u, d = t.Contents.TileMatrixSet;
			(r = n.TileMatrixSetLink.length > 1 ? "projection" in e ? o.a.findIndex(n.TileMatrixSetLink, (function(t, i, n) {
				var r = o.a.find(d, (function(e) {
					return e.Identifier == t.TileMatrixSet
				})).SupportedCRS,
					s = l.
				default.get(r.replace(/urn:ogc:def:crs:(\w+):(.*:)?(\w+)$/, "$1:$3")) || l.
				default.get(r),
					a = l.
				default.get(e.projection);
				return s && a ? l.
			default.equivalent(s, a):
				r == e.projection
			})) : o.a.findIndex(n.TileMatrixSetLink, (function(t, i, n) {
				return t.TileMatrixSet == e.matrixSet
			})) : 0) < 0 && (r = 0), a = n.TileMatrixSetLink[r].TileMatrixSet, u = n.TileMatrixSetLink[r].TileMatrixSetLimits;
			var f = n.Format[0];
			"format" in e && (f = e.format), (r = o.a.findIndex(n.Style, (function(t, i, n) {
				return "style" in e ? t.Title == e.style : t.isDefault
			}))) < 0 && (r = 0);
			var A = n.Style[r].Identifier,
				p = {};
			"Dimension" in n && n.Dimension.forEach((function(t, e, i) {
				var n = t.Identifier,
					r = t.Default;
				void 0 === r && (r = t.Value[0]), p[n] = r
			}));
			var g, m = t.Contents.TileMatrixSet,
				v = o.a.find(m, (function(t, e, i) {
					return t.Identifier == a
				})),
				y = v.SupportedCRS;
			if (y && (g = l.
		default.get(y.replace(/urn:ogc:def:crs:(\w+):(.*:)?(\w+)$/, "$1:$3")) || l.
		default.get(y)), "projection" in e) {
				var _ = l.
			default.get(e.projection);
				_ && (g && !l.
			default.equivalent(_, g) || (g = _))
			}
			var E, x, C = n.WGS84BoundingBox;
			if (void 0 !== C) {
				var I = l.
			default.get("EPSG:4326").getExtent();
				x = C[0] == I[0] && C[2] == I[2], E = l.
			default.transformExtent(C, "EPSG:4326", g);
				var S = g.getExtent();
				S && (s.
			default.containsExtent(S, E) || (E = void 0))
			}
			var T = c.
		default.createFromCapabilitiesMatrixSet(v, E, u),
				R = [],
				w = e.requestEncoding;
			if (w = void 0 !== w ? w : "", "OperationsMetadata" in t && "GetTile" in t.OperationsMetadata) for (var L = t.OperationsMetadata.GetTile.DCP.HTTP.Get, N = 0, P = L.length; N < P; ++N) if (L[N].Constraint) {
				var O = o.a.find(L[N].Constraint, (function(t) {
					return "GetEncoding" == t.name
				})).AllowedValues.Value;
				if ("" === w && (w = O[0]), w !== h.KVP) break;
				o.a.includes(O, h.KVP) && R.push(L[N].href)
			} else L[N].href && (w = h.KVP, R.push(L[N].href));
			return 0 === R.length && (w = h.REST, n.ResourceURL.forEach((function(t) {
				"tile" === t.resourceType && (f = t.format, R.push(t.template))
			}))), {
				urls: R,
				layer: e.layer,
				matrixSet: a,
				format: f,
				projection: g,
				requestEncoding: w,
				tileGrid: T,
				style: A,
				dimensions: p,
				wrapX: x,
				crossOrigin: e.crossOrigin
			}
		};
		e.
	default = f
	}, function(t, e, i) {
		"use strict";
		i.r(e);
		var n = i(0),
			r = i(79),
			o = i(1),
			s = {
				jsonp: function(t, e, i, r) {
					var o = document.createElement("script"),
						s = "olc_" + n.
					default.getUid(e);

					function a() {
						delete window[s], o.parentNode.removeChild(o)
					}
					o.async = !0, o.src = t + (-1 == t.indexOf("?") ? "?" : "&") + (r || "callback") + "=" + s;
					var l = setTimeout((function() {
						a(), i && i()
					}), 1e4);
					window[s] = function(t) {
						clearTimeout(l), a(), e(t)
					}, document.getElementsByTagName("head")[0].appendChild(o)
				}
			},
			a = s,
			l = i(9),
			u = i(59),
			h = i(71),
			c = i(49),
			d = i(75),
			f = function(t) {
				this.hidpi_ = void 0 !== t.hidpi && t.hidpi, h.a.call(this, {
					cacheSize: t.cacheSize,
					crossOrigin: "anonymous",
					opaque: !0,
					projection: l.
				default.get("EPSG:3857"),
					reprojectionErrorThreshold:
					t.reprojectionErrorThreshold,
					state: u.a.LOADING,
					tileLoadFunction: t.tileLoadFunction,
					tilePixelRatio: this.hidpi_ ? 2 : 1,
					wrapX: void 0 === t.wrapX || t.wrapX,
					transition: t.transition
				}), this.culture_ = void 0 !== t.culture ? t.culture : "en-us", this.maxZoom_ = void 0 !== t.maxZoom ? t.maxZoom : -1, this.apiKey_ = t.key, this.imagerySet_ = t.imagerySet;
				var e = "https://dev.virtualearth.net/REST/v1/Imagery/Metadata/" + this.imagerySet_ + "?uriScheme=https&include=ImageryProviders&key=" + this.apiKey_ + "&c=" + this.culture_;
				a.jsonp(e, this.handleImageryMetadataResponse.bind(this), void 0, "jsonp")
			};
		n.
	default.inherits(f, h.a), f.TOS_ATTRIBUTION = '<a class="ol-attribution-bing-tos" href="https://www.microsoft.com/maps/product/terms.html">Terms of Use</a>', f.prototype.getApiKey = function() {
			return this.apiKey_
		}, f.prototype.getImagerySet = function() {
			return this.imagerySet_
		}, f.prototype.handleImageryMetadataResponse = function(t) {
			if (200 == t.statusCode && "OK" == t.statusDescription && "ValidCredentials" == t.authenticationResultCode && 1 == t.resourceSets.length && 1 == t.resourceSets[0].resources.length) {
				var e = t.brandLogoUri; - 1 == e.indexOf("https") && (e = e.replace("http", "https"));
				var i = t.resourceSets[0].resources[0],
					n = -1 == this.maxZoom_ ? i.zoomMax : this.maxZoom_,
					s = this.getProjection(),
					a = d.a.extentFromProjection(s),
					h = i.imageWidth == i.imageHeight ? i.imageWidth : [i.imageWidth, i.imageHeight],
					A = d.a.createXYZ({
						extent: a,
						minZoom: i.zoomMin,
						maxZoom: n,
						tileSize: h / (this.hidpi_ ? 2 : 1)
					});
				this.tileGrid = A;
				var p = this.culture_,
					g = this.hidpi_;
				if (this.tileUrlFunction = r.a.createFromTileUrlFunctions(i.imageUrlSubdomains.map((function(t) {
					var e = [0, 0, 0],
						n = i.imageUrl.replace("{subdomain}", t).replace("{culture}", p);
					return function(t, i, r) {
						if (t) {
							c.a.createOrUpdate(t[0], t[1], -t[2] - 1, e);
							var o = n;
							return g && (o += "&dpi=d1&device=mobile"), o.replace("{quadkey}", c.a.quadKey(e))
						}
					}
				}))), i.imageryProviders) {
					var m = l.
				default.getTransformFromProjections(l.
				default.get("EPSG:4326"), this.getProjection());
					this.setAttributions((function(t) {
						var e = [],
							n = t.viewState.zoom;
						return i.imageryProviders.map((function(i) {
							for (var r = !1, s = i.coverageAreas, a = 0, l = s.length; a < l; ++a) {
								var u = s[a];
								if (n >= u.zoomMin && n <= u.zoomMax) {
									var h = u.bbox,
										c = [h[1], h[0], h[3], h[2]],
										d = o.
									default.applyTransform(c, m);
									if (o.
								default.intersects(d, t.extent)) {
										r = !0;
										break
									}
								}
							}
							r && e.push(i.attribution)
						})), e.push(f.TOS_ATTRIBUTION), e
					}))
				}
				this.setLogo(e), this.setState(u.a.READY)
			} else this.setState(u.a.ERROR)
		};
		e.
	default = f
	}, function(t, e, i) {
		"use strict";
		i.r(e);
		var n = i(0),
			r = i(15),
			o = i(26),
			s = i(69),
			a = i(93),
			l = function() {
				s.a.call(this)
			};
		n.
	default.inherits(l, s.a), l.prototype.getObject_ = function(t) {
			if ("string" == typeof t) {
				var e = JSON.parse(t);
				return e || null
			}
			return null !== t ? t : null
		}, l.prototype.getType = function() {
			return a.a.JSON
		}, l.prototype.readFeature = function(t, e) {
			return this.readFeatureFromObject(this.getObject_(t), this.getReadOptions(t, e))
		}, l.prototype.readFeatures = function(t, e) {
			return this.readFeaturesFromObject(this.getObject_(t), this.getReadOptions(t, e))
		}, l.prototype.readFeatureFromObject = function(t, e) {}, l.prototype.readFeaturesFromObject = function(t, e) {}, l.prototype.readGeometry = function(t, e) {
			return this.readGeometryFromObject(this.getObject_(t), this.getReadOptions(t, e))
		}, l.prototype.readGeometryFromObject = function(t, e) {}, l.prototype.readProjection = function(t) {
			return this.readProjectionFromObject(this.getObject_(t))
		}, l.prototype.readProjectionFromObject = function(t) {}, l.prototype.writeFeature = function(t, e) {
			return JSON.stringify(this.writeFeatureObject(t, e))
		}, l.prototype.writeFeatureObject = function(t, e) {}, l.prototype.writeFeatures = function(t, e) {
			return JSON.stringify(this.writeFeaturesObject(t, e))
		}, l.prototype.writeFeaturesObject = function(t, e) {}, l.prototype.writeGeometry = function(t, e) {
			return JSON.stringify(this.writeGeometryObject(t, e))
		}, l.prototype.writeGeometryObject = function(t, e) {};
		var u = l,
			h = i(149),
			c = i(58),
			d = i(94),
			f = i(104),
			A = i(106),
			p = i(25),
			g = i(31),
			m = i(8),
			v = i(9),
			y = function(t) {
				var e = t || {};
				u.call(this), this.defaultDataProjection = v.
			default.get(e.defaultDataProjection ? e.defaultDataProjection : "EPSG:4326"), e.featureProjection && (this.defaultFeatureProjection = v.
			default.get(e.featureProjection)), this.geometryName_ = e.geometryName, this.extractGeometryName_ = e.extractGeometryName
			};
		n.
	default.inherits(y, u), y.readGeometry_ = function(t, e) {
			if (!t) return null;
			var i = y.GEOMETRY_READERS_[t.type];
			return (s.a.transformWithOptions(i(t), !1, e))
		}, y.readGeometryCollectionGeometry_ = function(t, e) {
			var i = t.geometries.map((function(t) {
				return y.readGeometry_(t, e)
			}));
			return new h.
		default (i)
		}, y.readPointGeometry_ = function(t) {
			return new p.
		default (t.coordinates)
		}, y.readLineStringGeometry_ = function(t) {
			return new c.
		default (t.coordinates)
		}, y.readMultiLineStringGeometry_ = function(t) {
			return new d.
		default (t.coordinates)
		}, y.readMultiPointGeometry_ = function(t) {
			return new f.a(t.coordinates)
		}, y.readMultiPolygonGeometry_ = function(t) {
			return new A.a(t.coordinates)
		}, y.readPolygonGeometry_ = function(t) {
			return new g.
		default (t.coordinates)
		}, y.writeGeometry_ = function(t, e) {
			return (0, y.GEOMETRY_WRITERS_[t.getType()])(s.a.transformWithOptions(t, !0, e), e)
		}, y.writeEmptyGeometryCollectionGeometry_ = function(t) {
			return {
				type: "GeometryCollection",
				geometries: []
			}
		}, y.writeGeometryCollectionGeometry_ = function(t, e) {
			return {
				type: "GeometryCollection",
				geometries: t.getGeometriesArray().map((function(t) {
					var i = m.a.assign({}, e);
					return delete i.featureProjection, y.writeGeometry_(t, i)
				}))
			}
		}, y.writeLineStringGeometry_ = function(t, e) {
			return {
				type: "LineString",
				coordinates: t.getCoordinates()
			}
		}, y.writeMultiLineStringGeometry_ = function(t, e) {
			return {
				type: "MultiLineString",
				coordinates: t.getCoordinates()
			}
		}, y.writeMultiPointGeometry_ = function(t, e) {
			return {
				type: "MultiPoint",
				coordinates: t.getCoordinates()
			}
		}, y.writeMultiPolygonGeometry_ = function(t, e) {
			var i;
			return e && (i = e.rightHanded), {
				type: "MultiPolygon",
				coordinates: t.getCoordinates(i)
			}
		}, y.writePointGeometry_ = function(t, e) {
			return {
				type: "Point",
				coordinates: t.getCoordinates()
			}
		}, y.writePolygonGeometry_ = function(t, e) {
			var i;
			return e && (i = e.rightHanded), {
				type: "Polygon",
				coordinates: t.getCoordinates(i)
			}
		}, y.GEOMETRY_READERS_ = {
			Point: y.readPointGeometry_,
			LineString: y.readLineStringGeometry_,
			Polygon: y.readPolygonGeometry_,
			MultiPoint: y.readMultiPointGeometry_,
			MultiLineString: y.readMultiLineStringGeometry_,
			MultiPolygon: y.readMultiPolygonGeometry_,
			GeometryCollection: y.readGeometryCollectionGeometry_
		}, y.GEOMETRY_WRITERS_ = {
			Point: y.writePointGeometry_,
			LineString: y.writeLineStringGeometry_,
			Polygon: y.writePolygonGeometry_,
			MultiPoint: y.writeMultiPointGeometry_,
			MultiLineString: y.writeMultiLineStringGeometry_,
			MultiPolygon: y.writeMultiPolygonGeometry_,
			GeometryCollection: y.writeGeometryCollectionGeometry_,
			Circle: y.writeEmptyGeometryCollectionGeometry_
		}, y.prototype.readFeature, y.prototype.readFeatures, y.prototype.readFeatureFromObject = function(t, e) {
			var i = null;
			i = "Feature" === t.type ? t : {
				type: "Feature",
				geometry: t
			};
			var n = y.readGeometry_(i.geometry, e),
				r = new o.
			default;
			return this.geometryName_ ? r.setGeometryName(this.geometryName_):
			this.extractGeometryName_ && void 0 !== i.geometry_name && r.setGeometryName(i.geometry_name), r.setGeometry(n), void 0 !== i.id && r.setId(i.id), i.properties && r.setProperties(i.properties), r
		}, y.prototype.readFeaturesFromObject = function(t, e) {
			var i = null;
			if ("FeatureCollection" === t.type) {
				i = [];
				var n, r, o = t.features;
				for (n = 0, r = o.length; n < r; ++n) i.push(this.readFeatureFromObject(o[n], e))
			} else i = [this.readFeatureFromObject(t, e)];
			return i
		}, y.prototype.readGeometry, y.prototype.readGeometryFromObject = function(t, e) {
			return y.readGeometry_(t, e)
		}, y.prototype.readProjection, y.prototype.readProjectionFromObject = function(t) {
			var e, i = t.crs;
			return i ? "name" == i.type ? e = v.
		default.get(i.properties.name):
			r.a.assert(!1, 36) : e = this.defaultDataProjection, e
		}, y.prototype.writeFeature, y.prototype.writeFeatureObject = function(t, e) {
			e = this.adaptOptions(e);
			var i = {
				type: "Feature"
			},
				n = t.getId();
			void 0 !== n && (i.id = n);
			var r = t.getGeometry();
			i.geometry = r ? y.writeGeometry_(r, e) : null;
			var o = t.getProperties();
			return delete o[t.getGeometryName()], m.a.isEmpty(o) ? i.properties = null : i.properties = o, i
		}, y.prototype.writeFeatures, y.prototype.writeFeaturesObject = function(t, e) {
			e = this.adaptOptions(e);
			var i, n, r = [];
			for (i = 0, n = t.length; i < n; ++i) r.push(this.writeFeatureObject(t[i], e));
			return ({
				type: "FeatureCollection",
				features: r
			})
		}, y.prototype.writeGeometry, y.prototype.writeGeometryObject = function(t, e) {
			return y.writeGeometry_(t, this.adaptOptions(e))
		};
		e.
	default = y
	}, function(t, e, i) {
		"use strict";
		i.r(e);
		var n = i(0),
			r = {
				ACCURACY: "accuracy",
				ACCURACY_GEOMETRY: "accuracyGeometry",
				ALTITUDE: "altitude",
				ALTITUDE_ACCURACY: "altitudeAccuracy",
				HEADING: "heading",
				POSITION: "position",
				PROJECTION: "projection",
				SPEED: "speed",
				TRACKING: "tracking",
				TRACKING_OPTIONS: "trackingOptions"
			},
			o = i(14),
			s = i(101),
			a = i(3),
			l = i(5),
			u = i(31),
			h = i(35),
			c = i(11),
			d = i(9),
			f = i(127),
			A = function(t) {
				o.a.call(this);
				var e = t || {};
				this.position_ = null, this.transform_ = d.
			default.identityTransform, this.sphere_ = new s.
			default (f.a.RADIUS), this.watchId_ = void 0, a.a.listen(this, o.a.getChangeEventType(r.PROJECTION), this.handleProjectionChanged_, this), a.a.listen(this, o.a.getChangeEventType(r.TRACKING), this.handleTrackingChanged_, this), void 0 !== e.projection && this.setProjection(e.projection), void 0 !== e.trackingOptions && this.setTrackingOptions(e.trackingOptions), this.setTracking(void 0 !== e.tracking && e.tracking)
			};
		n.
	default.inherits(A, o.a), A.prototype.disposeInternal = function() {
			this.setTracking(!1), o.a.prototype.disposeInternal.call(this)
		}, A.prototype.handleProjectionChanged_ = function() {
			var t = this.getProjection();
			t && (this.transform_ = d.
		default.getTransformFromProjections(d.
		default.get("EPSG:4326"), t), this.position_ && this.set(r.POSITION, this.transform_(this.position_)))
		}, A.prototype.handleTrackingChanged_ = function() {
			if (h.a.GEOLOCATION) {
				var t = this.getTracking();
				t && void 0 === this.watchId_ ? this.watchId_ = navigator.geolocation.watchPosition(this.positionChange_.bind(this), this.positionError_.bind(this), this.getTrackingOptions()) : t || void 0 === this.watchId_ || (navigator.geolocation.clearWatch(this.watchId_), this.watchId_ = void 0)
			}
		}, A.prototype.positionChange_ = function(t) {
			var e = t.coords;
			this.set(r.ACCURACY, e.accuracy), this.set(r.ALTITUDE, null === e.altitude ? void 0 : e.altitude), this.set(r.ALTITUDE_ACCURACY, null === e.altitudeAccuracy ? void 0 : e.altitudeAccuracy), this.set(r.HEADING, null === e.heading ? void 0 : c.a.toRadians(e.heading)), this.position_ ? (this.position_[0] = e.longitude, this.position_[1] = e.latitude) : this.position_ = [e.longitude, e.latitude];
			var i = this.transform_(this.position_);
			this.set(r.POSITION, i), this.set(r.SPEED, null === e.speed ? void 0 : e.speed);
			var n = u.
		default.circular(this.sphere_, this.position_, e.accuracy);
			n.applyTransform(this.transform_), this.set(r.ACCURACY_GEOMETRY, n), this.changed()
		}, A.prototype.positionError_ = function(t) {
			t.type = l.a.ERROR, this.setTracking(!1), this.dispatchEvent(t)
		}, A.prototype.getAccuracy = function() {
			return this.get(r.ACCURACY)
		}, A.prototype.getAccuracyGeometry = function() {
			return this.get(r.ACCURACY_GEOMETRY) || null
		}, A.prototype.getAltitude = function() {
			return this.get(r.ALTITUDE)
		}, A.prototype.getAltitudeAccuracy = function() {
			return this.get(r.ALTITUDE_ACCURACY)
		}, A.prototype.getHeading = function() {
			return this.get(r.HEADING)
		}, A.prototype.getPosition = function() {
			return this.get(r.POSITION)
		}, A.prototype.getProjection = function() {
			return this.get(r.PROJECTION)
		}, A.prototype.getSpeed = function() {
			return this.get(r.SPEED)
		}, A.prototype.getTracking = function() {
			return this.get(r.TRACKING)
		}, A.prototype.getTrackingOptions = function() {
			return this.get(r.TRACKING_OPTIONS)
		}, A.prototype.setProjection = function(t) {
			this.set(r.PROJECTION, d.
		default.get(t))
		}, A.prototype.setTracking = function(t) {
			this.set(r.TRACKING, t)
		}, A.prototype.setTrackingOptions = function(t) {
			this.set(r.TRACKING_OPTIONS, t)
		};
		e.
	default = A
	}, function(t, e, i) {
		"use strict";
		i.r(e);
		var n = i(0),
			r = i(14),
			o = i(39),
			s = i(117),
			a = i(33),
			l = i(1),
			u = i(81),
			h = function(t) {
				t = t || {}, this.duration_ = "number" == typeof t.duration ? t.duration >= 0 ? t.duration : 0 : 1e3, this.fade_ = "function" == typeof t.fade ? t.fade : null, this.repeat_ = Number(t.repeat);
				var e = "function" == typeof t.easing ? t.easing : o.
			default.linear;
				t.revers ? this.easing_ = function(t) {
					return 1 - e(t)
				}:
				this.easing_ = e, this.hiddenStyle = t.hiddenStyle, r.a.call(this)
			};
		n.
	default.inherits(h, r.a), h.prototype.drawGeom_ = function(t, e, i) {
			this.fade_ && (t.context.globalAlpha = this.fade_(1 - t.elapsed));
			for (var n = t.style, r = 0; r < n.length; r++) {
				var o = 0,
					a = !s.
				default.prototype.getFeaturesAtPixel && n[r].getImage();
				a && (o = a.getScale(), a.setScale(t.frameState.pixelRatio * o));
				try {
					t.vectorContext.setStyle(n[r]), n[r].getZIndex() < 0 ? t.vectorContext.drawGeometry(i || e) : t.vectorContext.drawGeometry(e)
				} catch (t) {}
				a && a.setScale(o)
			}
		}, h.prototype.animate = function(t) {
			return !1
		}, s.
	default.prototype.animateFeature = a.
	default.prototype.animateFeature = function(t, e) {
			var i, n = this,
				r = t.getStyle(),
				o = r || (this.getStyleFunction ? this.getStyleFunction()(t) : null);
			o || (o = []), o instanceof Array || (o = [o]), t.setStyle(e.hiddenStyle || []);
			var s = {
				vectorContext: null,
				frameState: null,
				start: 0,
				time: 0,
				elapsed: 0,
				extent: !1,
				feature: t,
				geom: t.getGeometry(),
				typeGeom: t.getGeometry().getType(),
				bbox: t.getGeometry().getExtent(),
				coord: l.
			default.getCenter(t.getGeometry().getExtent()),
				style:
				o
			};
			e instanceof Array || (e = [e]);
			for (var a = e.length - 1; a >= 0; a--) 0 === e[a].duration_ && e.splice(a, 1);
			var h = 0,
				c = 0;

			function d(i) {
				s.vectorContext = i.vectorContext, s.frameState = i.frameState, s.extent || (s.extent = i.frameState.extent, s.start = i.frameState.time, s.context = i.context), s.time = i.frameState.time - s.start, s.elapsed = s.time / e[c].duration_, s.elapsed > 1 && (s.elapsed = 1), e[c].animate(s) || (++h < e[c].repeat_ ? s.extent = !1 : c < e.length - 1 ? (e[c].dispatchEvent({
					type: "animationend",
					feature: t
				}), c++, h = 0, s.extent = !1) : f()), i.frameState.animate = !0
			}
			function f(o) {
				u.
			default.unByKey(i), i = null, t.setStyle(r);
				var s = {
					type: "animationend",
					feature: t
				};
				if (o) for (var a in o) o.hasOwnProperty(a) && (s[a] = o[a]);
				e[c].dispatchEvent(s), n.dispatchEvent(s)
			}
			function A(r) {
				if (e.length && !i) {
					i = n.on("postcompose", d.bind(n)), n.renderSync ? n.renderSync() : n.changed();
					var o = {
						type: "animationstart",
						feature: t
					};
					if (r) for (var s in r) r.hasOwnProperty(s) && (o[s] = r[s]);
					e[c].dispatchEvent(o), n.dispatchEvent(o)
				}
			}
			return A(), {
				start: A,
				stop: f,
				isPlaying: function() {
					return !!i
				}
			}
		};
		var c = h;
		i.d(e, "ol_featureAnimation_Zoom", (function() {
			return d
		})), i.d(e, "ol_featureAnimation_ZoomOut", (function() {
			return f
		}));
		var d = function(t) {
				t = t || {}, c.call(this, t), this.set("zoomout", t.zoomOut)
			};
		n.
	default.inherits(d, c);
		var f = function(t) {
				(t = t || {}).zoomOut = !0, d.call(this, t)
			};
		n.
	default.inherits(f, d), d.prototype.animate = function(t) {
			var e = this.easing_(t.elapsed);
			if (e) {
				this.get("zoomout") && (e = 1 / e);
				for (var i, n = t.style, r = [], o = 0; o < n.length; o++)(i = n[o].getImage()) && (r[o] = i.getScale(), i.setScale(r[o] * e));
				t.context.save();
				var s = t.frameState.pixelRatio,
					a = t.frameState.coordinateToPixelTransform,
					l = (1 / e - 1) * s * (a[0] * t.coord[0] + a[1] * t.coord[1] + a[4]),
					u = (1 / e - 1) * s * (a[2] * t.coord[0] + a[3] * t.coord[1] + a[5]);
				t.context.scale(e, e), t.context.translate(l, u), this.drawGeom_(t, t.geom), t.context.restore();
				for (o = 0; o < n.length; o++)(i = n[o].getImage()) && i.setScale(r[o])
			}
			return t.time <= this.duration_
		}
	}, function(t, e, i) {
		"use strict";
		i.r(e);
		var n = i(0),
			r = i(27),
			o = i(42),
			s = i(26),
			a = i(24),
			l = i(78),
			u = i(10),
			h = i(19),
			c = i(3),
			d = i(21),
			f = i(5),
			A = i(28),
			p = i(1),
			g = i(4),
			m = i(25),
			v = {
				MODIFYSTART: "modifystart",
				MODIFYEND: "modifyend"
			},
			y = i(23),
			_ = i(33),
			E = i(30),
			x = i(74),
			C = i(84),
			I = i(34),
			S = function(t) {
				var e;
				if (y.a.call(this, {
					handleDownEvent: S.handleDownEvent_,
					handleDragEvent: S.handleDragEvent_,
					handleEvent: S.handleEvent,
					handleUpEvent: S.handleUpEvent_
				}), this.condition_ = t.condition ? t.condition : A.
			default.primaryAction, this.defaultDeleteCondition_ = function(t) {
					return A.
				default.altKeyOnly(t) && A.
				default.singleClick(t)
				}, this.deleteCondition_ = t.deleteCondition ? t.deleteCondition:
				this.defaultDeleteCondition_, this.insertVertexCondition_ = t.insertVertexCondition ? t.insertVertexCondition : A.
			default.always, this.vertexFeature_ = null, this.vertexSegments_ = null, this.lastPixel_ = [0, 0], this.ignoreNextSingleClick_ = !1, this.modified_ = !1, this.rBush_ = new C.a, this.pixelTolerance_ = void 0 !== t.pixelTolerance ? t.pixelTolerance:
				10, this.snappedToVertex_ = !1, this.changingFeature_ = !1, this.dragSegments_ = [], this.overlay_ = new _.
			default ({
					source: new E.
				default ({
						useSpatialIndex: !1,
						wrapX: !! t.wrapX
					}),
					style:
					t.style ? t.style : S.getDefaultStyleFunction(),
					updateWhileAnimating: !0,
					updateWhileInteracting: !0
				}), this.SEGMENT_WRITERS_ = {
					Point: this.writePointGeometry_,
					LineString: this.writeLineStringGeometry_,
					LinearRing: this.writeLineStringGeometry_,
					Polygon: this.writePolygonGeometry_,
					MultiPoint: this.writeMultiPointGeometry_,
					MultiLineString: this.writeMultiLineStringGeometry_,
					MultiPolygon: this.writeMultiPolygonGeometry_,
					Circle: this.writeCircleGeometry_,
					GeometryCollection: this.writeGeometryCollectionGeometry_
				}, this.source_ = null, t.source ? (this.source_ = t.source, e = new r.
			default (this.source_.getFeatures()), c.a.listen(this.source_, x.a.ADDFEATURE, this.handleSourceAdd_, this), c.a.listen(this.source_, x.a.REMOVEFEATURE, this.handleSourceRemove_, this)):
				e = t.features, !e) throw new Error("The modify interaction requires features or a source");
				this.features_ = e, this.features_.forEach(this.addFeature_, this), c.a.listen(this.features_, o.a.ADD, this.handleFeatureAdd_, this), c.a.listen(this.features_, o.a.REMOVE, this.handleFeatureRemove_, this), this.lastPointerEvent_ = null
			};
		n.
	default.inherits(S, y.a), S.MODIFY_SEGMENT_CIRCLE_CENTER_INDEX = 0, S.MODIFY_SEGMENT_CIRCLE_CIRCUMFERENCE_INDEX = 1, S.prototype.addFeature_ = function(t) {
			var e = t.getGeometry();
			e && e.getType() in this.SEGMENT_WRITERS_ && this.SEGMENT_WRITERS_[e.getType()].call(this, t, e);
			var i = this.getMap();
			i && i.isRendered() && this.getActive() && this.handlePointerAtPixel_(this.lastPixel_, i), c.a.listen(t, f.a.CHANGE, this.handleFeatureChange_, this)
		}, S.prototype.willModifyFeatures_ = function(t) {
			this.modified_ || (this.modified_ = !0, this.dispatchEvent(new S.Event(v.MODIFYSTART, this.features_, t)))
		}, S.prototype.removeFeature_ = function(t) {
			this.removeFeatureSegmentData_(t), this.vertexFeature_ && 0 === this.features_.getLength() && (this.overlay_.getSource().removeFeature(this.vertexFeature_), this.vertexFeature_ = null), c.a.unlisten(t, f.a.CHANGE, this.handleFeatureChange_, this)
		}, S.prototype.removeFeatureSegmentData_ = function(t) {
			var e = this.rBush_,
				i = [];
			e.forEach((function(e) {
				t === e.feature && i.push(e)
			}));
			for (var n = i.length - 1; n >= 0; --n) e.remove(i[n])
		}, S.prototype.setActive = function(t) {
			this.vertexFeature_ && !t && (this.overlay_.getSource().removeFeature(this.vertexFeature_), this.vertexFeature_ = null), y.a.prototype.setActive.call(this, t)
		}, S.prototype.setMap = function(t) {
			this.overlay_.setMap(t), y.a.prototype.setMap.call(this, t)
		}, S.prototype.handleSourceAdd_ = function(t) {
			t.feature && this.features_.push(t.feature)
		}, S.prototype.handleSourceRemove_ = function(t) {
			t.feature && this.features_.remove(t.feature)
		}, S.prototype.handleFeatureAdd_ = function(t) {
			this.addFeature_(t.element)
		}, S.prototype.handleFeatureChange_ = function(t) {
			if (!this.changingFeature_) {
				var e = t.target;
				this.removeFeature_(e), this.addFeature_(e)
			}
		}, S.prototype.handleFeatureRemove_ = function(t) {
			var e = t.element;
			this.removeFeature_(e)
		}, S.prototype.writePointGeometry_ = function(t, e) {
			var i = e.getCoordinates(),
				n = {
					feature: t,
					geometry: e,
					segment: [i, i]
				};
			this.rBush_.insert(e.getExtent(), n)
		}, S.prototype.writeMultiPointGeometry_ = function(t, e) {
			var i, n, r, o, s = e.getCoordinates();
			for (n = 0, r = s.length; n < r; ++n) o = {
				feature: t,
				geometry: e,
				depth: [n],
				index: n,
				segment: [i = s[n], i]
			}, this.rBush_.insert(e.getExtent(), o)
		}, S.prototype.writeLineStringGeometry_ = function(t, e) {
			var i, n, r, o, s = e.getCoordinates();
			for (i = 0, n = s.length - 1; i < n; ++i) o = {
				feature: t,
				geometry: e,
				index: i,
				segment: r = s.slice(i, i + 2)
			}, this.rBush_.insert(p.
		default.boundingExtent(r), o)
		}, S.prototype.writeMultiLineStringGeometry_ = function(t, e) {
			var i, n, r, o, s, a, l, u = e.getCoordinates();
			for (o = 0, s = u.length; o < s; ++o) for (n = 0, r = (i = u[o]).length - 1; n < r; ++n) l = {
				feature: t,
				geometry: e,
				depth: [o],
				index: n,
				segment: a = i.slice(n, n + 2)
			}, this.rBush_.insert(p.
		default.boundingExtent(a), l)
		}, S.prototype.writePolygonGeometry_ = function(t, e) {
			var i, n, r, o, s, a, l, u = e.getCoordinates();
			for (o = 0, s = u.length; o < s; ++o) for (n = 0, r = (i = u[o]).length - 1; n < r; ++n) l = {
				feature: t,
				geometry: e,
				depth: [o],
				index: n,
				segment: a = i.slice(n, n + 2)
			}, this.rBush_.insert(p.
		default.boundingExtent(a), l)
		}, S.prototype.writeMultiPolygonGeometry_ = function(t, e) {
			var i, n, r, o, s, a, l, u, h, c, d = e.getCoordinates();
			for (a = 0, l = d.length; a < l; ++a) for (o = 0, s = (u = d[a]).length; o < s; ++o) for (n = 0, r = (i = u[o]).length - 1; n < r; ++n) c = {
				feature: t,
				geometry: e,
				depth: [o, a],
				index: n,
				segment: h = i.slice(n, n + 2)
			}, this.rBush_.insert(p.
		default.boundingExtent(h), c)
		}, S.prototype.writeCircleGeometry_ = function(t, e) {
			var i = e.getCenter(),
				n = {
					feature: t,
					geometry: e,
					index: S.MODIFY_SEGMENT_CIRCLE_CENTER_INDEX,
					segment: [i, i]
				},
				r = {
					feature: t,
					geometry: e,
					index: S.MODIFY_SEGMENT_CIRCLE_CIRCUMFERENCE_INDEX,
					segment: [i, i]
				},
				o = [n, r];
			n.featureSegments = r.featureSegments = o, this.rBush_.insert(p.
		default.createOrUpdateFromCoordinate(i), n), this.rBush_.insert(e.getExtent(), r)
		}, S.prototype.writeGeometryCollectionGeometry_ = function(t, e) {
			var i, n = e.getGeometriesArray();
			for (i = 0; i < n.length; ++i) this.SEGMENT_WRITERS_[n[i].getType()].call(this, t, n[i])
		}, S.prototype.createOrUpdateVertexFeature_ = function(t) {
			var e = this.vertexFeature_;
			e ? e.getGeometry().setCoordinates(t) : (e = new s.
		default (new m.
		default (t)), this.vertexFeature_ = e, this.overlay_.getSource().addFeature(e));
			return e
		}, S.compareIndexes_ = function(t, e) {
			return t.index - e.index
		}, S.handleDownEvent_ = function(t) {
			if (!this.condition_(t)) return !1;
			this.handlePointerAtPixel_(t.pixel, t.map);
			var e = t.map.getCoordinateFromPixel(t.pixel);
			this.dragSegments_.length = 0, this.modified_ = !1;
			var i = this.vertexFeature_;
			if (i) {
				var r = [],
					o = i.getGeometry().getCoordinates(),
					s = p.
				default.boundingExtent([o]),
					a = this.rBush_.getInExtent(s),
					l = {};
				a.sort(S.compareIndexes_);
				for (var u = 0, c = a.length; u < c; ++u) {
					var d = a[u],
						f = d.segment,
						A = n.
					default.getUid(d.feature),
						m = d.depth;
					if (m && (A += "-" + m.join("-")), l[A] || (l[A] = new Array(2)), d.geometry.getType() === g.a.CIRCLE && d.index === S.MODIFY_SEGMENT_CIRCLE_CIRCUMFERENCE_INDEX) {
						var v = S.closestOnSegmentData_(e, d);
						h.
					default.equals(v, o) && !l[A][0] && (this.dragSegments_.push([d, 0]), l[A][0] = d)
					} else if (h.
				default.equals(f[0], o) && !l[A][0]) this.dragSegments_.push([d, 0]), l[A][0] = d;
					else if (h.
				default.equals(f[1], o) && !l[A][1]) {
						if ((d.geometry.getType() === g.a.LINE_STRING || d.geometry.getType() === g.a.MULTI_LINE_STRING) && l[A][0] && 0 === l[A][0].index) continue;
						this.dragSegments_.push([d, 1]), l[A][1] = d
					} else this.insertVertexCondition_(t) && n.
				default.getUid(f) in this.vertexSegments_ && !l[A][0] && !l[A][1] && r.push([d, o])
				}
				r.length && this.willModifyFeatures_(t);
				for (var y = r.length - 1; y >= 0; --y) this.insertVertex_.apply(this, r[y])
			}
			return !!this.vertexFeature_
		}, S.handleDragEvent_ = function(t) {
			this.ignoreNextSingleClick_ = !1, this.willModifyFeatures_(t);
			for (var e = t.coordinate, i = 0, n = this.dragSegments_.length; i < n; ++i) {
				for (var r, o = this.dragSegments_[i], s = o[0], a = s.depth, l = s.geometry, u = s.segment, c = o[1]; e.length < l.getStride();) e.push(u[c][e.length]);
				switch (l.getType()) {
				case g.a.POINT:
					r = e, u[0] = u[1] = e;
					break;
				case g.a.MULTI_POINT:
					(r = l.getCoordinates())[s.index] = e, u[0] = u[1] = e;
					break;
				case g.a.LINE_STRING:
					(r = l.getCoordinates())[s.index + c] = e, u[c] = e;
					break;
				case g.a.MULTI_LINE_STRING:
				case g.a.POLYGON:
					(r = l.getCoordinates())[a[0]][s.index + c] = e, u[c] = e;
					break;
				case g.a.MULTI_POLYGON:
					(r = l.getCoordinates())[a[1]][a[0]][s.index + c] = e, u[c] = e;
					break;
				case g.a.CIRCLE:
					u[0] = u[1] = e, s.index === S.MODIFY_SEGMENT_CIRCLE_CENTER_INDEX ? (this.changingFeature_ = !0, l.setCenter(e), this.changingFeature_ = !1) : (this.changingFeature_ = !0, l.setRadius(h.
				default.distance(l.getCenter(), e)), this.changingFeature_ = !1)
				}
				r && this.setGeometryCoordinates_(l, r)
			}
			this.createOrUpdateVertexFeature_(e)
		}, S.handleUpEvent_ = function(t) {
			for (var e, i, n = this.dragSegments_.length - 1; n >= 0; --n) if ((i = (e = this.dragSegments_[n][0]).geometry).getType() === g.a.CIRCLE) {
				var r = i.getCenter(),
					o = e.featureSegments[0],
					s = e.featureSegments[1];
				o.segment[0] = o.segment[1] = r, s.segment[0] = s.segment[1] = r, this.rBush_.update(p.
			default.createOrUpdateFromCoordinate(r), o), this.rBush_.update(i.getExtent(), s)
			} else this.rBush_.update(p.
		default.boundingExtent(e.segment), e);
			return this.modified_ && (this.dispatchEvent(new S.Event(v.MODIFYEND, this.features_, t)), this.modified_ = !1), !1
		}, S.handleEvent = function(t) {
			return !(t instanceof l.a) || (this.lastPointerEvent_ = t, t.map.getView().getInteracting() || t.type != a.a.POINTERMOVE || this.handlingDownUpSequence || this.handlePointerMove_(t), this.vertexFeature_ && this.deleteCondition_(t) && (e = !(t.type != a.a.SINGLECLICK || !this.ignoreNextSingleClick_) || this.removePoint()), t.type == a.a.SINGLECLICK && (this.ignoreNextSingleClick_ = !1), y.a.handleEvent.call(this, t) && !e);
			var e
		}, S.prototype.handlePointerMove_ = function(t) {
			this.lastPixel_ = t.pixel, this.handlePointerAtPixel_(t.pixel, t.map)
		}, S.prototype.handlePointerAtPixel_ = function(t, e) {
			var i = e.getCoordinateFromPixel(t),
				r = p.
			default.buffer(p.
			default.createOrUpdateFromCoordinate(i), e.getView().getResolution() * this.pixelTolerance_),
				o = this.rBush_.getInExtent(r);
			if (o.length > 0) {
				o.sort((function(t, e) {
					return S.pointDistanceToSegmentDataSquared_(i, t) - S.pointDistanceToSegmentDataSquared_(i, e)
				}));
				var s = o[0],
					a = s.segment,
					l = S.closestOnSegmentData_(i, s),
					u = e.getPixelFromCoordinate(l),
					c = h.
				default.distance(t, u);
				if (c <= this.pixelTolerance_) {
					var d = {};
					if (s.geometry.getType() === g.a.CIRCLE && s.index === S.MODIFY_SEGMENT_CIRCLE_CIRCUMFERENCE_INDEX) this.snappedToVertex_ = !0, this.createOrUpdateVertexFeature_(l);
					else {
						var f, A = e.getPixelFromCoordinate(a[0]),
							m = e.getPixelFromCoordinate(a[1]),
							v = h.
						default.squaredDistance(u, A),
							y = h.
						default.squaredDistance(u, m);
						c = Math.sqrt(Math.min(v, y)), this.snappedToVertex_ = c <= this.pixelTolerance_, this.snappedToVertex_ && (l = v > y ? a[1] : a[0]), this.createOrUpdateVertexFeature_(l);
						for (var _ = 1, E = o.length; _ < E && (f = o[_].segment, h.
					default.equals(a[0], f[0]) && h.
					default.equals(a[1], f[1]) || h.
					default.equals(a[0], f[1]) && h.
					default.equals(a[1], f[0])); ++_) d[n.
					default.getUid(f)] = !0
					}
					return d[n.
				default.getUid(a)] = !0, void(this.vertexSegments_ = d)
				}
			}
			this.vertexFeature_ && (this.overlay_.getSource().removeFeature(this.vertexFeature_), this.vertexFeature_ = null)
		}, S.pointDistanceToSegmentDataSquared_ = function(t, e) {
			var i = e.geometry;
			if (i.getType() === g.a.CIRCLE) {
				var n = i;
				if (e.index === S.MODIFY_SEGMENT_CIRCLE_CIRCUMFERENCE_INDEX) {
					var r = h.
				default.squaredDistance(n.getCenter(), t),
						o = Math.sqrt(r) - n.getRadius();
					return o * o
				}
			}
			return h.
		default.squaredDistanceToSegment(t, e.segment)
		}, S.closestOnSegmentData_ = function(t, e) {
			var i = e.geometry;
			return i.getType() === g.a.CIRCLE && e.index === S.MODIFY_SEGMENT_CIRCLE_CIRCUMFERENCE_INDEX ? i.getClosestPoint(t) : h.
		default.closestOnSegment(t, e.segment)
		}, S.prototype.insertVertex_ = function(t, e) {
			for (var i, n = t.segment, r = t.feature, o = t.geometry, s = t.depth, a = t.index; e.length < o.getStride();) e.push(0);
			switch (o.getType()) {
			case g.a.MULTI_LINE_STRING:
			case g.a.POLYGON:
				(i = o.getCoordinates())[s[0]].splice(a + 1, 0, e);
				break;
			case g.a.MULTI_POLYGON:
				(i = o.getCoordinates())[s[1]][s[0]].splice(a + 1, 0, e);
				break;
			case g.a.LINE_STRING:
				(i = o.getCoordinates()).splice(a + 1, 0, e);
				break;
			default:
				return
			}
			this.setGeometryCoordinates_(o, i);
			var l = this.rBush_;
			l.remove(t), this.updateSegmentIndices_(o, a, s, 1);
			var u = {
				segment: [n[0], e],
				feature: r,
				geometry: o,
				depth: s,
				index: a
			};
			l.insert(p.
		default.boundingExtent(u.segment), u), this.dragSegments_.push([u, 1]);
			var h = {
				segment: [e, n[1]],
				feature: r,
				geometry: o,
				depth: s,
				index: a + 1
			};
			l.insert(p.
		default.boundingExtent(h.segment), h), this.dragSegments_.push([h, 0]), this.ignoreNextSingleClick_ = !0
		}, S.prototype.removePoint = function() {
			if (this.lastPointerEvent_ && this.lastPointerEvent_.type != a.a.POINTERDRAG) {
				var t = this.lastPointerEvent_;
				return this.willModifyFeatures_(t), this.removeVertex_(), this.dispatchEvent(new S.Event(v.MODIFYEND, this.features_, t)), this.modified_ = !1, !0
			}
			return !1
		}, S.prototype.removeVertex_ = function() {
			var t, e, i, r, o, s, a, l, u, h, c, d = this.dragSegments_,
				f = {},
				A = !1;
			for (o = d.length - 1; o >= 0; --o) h = (i = d[o])[0], c = n.
		default.getUid(h.feature), h.depth && (c += "-" + h.depth.join("-")), c in f || (f[c] = {}), 0 === i[1] ? (f[c].right = h, f[c].index = h.index):
			1 == i[1] && (f[c].left = h, f[c].index = h.index + 1);
			for (c in f) {
				switch (u = f[c].right, a = f[c].left, (l = (s = f[c].index) - 1) < 0 && (l = 0), t = e = (r = (h = void 0 !== a ? a : u).geometry).getCoordinates(), A = !1, r.getType()) {
				case g.a.MULTI_LINE_STRING:
					e[h.depth[0]].length > 2 && (e[h.depth[0]].splice(s, 1), A = !0);
					break;
				case g.a.LINE_STRING:
					e.length > 2 && (e.splice(s, 1), A = !0);
					break;
				case g.a.MULTI_POLYGON:
					t = t[h.depth[1]];
				case g.a.POLYGON:
					(t = t[h.depth[0]]).length > 4 && (s == t.length - 1 && (s = 0), t.splice(s, 1), A = !0, 0 === s && (t.pop(), t.push(t[0]), l = t.length - 1))
				}
				if (A) {
					this.setGeometryCoordinates_(r, e);
					var m = [];
					if (void 0 !== a && (this.rBush_.remove(a), m.push(a.segment[0])), void 0 !== u && (this.rBush_.remove(u), m.push(u.segment[1])), void 0 !== a && void 0 !== u) {
						var v = {
							depth: h.depth,
							feature: h.feature,
							geometry: h.geometry,
							index: l,
							segment: m
						};
						this.rBush_.insert(p.
					default.boundingExtent(v.segment), v)
					}
					this.updateSegmentIndices_(r, s, h.depth, -1), this.vertexFeature_ && (this.overlay_.getSource().removeFeature(this.vertexFeature_), this.vertexFeature_ = null), d.length = 0
				}
			}
			return A
		}, S.prototype.setGeometryCoordinates_ = function(t, e) {
			this.changingFeature_ = !0, t.setCoordinates(e), this.changingFeature_ = !1
		}, S.prototype.updateSegmentIndices_ = function(t, e, i, n) {
			this.rBush_.forEachInExtent(t.getExtent(), (function(r) {
				r.geometry === t && (void 0 === i || void 0 === r.depth || u.a.equals(r.depth, i)) && r.index > e && (r.index += n)
			}))
		}, S.getDefaultStyleFunction = function() {
			var t = I.
		default.createDefaultEditing();
			return function(e, i) {
				return t[g.a.POINT]
			}
		}, S.Event = function(t, e, i) {
			d.a.call(this, t), this.features = e, this.mapBrowserEvent = i
		}, n.
	default.inherits(S.Event, d.a);
		e.
	default = S
	}, function(t, e, i) {
		"use strict";
		i.r(e);
		var n = i(0),
			r = i(27),
			o = i(14),
			s = i(3),
			a = i(21),
			l = i(20),
			u = i(10),
			h = i(23),
			c = i(111),
			d = {
				TRANSLATESTART: "translatestart",
				TRANSLATING: "translating",
				TRANSLATEEND: "translateend"
			},
			f = function(t) {
				h.a.call(this, {
					handleDownEvent: f.handleDownEvent_,
					handleDragEvent: f.handleDragEvent_,
					handleMoveEvent: f.handleMoveEvent_,
					handleUpEvent: f.handleUpEvent_
				});
				var e, i = t || {};
				if (this.lastCoordinate_ = null, this.features_ = void 0 !== i.features ? i.features : null, i.layers) if ("function" == typeof i.layers) e = i.layers;
				else {
					var n = i.layers;
					e = function(t) {
						return u.a.includes(n, t)
					}
				} else e = l.a.TRUE;
				this.layerFilter_ = e, this.hitTolerance_ = i.hitTolerance ? i.hitTolerance : 0, this.lastFeature_ = null, s.a.listen(this, o.a.getChangeEventType(c.a.ACTIVE), this.handleActiveChanged_, this)
			};
		n.
	default.inherits(f, h.a), f.handleDownEvent_ = function(t) {
			if (this.lastFeature_ = this.featuresAtPixel_(t.pixel, t.map), !this.lastCoordinate_ && this.lastFeature_) {
				this.lastCoordinate_ = t.coordinate, f.handleMoveEvent_.call(this, t);
				var e = this.features_ || new r.
			default ([this.lastFeature_]);
				return this.dispatchEvent(new f.Event(d.TRANSLATESTART, e, t.coordinate)), !0
			}
			return !1
		}, f.handleUpEvent_ = function(t) {
			if (this.lastCoordinate_) {
				this.lastCoordinate_ = null, f.handleMoveEvent_.call(this, t);
				var e = this.features_ || new r.
			default ([this.lastFeature_]);
				return this.dispatchEvent(new f.Event(d.TRANSLATEEND, e, t.coordinate)), !0
			}
			return !1
		}, f.handleDragEvent_ = function(t) {
			if (this.lastCoordinate_) {
				var e = t.coordinate,
					i = e[0] - this.lastCoordinate_[0],
					n = e[1] - this.lastCoordinate_[1],
					o = this.features_ || new r.
				default ([this.lastFeature_]);
				o.forEach((function(t) {
					var e = t.getGeometry();
					e.translate(i, n), t.setGeometry(e)
				})), this.lastCoordinate_ = e, this.dispatchEvent(new f.Event(d.TRANSLATING, o, e))
			}
		}, f.handleMoveEvent_ = function(t) {
			var e = t.map.getViewport();
			this.featuresAtPixel_(t.pixel, t.map) ? (e.classList.remove(this.lastCoordinate_ ? "ol-grab" : "ol-grabbing"), e.classList.add(this.lastCoordinate_ ? "ol-grabbing" : "ol-grab")) : e.classList.remove("ol-grab", "ol-grabbing")
		}, f.prototype.featuresAtPixel_ = function(t, e) {
			return e.forEachFeatureAtPixel(t, function(t) {
				if (!this.features_ || u.a.includes(this.features_.getArray(), t)) return t
			}.bind(this), {
				layerFilter: this.layerFilter_,
				hitTolerance: this.hitTolerance_
			})
		}, f.prototype.getHitTolerance = function() {
			return this.hitTolerance_
		}, f.prototype.setHitTolerance = function(t) {
			this.hitTolerance_ = t
		}, f.prototype.setMap = function(t) {
			var e = this.getMap();
			h.a.prototype.setMap.call(this, t), this.updateState_(e)
		}, f.prototype.handleActiveChanged_ = function() {
			this.updateState_(null)
		}, f.prototype.updateState_ = function(t) {
			var e = this.getMap(),
				i = this.getActive();
			e && i || (e = e || t) && e.getViewport().classList.remove("ol-grab", "ol-grabbing")
		}, f.Event = function(t, e, i) {
			a.a.call(this, t), this.features = e, this.coordinate = i
		}, n.
	default.inherits(f.Event, a.a);
		e.
	default = f
	}])
}));